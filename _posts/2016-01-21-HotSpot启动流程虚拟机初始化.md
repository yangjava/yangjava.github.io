---
layout: post
categories: [JVM]
description: none
keywords: JVM
---
## HotSpot启动流程虚拟机初始化

## 虚拟机初始化
在环境都准备好之后，会由`JVMInit()`执行虚拟机初始化工作，首先会通过`ShowSplashScreen()`方法加载启动动画，之后会进入`CountinueInNewThread()`方法，由新的线程负责创建虚拟机的工作。
```
int
JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
        int argc, char **argv,
        int mode, char *what, int ret)
{
    ShowSplashScreen();
    return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
}
```

## 在新线程中继续虚拟机的创建
我们找到了`java.c/ConutinueInNewThread()`的方法。这个方法分为两个部分，第一部分就是确定线程栈的深度，第二部分就是由`ContinueInNewThread0()`这个方法实现真正的虚拟机创建过程。
```
// 组织参数，执行真正的虚拟机入口函数
int
ContinueInNewThread(InvocationFunctions* ifn/* 函数指针 */, jlong threadStackSize/* 线程栈大小 */,
                    int argc, char **argv,
                    int mode, char *what, int ret)
{

    /*
     * If user doesn't specify stack size, check if VM has a preference.
     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
     * return its default stack size through the init args structure.
     */
     // 如果没有指定线程栈大小， 则会检查vm是否指定一个默认值.注意：虚拟机不再支持1.1，但是他会通过初始化参数返回一个默认的栈大小值.
    if (threadStackSize == 0) {
      struct JDK1_1InitArgs args1_1;
      memset((void*)&args1_1, 0, sizeof(args1_1));
      //指定版本号
      args1_1.version = JNI_VERSION_1_1;
      //通过虚拟机返回一个指定的参数值，该方法时从libjvm.so里面导出的函数指针
      ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
      if (args1_1.javaStackSize > 0) {
      //如果查询到有效值，则会修改全局定义的栈大小
         threadStackSize = args1_1.javaStackSize;
      }
    }

    { /* Create a new thread to create JVM and invoke main method */
      // 创建一个新线程去创建jvm，然后调用main方法
      JavaMainArgs args;
      int rslt;

      args.argc = argc;
      args.argv = argv;
      args.mode = mode;
      args.what = what;
      args.ifn = *ifn;

      rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&args);
      /* If the caller has deemed there is an error we
       * simply return that, otherwise we return the value of
       * the callee
       */
      return (ret != 0) ? ret : rslt;
    }
}
```
由`ContinueInNewThread0()`这个方法实现真正的虚拟机创建过程。
```
/*
 * Block current thread and continue execution in a new thread
 */
// 尝试创建新线程执行代码逻辑，创建新线程失败则在当前线程执行代码逻辑
// 暂停当前线程，然后继续执行一个新的线程
int
ContinueInNewThread0(int (JNICALL *continuation)(void *), //线程入口函数，在这里具体执行的时JavaMain方法
                    jlong stack_size,                     //线程栈大小，会使用该值创建线程
                    void * args) {                        //参数
    int rslt;
#ifdef __linux__
    pthread_t tid;
    //声明线程属性
    pthread_attr_t attr;
    //初始化线程属性并设置相关属性值
    pthread_attr_init(&attr);              
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE); //可join线程

    //设置线程栈深度
    if (stack_size > 0) {   //如果给定的线程栈大小值有效，则设置创建线程的栈大小，否则使用默认值
      pthread_attr_setstacksize(&attr, stack_size);
    }
    // 调用线程库创建线程，并设定入口函数为JavaMain
    if (pthread_create(&tid, &attr, (void *(*)(void*))continuation, (void*)args) == 0) {
      void * tmp;
      pthread_join(tid, &tmp);  // 创建成功后，并等待线程的结束，主线程挂起
      rslt = (int)tmp;
    } else {
     /*
      * Continue execution in current thread if for some reason (e.g. out of
      * memory/LWP)  a new thread can't be created. This will likely fail
      * later in continuation as JNI_CreateJavaVM needs to create quite a
      * few new threads, anyway, just give it a try..
      */
      // 如果因为某些条件导致创建线程失败，则在当前线程执行JavaMain方法
      rslt = continuation(args);
    }

    pthread_attr_destroy(&attr);  //线程回收
#else /* ! __linux__ */
    thread_t tid;
    long flags = 0;
    if (thr_create(NULL, stack_size, (void *(*)(void *))continuation, args, flags, &tid) == 0) {
      void * tmp;
      thr_join(tid, NULL, &tmp);
      rslt = (int)tmp;
    } else {
      /* See above. Continue in current thread if thr_create() failed */
      rslt = continuation(args);
    }
#endif /* __linux__ */
    return rslt;
}

```
在这个方法中，首先调用了`pthread_create()`函数创建了一个新线程，同时旧线程被join等待新线程运行完成后返回。

`pthread_create()`是unix操作系统创建线程的函数，它的第一个参数表示线程标识，第二参数表示线程属性，第三个参数表示创建线程所要执行函数的地址，第四个参数则是将要执行的函数的参数。

等到新线程运行完成后，旧的线程也会返回。此时说明运行结束，进程将会退出。

需要注意的是此时传入的函数地址，它是指向`java.c/JavaMain()`函数。也就是说新创建的线程将会开始执行该函数。