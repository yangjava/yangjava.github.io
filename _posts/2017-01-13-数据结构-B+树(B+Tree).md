---
layout: post
categories: DataStructure
description: none
keywords: DataStructure
---



## B+树(B+Tree)

![B+tree图解](png/Java/数据结构-B+tree图解.png)

**B+树是从B树的变体**。跟B树的不同：

- **内部节点不保存数据，只用于索引**
- **B+树的每个叶子节点之间存在指针相连，而且是单链表**，叶子节点本身依关键字的大小自小而大顺序链接



**案例分析**

如下图，其实B+树上二叉搜索树的扩展，二叉搜索树是每次一分为二，B树是每次一分为多，现代操作系统中，磁盘的存储结构使用的是B+树机制，mysql的innodb引擎的存储方式也是B+树机制：

![B+Tree](png/Java/数据结构-B+Tree.png)

**B+树与B树相比有以下优势**

- **更少的IO次数**：B+树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比B数多很多（即阶m更大），因此B+树的高度更低，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高
- **更适于范围查询**：在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要对链表进行遍历即可
- **更稳定的查询效率**：B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。



**B+树劣势**

由于键会重复出现，因此**会占用更多的空间**。但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树的在数据库中的使用比B树更加广泛。



## B*树

是B+树的变体，**在B+树的非根和非叶子结点再增加指向兄弟的指针**，且**定义了非叶子结点关键字个数至少为(2/3)×M**，即块的最低使用率为2/3（代替B+树的1/2）：

![Bx树](png/Java/数据结构-Bx树.jpg)
