---
layout: post
categories: Linux
description: none
keywords: Linux
---
# Linux进程管理
进程管理在任何操作系统中都是最重要的任务之一。有效的进程管理能够让一个应用程序稳定有效地运作。Linux进程管理包括进程调度、中断处理、信号、进程优先级、进程切换、进程状态、进程内存等等。

## 什么是进程
进程是在处理器上执行的一个实例，进程可使用任意资源以便Linux内核可以处理完成它的任务。

在Linux操作系统上运行的所有进程都是通过task_struct结构来管理的，其也被称为“进程描述符”。一个进程描述符包含了单个进程在运行期间所有必要的信息，比如进程标识、进程的属性、构建进程的资源等。如果知道进程的结构，就能了解进程的执行对性能的重要性。

## 进程的生命周期
每个进程都有自己的生命周期，比如创建、执行、终止、删除等。只要系统启动和运行，这些阶段就会不断地被重复，因此，从性能的角度讲，进程的生命周期是非常重要的。
```text
  
  [父进程]  wait()=>         [父进程]
  
  fork()=> [子进程]  exec()=>[子进程]   exit()=>[僵尸进程]
```
当一个进程创建一个新进程的时候，创建进程（父进程）发出一个fork()系统调用，然后父进程得到一个新创建的进程（子进程）的进程描述符，并设置一个新的进程ID。它复制父进程的进程描述符的值给子进程。此时父进程的整个地址空间是不能被复制的，两个进程共享相同的地址空间。

exec()系统调用将新的程序复制到子进程的地址空间。因为两个进程共享相同的地址空间，所以新程序写数据时会导致页错误。对此，内核会给子进程分配新的物理页。

这种延迟的操作被称为Copy On Write。通常子进程执行它自己的程序，而不是执行与父进程相同的操作。此操作可避免不必要的开销，因为复制整个地址空间是非常慢和低效的操作，会占用处理器大量的时间与资源。

当程序执行完成的时候，通过一个exit()系统调用终止子进程。exit()系统调用释放进程的大部分数据结构并发送一个终止信号通知父进程。此时的进程被称为僵尸进程（zombie process）。

子进程不会完全被移除，直到父进程通过wait()系统调用得知子进程已终止。只要子进程的终止通知发送到父进程，父进程就会移除所有子进程的数据结构，并释放进程描述符。

## 线程
线程是在进程中产生的一个执行单元，其在同一个进程中与其他线程并行运行。它们可以共享相同的资源，比如内存、地址空间、打开的文件，等等。它们也可以访问同一组应用程序的数据。线程也被称为轻量级进程（Light Weight Process, LWP）。因为它们共享资源，所以它们中的每个线程不能同时改变它们共享的资源。因此，互斥、锁、序列化等是用户应用程序要实现的机制。

从性能的角度来看，线程的创建要比进程的创建开销更小，因为创建线程不需要复制资源。另一方面，进程和线程在调度算法上有相似的特征。内核处理它们使用相似的方式。
在当前的Linux实现中，线程支持POSIX（可移植操作系统接口）UNIX兼容库（pthread）。在Linux操作系统中有如下几个线程实现：
- LinuxThreads。 自Linux 2.0内核开始，LinuxThreads成为默认的线程实现。LinuxThreads有一些不符合POSIX标准的实现。未来的企业级Linux发行版不支持LinuxThreads。
- Native POSIX Thread Library (NPTL)。 NPTL最初是由Red Hat开发的。NPTL更加符合POSIX标准，其增强了2.6内核的性能，比如新的clone()系统调用、信号处理的实现，等等。它比LinuxThreads有更好的性能和可扩展性。 NPTL与LinuxThreads有一些不兼容。如果一个应用程序依赖于LinuxThread，则通过NPTL实现可能不能工作。
- Next Generation POSIX Thread（NGPT下一代POSIX线程）。 NGPT是IBM开发的POSIX线程库的版本。它当前正处在维护状态，并没有进一步发展的计划。

使用LD_ASSUME_KERNEL环境变量，可以选择应用程序要使用的线程库。

## 进程优先级和nice等级
进程优先级是一个数字，用来确定CPU处理进程的顺序，并可以确定静态（实时）优先级和动态（非实时）优先级。一个具有最高优先级的进程有较大的机会得到在一个处理器上运行的权限。

最高静态（实时）优先级（99）对应于系统优先级0，最低静态（实时）优先级（0）对应于系统优先级99。这些静态（实时）优先级，系统是不能动态改变它们的。

对于动态（非实时）优先级，内核需要使用一个基于进程行为和特征的算法做上下+/－5的动态调整。一个进程可以间接地通过使用进程的nice级别来改变静态优先级。一个具有较高静态优先级的进程会具有更长的时间片（进程在一个处理器上运行多长时间）。Linux支持的nice级别可从19（最低优先级）到－20（最高优先级）。默认值是0。将一个程序的nice级别改为一个负数（使得它有较高优先级），则需要使用root登录，或者使用su命令切换到root账号。

## 上下文切换
在处理器执行期间，运行进程的信息被存储在处理器的寄存器和高速缓存（cache）中，执行的进程被加载到寄存器的数据集被称为上下文（context）。在切换过程中，先存储运行进程的上下文，然后将下一个要运行的进程的上下文恢复到寄存器。进程描述符和内核模式堆栈区域用于存储上下文。这个切换的过程被称为上下文切换（context switching）。一般不能有太多的上下文切换，因为处理器每次要刷新寄存器和高速缓存（cache），以便释放空间给新的进程。这可能会导致性能问题。

## 中断处理
中断处理是优先级最高的任务之一。中断通常由I/O设备产生，比如网络接口卡、键盘、磁盘控制器、串行适配卡，等等。中断处理是Linux内核通知事件（比如键盘输入、以太网帧到达，等等）。它告诉内核中断进程执行，并要尽可能快地执行中断处理，因为有些设备需要快速响应。这对于系统的稳定性是至关重要的。当一个中断信号到达内核的时候，内核必须从当前执行的进程切换到一个新的进程，以处理这个中断。这意味着中断会导致上下文切换。这也暗示大量的中断会导致性能下降。

在Linux实现中，有两种类型的中断。硬中断是由硬件设备产生的，需要快速响应（如磁盘I/O中断、网络适配器中断、键盘中断、鼠标中断等）。软中断被用来处理可以推迟的任务（如TCP/IP操作、SCSI协议操作，等等）。可以在/proc/interrupts下看到硬件中断相关的信息。 在一个多处理器的环境中，中断是由每个处理器处理的。将中断绑定到单个处理器上可以提高系统的性能。

## 进程状态
每个进程都有自己的状态。在进程执行期间进程状态会变化。下面是一些重要的状态：
- TASK_RUNNING。 在这种状态下，进程正在CPU上运行，或者在队列（运行队列）中等待运行。
- TASK_STOPPED。 在这种状态下，进程由于某些信号（例如SIGINT、SIGSTOP等）被暂停。进程在等待一个恢复信号比如SIGCONT。
- TASK_INTERRUPTIBLE。 在这种状态下，进程暂停，并等待某个条件得到满足。如果进程处在TASK_INTERRUPTIBLE状态下并接收到一个停止信号，进程的状态会改变，操作将被中断。TASK_INTERRUPTIBLE进程的一个典型的例子是进程等待键盘中断。
- TASK_UNINTERRUPTIBLE。 类似于TASK_INTERRUPTIBLE，当一个进程处在TASK_INTERRUPTIBLE状态时，它是能够被中断的。在TASK_UNINTERRUPTIBLE状态下会给进程发送一个不执行任何操作的信号。
- TASK_UNINTERRUPTIBLE。 进程的典型例子是一个进程在等待磁盘I/O操作。
- TASK_ZOMBIE。 一个进程通过exit()系统调用退出之后，它的父进程应该知道它已终止。在TASK_ZOMBIE状态下，一个进程在等待通知它的父进程释放所有的数据结构。

### 僵尸进程
当一个进程接收到一个终止信号时，在它结束之前一般需要一些时间结束所有的任务（比如关闭打开的文件）。通常在很短的时间内，这个进程是一个僵尸进程。

在进程完成所有的关闭任务之后，它将相关终止报告发给父进程。有时候，一个僵尸进程不能终止自己，在这种情况下其显示为Z（僵尸）状态。

使用kill命令是不能杀死这样一个进程的，因为它已经被认定为死亡。如果你无法摆脱一个僵尸进程，你可以杀死父进程，这样僵尸就会随之消失。注意，init进程是一个非常重要的进程，如果僵尸进程的父进程是init，那么需要重新启动系统来摆脱僵尸进程。

## 进程的内存段
进程使用它们自己的内存地址区域来执行工作。工作的变化取决于当前情况和进程的使用。一个进程可以有不同的工作负载和不同需求的数据大小。进程能处理各种各样的数据大小。为了满足这一需求，Linux内核对每个进程采用的是动态内存分配机制。

进程的内存区域由这些段组成：
- 文本段。 这个区域用来存储可执行代码。
- 数据段。 数据段由3个区域组成：
    - 数据。这个区域存储初始化数据，比如静态变量。
- BSS。这个区域存储零初始化数据。数据被初始化为零。
- 堆（Heap）。在这个区域，malloc()会根据需求动态分配内存。堆向着较高的地址增长。
- 堆栈段 （Stack segment）。这个区域是局部变量、函数参数、返回的存储函数的存放区域。堆栈向着较低地址增长。

使用pamp命令可以显示一个用户态进程的内存地址空间分配情况。使用ps命令可以显示段的总共大小

## Linux CPU调度程序
任何计算机的基本功能都是计算。为了能够计算，必须有一种方法能对计算资源、处理器、计算任务进行管理，同时也要了解线程或进程。一个单独的CPU在一个时间只能执行一个程序。Linux使用多任务处理（multitasking）机制使得系统中可以多个程序同时运行。在多任务处理（multitasking）机制下，多个程序共享CPU，它们在CPU上轮流运行。

内核使用进程调度程序来确定哪个程序在哪个给定时间点运行。为了工作正常，进程调度程序必须合理调度不同的资源。它必须很快确定接下来轮到哪个进程得到CPU。通常它必须保证各进程得到的CPU时间是公平的，但是允许高优先级进程得到更大的CPU时间，或许可以抢占较低优先级进程的CPU时间。它必须对交互式应用程序做出响应。最后，在多种多样的负载条件下它应该表现出可预见性和可扩展性，如同给系统添加额外的程序。

### O(1)调度程序
O(1)调度程序是在Linux 2.6内核中引进的，比如Red Hat Enterprise Linux 4和Red Hat Enterprise Linux 5。以前的调度程序在O(n)时间里操作，它必须扫描整个进程列表，以便找到下一个要运行的进程。这不能很好地扩展拥有大量进程的系统。O(1)调度程序工作时每个CPU使用2个队列：一个运行队列和一个过期的队列。调度程序根据它们的优先级将它们放置在运行队列的进程列表中，需要调度时，取出运行队列中最高优先级列表中的第一个进程，并运行它。调度程序基于进程的优先级和以前的阻塞率给进程分配一个时间片，当进程时间片用完后，进程调度程序将其移动到过期队列相应的优先级列表中。然后它从运行队列中取出下一个具有最高优先级的进程，重复以上过程。一旦运行队列中不再有进程等待，调度程序就将过期队列转变为新的运行队列，之前的运行队列成为新的过期队列，开始再次循环。

一般交互式进程（相对于实时进程）有机会得到较高的优先级，拥有较长的时间片，比较低优先级的进程能得到较多的计算时间，但是它们不会导致完全饿死低优先级进程。这种算法的优点是极大地提高了可扩展性。企业级工作负载通常包括大量的线程和进程，并且也有相当数量的处理器。新的O(1) CPU调度程序在2.6内核中被设计出来，但又可向前移植到2.4内核系列中。

新的调度程序另一个显著的优势是支持非统一内存架构（Non-Uniform Memory Architecture, NUMA）和对称多线程处理器（SMP），比如，Intel超线程（HT）技术（Intel Hyper-Threading technology）。

NUMA支持确保了负载均衡不会在NUMA节点之前发生，除非一个节点负担过重。这种机制确保了流量相对缓慢的可伸缩性链路在NUMA系统中达到最小化。虽然负载均衡可穿越处理器在调度域中将负载均衡到每个调度器滴答，但只有节点过载并要求负载均衡才会出现跨越调度域的工作负载。

## 完全公平调度程序
Completely Fair Scheduler (CFS)在Linux 2.6.23内核版本中第一次被引入，例如在Red Hat Enterprise Linux 6中，用来替代O(1)调度程序。CFS使用基于“虚拟时间”的红黑树。虚拟时间是基于进程等待运行的时间、竞争CPU的进程数量以及进程的优先级来计算的。具有最多虚拟时间的进程（最长等待CPU的时间）得到使用CPU的权限。随着它使用CPU周期的增加，它的虚拟时间在减少。一旦进程不再拥有最多的虚拟时间，它将被拥有最多虚拟时间的进程抢占。但是，它在内核中的代码却是比较简单的，规模和表现也良好，并且在它的调度下一些“病态的”用户进程想要伤害系统的交互性是很困难的。









