---
layout: post
categories: [Redis]
description: none
keywords: Redis
---
# Redis字符串


## 字符串（String）
字符串（string）键是Redis最基本的键值对类型，这种类型的键值对会在数据库中把单独的一个键和单独的一个值关联起来，被关联的键和值既可以是普通的文字数据，也可以是图片、视频、音频、压缩文件等更为复杂的二进制数据。

Redis为字符串键提供了一系列操作命令，通过使用这些命令，用户可以：
- 为字符串键设置值。
- 获取字符串键的值。
- 在获取旧值的同时为字符串键设置新值。
- 同时为多个字符串键设置值，或者同时获取多个字符串键的值。
- 获取字符串值的长度。
- 获取字符串值指定索引范围内的内容，或者对字符串值指定索引范围内的内容进行修改。
- 将一些内容追加到字符串值的末尾。
- 对字符串键存储的整数值或者浮点数值执行加法操作或减法操作。

### SET：为字符串键设置值
创建字符串键最常用的方法就是使用SET命令，这个命令可以为一个字符串键设置相应的值。在最基本的情况下，用户只需要向SET命令提供一个键和一个值就可以了：
```shell
SET key value
```
与之前提到过的一样，这里的键和值既可以是文字也可以是二进制数据。
比如通过执行以下命令，我们可以创建出一个键为"book"，值为"The Design and Implementation of Redis"的字符串键：
```
redis> SET book "The Design and Implementation of Redis"
OK
```
Redis数据库是以无序的方式存放数据库键的，一个新加入的键可能会出现在数据库的任何位置上，因此我们在使用Redis的过程中不应该对键在数据库中的摆放位置做任何假设，以免造成错误。

在默认情况下，对一个已经设置了值的字符串键执行SET命令将导致键的旧值被新值覆盖。举个例子，如果我们连续执行以下两条SET命令，那么第一条SET命令设置的值将被第二条SET命令设置的值所覆盖。

从Redis 2.6.12版本开始，用户可以通过向SET命令提供可选的NX选项或者XX选项来指示SET命令是否要覆盖一个已经存在的值：
```
SET key value [NX|XX]
```
如果用户在执行SET命令时给定了NX选项，那么SET命令只会在键没有值的情况下执行设置操作，并返回OK表示设置成功；如果键已经存在，那么SET命令将放弃执行设置操作，并返回空值nil表示设置失败。
以下代码展示了带有NX选项的SET命令的行为：
```
redis> SET password "123456" NX
OK       -- 对尚未有值的password键进行设置，成功
redis> SET password "999999" NX
(nil)    -- password键已经有了值，设置失败
```
因为第二条SET命令没有改变password键的值，所以password键的值仍然是刚开始时设置的"123456"。

如果用户在执行SET命令时给定了XX选项，那么SET命令只会在键已经有值的情况下执行设置操作，并返回OK表示设置成功；如果给定的键并没有值，那么SET命令将放弃执行设置操作，并返回空值表示设置失败。
```shell
redis> SET mysql-homepage "mysql.org"
OK    -- 为键mysql-homepage设置一个值
redis> SET mysql-homepage "mysql.com" XX
OK    -- 对键的值进行更新
```
在第二条SET命令执行之后，mysql-homepage键的值将从原来的"mysql.org"更新为"mysql.com"。

**注意**：不带任何可选项的SET命令从Redis 1.0.0版本开始可用；带有NX、XX等可选项的SET命令从Redis 2.6.12版本开始可用。

### GET：获取字符串键的值
用户可以使用GET命令从数据库中获取指定字符串键的值：
```
GET key
```
GET命令接受一个字符串键作为参数，然后返回与该键相关联的值。
我们可以通过执行以下GET命令来取得各个字符串键相关联的值：
```shell
redis> GET message
"hello world"
```
另外，如果用户给定的字符串键在数据库中并没有与之相关联的值，那么GET命令将返回一个空值：
```shell
redis> GET date
(nil)
```
上面这个GET命令的执行结果表示数据库中并不存在date键，也没有与之相关联的值。

因为Redis的数据库要求所有键必须拥有与之相关联的值，所以如果一个键有值，那么我们就说这个键存在于数据库；相反，如果一个键没有值，那么我们就说这个键不存在于数据库。

### GETSET：获取旧值并设置新值
GETSET命令就像GET命令和SET命令的组合版本，GETSET首先获取字符串键目前已有的值，接着为键设置新值，最后把之前获取到的旧值返回给用户：
```
GETSET key new_value
```
以下代码展示了如何使用GETSET命令去获取number键的旧值并为它设置新值：
```
redis> GET number    -- number键现在的值为"10086"
"10086"
redis> GETSET number "12345"
"10086"              -- 返回旧值
redis> GET number    -- number键的值已被更新为"12345"
"12345"
```
如果被设置的键并不存在于数据库，那么GETSET命令将返回空值作为键的旧值：

### 锁
锁是一种同步机制，用于保证一项资源在任何时候只能被一个进程使用，如果有其他进程想要使用相同的资源，那么就必须等待，直到正在使用资源的进程放弃使用权为止。

一个锁的实现通常会有获取（acquire）和释放（release）这两种操作：
- 获取操作用于取得资源的独占使用权。在任何时候，最多只能有一个进程取得锁，我们把成功取得锁的这个进程称为锁的持有者。在锁已经被持有的情况下，所有尝试再次获取锁的操作都会失败。
- 释放操作用于放弃资源的独占使用权，一般由锁的持有者调用。在锁被释放之后，其他进程就可以再次尝试获取这个锁了。

获取操作acquire（）方法是通过执行带有NX选项的SET命令来实现的：
NX选项的值确保了代表锁的字符串键只会在没有值的情况下被设置：
- 如果给定的字符串键没有值，那么说明锁尚未被获取，SET命令将执行设置操作，并将result变量的值设置为True。
- 如果给定的字符串键已经有值了，那么说明锁已经被获取，SET命令将放弃执行设置操作，并将result变量的值设置为None。

acquire（）方法最后会通过检查result变量的值是否为True来判断自己是否成功取得了锁。

release（）方法通过检查delete（）方法的返回值是否为1来判断删除操作是否执行成功：如果用户尝试对一个尚未被获取的锁执行release（）方法，那么方法将返回false，表示没有锁被释放。

在使用DEL命令删除代表锁的字符串键之后，字符串键将重新回到没有值的状态，这时用户就可以再次调用acquire（）方法去获取锁了。

锁实现了基本的获取和释放功能，但它并不完美：
- 因为这个锁的释放操作无法验证进程的身份，所以无论执行释放操作的进程是否为锁的持有者，锁都会被释放。如果锁被持有者以外的其他进程释放，那么系统中可能会同时出现多个锁，导致锁的唯一性被破坏。
- 这个锁的获取操作不能设置最大加锁时间，因而无法让锁在超过给定的时限之后自动释放。因此，如果持有锁的进程因为故障或者编程错误而没有在退出之前主动释放锁，那么锁就会一直处于已被获取的状态，导致其他进程永远无法取得锁。

### MSET：一次为多个字符串键设置值
Redis还提供了MSET命令用于对字符串键进行设置。MSET命令可以一次为多个字符串键设置值：
```
MSET key value [key value ...]
```
以下代码展示了如何使用一条MSET命令去设置message、number和homepage这3个键：
```
redis> MSET message "hello world" number "10086" homepage "redis.io"
OK
```
MSET命令也会在执行设置操作之后返回OK表示设置成功。此外，如果给定的字符串键已经有相关联的值，那么MSET命令也会直接使用新值去覆盖已有的旧值。

MSET命令除了可以让用户更为方便地执行多个设置操作之外，还能有效地提高程序的效率：执行多条SET命令需要客户端和服务器之间进行多次网络通信，并因此耗费大量的时间；而使用一条MSET命令去代替多条SET命令只需要一次网络通信，从而有效地减少程序执行多个设置操作时的时间。

### MGET：一次获取多个字符串键的值
MGET命令就是一个多键版本的GET命令，MGET接受一个或多个字符串键作为参数，并返回这些字符串键的值：
```
MGET key [key ...]
```
MGET命令返回一个列表作为结果，这个列表按照用户执行命令时给定键的顺序排列各个键的值。比如，列表的第一个元素就是第一个给定键的值，第二个元素是第二个给定键的值，以此类推。
作为例子，以下代码展示了如何使用一条MGET命令去获取message、number和homepage这3个键的值：
```
redis> MGET message number homepage
1) "hello world"    -- message键的值
2) "10086"          -- number键的值
3) "redis.io"       -- homepage键的值
```
MGET命令在碰到不存在的键时也会返回空值：
```
redis> MGET not-exists-key
1) (nil)
```
MGET命令也可以将执行多个获取操作所需的网络通信次数从原来的N次降低至只需一次，从而有效地提高程序的运行效率。

### MSETNX：只在键不存在的情况下，一次为多个字符串键设置值
MSETNX命令与MSET命令一样，都可以对多个字符串键进行设置：
```
MSETNX key value [key value ...]
```
MSETNX与MSET的主要区别在于，MSETNX只会在所有给定键都不存在的情况下对键进行设置，而不会像MSET那样直接覆盖键已有的值：如果在给定键当中，即使有一个键已经有值了，那么MSETNX命令也会放弃对所有给定键的设置操作。MSETNX命令在成功执行设置操作时返回1，在放弃执行设置操作时则返回0。

在以下代码中，因为键k4已经存在，所以MSETNX将放弃对键k1、k2、k3和k4进行设置操作：
```
redis> MGET k1 k2 k3 k4
1) (nil)            -- 键k1、 k2和k3都不存在
2) (nil)
3) (nil)
4) "hello world"    -- 键k4已存在

redis> MSETNX k1 "one" k2 "two" k3 "three" k4 "four"
(integer) 0    -- 因为键k4已存在，所以MSETNX未能执行设置操作

redis> MGET k1 k2 k3 k4    -- 各个键的值没有变化
1) (nil)
2) (nil)
3) (nil)
4) "hello world"
```

### STRLEN：获取字符串值的字节长度
通过对字符串键执行STRLEN命令，用户可以取得字符串键存储的值的字节长度：
```shell
STRLEN key
```
以下代码展示了如何使用STRLEN去获取不同字符串值的字节长度：
```
redis> GET number
"10086"
redis> STRLEN number    -- number键的值长5字节
(integer) 5
redis> GET message
"hello world"
redis> STRLEN message   -- message键的值长11字节
(integer) 11
```
对于不存在的键，STRLEN命令将返回0：
```
redis> STRLEN not-exists-key
(integer) 0
```

### GETRANGE：获取字符串值指定索引范围上的内容
通过使用GETRANGE命令，用户可以获取字符串值从start索引开始，直到end索引为止的所有内容：
```
GETRANGE key start end
```
GETRANGE命令接受的是闭区间索引范围，也就是说，位于start索引和end索引上的值也会被包含在命令返回的内容当中。

举个例子，以下代码展示了如何使用GETRANGE命令去获取message键的值的不同部分：
```
redis> GETRANGE message 0 4     -- 获取字符串值索引0至索引4上的内容
"hello"
redis> GETRANGE message 6 10    -- 获取字符串值索引6至索引10上的内容
"world"
```

### SETRANGE：对字符串值的指定索引范围进行设置
通过使用SETRANGE命令，用户可以将字符串键的值从索引index开始的部分替换为指定的新内容，被替换内容的长度取决于新内容的长度：
```
SETRANGE key index substitute
```
SETRANGE命令在执行完设置操作之后，会返回字符串值当前的长度作为结果。

例如，我们可以通过执行以下命令，将message键的值从原来的"hello world"修改为"hello Redis"：
```
redis> GET message
"hello world"
redis> SETRANGE message 6 "Redis"
(integer) 11    -- 字符串值当前的长度为11字节
redis> GET message
"hello Redis"
```
当用户给定的新内容比被替换的内容更长时，SETRANGE命令就会自动扩展被修改的字符串值，从而确保新内容可以顺利写入。 SETRANGE命令除了会根据用户给定的新内容自动扩展字符串值之外，还会根据用户给定的index索引扩展字符串。

当用户给定的index索引超出字符串值的长度时，字符串值末尾直到索引index-1之间的部分将使用空字节进行填充，换句话说，这些字节的所有二进制位都会被设置为0。

### APPEND：追加新内容到值的末尾
通过调用APPEND命令，用户可以将给定的内容追加到字符串键已有值的末尾：
```
APPEND key suffix
```
APPEND命令在执行追加操作之后，会返回字符串值当前的长度作为命令的返回值。

举个例子，对于以下这个名为description的键来说：
```
redis> GET description
"Redis"
redis> APPEND description " is a database"
(integer) 19    -- 追加操作执行完毕之后，值的长度
redis> GET description
"Redis is a database" --在执行完追加操作之后的值
```
如果用户给定的键并不存在，那么APPEND命令会先将键的值初始化为空字符串""，然后再执行追加操作，最终效果与使用SET命令为键设置值的情况类似：
```
redis> GET append_msg  -- 键不存在
(nil)
redis> APPEND append_msg "hello"  -- 效果相当于执行SET append_msg "hello"
(integer) 5
redis> GET append_msg
"hello"
```

### 使用字符串键存储数字值
每当用户将一个值存储到字符串键里面的时候，Redis都会对这个值进行检测，如果这个值能够被解释为以下两种类型的其中一种，那么Redis就会把这个值当作数字来处理：
- 第一种类型是能够使用C语言的long long int类型存储的整数，在大多数系统中，这种类型存储的都是64位长度的有符号整数，取值范围介于-9223372036854775808和9223372036854775807之间。
- 第二种类型是能够使用C语言的long double类型存储的浮点数，在大多数系统中，这种类型存储的都是128位长度的有符号浮点数，取值范围介于3.36210314311209350626e-4932和1.18973149535723176502e+4932L之间。

### INCRBY、DECRBY：对整数值执行加法操作和减法操作

### INCRBYFLOAT：对数字值执行浮点数加法操作

### 计数器
计数器也是构建应用程序时必不可少的组件之一，如对于网站的访客数量、用户执行某个操作的次数、某首歌或者某个视频的播放量、论坛帖子的回复数量等，记录这些信息都需要用到计数器。实际上，计数器在互联网中几乎无处不在，因此如何简单、高效地实现计数器一直都是构建应用程序时经常会遇到的一个问题。

计数器实现：这个程序把计数器的值存储在一个字符串键里面，并通过INCRBY命令和DECRBY命令对计数器的值执行加法操作和减法操作，在需要时，用户还可以通过调用GETSET方法来清零计数器并取得清零之前的旧值。

### 限速器
为了保障系统的安全性和性能，并保证系统的重要资源不被滥用，应用程序常常会对用户的某些行为进行限制，比如：
- 为了防止网站内容被网络爬虫抓取，网站管理者通常会限制每个IP地址在固定时间段内能够访问的页面数量，比如1min之内最多只能访问30个页面，超过这一限制的用户将被要求进行身份验证，确认本人并非网络爬虫，或者等到限制解除之后再进行访问。
- 为了防止用户的账号遭到暴力破解，网上银行通常会对访客的密码试错次数进行限制，如果一个访客在尝试登录某个账号的过程中，连续好几次输入了错误的密码，那么这个账号将被冻结，只能等到第二天再尝试登录，有的银行还会向账号持有者的手机发送通知来汇报这一情况。

实现这些限制机制的其中一种方法是使用限速器，它可以限制用户在指定时间段之内能够执行某项操作的次数。
使用字符串键实现的限速器：这个限速器程序会把操作的最大可执行次数存储在一个字符串键里面，然后在用户每次尝试执行被限制的操作之前，使用DECR命令将操作的可执行次数减1，最后通过检查可执行次数的值来判断是否执行该操作。












