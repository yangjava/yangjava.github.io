---
layout: post
categories: [Redis]
description: none
keywords: Redis
---
# Redis优化实战
Redis的性能如此之高归功于它的数据都存储在 内存 中！提前制定合理的内存优化策略，对于资源利用率的提升是很有必要的。

## 内存优化

### 控制key的长度
最简单直接的内存优化，就是控制 key 的长度。

在业务开发时，你需要提前预估整个 Redis 中写入 key 的数量，如果 key 数量达到了百万级别，那么，过长的 key 名也会占用过多的内存空间。

所以在保证 key 简单、清晰的前提下，尽可能把 key 定义得短一些。
```
例如，原有的 key 为 taobao:address:123，则可以优化为 tb:addr:123。
```
这个方案对Redis内存的优化非常直接和高效。

### 避免存储 bigkey
除了关注 key 的长度，同样需要关注 value 的大小，要避免出现大量存储bigkey的情况。

除此之外，客户端在读写 bigkey 时，还有产生性能问题。

所以，你要避免在 Redis 中存储 bigkey，我给你的建议是：
- String：大小控制在 10KB 以下
- List/Hash/Set/ZSet：元素数量控制在 1 万以下

### 选择合适的数据类型
Redis 提供了丰富的数据类型，这些数据类型在实现上，也对内存使用做了优化。

例如，String、Set 在存储 int 数据时，会采用整数编码存储。Hash、ZSet 在元素数量比较少时（可配置），会采用压缩列表（ziplist）存储，在存储比较多的数据时，才会转换为哈希表和跳表。

作者这么设计的原因，就是为了进一步节约内存资源。

那么你在存储数据时，就可以利用这些特性来优化 Redis 的内存。这里我给你的建议如下：

- String、Set：尽可能存储 int 类型数据
- Hash、ZSet：存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存

### 不要当做数据库来使用
Redis 数据存储在内存中，这也意味着其资源是有限的。你在使用 Redis 时，要把它当做缓存来使用，而不是数据库。

所以，你的应用写入到 Redis 中的数据，尽可能地都设置「过期时间」。

业务应用的代码逻辑应该是在 Redis 中查不到数据时，再从后端数据库中加载到 Redis 中。

### 实例设置 maxmemory + 淘汰策略
虽然你的 Redis key 都设置了过期时间，但如果你的业务应用写入量很大，并且过期时间设置得比较久，那么短期间内 Redis 的内存依旧会快速增长。

如果不控制 Redis 的内存上限，也会导致使用过多的内存资源。

对于这种场景，需要提前预估业务数据量，然后给这个实例设置 maxmemory 控制实例的内存上限，这样可以避免 Redis 的内存持续膨胀。

配置了 maxmemory，此时你还要设置数据淘汰策略，而淘汰策略如何选择，你需要结合你的业务特点来决定：

- volatile-lru / allkeys-lru：优先保留最近访问过的数据
- volatile-lfu / allkeys-lfu：优先保留访问次数最频繁的数据（4.0+版本支持）
- volatile-ttl ：优先淘汰即将过期的数据
- volatile-random / allkeys-random：随机淘汰数据











































