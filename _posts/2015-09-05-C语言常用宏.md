---
layout: post
categories: [C]
description: none
keywords: C
---
# C语言常用宏
写好C语言，漂亮的宏定义很重要，使用宏定义可以防止出错，提高可移植性，可读性，方便性等等。

## 使用宏定义避免重复引入
在实际多文件开发中，我们往往使用如下的宏定义来避免发生重复引入：
```
#ifndef _NAME_H
#define _NAME_H
//头文件内容
#endif
```
其中，_NAME_H 是宏的名称。需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同。

当程序中第一次 #include 该文件时，由于 _NAME_H 尚未定义，所以会定义 _NAME_H 并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 _NAME_H，所以不会再重复执行“头文件内容”部分的代码。

也就是说，我们可以将前面项目中的 student.h 文件做如下修改：
```
#ifndef _STUDENT_H
#define _STUDENT_H
class Student {
    //......
};
#endif
```
虽然该项目 main.cpp 文件中仍 #include 了 2 次 "student.h"，但鉴于 _STUDENT_H 宏只能定义一次，所以 Student 类也仅会定义一次。再次执行该项目会发现，其可以正常执行。

## 重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。
```
typedef unsigned char boolean; /* Boolean value type. */
typedef unsigned long int uint32; /* Unsigned 32 bit value */
typedef unsigned short uint16; /* Unsigned 16 bit value */
typedef unsigned char uint8; /* Unsigned 8 bit value */
typedef signed long int int32; /* Signed 32 bit value */
typedef signed short int16; /* Signed 16 bit value */
typedef signed char int8; /* Signed 8 bit value */
```

下面的不建议使用：
```
typedef unsigned char byte; /* Unsigned 8 bit value type. */
typedef unsigned short word; /* Unsinged 16 bit value type. */
typedef unsigned long dword; /* Unsigned 32 bit value type. */
typedef unsigned char uint1; /* Unsigned 8 bit value type. */
typedef unsigned short uint2; /* Unsigned 16 bit value type. */
typedef unsigned long uint4; /* Unsigned 32 bit value type. */
typedef signed char int1; /* Signed 8 bit value type. */
typedef signed short int2; /* Signed 16 bit value type. */
typedef long int int4; /* Signed 32 bit value type. */
typedef signed long sint31; /* Signed 32 bit value */
typedef signed short sint15; /* Signed 16 bit value */
typedef signed char sint7; /* Signed 8 bit value */
```

## 得到指定地址上的一个字节或字
```
#define MEM_B( x ) ( *( (byte *) (x) ) )
#define MEM_W( x ) ( *( (word *) (x) ) )
```

## 求最大值和最小值
```
#define MAX( x, y ) ( ((x) > (y)) ? (x) : (y) )
#define MIN( x, y ) ( ((x) < (y)) ? (x) : (y) )
```

## 得到一个field在结构体(struct)中的偏移量
```
#define FPOS( type, field )
/*lint -e545 */ ( (dword) &(( type *) 0)-> field ) /*lint +e545 */
```

## 得到一个结构体中field所占用的字节数
```
#define FSIZ( type, field ) sizeof( ((type *) 0)->field )
```

## 按照LSB格式把两个字节转化为一个Word
```
#define FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )
```

## 按照LSB格式把一个Word转化为两个字节
```
#define FLOPW( ray, val )
(ray)[0] = ((val) / 256);
(ray)[1] = ((val) & 0xFF)
```

## 得到一个变量的地址(word宽度)
```
#define B_PTR( var ) ( (byte *) (void *) &(var) )
#define W_PTR( var ) ( (word *) (void *) &(var) )
```

## 得到一个字的高位和低位字节
```
#define WORD_LO(xxx) ((byte) ((word)(xxx) & 255))
#define WORD_HI(xxx) ((byte) ((word)(xxx) >> 8))
```

## 返回一个比X大的最接近的8的倍数
```
#define RND8( x ) ((((x) + 7) / 8 ) * 8 )
```

## 将一个字母转换为大写
```
#define UPCASE( c ) ( ((c) >= 'a' && (c) <= 'z') ? ((c) - 0x20) : (c) )
```

## 判断字符是不是10进制的数字
```
#define DECCHK( c ) ((c) >= '0' && (c) <= '9')
```

## 判断字符是不是16进制的数字
```
#define HEXCHK( c ) ( ((c) >= '0' && (c) <= '9') ||
((c) >= 'A' && (c) <= 'F') ||
((c) >= 'a' && (c) <= 'f') )
```

## 防止溢出的一个方法
```
#define INC_SAT( val ) (val = ((val)+1 > (val)) ? (val)+1 : (val))
```

## 返回数组元素的个数
```
#define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )
```

## 返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)
```
#define MOD_BY_POWER_OF_TWO( val, mod_by )
( (dword)(val) & (dword)((mod_by)-1) )
```

## 对于IO空间映射在存储空间的结构，输入输出处理
```
#define inp(port) (*((volatile byte *) (port)))
#define inpw(port) (*((volatile word *) (port)))
#define inpdw(port) (*((volatile dword *)(port)))
#define outp(port, val) (*((volatile byte *) (port)) = ((byte) (val)))
#define outpw(port, val) (*((volatile word *) (port)) = ((word) (val)))
#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
```










