---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL源码查询展开

## 整体介绍
内容基于 MySQL 8.0.32 源码。

对于 select * from table 中的星号，我们再熟悉不过了：它告诉 MySQL 返回表所有字段的内容。

MySQL 服务端收到 select 语句之后，会在 server 层把星号展开为表中的所有字段，然后告诉存储引擎返回这些字段的内容。

对于存储引擎来说，它只需要按照 server 层的要求返回指定字段的内容即可，它不知道（也不需要知道）客户端是要求返回表中所有字段，还是部分字段的内容。

select * 中的星号展开为表中所有字段涉及 2 个阶段：
- 词法 & 语法分析阶段：标记 select 字段列表中包含几个星号。
- 查询准备阶段：把星号展开为表中所有字段。

## 源码分析
Item_asterisk::itemize()
```
// sql/item.cc
bool Item_asterisk::itemize(Parse_context *pc, Item **res) {
  ...
  pc->select->with_wild++;
  return false;
}
```
多表连接时，select 字段列表中可能会包含多个星号，词法 & 语法分析阶段，每碰到 select 字段列表中的一个星号，Item_asterisk::itemize() 就会给 pc->select->with_wild 属性加 1。

pc->select 是 Query_block 对象的指针，定义如下：
```
// sql/parse_tree_node_base.h
struct Parse_context {
  ...
  Query_block *select; ///< Current Query_block object
  ...
};
```
后面 Query_block::prepare() 访问的 with_wild 属性就是这里的 pc->select->with_wild。

## Query_block::prepare()
```
// sql/sql_resolver.cc
bool Query_block::prepare(THD *thd, mem_root_deque<Item *> *insert_field_list) {
  ...
  if (with_wild && setup_wild(thd)) return true;
  ...
}
```
prepare() 方法中，关于 select * 的逻辑比较简单，就这一行。

如果 with_wild 大于 0，则调用 setup_wild(thd)，处理 select 字段列表中星号展开为表中所有字段的逻辑。

## Query_block::setup_wild()

```
// sql/sql_resolver.cc
bool Query_block::setup_wild(THD *thd) {
  ...
  // 从 select 字段列表中的第 1 个字段开始处理
  // 满足 2 个条件中的任意一个就结束循环：
  // 1. with_wild > 0 为 false，
  //    说明已处理完所有星号，结束循环
  // 2. it != fields.end() 为 false，
  //    说明已经处理了所有字段，结束循环
  for (auto it = fields.begin(); with_wild > 0 && it != fields.end(); ++it) {
    Item *item = *it;
    // item->hidden = true
    // 表示 select 字段列表中的这个字段
    // 是查询优化器给【偷偷】加上的
    // 肯定不会是星号，直接跳过
    if (item->hidden) continue;
    Item_field *item_field;
    // Item::FIELD_ITEM 说明当前循环的字段
    // 是个普通字段，不是函数、子查询等
    // 那它就有可能是星号，需要通过 item_field->is_asterisk() 
    // 进一步判断是否是星号
    if (item->type() == Item::FIELD_ITEM &&
        (item_field = down_cast<Item_field *>(item)) &&
        // 如果 item_field 对应的字段是星号
        // item_field->is_asterisk() 会返回 true
        item_field->is_asterisk()) {
      assert(item_field->field == nullptr);
      // 只有 create view as ... 中的 select 语句
      // any_privileges 为 true
      // 其它情况下，它的值为 false
      // insert_fields() 方法中会用到
      const bool any_privileges = item_field->any_privileges;
      // 如果当前 Query_block 对应的是子查询
      // master_query_expression()->item
      // 指向主查询中该子查询所属的 where 条件
      Item_subselect *subsel = master_query_expression()->item;
      ...
      // 当前 Query_block 是 exists 子查询
      // 并且子查询中不包含 having 子句
      // 则可以把子查询中的星号替换为常量
      if (subsel && subsel->substype() == Item_subselect::EXISTS_SUBS &&
          !having_cond()) {
        ...
        *it = new Item_int(NAME_STRING("Not_used"), 1,
                           MY_INT64_NUM_DECIMAL_DIGITS);
      } else {
      // 不满足 if 中的条件
      // 则需要调用 insert_fields()
      // 把星号展开为表中所有字段
        assert(item_field->context == &this->context);
        if (insert_fields(thd, this, item_field->db_name,
                          item_field->table_name, &fields, &it, any_privileges))
          return true;
      }

      // 每处理完 select 字段列表中的一个星号
      // with_wild 就减 1
      // 减到 0 之后，就说明所有星号都已经处理过了
      with_wild--;
    }
  }

  return false;
}
```
Query_block::setup_wild() 的主体逻辑是迭代 select 字段列表中的每个字段，遇到星号就处理，不是星号就忽略，星号的处理逻辑有 2 种：

第 1 种：满足 if (subsel && ...) 条件，说明 select 语句是 where 条件中的 exists 子查询，并且子查询中不包含 having 子句。这种场景下，select 字段列表中的星号可以被替换为常量，而不需要展开为表的所有字段。

*it = new Item_int(...) 创建了一个代表常量的字段对象，字段名为 Not_used，字段值为 1，用于替换 select 字段列表中的星号。

这种场景的示例 SQL 如下：
```
select st1, i1 from t1 where exists(
  select * from t2 where t1.i1 = t2.i1
)
```
子查询只需要判断 t2 表中是否存在满足 t1.i1 = t2.i1 的记录，而不需要读取 t2 表的所有字段，因为读取了所有字段，也用不上，纯属浪费，所以，星号也就可以被替换成常量了。替换之后的 SQL 相当于这样：
```
select st1, i1 from t1 where exists(
  select 1 from t2 where t1.i1 = t2.i1
)
```
实际上，子查询执行过程中，server 层会要求存储引擎返回 t2 表的 i1 字段内容，用于判断 t2 表中是否存在满足 t1.i1 = t2.i1 的记录。

这个逻辑是 server 层自主实现的，和 select * 中的星号展开为表中所有字段的逻辑不相关，我们知道有这个逻辑就可以，不展开介绍了。

不满足 if (subsel && ...) 条件，就需要调用 insert_fields()，把 select 字段列表中的星号展开为表的所有字段。

## insert_fields()
```
// sql/sql_base.cc
bool insert_fields(THD *thd, Query_block *query_block, const char *db_name,
                   const char *table_name, mem_root_deque<Item *> *fields,
                   mem_root_deque<Item *>::iterator *it, bool any_privileges) {
  ...
  bool found = false;

  Table_ref *tables;
  // 按照 select 语句中表的出现顺序
  // 初始化表的迭代器
  Tables_in_user_order_iterator user_it;
  user_it.init(query_block, table_name != nullptr);

  while (true) {
    // 从迭代器中获取下一个需要处理的表
    tables = user_it.get_next();
    // tables == nullptr 说明迭代结束，结束循环
    if (tables == nullptr) break;
    // 表中的字段迭代器
    Field_iterator_table_ref field_iterator;
    TABLE *const table = tables->table;

    assert(tables->is_leaf_for_name_resolution());

    // if 进行 2 个条件判断，任何一个不满足则跳过当前表：
    // 1. table_name 不为 NULL 说明星号前面指定了表名
    //    比较星号前面的表名和当前迭代的表名是否相同
    // 2. db_name 不为 NULL 说明星号前面指定了数据库名
    //    比较星号前面的数据库名和当前迭代的表所属的数据库名是否相同
    if ((table_name &&
         my_strcasecmp(table_alias_charset, table_name, tables->alias)) ||
        (db_name && strcmp(tables->db, db_name))) 
      continue;

    // 以下 2 种情况都满足，需要检查
    // 当前连接用户是否有表中所有字段的 select 权限：
    // 1. !any_privileges 为 true
    //    说明当前 select 语句
    //    不是 create view as ... 中的 select 语句
    // 2. 当前连接用户没有表的 select 权限，
    if (!any_privileges && !(tables->grant.privilege & SELECT_ACL)) {
      field_iterator.set(tables);
      if (check_grant_all_columns(thd, SELECT_ACL, &field_iterator))
        return true;
    }
    ...
    // 初始化字段迭代器
    field_iterator.set(tables);
    // 迭代当前表的每一个字段
    for (; !field_iterator.end_of_fields(); field_iterator.next()) {
      // 根据字段对象创建 Item
      Item *const item = field_iterator.create_item(thd);
      if (!item) return true; /* purecov: inspected */
      assert(item->fixed);
      ...
      // found 的初始值为 false，
      // 表示这是表中第 1 个字段
      // 用该字段的 Item 对象替换星号的 Item 对象
      if (!found) {
        found = true;
        **it = item; /* Replace '*' with the first found item. */
      } else {
      // 表中第 2 个及以后的字段时，
      // Item 对象赋值给 it + 1 指向的位置
      // 也就是加入了 select 字段列表
        /* Add 'item' to the SELECT list, after the current one. */
        *it = fields->insert(*it + 1, item);
      }
      ...
    }
  }
  ...
```
insert_fields() 的主要逻辑如下：

按照 select 语句中表的出现顺序迭代每个表，每迭代一个表，都会判断该表名和星号前面的表名（如果有）是否相同，以及该表所属的数据库名和星号前面的数据库名是否相同（如果有）。

如果当前迭代的表名、表所属的数据库名和星号前面的表名、数据库名都相同，接下来会进行访问权限检查。

如果当前连接用户有表的 select 权限，说明它对表中的所有列都有查询权限，否则，需要调用 check_grant_all_columns(...)，检查它对表中每一个字段是否有 select 权限。

通过权限检查之后，就开始迭代表中的每个字段，每迭代一个字段，都根据该字段构造一个 Item 对象，并把 Item 对象加入 select 字段列表。

## 总结
select * 中的星号展开为表中所有字段涉及词法 & 语法分析阶段、查询准备阶段，总结如下：

迭代 select 字段列表中的每个字段。
碰到星号会判断是否需要展开为表的所有字段。
如果需要展开，则按照 select 语句中表的出现顺序迭代每个表。
迭代每个表时，检查当前连接用户是否有该表或表中所有字段的 select 权限。
通过权限检查之后，把当前迭代的表的字段逐个加入 select 字段列表。



































































































































