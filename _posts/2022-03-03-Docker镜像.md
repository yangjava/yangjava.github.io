---
layout: post
categories: Docker
description: none
keywords: Docker
---
# Docker镜像
镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时的库、环境变量和配置文件。

镜像是一个只读模板，带有创建Docker容器的说明。通常，一个镜像基于另一个镜像，并带有一些额外的定制。例如，您可以构建一个基于ubuntu镜像的镜像，但是要安装Apache web服务器和您的应用程序，以及运行应用程序所需的配置细节。

Docker 镜像（Image），就相当于是一个 模板，其中包含创建 Docker 容器的说明，可以通过模板来创建容器服务，通过这个镜像我们可以创建多个容器，最终服务运行或项目运行都是在容器中的。

Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新 的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。

## 镜像简介

镜像包含了一个软件的运行环境，是一个不包含Linux内核而又精简的Linux操作系统，一个镜像可以创建N个容器。

镜像是一个分层存储的架构，由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。

从下载过程中可以看到，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。

```
[root@localhost usr]# docker pull mysql
Using default tag: latest
latest: Pulling from library/mysql
a4b007099961: Pull complete 
e2b610d88fd9: Pull complete 
38567843b438: Pull complete 
5fc423bf9558: Pull complete 
aa8241dfe828: Pull complete 
cc662311610e: Pull complete 
9832d1192cf2: Pull complete 
f2aa1710465f: Pull complete 
4a2d5722b8f3: Pull complete 
3a246e8d7cac: Pull complete 
2f834692d7cc: Pull complete 
a37409568022: Pull complete 
Digest: sha256:b2ae0f527005d99bacdf3a220958ed171e1eb0676377174f0323e0a10912408a
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest
```

通过 **docker history <ID/NAME>** 查看镜像中各层内容及大小，每层会对应着 Dockerfile 中的一条指令。

```
[root@localhost usr]# docker history mysql
IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT
562c9bc24a08   5 days ago   /bin/sh -c #(nop)  CMD ["mysqld"]               0B        
<missing>      5 days ago   /bin/sh -c #(nop)  EXPOSE 3306 33060            0B        
<missing>      5 days ago   /bin/sh -c #(nop)  ENTRYPOINT ["docker-entry…   0B        
<missing>      5 days ago   /bin/sh -c ln -s usr/local/bin/docker-entryp…   34B       
<missing>      5 days ago   /bin/sh -c #(nop) COPY file:e9a583a365264f0f…   13.5kB    
<missing>      5 days ago   /bin/sh -c #(nop) COPY dir:2e040acc386ebd23b…   1.12kB    
<missing>      5 days ago   /bin/sh -c #(nop)  VOLUME [/var/lib/mysql]      0B        
<missing>      5 days ago   /bin/sh -c {   echo mysql-community-server m…   384MB     
<missing>      5 days ago   /bin/sh -c echo 'deb [ signed-by=/etc/apt/ke…   97B       
<missing>      5 days ago   /bin/sh -c #(nop)  ENV MYSQL_VERSION=8.0.28-…   0B        
<missing>      5 days ago   /bin/sh -c #(nop)  ENV MYSQL_MAJOR=8.0          0B        
<missing>      5 days ago   /bin/sh -c set -eux;  key='859BE8D7C586F5384…   2.29kB    
<missing>      5 days ago   /bin/sh -c set -eux;  apt-get update;  apt-g…   53.6MB    
<missing>      5 days ago   /bin/sh -c mkdir /docker-entrypoint-initdb.d    0B        
<missing>      5 days ago   /bin/sh -c set -eux;  savedAptMark="$(apt-ma…   4.06MB    
<missing>      5 days ago   /bin/sh -c #(nop)  ENV GOSU_VERSION=1.14        0B        
<missing>      5 days ago   /bin/sh -c apt-get update && apt-get install…   9.34MB    
<missing>      5 days ago   /bin/sh -c groupadd -r mysql && useradd -r -…   329kB     
<missing>      6 days ago   /bin/sh -c #(nop)  CMD ["bash"]                 0B        
<missing>      6 days ago   /bin/sh -c #(nop) ADD file:7f5787c324936e09d…   69.3MB  
```

由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。

```
[root@localhost usr]# docker images
REPOSITORY   TAG       IMAGE ID       CREATED      SIZE
mysql        latest    562c9bc24a08   5 days ago   521MB

```

## 镜像原理

UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

类似于花卷这种常见的早餐,文件系统可以通过一层一层的嵌套,对外暴露统一的"表面层"来供使用者操作

> 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录

docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。

bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。

rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。

**平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？**

对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。

## 镜像管理

Docker 运行容器前需要本地存在对应的镜像，如果镜像不存在本地，Docker 会从镜像仓库下载，默认是 Docker Hub 公共注册服务器中的仓库。

Docker Hub 是由 Docker 公司负责维护的公共注册中心，包含大量的优质容器镜像，Docker 工具默认从这个公共镜像库下载镜像。下载的镜像如何使用可以参考官方文档。

地址：https://hub.docker.com/explore

如果从 Docker Hub 下载镜像非常缓慢，可以先配置镜像加速器，

参考：https://www.daocloud.io/mirror

Linux下通过以下命令配置镜像站：

```
# curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io

# systemctl restart docker
```

### ① 搜索镜像

**docker search <NAME> [选项]**

```
[root@localhost usr]# docker search mysql
NAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql                            MySQL is a widely used, open-source relation…   12289     [OK]       
mariadb                          MariaDB Server is a high performing open sou…   4726      [OK]       
mysql/mysql-server               Optimized MySQL Server Docker images. Create…   911                  [OK]
percona                          Percona Server is a fork of the MySQL relati…   572       [OK]       
phpmyadmin                       phpMyAdmin - A web interface for MySQL and M…   476       [OK]       
mysql/mysql-cluster              Experimental MySQL Cluster Docker images. Cr…   93                   
centos/mysql-57-centos7          MySQL 5.7 SQL database server                   92                   
bitnami/mysql                    Bitnami MySQL Docker Image                      67                   [OK]
databack/mysql-backup            Back up mysql databases to... anywhere!         58                   
ubuntu/mysql                     MySQL open source fast, stable, multi-thread…   25                   
circleci/mysql                   MySQL is a widely used, open-source relation…   25                   
mysql/mysql-router               MySQL Router provides transparent routing be…   23                   
centos/mysql-56-centos7          MySQL 5.6 SQL database server                   22                   
google/mysql                     MySQL server for Google Compute Engine          20                   [OK]
vmware/harbor-db                 Mysql container for Harbor                      10                   
mysqlboy/mydumper                mydumper for mysql logcial backups              3                    
mysqlboy/docker-mydumper         docker-mydumper containerizes MySQL logical …   3                    
bitnami/mysqld-exporter                                                          2                    
ibmcom/mysql-s390x               Docker image for mysql-s390x                    1                    
mirantis/mysql                                                                   0                    
mysqlboy/elasticsearch                                                           0                    
mysqleatmydata/mysql-eatmydata                                                   0                    
ibmcom/tidb-ppc64le              TiDB is a distributed NewSQL database compat…   0                    
mysql/mysql-operator             MySQL Operator for Kubernetes                   0                    
cimg/mysql                                                                       0     
```

各个选项说明:

- **NAME:** 镜像仓库源的名称
- **DESCRIPTION:** 镜像的描述
- **OFFICIAL:** 是否 docker 官方发布
- **stars:** 类似 Github 里面的 star，表示点赞、喜欢的意思。
- **AUTOMATED:** 自动构建。



### ② 下载镜像

**docker pull [选项] [Docker Registry地址]<仓库名>:<标签>**

Docker Registry地址：地址的格式一般是 <域名/IP>[:端口号] 。默认地址是Docker Hub。

仓库名：仓库名是两段式名称，既 <用户名>/<软件名> 。对于 Docker Hub，如果不给出用户名，则默认为 library ，也就是官方镜像。

```
[root@localhost usr]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
Digest: sha256:bfea6278a0a267fad2634554f4f0c6f31981eea41c553fdf5a83e95a41d40c38
Status: Image is up to date for hello-world:latest
docker.io/library/hello-world:latest

```

### ③ 列出本地镜像

**docker images [选项]**

```
[root@localhost usr]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
mysql         latest    562c9bc24a08   5 days ago     521MB
hello-world   latest    feb5d9fea6a5   6 months ago   13.3kB
```

各个选项说明:

- **REPOSITORY：**表示镜像的仓库源
- **TAG：**镜像的标签
- **IMAGE ID：**镜像ID
- **CREATED：**镜像创建时间
- **SIZE：**镜像大小



同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。

所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：

```
[root@localhost usr]# docker run -t -i ubuntu:15.10 /bin/bash 
```

参数说明：

- **-i**: 交互式操作。
- **-t**: 终端。
- **ubuntu:15.10**: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。
- **/bin/bash**：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。

如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。



查看虚悬镜像（镜像既没有仓库名，也没有标签，显示为 <none>）：**docker images -f dangling=true**

默认的 docker images 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像：**docker images -a**

只列出镜像ID：**docker images -q**

列出部分镜像：**docker images redis**

以特定格式显示：**docker images --format "{{.ID}}: {{.Repository}}"**

### ④ 给镜像打 Tag

**docker tag <IMAGE ID> [<\**用户名\**>/]<镜像名>:<标签>**

镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。

我们可以使用 docker tag 命令，为镜像添加一个新的标签。

```
[root@localhost usr]# docker tag 860c279d2fec root/centos:dev
```

docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。

使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。

### ⑤ 删除本地镜像

**docker rmi [选项] <镜像1> [<镜像2> ...]**

<镜像> 可以是镜像短 ID、镜像长 ID、镜像名或者镜像摘要。

删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的Untagged 的信息。

镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。

除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。

### ⑥ 批量删除镜像

删除所有虚悬镜像：**docker rmi $(docker images -q -f dangling=true)**

删除所有仓库名为 redis 的镜像：**docker rmi $(docker images -q redis)**

删除所有在 mysql:8.0 之前的镜像：**docker rmi $(docker images -q -f before=mysql:8.0)**

### ⑦ 导出镜像

**docker save -o <镜像文件> <镜像>**

可以将一个镜像完整的导出，就可以传输到其它地方去使用。

![img](https://img2018.cnblogs.com/blog/856154/201909/856154-20190910000642896-1030526149.png)

### ⑧ 导入镜像

**docker load -i <镜像文件>**

![img](https://img2018.cnblogs.com/blog/856154/201909/856154-20190910000534924-1667611011.png)

###  ⑨更新镜像

更新镜像之前，我们需要使用镜像来创建一个容器。

更新镜像之前，我们需要使用镜像来创建一个容器。

```
[root@localhost usr]# docker run -t -i ubuntu:15.10 /bin/bash
```

在运行的容器内使用 **apt-get update** 命令进行更新。

在完成操作之后，输入 exit 命令来退出这个容器。

此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。

```
[root@localhost usr]# docker commit -m="has update" -a="runoob" e218edb10161 runoob/ubuntu:v2
```

各个参数说明：

- **-m:** 提交的描述信息
- **-a:** 指定镜像作者
- **e218edb10161：**容器 ID
- **runoob/ubuntu:v2:** 指定要创建的目标镜像名

### ⑩构建镜像

我们使用命令 **docker build** ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。

每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。

第一条FROM，指定使用哪个镜像源

RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。

然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。


## Docker镜像相关概念
据Docker官网的技术文档描述，Image（镜像）是Docker术语的一种，代表一个只读的layer。而layer则具体代表Docker Container文件系统中可叠加的一部分。
那么理解之前，先让我们来认识一下与Docker镜像相关的4个概念：rootfs、Union mount、image以及layer。

### rootfs
Rootfs：代表一个Docker Container在启动时（而非运行后）其内部进程可见的文件系统视角，或者是Docker Container的根目录。当然，该目录下含有Docker Container所需要的系统文件、工具、容器文件等。

传统来说，Linux操作系统内核启动时，内核首先会挂载一个只读（read-only）的rootfs，当系统检测其完整性之后，决定是否将其切换为读写（read-write）模式，或者最后在rootfs之上另行挂载一种文件系统并忽略rootfs。Docker架构下，依然沿用Linux中rootfs的思想。当Docker Daemon为Docker Container挂载rootfs的时候，与传统Linux内核类似，将其设定为只读（read-only）模式。在rootfs挂载完毕之后，和Linux内核不一样的是，Docker Daemon没有将Docker Container的文件系统设为读写（read-write）模式，而是利用Union mount的技术，在这个只读的rootfs之上再挂载一个读写（read-write）的文件系统，挂载时该读写（read-write）文件系统内空无一物。

举一个Ubuntu容器启动的例子。假设用户已经通过Docker Registry下拉了Ubuntu:14.04的镜像，并通过命令docker run –it ubuntu:14.04 /bin/bash将其启动运行。则Docker Daemon为其创建的rootfs以及容器可读写的文件系统
```text
drwxr-xr-x   1 root root 4096 Feb 13 01:54 .
drwxr-xr-x   1 root root 4096 Feb 13 01:54 ..
-rwxr-xr-x   1 root root    0 Feb 13 01:54 .dockerenv
lrwxrwxrwx   1 root root    7 Nov  1 21:15 bin -> usr/bin
drwxr-xr-x   2 root root 4096 Apr 18  2022 boot
drwxr-xr-x   5 root root  360 Feb 13 01:54 dev
drwxr-xr-x   1 root root 4096 Feb 13 01:54 etc
drwxr-xr-x   2 root root 4096 Apr 18  2022 home
lrwxrwxrwx   1 root root    7 Nov  1 21:15 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Nov  1 21:15 lib32 -> usr/lib32
lrwxrwxrwx   1 root root    9 Nov  1 21:15 lib64 -> usr/lib64
lrwxrwxrwx   1 root root   10 Nov  1 21:15 libx32 -> usr/libx32
drwxr-xr-x   2 root root 4096 Nov  1 21:15 media
drwxr-xr-x   2 root root 4096 Nov  1 21:15 mnt
drwxr-xr-x   2 root root 4096 Nov  1 21:15 opt
dr-xr-xr-x 399 root root    0 Feb 13 01:54 proc
drwx------   2 root root 4096 Nov  1 21:18 root
drwxr-xr-x   5 root root 4096 Nov  1 21:18 run
lrwxrwxrwx   1 root root    8 Nov  1 21:15 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Nov  1 21:15 srv
dr-xr-xr-x  11 root root    0 Feb 13 01:54 sys
drwxrwxrwt   2 root root 4096 Nov  1 21:18 tmp
drwxr-xr-x  14 root root 4096 Nov  1 21:15 usr
drwxr-xr-x  11 root root 4096 Nov  1 21:18 var
```
正如read-only和read-write的含义那样，该容器中的进程对rootfs中的内容只拥有读权限，对于read-write读写文件系统中的内容既拥有读权限也拥有写权限。容器虽然只有一个文件系统，但该文件系统由“两层”组成，分别为读写文件系统和只读文件系统。这样的理解已然有些层级（layer）的意味。 简单来讲，可以将Docker Container的文件系统分为两部分，而上文提到是Docker Daemon利用Union Mount的技术，将两者挂载。那么Union mount又是一种怎样的技术？

## Union mount
Union mount：代表一种文件系统挂载的方式，允许同一时刻多种文件系统挂载在一起，并以一种文件系统的形式，呈现多种文件系统内容合并后的目录。

一般情况下，通过某种文件系统挂载内容至挂载点的话，挂载点目录中原先的内容将会被隐藏。而Union mount则不会将挂载点目录中的内容隐藏，反而是将挂载点目录中的内容和被挂载的内容合并，并为合并后的内容提供一个统一独立的文件系统视角。通常来讲，被合并的文件系统中只有一个会以读写（read-write）模式挂载，而其他的文件系统的挂载模式均为只读（read-only）。实现这种Union mount技术的文件系统一般被称为Union Filesystem，较为常见的有UnionFS、AUFS、OverlayFS等。

Docker实现容器文件系统Union mount时，提供多种具体的文件系统解决方案，如Docker早版本沿用至今的的AUFS，还有在docker 1.4.0版本中开始支持的OverlayFS等。 更深入的了解Union mount，可以使用AUFS文件系统来进一步阐述上文中ubuntu:14.04容器文件系统的例子。

使用镜像ubuntu:14.04创建的容器中，可以暂且将该容器整个rootfs当成是一个文件系统。上文也提到，挂载时读写（read-write）文件系统中空无一物。既然如此，从用户视角来看，容器内文件系统和rootfs完全一样，用户完全可以按照往常习惯，无差别的使用自身视角下文件系统中的所有内容；然而，从内核的角度来看，两者在有着非常大的区别。追溯区别存在的根本原因，那就不得不提及AUFS等文件系统的COW（copy-on-write）特性。

COW文件系统和其他文件系统最大的区别就是：从不覆写已有文件系统中已有的内容。由于通过COW文件系统将两个文件系统（rootfs和read-write filesystem）合并，最终用户视角为合并后的含有所有内容的文件系统，然而在Linux内核逻辑上依然可以区别两者，那就是用户对原先rootfs中的内容拥有只读权限，而对read-write filesystem中的内容拥有读写权限。

既然对用户而言，全然不知哪些内容只读，哪些内容可读写，这些信息只有内核在接管，那么假设用户需要更新其视角下的文件/etc/hosts，而该文件又恰巧是rootfs只读文件系统中的内容，内核是否会抛出异常或者驳回用户请求呢？答案是否定的。当此情形发生时，COW文件系统首先不会覆写read-only文件系统中的文件，即不会覆写rootfs中/etc/hosts，其次反而会将该文件拷贝至读写文件系统中，即拷贝至读写文件系统中的/etc/hosts，最后再对后者进行更新操作。如此一来，纵使rootfs与read-write filesystem中均由/etc/ hosts，诸如AUFS类型的COW文件系统也能保证用户视角中只能看到read-write filesystem中的/etc/hosts，即更新后的内容。

当然，这样的特性同样支持rootfs中文件的删除等其他操作。例如：用户通过apt-get软件包管理工具安装Golang，所有与Golang相关的内容都会被安装在读写文件系统中，而不会安装在rootfs。此时用户又希望通过apt-get软件包管理工具删除所有关于MySQL的内容，恰巧这部分内容又都存在于rootfs中时，删除操作执行时同样不会删除rootfs实际存在的MySQL，而是在read-write filesystem中删除该部分内容，导致最终rootfs中的MySQL对容器用户不可见，也不可访。 掌握Docker中rootfs以及Union mount的概念之后，再来理解Docker镜像，就会变得水到渠成。

## image
Docker中rootfs的概念，起到容器文件系统中基石的作用。对于容器而言，其只读的特性，也是不难理解。神奇的是，实际情况下Docker的rootfs设计与实现比上文的描述还要精妙不少。

继续以ubuntu 14.04为例，虽然通过AUFS可以实现rootfs与read-write filesystem的合并，但是考虑到rootfs自身接近200MB的磁盘大小，如果以这个rootfs的粒度来实现容器的创建与迁移等，是否会稍显笨重，同时也会大大降低镜像的灵活性。而且，若用户希望拥有一个ubuntu 14.10的rootfs，那么是否有必要创建一个全新的rootfs，毕竟ubuntu 14.10和ubuntu 14.04的rootfs中有很多一致的内容。

Docker中image的概念，非常巧妙的解决了以上的问题。最为简单的解释image，就是 Docker容器中只读文件系统rootfs的一部分。换言之，实际上Docker容器的rootfs可以由多个image来构成。多个image构成rootfs的方式依然沿用Union mount技术。

基于以上的概念，Docker Image中又抽象出两种概念：Parent Image以及Base Image。除了容器rootfs最底层的image，其余image都依赖于其底下的一个或多个image，而Docker中将下一层的image称为上一层image的Parent Image。

通过image的形式，原先较为臃肿的rootfs被逐渐打散成轻便的多层。Image除了轻便的特性，同时还有上文提到的只读特性，如此一来，在不同的容器、不同的rootfs中image完全可以用来复用。

## layer
Docker术语中，layer是一个与image含义较为相近的词。容器镜像的rootfs是容器只读的文件系统，rootfs又是由多个只读的image构成。于是，rootfs中每个只读的image都可以称为一层layer。

除了只读的image之外，Docker Daemon在创建容器时会在容器的rootfs之上，再mount一层read-write filesystem，而这一层文件系统，也称为容器的一层layer，常被称为top layer。

因此，总结而言，Docker容器中的每一层只读的image，以及最上层可读写的文件系统，均被称为layer。如此一来，layer的范畴比image多了一层，即多包含了最上层的read-write filesystem。 有了layer的概念，大家可以思考这样一个问题：容器文件系统分为只读的rootfs，以及可读写的top layer，那么容器运行时若在top layer中写入了内容，那这些内容是否可以持久化，并且也被其它容器复用？

上文对于image的分析中，提到了image有复用的特性，既然如此，再提一个更为大胆的假设：容器的top layer是否可以转变为image？ 答案是肯定的。Docker的设计理念中，top layer转变为image的行为（Docker中称为commit操作），大大释放了容器rootfs的灵活性。Docker的开发者完全可以基于某个镜像创建容器做开发工作，并且无论在开发周期的哪个时间点，都可以对容器进行commit，将所有top layer中的内容打包为一个image，构成一个新的镜像。Commit完毕之后，用户完全可以基于新的镜像，进行开发、分发、测试、部署等。不仅docker commit的原理如此，基于Dockerfile的docker build，其追核心的思想，也是不断将容器的top layer转化为image。

## docker镜像原理图
```text
[容器层]    =》 应用程序，
[基础镜像]  =》基础镜像依赖包，例如JDK Tomcat等
[Rootfs]   =》Docker获取基础镜像容器内Linux发行版
[bootfs]   =》宿主机提供的Linux内核
```
下面详细解释一下图中各个分层：
- 首先我们看最底层的bootfs：Bootfs全名boot-file system，即引导文件系统；主要包含bootloader（系统加载）和kernel（内核）；bootloader主要用于引导加载kernel，kernel内核主要是宿主机提供的linux内核。Linux刚启动时会加载bootfs文件系统，也就是加载宿主机的linux内核。所以，我们的docker容器在运行时，第一步就是加载宿主机的linux内核。linux内核加载完成后，就会启动第二层。
- 第二层是叫Rootfs，即root-file system；Rootfs在bootfs之上，包含的就是典型的linux系统中/dev、/proc、/etc等标准目录和文件；rootfs就是各种不同操作系统的发行版，比如ubuntu、centos等；所以，第二步就是由Rootfs，负责docker获取基础镜像；即进行完第二步，我们就获取到了基础的linux发行版（比如是centos还是ubuntu等），例如我们本例中获取的就是centos发行版。
- 第三层是依赖层，我们在依赖层就可以定制化安装我们所需要的各种依赖环境了；此容器是用来运行什么的，我们就得安装什么依赖了。比如我们的镜像是用来运行tomcat的，而tomcat想要运行，就必须得先有jdk环境（java环境），即第三层安装jdk，安装完jdk后才能去第四层安装tomcat；tomcat也装好了后，必须得放入文件才能运行，这个文件时需要我们自己写的；所以最后一层就是容器层（container层）。
- 最后一层是容器层（container层），它的作用是就是本容器所要实现的具体功能了；比如在本例中就是运行具体的tomcat程序。



# 参考资料
http://www.csdn.net/article/2014-09-24⁄2821832

http://en.wikipedia.org/wiki/Cgroups

http://www.infoq.com/cn/articles/docker-future

https://docs.docker.com/terms/image/

https://docs.docker.com/terms/layer/#layer

http://en.wikipedia.org/wiki/Union_mount

https://www.usenix.org/legacy/publications/library/proceedings/neworl/full_papers/mckusick.a

http://www.qnx.com/developers/docs/660/index.jsp?topic=%2Fcom.qnx.doc.neutrino.sys_arch%2Ftopic%2Ffsys_COW_filesystem.html




