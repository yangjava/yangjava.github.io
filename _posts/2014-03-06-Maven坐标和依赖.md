---
layout: post
categories: [Maven]
description: none
keywords: Maven
---
# Maven依赖
Maven的一大功能是管理项目依赖。为了能自动化地解析任何一个Java构件，Maven就必须将它们唯一标识，这就依赖管理的底层基础——坐标。

分析Maven坐标的作用，解释其每一个元素；在此基础上，再介绍如何配置Maven，以及相关的经验和技巧，以帮助我们管理项目依赖。

## 何为Maven坐标
在实际生活中，我们也可以将地址看成是一种坐标。省、市、区、街道等一系列信息同样可以唯一标识城市中的任一居住地址和工作地址。邮局和快递公司正是基于这样一种坐标进行日常工作的。

`Maven` 定义了这样一组规则：世界上任务一个构件都可以使用Maven坐标唯一标示，Maven坐标元素包括`groupId`、 `artifactId`、 `version`、 `packaging`、 `classifier`。

现在，只要我们提供正确的坐标元素，Maven就能找到对应的构件。

比如说，当需要使用Java5平台上TestNG的5.8版本时，就告诉`Maven：“groupId=org.testng；artifactId=testng；version=5.8；classifier=jdk15”`，Maven就会从仓库中寻找相应的构件供我们使用。

Maven是从哪里下载构件的呢？其实，Maven内置了一个中央仓库的地址，该中央仓库包含了世界上大部分流行的开源项目构件，Maven会在需要的时候去那里下载。   

在我们开发自己项目的时候，也需要为其定义适当的坐标，这是Maven强制要求的。在这个基础上，其他Maven项目才能引用该项目生成的构件。

## 坐标详解
Maven坐标为各种构件引入了秩序，任何一个构件都必须明确定义自己的坐标，而一组Maven坐标是通过一些元素定义的，它们是`groupId`、 `artifactId`、 `version`、 `packaging`、 `classifier`。

先看一组坐标定义，如下：
```
<groupId>org.sonatype.nexus</groupId>
<artifactId>nexus-indexer</artifactId>
<version>2.0.0</version>
<packaging>jar</packaging>
```
上述代码片段中，其坐标分别为groupId:org.sonatype.nexus、artifactId:nexus-indexer、version:2.0.0、packaging:jar，没有classifier。

下面详细解释一下各个坐标元素：
- groupId
定义当前Maven项目隶属的实际项目。Maven项目和实际项目不一定一对一关系，比如SpringFramework这一实际项目，其对应的Maven项目会有很多spring-core，spring-context等，这是由于Maven中模块的概念，一个实际项目往往会被划分成很多模块。
**groupId不应该只对应公司，还需要定义到项目。** 格式应该与Java包表示方式类似，通常与域名反向一一对应。

- artifactId
该元素定义实际项目中的一个Maven项目（模块），推荐的做法是使用实际项目名称作为artifactId的前缀，模块作为后缀。这样做的好处是方便寻找实际构件。
在默认情况下，Maven生成的构件，其文件名会以artifactId作为开头，如nexus-indexer-2.0.0.jar

- version
该元素定义Maven项目当前所处的版本，如上例中nexus-indexer的版本是2.0.0。需要注意的是，Maven定义了一套完整的版本规范，以及快照（SNAPSHOT）的概念。

- packaging
定义Maven项目的打包方式，首先，打包方式通常与所生成构件的文件扩展名对应，如上例中packaging为jar，最终的文件名为nexus-indexer-2.0.0.jar，而使用war打包方式的Maven项目，最终生成的构件会有一个.war文件，不过这不是绝对的。
其次，打包方式会影响到构建的生命周期，比如jar打包和war打包会使用不同的命令。最后，当不定义packaging的时候，Maven会使用默认值jar。
packaging并非一定与构件扩展名对应，比如packaging为maven-plugin的构件扩展名为jar。

- classifier
该元素用来帮助定义构建输出的一些附属构件。附属构件与主构件对应，如上例中的主构件是nexus-indexer-2.0.0.jar，该项目可能还会通过使用一些插件生成如nexus-indexer-2.0.0-javadoc.jar、nexus-indexer-2.0.0-sources.jar这样一些附属构件，其包含了Java文档和源代码。
这时候，javadoc和sources就是这两个附属构件的classifier。这样，附属构件也就拥有了自己唯一的坐标。

总结：以上五个元素，groupId、artifactId、version是必须定义的，packaging是可选的，默认为jar，而classifier是不能直接定义的。

## Maven实战
以邮件发送详细阐述该模块的实现，包括POM配置、主代码和测试代码。由于该背景案例的实现是基于Spring Framework，因此还会涉及相关的Spring配置。

首先看一下该模块的POM
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.demo.message</groupId>
    <artifactId>message-api</artifactId>
    <version>1.0.0-SNAPSHOT</version>
  
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.3.9</version>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.7</version>
            <scope>test</scope>
        </dependency>
        
    </dependencies>
</project>
```
先观察该项目模块的坐标
groupId:com.demo.message  由于该模块属于消息项目的一部分，因此，其groupId对应了message项目。
artifactId:message-api    紧接着，该模块的artifactId仍然以message 作为前缀，以方便区分其他项目的构建。
version:1.0.0-SNAPSHOT。  最后，1.0.0-SNAPSHOT表示该版本处于开发中，还不稳定。
再看dependencies元素，其包含了多个dependency子元素，这是POM中定义项目依赖的位置。以第一个依赖为例，其groupId:artifactId:version为org.springframework:spring-core:2.5.6，这便是依赖的坐标，任何一个Maven项目都需要定义自己的坐标，当这个Maven项目成为其他Maven项目的依赖的时候，这组坐标就体现了其价值。
紧接着的依赖为junit:junit:4.7，这个依赖特殊的地方在于一个值为test的scope子元素，scope用来定义依赖范围。当依赖范围是test的时候，该依赖只会被加入到测试代码的classpath中。也就是说，对于项目主代码，该依赖是没有任何作用的。JUnit是单元测试框架，只有在测试的时候才需要，因此使用该依赖范围。

### 构建
使用mvn clean install构建message-api,Maven会根据POM配置自动下载所需要的依赖构件，执行编译、测试、打包等工作，最后将项目生成的构件message-api-1.0.0-SNAP-SHOT.jar安装到本地仓库中。这时，该模块就能供其他Maven项目使用了。

### 依赖的配置
一个依赖声明可以包含如下的一些元素：
```
<project>
<dependencies>
<dependency>
<groupId>……</groupId>
<artifactId>……</artifactId>
<version>……</version>
<type>……</type>
<scope>……</scope>
<optional>……</optional>
<exclusions>
<exclusion></exclusion>
</exclusions>
</dependency>
</dependencies>
</project>
```
根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：
- groupId、artifactId和version：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。
- type：依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar。
- scope：依赖的范围。
- optional：标记依赖是否可选。
- exclusions：用来排除传递性依赖。

大部分依赖声明只包含基本坐标，然而在一些特殊情况下，其他元素至关重要。

## 依赖范围
JUnit依赖的测试范围是test，测试范围用元素scope表示。首先需要知道，Maven在编译项目主代码的时候需要使用一套classpath。在上例中，编译项目主代码的时候需要用到spring-core，该文件以依赖的方式被引入到classpath中。

其次，Maven在编译和执行测试的时候会使用另外一套classpath。上例中的JUnit就是一个很好的例子，该文件也以依赖的方式引入到测试使用的classpath中，不同的是这里的依赖范围是test。

最后，实际运行Maven项目的时候，又会使用一套classpath，上例中的spring-core需要在该classpath中，而JUnit则不需要。

依赖范围就是用来控制依赖与这三种classpath（编译classpath、测试classpath、运行classpath）的关系，Maven有以下几种依赖范围：

compile：编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖。

test：测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是JUnit，它只有在编译测试代码及运行测试的时候才需要。

provided：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试class-path有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。

runtime：运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行class-path有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。

system：系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：

＜dependency＞

＜groupId＞javax.sql＜/groupId＞

＜artifactId＞jdbc-stdext＜/artifactId＞

＜version＞2.0＜/version＞

＜scope＞system＜/scope＞

＜systemPath＞$ {java.home}/lib/rt.jar＜/systemPath＞

＜/dependency＞

import（Maven 2.0.9及以上）：导入依赖范围。该依赖范围不会对三种classpath产生实际的影响，本书将在8.3.3节介绍Maven依赖和dependencyManagement的时候详细介绍此依赖范围。

上述除import以外的各种依赖范围与三种classpath的关系如表

⑤system：系统依赖范围。和privated依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显示的指定依赖文件的路径。由于此类的依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。可以引用环境变量


| 属性值      | 作用                                                                                                                                                                                                                                                                                                                                                                                         |
|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| compile  | ==编译范围==<br />scope的默认值就是compile。  在编译,测试,打包,安装,发布全部生命周期都存在的依赖资源                                                                                                                                                                                                                                                                                                                           |
| test     | ==测试范围==  <br />运行测试代码时,才加载的依赖资源,打包,安装,发布都不参加.                                                                                                                                                                                                                                                                                                                                             |
| runtime  | ==运行时范围==<br />和compile的唯一区别,就是不参加编译;  例如JDBC可以不写代码编译,但是必须在运行,打包安装其他阶段参加.                                                                                                                                                                                                                                                                                                                  |
| provided | ==在编译阶段使用,但是运行,打包安装都不参加==<br />官方给了一个案例:servlet-api,编辑servlet,web应用等代码使用的内容,必须使用provided;(web应用,在tomcat中运行),如果将servlet-api依赖资源打包到war包,扔到tomcat执行会出现冲突;编写任何web应用时,使用到servlet-api的资源,必须添加provided的范围;                                                                                                                                                                                        |
| system   | ==系统范围==<br />  在当前项目的环境中存在需要使用的jar包资源,maven没有提供groupId artifactId version,可以使用system指定从本地路径进行加载  <br />`<dependency>` <br />        `<groupId>cn.tedu</groupId> `<br />       `<artifactId>wotongzhuo</artifactId>`<br />       `<version>1.0</version> ` <br />       `<scope>system</scope> `<br />       `<systemPath>D:\\piaoqian\\xxw\\xxw.jar</systemPath>`<br />  `</dependency> ` |


## 可传递性依赖发现

一种相当常见的情况，比如说 A 依赖于其他库 B。如果，另外一个项目 C 想要使用 A ，那么 C 项目也需要使用库 B。

Maven 可以避免去搜索所有所需库的需求。Maven 通过读取项目文件（pom.xml），找出它们项目之间的依赖关系。

我们需要做的只是在每个项目的 pom 中定义好直接的依赖关系。其他的事情 Maven 会帮我们搞定。

通过可传递性的依赖，所有被包含的库的图形会快速的增长。当有重复库时，可能出现的情形将会持续上升。Maven 提供一些功能来控制可传递的依赖的程度。



| 功能      | 功能描述                                                                                     |
|---------|------------------------------------------------------------------------------------------|
| 依赖调节    | 决定当多个手动创建的版本同时出现时，哪个依赖版本将会被使用。 如果两个依赖版本在依赖树里的深度是一样的时候，第一个被声明的依赖将会被使用。                    |
| 依赖管理    | 直接的指定手动创建的某个版本被使用。例如当一个工程 C 在自己的依赖管理模块包含工程 B，即 B 依赖于 A， 那么 A 即可指定在 B 被引用时所使用的版本。         |
| 依赖范围    | 包含在构建过程每个阶段的依赖。                                                                          |
| 依赖排除    | 任何可传递的依赖都可以通过 "exclusion" 元素被排除在外。举例说明，A 依赖 B， B 依赖 C，因此 A 可以标记 C 为 "被排除的"。              |
| 依赖可选    | 任何可传递的依赖可以被标记为可选的，通过使用 "optional" 元素。例如：A 依赖 B， B 依赖 C。因此，B 可以标记 C 为可选的， 这样 A 就可以不再使用 C。 |

## Maven的依赖范围

<scope></scope>标签

在项目中导入的依赖并不一定在项目全生命周期中都要用，此时可以通过scope属性指定依赖应用的范围。

```xml

```

依赖范围就是用来控制依赖与这三种classpath（编译classpath、测试classpath、运行classpath）的关系，Maven存在以下几种依赖范围。

①compile：编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，在编译、测试和运行的时候都需要使用该依赖。

②test：测试依赖范围。只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型例子是Junit。

③provided：已提供依赖范围。对于编译和测试classpath有效，但在运行时无效。典型例子是servlet-api，编译和测试项目的时候需要该依赖，但是运行项目的时候，由于容器已经提供，就不需要Maven重复的引入一遍。（servlet的创建是通过容器例如tomcat启动的时候加载文件到内存中创建的，所以不需要重复依赖）。

④runtime：运行时依赖范围。对于测试和运行classpath有效，但是在编译主代码时无效。典型例子jdbc驱动实现，项目主代码的编译只需要jdk提供的jdbc接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体jdbc驱动。

⑤system：系统依赖范围。和privated依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显示的指定依赖文件的路径。由于此类的依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。可以引用环境变量


| 属性值      | 作用                                                                                                                                                                                                                                                                                                                                                                                         |
|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| compile  | ==编译范围==<br />scope的默认值就是compile。  在编译,测试,打包,安装,发布全部生命周期都存在的依赖资源                                                                                                                                                                                                                                                                                                                           |
| test     | ==测试范围==  <br />运行测试代码时,才加载的依赖资源,打包,安装,发布都不参加.                                                                                                                                                                                                                                                                                                                                             |
| runtime  | ==运行时范围==<br />和compile的唯一区别,就是不参加编译;  例如JDBC可以不写代码编译,但是必须在运行,打包安装其他阶段参加.                                                                                                                                                                                                                                                                                                                  |
| provided | ==在编译阶段使用,但是运行,打包安装都不参加==<br />官方给了一个案例:servlet-api,编辑servlet,web应用等代码使用的内容,必须使用provided;(web应用,在tomcat中运行),如果将servlet-api依赖资源打包到war包,扔到tomcat执行会出现冲突;编写任何web应用时,使用到servlet-api的资源,必须添加provided的范围;                                                                                                                                                                                        |
| system   | ==系统范围==<br />  在当前项目的环境中存在需要使用的jar包资源,maven没有提供groupId artifactId version,可以使用system指定从本地路径进行加载  <br />`<dependency>` <br />        `<groupId>cn.tedu</groupId> `<br />       `<artifactId>wotongzhuo</artifactId>`<br />       `<version>1.0</version> ` <br />       `<scope>system</scope> `<br />       `<systemPath>D:\\piaoqian\\xxw\\xxw.jar</systemPath>`<br />  `</dependency> ` |


## 依赖传递性
当我们依赖的jar包，而此jar包还依赖别的jar包的时候，我们需要同时将这些依赖的jar包都依赖上，而去找却很麻烦。

account-email依赖spring-core包，而spring依赖Commons-logging。

有了传递性依赖机制，Maven会解析各个直接依赖的pom，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。


## 传递性依赖和依赖范围

假设A依赖B，B依赖C，那么A对于B是第一直接依赖，B对C是第二直接依赖，A对C是传递性依赖；第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围。

## 依赖调解

如果两个传递依赖都使用了相同的jar包，则选择哪个作为被解析的呢？第一原则：路径最近优先，例如A->B->C->D（1.0）和F->D（2.0），两条路径都依赖D，则按照最近的原则，则解析D（2.0）版本。

如果路径相同，则第一依赖关系在pom文件中顺序执行。哪个依赖声明靠前，解析哪个。

## 可选依赖

如果存在依赖A->B、B->X（可选）、B->Y（可选）。如果这三个依赖都是compile的，X、Y就是A的传递性依赖，但是X、Y是可选依赖，X、Y将不会对A有任何影响。

使用可选依赖参数解决：<optional>true</optional>

## 排除依赖

当我们依赖某个类库X的时候，而这个类库还依赖其他类库Y，由于传递依赖，我们也将解析Y，而Y有可能是不稳定版本，也有可能中央仓库不存在，则我们需要排除对Y的依赖而自己去声明一个对Y其他替代版本的依赖。


```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>4.3.7.RELEASE</version>
    <exclusions>
        <exclusion>
            <!-- 坐标指定移除内容 -->
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>4.3.7.RELEASE</version>
        </exclusion>
    </exclusions>
</dependency>
```

项目A依赖项目B，但是由于一些原因，不想引入传递依赖C，而是自己显示的生猛对于项目C1.1.0版本的依赖，例子中使用exclusions元素声明排除依赖，exclusions可以包含一个或者多个exclusion子元素。注意：声明exclusion时只需要groupId和artifactId，因为这两个元素就能唯一定位依赖图中的某个依赖，Maven解析后的依赖中，不可能出现groupId和artifactId相同但是版本不同的两个依赖。


## 归类依赖

例如我们依赖spring的jar包，好几个但是版本是一致的，所以如果升级的时候一起升级，所以版本统一管理更好。
例子如下：

```xml
    <properties>
        <org.springframework-version>4.0.0.RELEASE</org.springframework-version>
    </properties>

    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>${org.springframework-version}</version>
    </dependency>
```

这样升级的时候一块升级，方便！！

## 优化依赖

Maven会自动解析所有项目的直接依赖和传递性依赖，并且根据规则正确判断每个依赖的范围，对于一些依赖冲突，也能进行调节，以确保任何一个构件只有唯一的版本在依赖中存在，这些工作之后，最后得到那些依赖被称为已解析依赖。

可以使用命令查看当前项目的已解析依赖：mvn dependency ：list。或者使用mvn dependency ：tree查看依赖树。

当发现项目中没有使用到的构件在依赖树种，我们可以将其删除掉。不过需要谨慎！！！！！	
	
## 从仓库解析依赖的机制
当本地仓库没有依赖构件时候，Maven会自动从远程仓库下载；当依赖版本为快照版本的时候，Maven会自动找到最新的快照。依赖解析机制如下：

- 1）当依赖范围是system，Maven直接从本地文件系统解析构件。

- 2）根据依赖坐标计算仓库路径，先从本地仓库查询构件，如果发现则解析成功。

- 3）本地不存在，如果依赖版本是显示的发布版本构件，如：1.2.0等，则遍历所有远程仓库，发现后下载解析使用。

- 4）如果依赖版本是release或者latest，则基于更新策略读取所有远程仓库的元数据/groupId/artifactId/maven-metadata.xml，将其与本地仓库的对应元数据合并后，计算出release或者latest的真实的值，然后基于这个真实的值检查本地和远程仓库到2），3）。

- 5）如果依赖版本是snapshot，则基于更新策略得到最新的快照版本的值，然后基于这个真实的值检查本地和远程仓库到2），3）。

- 6）如果解析后得到的构件版本是时间戳格式的快照，则将时间戳改成非时间戳，并使用这个构件。

当依赖的版本不明晰的时候，如：snapshot，latest，release，Maven就需要基于更新远程仓库的策略来检查更新。上节有讲，此处不在多说。可以在命令行加上参数-U强制检查更新，使用后Maven会忽略<updatePolicy>的配置。

当Maven检查完更新策略，并决定检查依赖更新的时候，就需要检查仓库元数据maven-metadata.xml。

release版本：仓库中存在该构件的最新发布版本。

latest版本：仓库中存在该构件的最新版本（包含快照）。最新是基于/groupId/artifactId/maven-metadata.xml计算出来（远程仓库）。

注意：依赖声明的latest和release是不推荐使用的，因为Maven随时都可能解析到不同的构件，并且Maven不会明确告诉用户这种变化，如果出现构件失败，查找问题比较复杂。

仓库的元数据并不是永远正确的，当用户发现无法解析某些构件或者解析到错误构件的时候，就可能出现仓库元数据错误，需要手动的或者使用工具（如Nexus）对其进行修复。



