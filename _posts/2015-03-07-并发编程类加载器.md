---
layout: post
categories: JUC
description: none
keywords: JUC
---
# 并发编程类加载器
必须掌握JVM的类加载器原理和整个类加载的过程，在详细地掌握了ClassLoader知识以后，再回过头来看线程上下文的类加载器肯定会更加透彻。

- 循序渐进地理解一个class文件是如何被JVM加载并且最后得以运行的。
- 介绍JVM自带的三大类加载器——根加载器、扩展类加载器、系统类加载器——不同的职责和各自的特点，然后重点讲解自定义类加载器、双亲委托机制，以及如何打破JDK的双亲委托模型。
- 重点介绍和线程关系非常密切的上下文类加载器，以及通过JDBC驱动的源码剖析，让读者理解数据库驱动的加载过程。

## 类的加载过程
ClassLoader的主要职责就是负责加载各种class文件到JVM中，ClassLoader是一个抽象的class，给定一个class的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存区域中。

## 类的加载过程简介
类的加载过程一般分为三个比较大的阶段，分别是加载阶段、连接阶段和初始化阶段

- 加载阶段：主要负责查找并且加载类的二进制数据文件，其实就是class文件。
- 连接阶段：连接阶段所做的工作比较多，细分的话还可以分为如下三个阶段。
- 验证：主要是确保类文件的正确性，比如class的版本，class文件的魔术因子是否正确。
- 准备：为类的静态变量分配内存，并且为其初始化默认值。
- 解析：把类中的符号引用转换为直接引用。
- 初始化阶段：为类的静态变量赋予正确的初始值（代码编写阶段给定的值）。

当一个JVM在我们通过执行Java命令启动之后，其中可能包含的类非常多，是不是每一个类都会被初始化呢？答案是否定的，JVM对类的初始化是一个延迟的机制，即使用的是lazy的方式，当一个类在首次使用的时候才会被初始化，在同一个运行时包下，一个Class只会被初始化一次（运行时包和类的包是有区别的），那么什么是类的主动使用和被动使用呢？

接下来我们通过一些实例来进行相应的总结。

## 类的主动使用和被动使用
JVM虚拟机规范规定了，每个类或者接口被Java程序首次主动使用时才会对其进行初始化，当然随着JIT技术越来越成熟，JVM运行期间的编译也越来越智能，不排除JVM在运行期间提前预判并且初始化某个类。

### 类的主动使用
JVM同时规范了以下6种主动使用类的场景，具体如下。

- 通过new关键字会导致类的初始化：这种是大家经常采用的初始化一个类的方式，它肯定会导致类的加载并且最终初始化。

- 访问类的静态变量，包括读取和更新会导致类的初始化
这种情况的示例代码如下：
```
public class Simple
{
    static
    {
        System.out.println("I will be initialized");
    }

    public static int x = 10;
}
```
这段代码中x是一个简单的静态变量，其他类即使不对Simple进行new的创建，直接访问变量x也会导致类的初始化。

- 访问类的静态方法，会导致类的初始化
这种情况的示例代码如下：
```
public class Simple
{
    static
    {
        System.out.println("I will be initialized");
    }

    //静态方法
    public static void test(){

    }
}
```
同样，在其他类中直接调用test静态方法也会导致类的初始化。

- 对某个类进行反射操作，会导致类的初始化
这种情况的示例代码如下：
```
public static void main(String[] args) throws ClassNotFoundException
{
     Class.forName("com.demo.Simple");
}
```
运行上面的代码，同样会看到静态代码块中的输出语句执行。

- 初始化子类会导致父类的初始化
这种情况的示例代码如下：
```
public class Parent
{
    static
    {
        System.out.println("The parent is initialized");
    }

    public static int y=100;
}

public class Child extends Parent
{
    static
    {
        System.out.println("The child will be initialized");
    }

    public static int x = 10;
}

public class ActiveLoadTest
{
    public static void main(String[] args)
    {
        System.out.println(Child.x);
    }
}
```
在ActiveLoadTest中，我们调用了Child的静态变量，根据前面的知识可以得出Child类被初始化了，Child类又是Parent类的子类，子类的初始化会进一步导致父类的初始化，

当然这里需要注意的一点是，通过子类使用父类的静态变量只会导致父类的初始化，子类则不会被初始化，示例代码如下：
```
public class ActiveLoadTest
{
    public static void main(String[] args)
    {
        System.out.println(Child.y);
    }
}

```
改写后的ActiveLoadTest，直接用Child访问父类的静态变量y，并不会导致Child的初始化，仅仅会导致Parent的初始化。

- 启动类：也就是执行main函数所在的类会导致该类的初始化，比如使用java命令运行上文中的ActiveLoadTest类。

除了上述6种情况，其余的都称为被动使用，不会导致类的加载和初始化。

### 类的被动使用
关于类的主动引用和被动引用，下面有几个容易引起大家混淆的例子，我们来看一看。

- 构造某个类的数组时并不会导致该类的初始化，比如下面的例子：
```
public static void main(String[] args)
{
    Simple[] simples = new Simple[10];
    System.out.println(simples.length);
}

```
上面的代码中new方法新建了一个Simple类型的数组，但是它并不能导致Simple类的初始化，因此它是被动使用，不要被前面的new关键字所误导，事实上该操作只不过是在堆内存中开辟了一段连续的地址空间4byte×10。

- 引用类的静态常量不会导致类的初始化，请看下面的例子：
```
import java.util.Random;

public class GlobalConstants
{
    static
    {
        System.out.println("The GlobalConstants will be initialized.");
    }

    //在其他类中使用MAX不会导致GlobalConstants的初始化，静态代码块不会输出
public final static int MAX = 100;

    //虽然RANDOM是静态常量，但是由于计算复杂，只有初始化之后才能得到结果，因此在其他类中使用RANDOM会导致GlobalConstants的初始化
    public final static int RANDOM = new Random().nextInt();
}
```
这段代码中，MAX是一个被final修饰的静态变量，也就是一个静态常量，在其他类中直接访问MAX不会导致GlobalConstants的初始化，虽然它也是被static修饰的，但是如果在其他类中访问RANDOM则会导致类的初始化，因为RANDOM是需要进行随机函数计算的，在类的加载、连接阶段是无法对其进行计算的，需要进行初始化后才能对其赋予准确的值。

## 类的加载过程详解
在正式讲解类加载各个阶段的内容之前，请大家思考下面这段程序的输出结果，如果你不能准确计算出结果或者感觉有些模棱两可，那么在学习了本节的内容之后，相信你会很容易地得出结果，以及明白为什么是这样的结果：
```
public class Singleton
{

    //①
    private static int x = 0;

    private static int y;

    private static Singleton instance = new Singleton();//②

    private Singleton()
    {
        x++;
        y++;
    }

    public static Singleton getInstance()
    {
        return instance;
    }

    public static void main(String[] args)
    {
        Singleton singleton = Singleton.getInstance();
        System.out.println(singleton.x);
        System.out.println(singleton.y);
    }
}
```
运行上面的程序代码输出将是多少？如果将注释②的代码移到注释①的位置，输出结果又是什么呢？两种输出会产生不一样的结果，为何会发生这样的现象




















































































