---
layout: post
categories: [XxlJob]
description: none
keywords: XxlJob
---
# 任务调度源码XXL-JOB客户端源码

## 客户端源码依赖
```xml
        <dependency>
            <groupId>com.xuxueli</groupId>
            <artifactId>xxl-job-core</artifactId>
            <version>2.0.2</version>
        </dependency>
```

## 启动原理研究
xxl-job 启动核心是在`com.xxl.job.core.executor.impl.XxlJobSpringExecutor`类。所以以这个类入口进行查看
```java
public class XxlJobSpringExecutor extends XxlJobExecutor implements ApplicationContextAware {


    @Override
    public void start() throws Exception {
        // 初始化 JobHandler
        // init JobHandler Repository
        initJobHandlerRepository(applicationContext);
         // 初始化Glue脚本 
        // refresh GlueFactory
        GlueFactory.refreshInstance(1);


        // super start
        super.start();
    }

    private void initJobHandlerRepository(ApplicationContext applicationContext){
        if (applicationContext == null) {
            return;
        }
        // 服务包含JobHandler注解，并且实现IJobHandler接口
        // init job handler action
        Map<String, Object> serviceBeanMap = applicationContext.getBeansWithAnnotation(JobHandler.class);

        if (serviceBeanMap!=null && serviceBeanMap.size()>0) {
            for (Object serviceBean : serviceBeanMap.values()) {
                // 服务实现
                if (serviceBean instanceof IJobHandler){
                    String name = serviceBean.getClass().getAnnotation(JobHandler.class).value();
                    IJobHandler handler = (IJobHandler) serviceBean;
                    if (loadJobHandler(name) != null) {
                        throw new RuntimeException("xxl-job jobhandler naming conflicts.");
                    }
                    registJobHandler(name, handler);
                }
            }
        }
    }

    // ---------------------- applicationContext ----------------------
    private static ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

}
```
从名字也可以看出是为了整合Spring 进行包装的一个类。实现了ApplicationContextAware, SmartInitializingSingleton, DisposableBean 接口。

ApplicationContextAware 接口是为了获取到ApplicationContext对象，DisposableBean 是为了在容器销毁的时候调用destroy 方法，SmartInitializingSingleton 是容器创建完所有单例对象之后调用afterSingletonsInstantiated 方法。

com.xxl.job.core.executor.impl.XxlJobSpringExecutor#initJobHandlerMethodRepository 这个方法就是扫描Spring 容器中的对象，然后拿到对象带JobHandler注解的方法， 缓存到com.xxl.job.core.executor.XxlJobExecutor#jobHandlerRepository 静态map 中。

还有另一种方式就是直接手动注册：(缓存是存在静态map 中， 所以我们也可以自己注册。我们只需要让其根据name 能找到对应的handler即可)
```
static {
        // 手动通过如下方式注入到执行器容器。
        XxlJobExecutor.registJobHandler("XXLClassJob", new XXLClassJob());
    }
```

父类查看：`com.xxl.job.core.executor.XxlJobExecutor`
```java
public class XxlJobExecutor {
    private static final Logger logger = LoggerFactory.getLogger(XxlJobExecutor.class);
    private String adminAddresses;
    private String accessToken;
    private String appname;
    private String address;
    private String ip;
    private int port;
    private String logPath;
    private int logRetentionDays;
    private static List<AdminBiz> adminBizList;
    private EmbedServer embedServer = null;
    private static ConcurrentMap<String, IJobHandler> jobHandlerRepository = new ConcurrentHashMap();
    private static ConcurrentMap<Integer, JobThread> jobThreadRepository = new ConcurrentHashMap();

    public XxlJobExecutor() {
    }

    public void setAdminAddresses(String adminAddresses) {
        this.adminAddresses = adminAddresses;
    }

    public void setAccessToken(String accessToken) {
        this.accessToken = accessToken;
    }

    public void setAppname(String appname) {
        this.appname = appname;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setIp(String ip) {
        this.ip = ip;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public void setLogPath(String logPath) {
        this.logPath = logPath;
    }

    public void setLogRetentionDays(int logRetentionDays) {
        this.logRetentionDays = logRetentionDays;
    }

    public void start() throws Exception {
        // 创建以及记录日志路径
        XxlJobFileAppender.initLogPath(this.logPath);
        // 这里是记录服务器相关的地址和accessToken， 用于向服务器端发送数据，主要是注册本机地址和端口。
        this.initAdminBizList(this.adminAddresses, this.accessToken);
        // 启动一个单线程去清空指定的日志文件。
        JobLogFileCleanThread.getInstance().start((long)this.logRetentionDays);
        // 启动一个callback 任务执行线程
        TriggerCallbackThread.getInstance().start();
        // 这个就是获取到配置信息，然后启动一个内嵌的NettyServer， 接收http 请求的数据
        this.initEmbedServer(this.address, this.ip, this.port, this.appname, this.accessToken);
    }

    public void destroy() {
        this.stopEmbedServer();
        if (jobThreadRepository.size() > 0) {
            Iterator var1 = jobThreadRepository.entrySet().iterator();

            while(var1.hasNext()) {
                Map.Entry<Integer, JobThread> item = (Map.Entry)var1.next();
                JobThread oldJobThread = removeJobThread((Integer)item.getKey(), "web container destroy and kill the job.");
                if (oldJobThread != null) {
                    try {
                        oldJobThread.join();
                    } catch (InterruptedException var5) {
                        logger.error(">>>>>>>>>>> xxl-job, JobThread destroy(join) error, jobId:{}", item.getKey(), var5);
                    }
                }
            }

            jobThreadRepository.clear();
        }

        jobHandlerRepository.clear();
        JobLogFileCleanThread.getInstance().toStop();
        TriggerCallbackThread.getInstance().toStop();
    }

    private void initAdminBizList(String adminAddresses, String accessToken) throws Exception {
        if (adminAddresses != null && adminAddresses.trim().length() > 0) {
            String[] var3 = adminAddresses.trim().split(",");
            int var4 = var3.length;

            for(int var5 = 0; var5 < var4; ++var5) {
                String address = var3[var5];
                if (address != null && address.trim().length() > 0) {
                    AdminBiz adminBiz = new AdminBizClient(address.trim(), accessToken);
                    if (adminBizList == null) {
                        adminBizList = new ArrayList();
                    }

                    adminBizList.add(adminBiz);
                }
            }
        }

    }

    public static List<AdminBiz> getAdminBizList() {
        return adminBizList;
    }

    private void initEmbedServer(String address, String ip, int port, String appname, String accessToken) throws Exception {
        port = port > 0 ? port : NetUtil.findAvailablePort(9999);
        ip = ip != null && ip.trim().length() > 0 ? ip : IpUtil.getIp();
        if (address == null || address.trim().length() == 0) {
            String ip_port_address = IpUtil.getIpPort(ip, port);
            address = "http://{ip_port}/".replace("{ip_port}", ip_port_address);
        }

        this.embedServer = new EmbedServer();
        this.embedServer.start(address, port, appname, accessToken);
    }

    private void stopEmbedServer() {
        try {
            this.embedServer.stop();
        } catch (Exception var2) {
            logger.error(var2.getMessage(), var2);
        }

    }

    public static IJobHandler registJobHandler(String name, IJobHandler jobHandler) {
        logger.info(">>>>>>>>>>> xxl-job register jobhandler success, name:{}, jobHandler:{}", name, jobHandler);
        return (IJobHandler)jobHandlerRepository.put(name, jobHandler);
    }

    public static IJobHandler loadJobHandler(String name) {
        return (IJobHandler)jobHandlerRepository.get(name);
    }

    public static JobThread registJobThread(int jobId, IJobHandler handler, String removeOldReason) {
        JobThread newJobThread = new JobThread(jobId, handler);
        newJobThread.start();
        logger.info(">>>>>>>>>>> xxl-job regist JobThread success, jobId:{}, handler:{}", new Object[]{jobId, handler});
        JobThread oldJobThread = (JobThread)jobThreadRepository.put(jobId, newJobThread);
        if (oldJobThread != null) {
            oldJobThread.toStop(removeOldReason);
            oldJobThread.interrupt();
        }

        return newJobThread;
    }

    public static JobThread removeJobThread(int jobId, String removeOldReason) {
        JobThread oldJobThread = (JobThread)jobThreadRepository.remove(jobId);
        if (oldJobThread != null) {
            oldJobThread.toStop(removeOldReason);
            oldJobThread.interrupt();
            return oldJobThread;
        } else {
            return null;
        }
    }

    public static JobThread loadJobThread(int jobId) {
        JobThread jobThread = (JobThread)jobThreadRepository.get(jobId);
        return jobThread;
    }
}

```

## 服务器
```
public class EmbedServer {
    private static final Logger logger = LoggerFactory.getLogger(EmbedServer.class);
    private ExecutorBiz executorBiz;
    private Thread thread;

    public EmbedServer() {
    }

    public void start(final String address, final int port, final String appname, final String accessToken) {
        this.executorBiz = new ExecutorBizImpl();
        this.thread = new Thread(new Runnable() {
            public void run() {
                EventLoopGroup bossGroup = new NioEventLoopGroup();
                EventLoopGroup workerGroup = new NioEventLoopGroup();
                final ThreadPoolExecutor bizThreadPool = new ThreadPoolExecutor(0, 200, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue(2000), new ThreadFactory() {
                    public Thread newThread(Runnable r) {
                        return new Thread(r, "xxl-rpc, EmbedServer bizThreadPool-" + r.hashCode());
                    }
                }, new RejectedExecutionHandler() {
                    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                        throw new RuntimeException("xxl-job, EmbedServer bizThreadPool is EXHAUSTED!");
                    }
                });

                try {
                    ServerBootstrap bootstrap = new ServerBootstrap();
                    ((ServerBootstrap)bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)).childHandler(new ChannelInitializer<SocketChannel>() {
                        public void initChannel(SocketChannel channel) throws Exception {
                            channel.pipeline().addLast(new ChannelHandler[]{new IdleStateHandler(0L, 0L, 90L, TimeUnit.SECONDS)}).addLast(new ChannelHandler[]{new HttpServerCodec()}).addLast(new ChannelHandler[]{new HttpObjectAggregator(5242880)}).addLast(new ChannelHandler[]{new EmbedHttpServerHandler(EmbedServer.this.executorBiz, accessToken, bizThreadPool)});
                        }
                    }).childOption(ChannelOption.SO_KEEPALIVE, true);
                    ChannelFuture future = bootstrap.bind(port).sync();
                    EmbedServer.logger.info(">>>>>>>>>>> xxl-job remoting server start success, nettype = {}, port = {}", EmbedServer.class, port);
                    EmbedServer.this.startRegistry(appname, address);
                    future.channel().closeFuture().sync();
                } catch (InterruptedException var14) {
                    if (var14 instanceof InterruptedException) {
                        EmbedServer.logger.info(">>>>>>>>>>> xxl-job remoting server stop.");
                    } else {
                        EmbedServer.logger.error(">>>>>>>>>>> xxl-job remoting server error.", var14);
                    }
                } finally {
                    try {
                        workerGroup.shutdownGracefully();
                        bossGroup.shutdownGracefully();
                    } catch (Exception var13) {
                        EmbedServer.logger.error(var13.getMessage(), var13);
                    }

                }

            }
        });
        this.thread.setDaemon(true);
        this.thread.start();
    }

    public void stop() throws Exception {
        if (this.thread != null && this.thread.isAlive()) {
            this.thread.interrupt();
        }

        this.stopRegistry();
        logger.info(">>>>>>>>>>> xxl-job remoting server destroy success.");
    }

    public void startRegistry(String appname, String address) {
        ExecutorRegistryThread.getInstance().start(appname, address);
    }

    public void stopRegistry() {
        ExecutorRegistryThread.getInstance().toStop();
    }

    public static class EmbedHttpServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {
        private static final Logger logger = LoggerFactory.getLogger(EmbedHttpServerHandler.class);
        private ExecutorBiz executorBiz;
        private String accessToken;
        private ThreadPoolExecutor bizThreadPool;

        public EmbedHttpServerHandler(ExecutorBiz executorBiz, String accessToken, ThreadPoolExecutor bizThreadPool) {
            this.executorBiz = executorBiz;
            this.accessToken = accessToken;
            this.bizThreadPool = bizThreadPool;
        }

        protected void channelRead0(final ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {
            final String requestData = msg.content().toString(CharsetUtil.UTF_8);
            final String uri = msg.uri();
            final HttpMethod httpMethod = msg.method();
            final boolean keepAlive = HttpUtil.isKeepAlive(msg);
            final String accessTokenReq = msg.headers().get("XXL-JOB-ACCESS-TOKEN");
            this.bizThreadPool.execute(new Runnable() {
                public void run() {
                    Object responseObj = EmbedHttpServerHandler.this.process(httpMethod, uri, requestData, accessTokenReq);
                    String responseJson = GsonTool.toJson(responseObj);
                    EmbedHttpServerHandler.this.writeResponse(ctx, keepAlive, responseJson);
                }
            });
        }

        private Object process(HttpMethod httpMethod, String uri, String requestData, String accessTokenReq) {
            if (HttpMethod.POST != httpMethod) {
                return new ReturnT(500, "invalid request, HttpMethod not support.");
            } else if (uri != null && uri.trim().length() != 0) {
                if (this.accessToken != null && this.accessToken.trim().length() > 0 && !this.accessToken.equals(accessTokenReq)) {
                    return new ReturnT(500, "The access token is wrong.");
                } else {
                    try {
                        if ("/beat".equals(uri)) {
                            return this.executorBiz.beat();
                        } else if ("/idleBeat".equals(uri)) {
                            IdleBeatParam idleBeatParam = (IdleBeatParam)GsonTool.fromJson(requestData, IdleBeatParam.class);
                            return this.executorBiz.idleBeat(idleBeatParam);
                        } else if ("/run".equals(uri)) {
                            TriggerParam triggerParam = (TriggerParam)GsonTool.fromJson(requestData, TriggerParam.class);
                            return this.executorBiz.run(triggerParam);
                        } else if ("/kill".equals(uri)) {
                            KillParam killParam = (KillParam)GsonTool.fromJson(requestData, KillParam.class);
                            return this.executorBiz.kill(killParam);
                        } else if ("/log".equals(uri)) {
                            LogParam logParam = (LogParam)GsonTool.fromJson(requestData, LogParam.class);
                            return this.executorBiz.log(logParam);
                        } else {
                            return new ReturnT(500, "invalid request, uri-mapping(" + uri + ") not found.");
                        }
                    } catch (Exception var6) {
                        logger.error(var6.getMessage(), var6);
                        return new ReturnT(500, "request error:" + ThrowableUtil.toString(var6));
                    }
                }
            } else {
                return new ReturnT(500, "invalid request, uri-mapping empty.");
            }
        }

        private void writeResponse(ChannelHandlerContext ctx, boolean keepAlive, String responseJson) {
            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.copiedBuffer(responseJson, CharsetUtil.UTF_8));
            response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/html;charset=UTF-8");
            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
            if (keepAlive) {
                response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);
            }

            ctx.writeAndFlush(response);
        }

        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
            ctx.flush();
        }

        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
            logger.error(">>>>>>>>>>> xxl-job provider netty_http server caught exception", cause);
            ctx.close();
        }

        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
            if (evt instanceof IdleStateEvent) {
                ctx.channel().close();
                logger.debug(">>>>>>>>>>> xxl-job provider netty_http server close an idle channel.");
            } else {
                super.userEventTriggered(ctx, evt);
            }

        }
    }
}

```
这里启动NettyServer 是在start() 方法中。方法中异步开启线程，然后线程中去启动NettyServer。并且核心的一个Handler 是com.xxl.job.core.server.EmbedServer.EmbedHttpServerHandler#EmbedHttpServerHandler。 

这个Handler 内部核心的逻辑是在一个线程池中处理的。处理逻辑就是先拿到 请求的uri， 然后根据uri 选择不同的方法进行调用，调用完之后转为JSON，并写回到调用方。

## 注册服务
com.xxl.job.core.server.EmbedServer#startRegistry 开启注册服务的线程， 最终交给线程：`com.xxl.job.core.thread.ExecutorRegistryThread#start`
```
public class ExecutorRegistryThread {
    private static Logger logger = LoggerFactory.getLogger(ExecutorRegistryThread.class);
    private static ExecutorRegistryThread instance = new ExecutorRegistryThread();
    private Thread registryThread;
    private volatile boolean toStop = false;

    public ExecutorRegistryThread() {
    }

    public static ExecutorRegistryThread getInstance() {
        return instance;
    }

    public void start(final String appname, final String address) {
        if (appname != null && appname.trim().length() != 0) {
            if (XxlJobExecutor.getAdminBizList() == null) {
                logger.warn(">>>>>>>>>>> xxl-job, executor registry config fail, adminAddresses is null.");
            } else {
                this.registryThread = new Thread(new Runnable() {
                    public void run() {
                        RegistryParam registryParam;
                        Iterator var2;
                        AdminBiz adminBiz;
                        ReturnT registryResult;
                        while(!ExecutorRegistryThread.this.toStop) {
                            try {
                                registryParam = new RegistryParam(RegistType.EXECUTOR.name(), appname, address);
                                var2 = XxlJobExecutor.getAdminBizList().iterator();

                                while(var2.hasNext()) {
                                    adminBiz = (AdminBiz)var2.next();

                                    try {
                                        registryResult = adminBiz.registry(registryParam);
                                        if (registryResult != null && 200 == registryResult.getCode()) {
                                            registryResult = ReturnT.SUCCESS;
                                            ExecutorRegistryThread.logger.debug(">>>>>>>>>>> xxl-job registry success, registryParam:{}, registryResult:{}", new Object[]{registryParam, registryResult});
                                            break;
                                        }

                                        ExecutorRegistryThread.logger.info(">>>>>>>>>>> xxl-job registry fail, registryParam:{}, registryResult:{}", new Object[]{registryParam, registryResult});
                                    } catch (Exception var6) {
                                        ExecutorRegistryThread.logger.info(">>>>>>>>>>> xxl-job registry error, registryParam:{}", registryParam, var6);
                                    }
                                }
                            } catch (Exception var7) {
                                if (!ExecutorRegistryThread.this.toStop) {
                                    ExecutorRegistryThread.logger.error(var7.getMessage(), var7);
                                }
                            }

                            try {
                                if (!ExecutorRegistryThread.this.toStop) {
                                    TimeUnit.SECONDS.sleep(30L);
                                }
                            } catch (InterruptedException var5) {
                                if (!ExecutorRegistryThread.this.toStop) {
                                    ExecutorRegistryThread.logger.warn(">>>>>>>>>>> xxl-job, executor registry thread interrupted, error msg:{}", var5.getMessage());
                                }
                            }
                        }

                        try {
                            registryParam = new RegistryParam(RegistType.EXECUTOR.name(), appname, address);
                            var2 = XxlJobExecutor.getAdminBizList().iterator();

                            while(var2.hasNext()) {
                                adminBiz = (AdminBiz)var2.next();

                                try {
                                    registryResult = adminBiz.registryRemove(registryParam);
                                    if (registryResult != null && 200 == registryResult.getCode()) {
                                        registryResult = ReturnT.SUCCESS;
                                        ExecutorRegistryThread.logger.info(">>>>>>>>>>> xxl-job registry-remove success, registryParam:{}, registryResult:{}", new Object[]{registryParam, registryResult});
                                        break;
                                    }

                                    ExecutorRegistryThread.logger.info(">>>>>>>>>>> xxl-job registry-remove fail, registryParam:{}, registryResult:{}", new Object[]{registryParam, registryResult});
                                } catch (Exception var8) {
                                    if (!ExecutorRegistryThread.this.toStop) {
                                        ExecutorRegistryThread.logger.info(">>>>>>>>>>> xxl-job registry-remove error, registryParam:{}", registryParam, var8);
                                    }
                                }
                            }
                        } catch (Exception var9) {
                            if (!ExecutorRegistryThread.this.toStop) {
                                ExecutorRegistryThread.logger.error(var9.getMessage(), var9);
                            }
                        }

                        ExecutorRegistryThread.logger.info(">>>>>>>>>>> xxl-job, executor registry thread destory.");
                    }
                });
                this.registryThread.setDaemon(true);
                this.registryThread.setName("xxl-job, executor ExecutorRegistryThread");
                this.registryThread.start();
            }
        } else {
            logger.warn(">>>>>>>>>>> xxl-job, executor registry config fail, appname is null.");
        }
    }

    public void toStop() {
        this.toStop = true;
        this.registryThread.interrupt();

        try {
            this.registryThread.join();
        } catch (InterruptedException var2) {
            logger.error(var2.getMessage(), var2);
        }

    }
}

```
可以看到注册和删除都是这个线程进行的。 注册的时候是在一个while 循环中， 以30s 为周期进行休眠后发送注册信息(也就是发送appname和address)。发送注册信息实际也是获取com.xxl.job.core.executor.XxlJobExecutor#getAdminBizList 的列表，然后进行注册，注册的时候实际就是以http 接口的形式调用api/registry 接口(实际就是会调用到调度中心的controller 接口)， 也可以看出这里通信走的是http 协议。

## 调用原理
以run 调用为例子分析从admin 调度中心如何调用到服务内部。

比如服务器端我们手动执行一个的时候是通过和nettyServer 建立连接之后， 调用/run 然后传递相关参数进行调用。 然后调用到：com.xxl.job.core.biz.impl.ExecutorBizImpl#run
```java
public class ExecutorBizImpl implements ExecutorBiz {
    private static Logger logger = LoggerFactory.getLogger(ExecutorBizImpl.class);

    public ExecutorBizImpl() {
    }

    public ReturnT<String> beat() {
        return ReturnT.SUCCESS;
    }

    public ReturnT<String> idleBeat(IdleBeatParam idleBeatParam) {
        boolean isRunningOrHasQueue = false;
        JobThread jobThread = XxlJobExecutor.loadJobThread(idleBeatParam.getJobId());
        if (jobThread != null && jobThread.isRunningOrHasQueue()) {
            isRunningOrHasQueue = true;
        }

        return isRunningOrHasQueue ? new ReturnT(500, "job thread is running or has trigger queue.") : ReturnT.SUCCESS;
    }

    public ReturnT<String> run(TriggerParam triggerParam) {
        JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());
        IJobHandler jobHandler = jobThread != null ? jobThread.getHandler() : null;
        String removeOldReason = null;
        GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());
        IJobHandler originJobHandler;
        if (GlueTypeEnum.BEAN == glueTypeEnum) {
            originJobHandler = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());
            if (jobThread != null && jobHandler != originJobHandler) {
                removeOldReason = "change jobhandler or glue type, and terminate the old job thread.";
                jobThread = null;
                jobHandler = null;
            }

            if (jobHandler == null) {
                jobHandler = originJobHandler;
                if (originJobHandler == null) {
                    return new ReturnT(500, "job handler [" + triggerParam.getExecutorHandler() + "] not found.");
                }
            }
        } else if (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) {
            if (jobThread != null && (!(jobThread.getHandler() instanceof GlueJobHandler) || ((GlueJobHandler)jobThread.getHandler()).getGlueUpdatetime() != triggerParam.getGlueUpdatetime())) {
                removeOldReason = "change job source or glue type, and terminate the old job thread.";
                jobThread = null;
                jobHandler = null;
            }

            if (jobHandler == null) {
                try {
                    originJobHandler = GlueFactory.getInstance().loadNewInstance(triggerParam.getGlueSource());
                    jobHandler = new GlueJobHandler(originJobHandler, triggerParam.getGlueUpdatetime());
                } catch (Exception var7) {
                    logger.error(var7.getMessage(), var7);
                    return new ReturnT(500, var7.getMessage());
                }
            }
        } else {
            if (glueTypeEnum == null || !glueTypeEnum.isScript()) {
                return new ReturnT(500, "glueType[" + triggerParam.getGlueType() + "] is not valid.");
            }

            if (jobThread != null && (!(jobThread.getHandler() instanceof ScriptJobHandler) || ((ScriptJobHandler)jobThread.getHandler()).getGlueUpdatetime() != triggerParam.getGlueUpdatetime())) {
                removeOldReason = "change job source or glue type, and terminate the old job thread.";
                jobThread = null;
                jobHandler = null;
            }

            if (jobHandler == null) {
                jobHandler = new ScriptJobHandler(triggerParam.getJobId(), triggerParam.getGlueUpdatetime(), triggerParam.getGlueSource(), GlueTypeEnum.match(triggerParam.getGlueType()));
            }
        }

        if (jobThread != null) {
            ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), (ExecutorBlockStrategyEnum)null);
            if (ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy) {
                if (jobThread.isRunningOrHasQueue()) {
                    return new ReturnT(500, "block strategy effect：" + ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());
                }
            } else if (ExecutorBlockStrategyEnum.COVER_EARLY == blockStrategy && jobThread.isRunningOrHasQueue()) {
                removeOldReason = "block strategy effect：" + ExecutorBlockStrategyEnum.COVER_EARLY.getTitle();
                jobThread = null;
            }
        }

        if (jobThread == null) {
            jobThread = XxlJobExecutor.registJobThread(triggerParam.getJobId(), (IJobHandler)jobHandler, removeOldReason);
        }

        ReturnT<String> pushResult = jobThread.pushTriggerQueue(triggerParam);
        return pushResult;
    }

    public ReturnT<String> kill(KillParam killParam) {
        JobThread jobThread = XxlJobExecutor.loadJobThread(killParam.getJobId());
        if (jobThread != null) {
            XxlJobExecutor.removeJobThread(killParam.getJobId(), "scheduling center kill job.");
            return ReturnT.SUCCESS;
        } else {
            return new ReturnT(200, "job thread already killed.");
        }
    }

    public ReturnT<LogResult> log(LogParam logParam) {
        String logFileName = XxlJobFileAppender.makeLogFileName(new Date(logParam.getLogDateTim()), logParam.getLogId());
        LogResult logResult = XxlJobFileAppender.readLog(logFileName, logParam.getFromLineNum());
        return new ReturnT(logResult);
    }
}
```
这里会根据工作ID去判断。 如果第一次调用com.xxl.job.core.executor.XxlJobExecutor#loadJobHandler 先找到handler， 然后 调用com.xxl.job.core.executor.XxlJobExecutor#registJobThread 创建JobThread 并调用start 方法开启线程

com.xxl.job.core.thread.JobThread 源码如下：
```
public class JobThread extends Thread{
	private static Logger logger = LoggerFactory.getLogger(JobThread.class);

	private int jobId;
	private IJobHandler handler;
	private LinkedBlockingQueue<TriggerParam> triggerQueue;
	private Set<Integer> triggerLogIdSet;		// avoid repeat trigger for the same TRIGGER_LOG_ID

	private volatile boolean toStop = false;
	private String stopReason;

    private boolean running = false;    // if running job
	private int idleTimes = 0;			// idel times


	public JobThread(int jobId, IJobHandler handler) {
		this.jobId = jobId;
		this.handler = handler;
		this.triggerQueue = new LinkedBlockingQueue<TriggerParam>();
		this.triggerLogIdSet = Collections.synchronizedSet(new HashSet<Integer>());
	}
	public IJobHandler getHandler() {
		return handler;
	}

    /**
     * new trigger to queue
     *
     * @param triggerParam
     * @return
     */
	public ReturnT<String> pushTriggerQueue(TriggerParam triggerParam) {
		// avoid repeat
		if (triggerLogIdSet.contains(triggerParam.getLogId())) {
			logger.info(">>>>>>>>>>> repeate trigger job, logId:{}", triggerParam.getLogId());
			return new ReturnT<String>(ReturnT.FAIL_CODE, "repeate trigger job, logId:" + triggerParam.getLogId());
		}

		triggerLogIdSet.add(triggerParam.getLogId());
		triggerQueue.add(triggerParam);
        return ReturnT.SUCCESS;
	}

    /**
     * kill job thread
     *
     * @param stopReason
     */
	public void toStop(String stopReason) {
		/**
		 * Thread.interrupt只支持终止线程的阻塞状态(wait、join、sleep)，
		 * 在阻塞出抛出InterruptedException异常,但是并不会终止运行的线程本身；
		 * 所以需要注意，此处彻底销毁本线程，需要通过共享变量方式；
		 */
		this.toStop = true;
		this.stopReason = stopReason;
	}

    /**
     * is running job
     * @return
     */
    public boolean isRunningOrHasQueue() {
        return running || triggerQueue.size()>0;
    }

    @Override
	public void run() {

    	// init
    	try {
			handler.init();
		} catch (Throwable e) {
    		logger.error(e.getMessage(), e);
		}

		// execute
		while(!toStop){
			running = false;
			idleTimes++;

            TriggerParam triggerParam = null;
            ReturnT<String> executeResult = null;
            try {
				// to check toStop signal, we need cycle, so wo cannot use queue.take(), instand of poll(timeout)
				triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
				if (triggerParam!=null) {
					running = true;
					idleTimes = 0;
					triggerLogIdSet.remove(triggerParam.getLogId());

					// log filename, like "logPath/yyyy-MM-dd/9999.log"
					String logFileName = XxlJobFileAppender.makeLogFileName(new Date(triggerParam.getLogDateTim()), triggerParam.getLogId());
					XxlJobFileAppender.contextHolder.set(logFileName);
					ShardingUtil.setShardingVo(new ShardingUtil.ShardingVO(triggerParam.getBroadcastIndex(), triggerParam.getBroadcastTotal()));

					// execute
					XxlJobLogger.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + triggerParam.getExecutorParams());

					if (triggerParam.getExecutorTimeout() > 0) {
						// limit timeout
						Thread futureThread = null;
						try {
							final TriggerParam triggerParamTmp = triggerParam;
							FutureTask<ReturnT<String>> futureTask = new FutureTask<ReturnT<String>>(new Callable<ReturnT<String>>() {
								@Override
								public ReturnT<String> call() throws Exception {
									return handler.execute(triggerParamTmp.getExecutorParams());
								}
							});
							futureThread = new Thread(futureTask);
							futureThread.start();

							executeResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
						} catch (TimeoutException e) {

							XxlJobLogger.log("<br>----------- xxl-job job execute timeout");
							XxlJobLogger.log(e);

							executeResult = new ReturnT<String>(IJobHandler.FAIL_TIMEOUT.getCode(), "job execute timeout ");
						} finally {
							futureThread.interrupt();
						}
					} else {
						// just execute
						executeResult = handler.execute(triggerParam.getExecutorParams());
					}

					if (executeResult == null) {
						executeResult = IJobHandler.FAIL;
					} else {
						executeResult.setMsg(
								(executeResult!=null&&executeResult.getMsg()!=null&&executeResult.getMsg().length()>50000)
										?executeResult.getMsg().substring(0, 50000).concat("...")
										:executeResult.getMsg());
						executeResult.setContent(null);	// limit obj size
					}
					XxlJobLogger.log("<br>----------- xxl-job job execute end(finish) -----------<br>----------- ReturnT:" + executeResult);

				} else {
					if (idleTimes > 30) {
						XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
					}
				}
			} catch (Throwable e) {
				if (toStop) {
					XxlJobLogger.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
				}

				StringWriter stringWriter = new StringWriter();
				e.printStackTrace(new PrintWriter(stringWriter));
				String errorMsg = stringWriter.toString();
				executeResult = new ReturnT<String>(ReturnT.FAIL_CODE, errorMsg);

				XxlJobLogger.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
			} finally {
                if(triggerParam != null) {
                    // callback handler info
                    if (!toStop) {
                        // commonm
                        TriggerCallbackThread.pushCallBack(new HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTim(), executeResult));
                    } else {
                        // is killed
                        ReturnT<String> stopResult = new ReturnT<String>(ReturnT.FAIL_CODE, stopReason + " [job running，killed]");
                        TriggerCallbackThread.pushCallBack(new HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTim(), stopResult));
                    }
                }
            }
        }

		// callback trigger request in queue
		while(triggerQueue !=null && triggerQueue.size()>0){
			TriggerParam triggerParam = triggerQueue.poll();
			if (triggerParam!=null) {
				// is killed
				ReturnT<String> stopResult = new ReturnT<String>(ReturnT.FAIL_CODE, stopReason + " [job not executed, in the job queue, killed.]");
				TriggerCallbackThread.pushCallBack(new HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTim(), stopResult));
			}
		}

		// destroy
		try {
			handler.destroy();
		} catch (Throwable e) {
			logger.error(e.getMessage(), e);
		}

		logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());
	}
}

```

com.xxl.job.core.thread.JobThread 分析
- run 方法会先调用handler.init()。
- while 循环内部然后用一个标记为进行判断。
  - 1》首先将空闲次数idleTimes 自增， 标记当前又一次没有获取到任务进行空转。
  - 2》然后从triggerQueue 阻塞队列获取任务， 并且一次周期最长等待时间是3s
- 如果获取到任务， 将idleTimes 清零。然后构造一些参数信息，然后缓存到ThreadLocal 中。 然后调用handler.execute(); 进行任务的执行。 (如果是继承IJobHandler则直接调用execute 方法)； 如果是@XxlJob 注解的方式， 实则是生成了一个com.xxl.job.core.handler.impl.MethodJobHandler 反射进行调用。
- 如果获取不到， 则判断空闲次数是否到达30 次， 如果到达30 次。则调用com.xxl.job.core.executor.XxlJobExecutor#removeJobThread 移除该线程。 会将toStop 标记为置为true，然后线程正常结束后销毁。

这里有几个注意点：
- init 方法是每次创建一个JobThread 都会调用
- 每个jobid 对应的任务都会开启一个线程。此线程允许90s 内不执行任务， 如果超过90s线程会自动销毁。并且是每个jobId对应 一个线程。




















