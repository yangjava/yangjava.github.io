---
layout: post
categories: [Mongodb]
description: none
keywords: MongoDB
---
# Mongo源码启动
mongo是mongodb的一个C++写的javascript交互式的可执行客户端。

## 
先来看看mongo的启动,mongo的启动代码在mongo/shell/dbshell.cpp中。在dbshell.cpp中有main函数了，主要看这个函数就好了
```
int _main(int argc, char* argv[], char** envp) {
    //做一些信号的接收工作
    setupSignalHandlers();
    setupSignals();

    // Log to stdout for any early logging before we re-configure the logger
    auto& lv2Manager = logv2::LogManager::global();
    logv2::LogDomainGlobal::ConfigurationOptions lv2Config;
    uassertStatusOK(lv2Manager.getGlobalDomainInternal().configure(lv2Config));

    mongo::shell_utils::RecordMyLocation(argv[0]);
    //同mongod，根据命令行初始化全局变量
    mongo::runGlobalInitializersOrDie(argc, argv, envp);
    setGlobalServiceContext(ServiceContext::make());
    // TODO This should use a TransportLayerManager or TransportLayerFactory
    auto serviceContext = getGlobalServiceContext();

    OCSPManager::get()->startThreadPool();

    transport::TransportLayerASIO::Options opts;
    opts.enableIPv6 = shellGlobalParams.enableIPv6;
    opts.mode = transport::TransportLayerASIO::Options::kEgress;

    serviceContext->setTransportLayer(
        std::make_unique<transport::TransportLayerASIO>(opts, nullptr));
    auto tlPtr = serviceContext->getTransportLayer();
    uassertStatusOK(tlPtr->setup());
    uassertStatusOK(tlPtr->start());

     // hide password from ps output
    // hide password from ps output
    redactPasswordOptions(argc, argv);

    ErrorExtraInfo::invariantHaveAllParsers();

    if (!mongo::serverGlobalParams.quiet.load())
        std::cout << mongoShellVersion(VersionInfoInterface::instance()) << std::endl;

    auto consoleSink = boost::make_shared<boost::log::sinks::synchronous_sink<ShellBackend>>();
    consoleSink->set_filter(logv2::ComponentSettingsFilter(lv2Manager.getGlobalDomain(),
                                                           lv2Manager.getGlobalSettings()));
    consoleSink->set_formatter(ShellFormatter());

    consoleSink->locked_backend()->add_stream(
        boost::shared_ptr<std::ostream>(&logv2::Console::out(), boost::null_deleter()));

    consoleSink->locked_backend()->auto_flush();

    // Remove the initial config from above when setting this sink, otherwise we log everything
    // twice.
    lv2Config.makeDisabled();
    uassertStatusOK(lv2Manager.getGlobalDomainInternal().configure(lv2Config));

    boost::log::core::get()->add_sink(std::move(consoleSink));

    // Get the URL passed to the shell
    std::string& cmdlineURI = shellGlobalParams.url;

    // Parse the output of getURIFromArgs which will determine if --host passed in a URI
    MongoURI parsedURI;
    parsedURI = uassertStatusOK(MongoURI::parse(getURIFromArgs(
        cmdlineURI, str::escape(shellGlobalParams.dbhost), str::escape(shellGlobalParams.port))));

    // TODO: add in all of the relevant shellGlobalParams to parsedURI
    parsedURI.setOptionIfNecessary("compressors"s, shellGlobalParams.networkMessageCompressors);
    parsedURI.setOptionIfNecessary("authMechanism"s, shellGlobalParams.authenticationMechanism);
    parsedURI.setOptionIfNecessary("authSource"s, shellGlobalParams.authenticationDatabase);
    parsedURI.setOptionIfNecessary("gssapiServiceName"s, shellGlobalParams.gssapiServiceName);
    parsedURI.setOptionIfNecessary("gssapiHostName"s, shellGlobalParams.gssapiHostName);
#ifdef MONGO_CONFIG_SSL
    if (!awsIam::saslAwsClientGlobalParams.awsSessionToken.empty()) {
        parsedURI.setOptionIfNecessary("authmechanismproperties"s,
                                       std::string("AWS_SESSION_TOKEN:") +
                                           awsIam::saslAwsClientGlobalParams.awsSessionToken);
    }
#endif

    if (const auto authMechanisms = parsedURI.getOption("authMechanism")) {
        std::stringstream ss;
        ss << "DB.prototype._defaultAuthenticationMechanism = \""
           << str::escape(authMechanisms.get()) << "\";" << std::endl;
        mongo::shell_utils::dbConnect += ss.str();
    }

    if (const auto gssapiServiveName = parsedURI.getOption("gssapiServiceName")) {
        std::stringstream ss;
        ss << "DB.prototype._defaultGssapiServiceName = \"" << str::escape(gssapiServiveName.get())
           << "\";" << std::endl;
        mongo::shell_utils::dbConnect += ss.str();
    }
    //如果没有配置nodb，则生成连接服务器的js脚本，现在还不会执行,在之后初始化V8引擎后才会连接服务器
    if (!shellGlobalParams.nodb) {  // connect to db
        bool usingPassword = !shellGlobalParams.password.empty();
        //如果需要认证，则让用户输入密码 
        if (mechanismRequiresPassword(parsedURI) &&
            (parsedURI.getUser().size() || shellGlobalParams.username.size())) {
            usingPassword = true;
        }
        // 下面部分代码生成一堆JS验证信息，同样验证也会在V8初始化之后进行(在mongo::shell_utils::initScope函数中)。
        if (usingPassword && parsedURI.getPassword().empty()) {
            if (!shellGlobalParams.password.empty()) {
                parsedURI.setPassword(stdx::as_const(shellGlobalParams.password));
            } else {
                parsedURI.setPassword(mongo::askPassword());
            }
        }

        if (parsedURI.getUser().empty() && !shellGlobalParams.username.empty()) {
            parsedURI.setUser(stdx::as_const(shellGlobalParams.username));
        }

        std::stringstream ss;
        if (mongo::serverGlobalParams.quiet.load()) {
            ss << "__quiet = true;" << std::endl;
        }

        ss << "db = connect( \"" << parsedURI.canonicalizeURIAsString() << "\");" << std::endl;

        if (shellGlobalParams.shouldRetryWrites || parsedURI.getRetryWrites()) {
            // If the --retryWrites cmdline argument or retryWrites URI param was specified, then
            // replace the global `db` object with a DB object started in a session. The resulting
            // Mongo connection checks its _retryWrites property.
            ss << "db = db.getMongo().startSession().getDatabase(db.getName());" << std::endl;
        }

        mongo::shell_utils::dbConnect += ss.str();
    }
    
    // 下面部分将会初始化V8引擎,这个回调函数用来做连接成功后的记录工作
    mongo::ScriptEngine::setConnectCallback(mongo::shell_utils::onConnect);
    // 首先初始化ScriptEngine，然后设置Scope初始化回调函数initScope ，之后调用newScope()函数返回V8Scope对象，同时连接数据库，根据之前生成的信息进行验证。
    mongo::ScriptEngine::setup();
    mongo::getGlobalScriptEngine()->setJSHeapLimitMB(shellGlobalParams.jsHeapLimitMB);
    mongo::getGlobalScriptEngine()->setScopeInitCallback(mongo::shell_utils::initScope);
    mongo::getGlobalScriptEngine()->enableJIT(!shellGlobalParams.nojit);
    mongo::getGlobalScriptEngine()->enableJavaScriptProtection(
        shellGlobalParams.javascriptProtection);

    auto poolGuard = makeGuard([] { ScriptEngine::dropScopeCache(); });

    std::unique_ptr<mongo::Scope> scope(mongo::getGlobalScriptEngine()->newScope());
    shellMainScope = scope.get();

    if (shellGlobalParams.runShell && !mongo::serverGlobalParams.quiet.load())
        std::cout << "type \"help\" for help" << std::endl;
    // V8初始化之后首先会去执行mongorc.js配置文件，这个有点像vim的.vimrc文件，所以一些必须要先执行的代码可以写到mongorc.js文件中。
    // Load and execute /etc/mongorc.js before starting shell
    std::string rcGlobalLocation;
#ifndef _WIN32
    rcGlobalLocation = "/etc/mongorc.js";
#else
    wchar_t programDataPath[MAX_PATH];
    if (S_OK == SHGetFolderPathW(nullptr, CSIDL_COMMON_APPDATA, nullptr, 0, programDataPath)) {
        rcGlobalLocation = str::stream()
            << toUtf8String(programDataPath) << "\\MongoDB\\mongorc.js";
    }
#endif
    if (!rcGlobalLocation.empty() && ::mongo::shell_utils::fileExists(rcGlobalLocation)) {
        if (!scope->execFile(rcGlobalLocation, false, true)) {
            std::cout << "The \"" << rcGlobalLocation << "\" file could not be executed"
                      << std::endl;
        }
    }
 // 从代码中可以看出mongorc.js文件在Windows下路径是%appdata%\MongoDB\mongorc.js，在Linux下面是”/etc/mongorc.js”。
    if (!shellGlobalParams.script.empty()) {
        mongo::shell_utils::MongoProgramScope s;
        if (!scope->exec(shellGlobalParams.script, "(shell eval)", false, true, false)) {
            std::cout << "exiting with code " << static_cast<int>(kEvalError) << std::endl;
            return kEvalError;
        }
        scope->exec("shellPrintHelper( __lastres__ );", "(shell2 eval)", true, true, false);
    }

    for (size_t i = 0; i < shellGlobalParams.files.size(); ++i) {
        mongo::shell_utils::MongoProgramScope s;

        if (shellGlobalParams.files.size() > 1)
            std::cout << "loading file: " << shellGlobalParams.files[i] << std::endl;

        if (!scope->execFile(shellGlobalParams.files[i], false, true)) {
            std::cout << "failed to load: " << shellGlobalParams.files[i] << std::endl;
            std::cout << "exiting with code " << static_cast<int>(kInputFileError) << std::endl;
            return kInputFileError;
        }

        // Check if the process left any running child processes.
        std::vector<ProcessId> pids = mongo::shell_utils::getRunningMongoChildProcessIds();

        if (!pids.empty()) {
            std::cout << "terminating the following processes started by "
                      << shellGlobalParams.files[i] << ": ";
            std::copy(pids.begin(), pids.end(), std::ostream_iterator<ProcessId>(std::cout, " "));
            std::cout << std::endl;

            if (mongo::shell_utils::KillMongoProgramInstances() != EXIT_SUCCESS) {
                std::cout << "one more more child processes exited with an error during "
                          << shellGlobalParams.files[i] << std::endl;
                std::cout << "exiting with code " << static_cast<int>(kProcessTerminationError)
                          << std::endl;
                return kProcessTerminationError;
            }

            bool failIfUnterminatedProcesses = false;
            const StringData code =
                "function() { return typeof TestData === 'object' && TestData !== null && "
                "TestData.hasOwnProperty('failIfUnterminatedProcesses') && "
                "TestData.failIfUnterminatedProcesses; }"_sd;
            shellMainScope->invokeSafe(code.rawData(), nullptr, nullptr);
            failIfUnterminatedProcesses = shellMainScope->getBoolean("__returnValue");

            if (failIfUnterminatedProcesses) {
                std::cout << "exiting with a failure due to unterminated processes, "
                             "a call to MongoRunner.stopMongod(), ReplSetTest#stopSet(), or "
                             "ShardingTest#stop() may be missing from the test"
                          << std::endl;
                std::cout << "exiting with code " << static_cast<int>(kUnterminatedProcess)
                          << std::endl;
                return kUnterminatedProcess;
            }
        }
    }

    if (shellGlobalParams.files.size() == 0 && shellGlobalParams.script.empty())
        shellGlobalParams.runShell = true;

    bool lastLineSuccessful = true;
    if (shellGlobalParams.runShell) {
        mongo::shell_utils::MongoProgramScope s;
        // If they specify norc, assume it's not their first time
        bool hasMongoRC = shellGlobalParams.norc;
        std::string rcLocation;
        if (!shellGlobalParams.norc) {
#ifndef _WIN32
            if (getenv("HOME") != nullptr)
                rcLocation = str::stream() << getenv("HOME") << "/.mongorc.js";
#else
            if (getenv("HOMEDRIVE") != nullptr && getenv("HOMEPATH") != nullptr)
                rcLocation = str::stream()
                    << toUtf8String(_wgetenv(L"HOMEDRIVE")) << toUtf8String(_wgetenv(L"HOMEPATH"))
                    << "\\.mongorc.js";
#endif
            if (!rcLocation.empty() && ::mongo::shell_utils::fileExists(rcLocation)) {
                hasMongoRC = true;
                if (!scope->execFile(rcLocation, false, true)) {
                    std::cout
                        << "The \".mongorc.js\" file located in your home folder could not be "
                           "executed"
                        << std::endl;
                    std::cout << "exiting with code " << static_cast<int>(kMongorcError)
                              << std::endl;
                    return kMongorcError;
                }
            }
        }

        if (!hasMongoRC && isatty(fileno(stdin))) {
            std::cout << "Welcome to the MongoDB shell.\n"
                         "For interactive help, type \"help\".\n"
                         "For more comprehensive documentation, see\n"
                         "\thttps://docs.mongodb.com/\n"
                         "Questions? Try the MongoDB Developer Community Forums\n"
                         "\thttps://community.mongodb.com"
                      << std::endl;
            File f;
            f.open(rcLocation.c_str(), false);  // Create empty .mongorc.js file
        }

        if (!shellGlobalParams.nodb && !mongo::serverGlobalParams.quiet.load() &&
            isatty(fileno(stdin))) {
            scope->exec(
                "shellHelper( 'show', 'startupWarnings' )", "(shellwarnings)", false, true, false);

            scope->exec(
                "shellHelper( 'show', 'freeMonitoring' )", "(freeMonitoring)", false, true, false);

            scope->exec("shellHelper( 'show', 'automationNotices' )",
                        "(automationnotices)",
                        false,
                        true,
                        false);

            scope->exec("shellHelper( 'show', 'nonGenuineMongoDBCheck' )",
                        "(nonGenuineMongoDBCheck)",
                        false,
                        true,
                        false);
        }

        shellHistoryInit();
 
        std::string prompt;
        int promptType;
        
        // 启动shell，等待用户输入，执行命令。  
        while (1) {
            inMultiLine = false;
            gotInterrupted = false;

            promptType = scope->type("prompt");
            if (promptType == String) {
                prompt = scope->getString("prompt");
            } else if ((promptType == Code) && execPrompt(*scope, "prompt", prompt)) {
            } else if (execPrompt(*scope, "defaultPrompt", prompt)) {
            } else {
                prompt = "> ";
            }
            
            char* line = shellReadline(prompt.c_str());

            char* linePtr = line;  // can't clobber 'line', we need to free() it later
            if (linePtr) {
                while (linePtr[0] == ' ')
                    ++linePtr;
                int lineLen = strlen(linePtr);
                while (lineLen > 0 && linePtr[lineLen - 1] == ' ')
                    linePtr[--lineLen] = 0;
            }

            if (!linePtr || (strlen(linePtr) == 4 && strstr(linePtr, "exit"))) {
                if (!mongo::serverGlobalParams.quiet.load())
                    std::cout << "bye" << std::endl;
                if (line)
                    free(line);
                break;
            }

            std::string code = linePtr;
            if (code == "exit" || code == "exit;") {
                free(line);
                break;
            }

            // Support idle session lifetime limits
            if (isSessionTimedOut()) {
                std::cout << "Idle Connection Timeout: Shell session has expired" << std::endl;
                if (line)
                    free(line);
                break;
            }

            if (code == "cls") {
                free(line);
                linenoiseClearScreen();
                continue;
            }

            if (code.size() == 0) {
                free(line);
                continue;
            }

            if (str::startsWith(linePtr, "edit ")) {
                shellHistoryAdd(linePtr);

                const char* s = linePtr + 5;  // skip "edit "
                while (*s && isspace(*s))
                    s++;

                edit(s);
                free(line);
                continue;
            }

            gotInterrupted = false;
            code = finishCode(code);
            if (gotInterrupted) {
                std::cout << std::endl;
                free(line);
                continue;
            }

            if (code.size() == 0) {
                free(line);
                break;
            }

            bool wascmd = false;
            {
                std::string cmd = linePtr;
                std::string::size_type firstSpace;
                if ((firstSpace = cmd.find(" ")) != std::string::npos)
                    cmd = cmd.substr(0, firstSpace);

                if (cmd.find("\"") == std::string::npos) {
                    try {
                        lastLineSuccessful =
                            scope->exec(std::string("__iscmd__ = shellHelper[\"") + cmd + "\"];",
                                        "(shellhelp1)",
                                        false,
                                        true,
                                        true);
                        if (scope->getBoolean("__iscmd__")) {
                            lastLineSuccessful =
                                scope->exec(std::string("shellHelper( \"") + cmd + "\" , \"" +
                                                code.substr(cmd.size()) + "\");",
                                            "(shellhelp2)",
                                            false,
                                            true,
                                            false);
                            wascmd = true;
                        }
                    } catch (std::exception& e) {
                        std::cout << "error2:" << e.what() << std::endl;
                        wascmd = true;
                        lastLineSuccessful = false;
                    }
                }
            }

            if (!wascmd) {
                try {
                // 可以看到整个流程的核心是scope->exec(…)函数，scope其实是V8Scope对象。
                    lastLineSuccessful = scope->exec(code.c_str(), "(shell)", false, true, false);
                    if (lastLineSuccessful) {
                        scope->exec(
                            "shellPrintHelper( __lastres__ );", "(shell2)", true, true, false);
                    }
                } catch (std::exception& e) {
                    std::cout << "error:" << e.what() << std::endl;
                    lastLineSuccessful = false;
                }
            }

            shellHistoryAdd(code.c_str());
            free(line);
        }

        shellHistoryDone();
    }

    return (lastLineSuccessful ? 0 : 1);
}

```
现在来看看mongo::globalScriptEngine->newScope()
```
mongo::Scope* MozJSScriptEngine::createScope() {
    return new MozJSProxyScope(this);
}
```

