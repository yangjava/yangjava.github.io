---
layout: post
categories: Computer
description: none
keywords: Computer
---
# 系统级IO

## I/O 设备
什么是 I/O 设备？

I/O 设备（输入/输出设备）是指用于人类与计算机进行通信的外部硬件。这些设备能够向计算机发送数据（输出）并从计算机接收数据（输入）。

I/O 设备可以分为两种类型：块设备（block devices）和字符设备（character devices）。
- 块设备：块设备是一种数据存储设备，它将数据分成固定大小的块进行读写。这些块的大小可以是几个字节到几千字节不等。块设备通常用于存储和检索大量数据，如硬盘驱动器（HDD）和固态硬盘（SSD）。块设备允许随机读写操作，可以在任意位置读取或写入数据。
- 字符设备：字符设备以字符为单位进行数据读写，而不是像块设备那样以固定大小的块进行读写。字符设备通常用于流式数据的输入和输出，例如键盘、鼠标和打印机等设备。字符设备以连续的字符流进行操作，无法随机访问设备中的特定位置。

这些不同类型的 I/O 设备在计算机系统中起着重要作用，使人类能够与计算机进行交互并进行数据的输入和输出。

## 块设备
块设备是一种能够存储固定大小块信息的设备，它以固定大小的块、扇区或群集为单位进行数据的读取和（可选）写入。每个块都具有自己的物理地址，使得可以对其进行随机访问。块设备的典型大小通常在512到65536字节之间。所有的数据传输都以连续的块为单位进行处理。

块设备具有以下基本特征：
- 独立性：每个块都是相互独立的，可以单独进行读取和写入操作。这意味着可以针对某个块进行读写，而无需影响其他块的内容。
- 随机访问：块设备支持随机读写，可以直接跳转到指定块的位置进行数据操作。这使得可以快速访问设备中的特定数据，而无需按照顺序逐个读取或写入。
- 存储容量：块设备通常具有大容量，能够存储大量数据。常见的块设备包括硬盘驱动器（HDD）、固态硬盘（SSD）、蓝光光盘和USB闪存驱动器等。
- 数据完整性：块设备支持数据的校验和纠错功能，以确保数据的完整性和可靠性。
- 性能优化：块设备通常采用缓存机制和高效的数据访问算法，以提高读写操作的性能。

与字符设备相比，块设备通常需要较少的引脚连接，因为它们不需要逐个字符地传输数据。块设备的优点在于其能够快速、随机地读写大量数据，适用于需要高速数据存储和检索的场景，如操作系统的文件系统、数据库等。

## 块设备的缺点
基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。

总结 来说：
- 不适合流式数据
块设备通常不适合处理流式数据，因为它们是以固定大小的块进行读写操作。对于需要按照连续流的方式读取或写入数据的应用，如音频或视频流，块设备可能不是最佳选择。
- 数据粒度
块设备的最小操作粒度是块的大小，这意味着即使只需要访问或修改数据块中的一小部分，也需要读取或写入整个块。这可能会导致存储空间的浪费和读写操作的效率降低。
- 随机访问延迟
尽管块设备支持随机访问，但在某些情况下，随机读写操作可能会引起较高的延迟。因为块设备通常具有机械部件（如硬盘驱动器中的旋转磁盘），在进行随机访问时需要进行磁头寻道和旋转等操作，这可能会导致延迟增加。
- 复杂性和管理开销
与字符设备相比，块设备的实现和管理通常更为复杂。块设备需要支持文件系统、缓存、磁盘分区和逻辑卷管理等功能，这可能会增加系统的管理开销和复杂性。
- 数据一致性
块设备在写入操作时存在数据一致性的挑战。由于块设备的写入操作是以块为单位进行的，当发生系统崩溃或断电等意外情况时，可能会导致正在写入的数据不完整或损坏，这可能需要额外的机制来确保数据的一致性和完整性。

## 字符设备
另一类I/O设备是字符设备（character devices）。与块设备不同，字符设备以字符为单位进行数据的发送和接收，而不考虑任何块结构。字符设备是不可寻址的，意味着无法直接访问设备中的特定位置或块。

字符设备具有以下特点：
- 字符流操作
字符设备处理数据时，将其视为连续的字符流，而不考虑数据的块结构。这意味着可以逐个字符地读取或写入数据，而无需按照固定块大小的方式进行操作。字符设备通常用于处理流式数据，如键盘、鼠标、打印机、串口通信设备等。
- 无寻道操作
字符设备没有寻道操作的概念，无法直接跳转到设备中的特定位置。数据在字符设备中按顺序进行处理，无法进行随机访问。这使得字符设备不适合于需要快速随机访问的应用场景。
- 设备多样性
字符设备涵盖了各种与计算机系统交互的设备，包括网络设备、声卡、摄像头、串口设备等。这些设备通常通过字符设备驱动程序与操作系统进行通信，提供与用户或其他设备的交互能力。
- 较少的硬件需求
相比块设备，字符设备通常需要较少的引脚和硬件资源。这是因为字符设备不需要对数据进行块划分和寻道操作，从而简化了与设备的物理连接。
- 实时性要求
某些字符设备对实时性有更高的要求，需要快速响应输入或输出的数据流。例如，实时音频或视频设备需要低延迟的数据传输，以确保实时流的连贯性和响应性。

字符设备在与人类交互的设备和流式数据的处理方面发挥着关键作用。它们提供了一种方便的方式来读取和写入字符流数据，并与计算机系统进行实时交互。通过字符设备，用户可以通过键盘输入数据，输出到显示器或打印机，或与其他外部设备进行通信。

## 设备控制器
首先需要先了解一下设备控制器的概念：

设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些特殊目的寄存器(special purpose registers) 也就是本地缓冲区中。

特殊用途寄存器，顾名思义是仅为一项任务而设计的寄存器。例如，cs，ds，gs 和其他段寄存器属于特殊目的寄存器，因为它们的存在是为了保存段号。eax，ecx 等是一般用途的寄存器，因为你可以无限制地使用它们。例如，你不能移动 ds，但是可以移动 eax，ebx。

通用目的寄存器比如有：eax、ecx、edx、ebx、esi、edi、ebp、esp

特殊目的寄存器比如有：cs、ds、ss、es、fs、gs、eip、flag

每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。

I/O 设备通常由机械组件(mechanical component)和电子组件(electronic component)构成。电子组件被称为 设备控制器(device controller)或者 适配器(adapter)。在个人计算机上，它通常采用可插入（PCIe）扩展插槽的主板上的芯片或印刷电路卡的形式。

控制器卡上通常会有一个连接器，通向设备本身的电缆可以插入到这个连接器中，很多控制器可以操作 2 个、4 个设置 8 个相同的设备。

控制器与设备之间的接口通常是一个低层次的接口。例如，磁盘可能被格式化为 2,000,000 个扇区，每个磁道 512 字节。然而，实际从驱动出来的却是一个串行的比特流，从一个前导符(preamble)开始，然后是一个扇区中的 4096 位，最后是一个校验和 或 ECC（错误码，Error-Correcting Code）。前导符是在对磁盘进行格式化的时候写上去的，它包括柱面数和扇区号，扇区大小以及类似的数据，此外还包含同步信息。

控制器的任务是把串行的位流转换为字节块，并进行必要的错误校正工作。字节块通常会在控制器内部的一个缓冲区按位进行组装，然后再对校验和进行校验并证明字节块没有错误后，再将它复制到内存中。

## 内存映射 I/O
每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。

为了控制寄存器，许多设备都会有数据缓冲区(data buffer)，来供系统进行读写。例如，在屏幕上显示一个像素的常规方法是使用一个视频 RAM，这一 RAM 基本上只是一个数据缓冲区，用来供程序和操作系统写入数据。

那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 I/O 端口(I/O port)号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是
```
1IN REG,PORT  
```
CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用
```
1OUT PORT,REG  
```
CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。

控制寄存器是一个处理器寄存器而改变或控制的一般行为 CPU 或其他数字设备。控制寄存器执行的常见任务包括中断控制，切换寻址模式，分页控制和协处理器控制。

这些方案是如何工作的呢？当 CPU 想要读入一个字的时候，无论是从内存中读入还是从 I/O 端口读入，它都要将需要的地址放到总线地址线上，然后在总线的一条控制线上调用一个 READ 信号。还有第二条信号线来表明需要的是 I/O 空间还是内存空间。如果是内存空间，内存将响应请求。如果是 I/O 空间，那么 I/O 设备将响应请求。如果只有内存空间，那么每个内存模块和每个 I/O 设备都会将地址线和它所服务的地址范围进行比较。如果地址落在这一范围之内，它就会响应请求。绝对不会出现地址既分配给内存又分配给 I/O 设备，所以不会存在歧义和冲突。

## 内存映射 I/O 的优点和缺点：
这两种寻址控制器的方案具有不同的优缺点。先来看一下内存映射 I/O 的优点。
- 第一，如果需要特殊的 I/O 指令读写设备控制寄存器，那么访问这些寄存器需要使用汇编代码，因为在 C 或 C++ 中不存在执行 IN 和 OUT指令的方法。调用这样的过程增加了 I/O 的开销。在内存映射中，控制寄存器只是内存中的变量，在 C 语言中可以和其他变量一样进行寻址。
- 第二，对于内存映射 I/O ，不需要特殊的保护机制就能够阻止用户进程执行 I/O 操作。操作系统需要保证的是禁止把控制寄存器的地址空间放在用户的虚拟地址中就可以了。
- 第三，对于内存映射 I/O，可以引用内存的每一条指令也可以引用控制寄存器，便于引用。

在计算机设计中，几乎所有的事情都要权衡。内存映射 I/O 也是一样，它也有自己的缺点。首先，大部分计算机现在都会有一些对于内存字的缓存。缓存一个设备控制寄存器的代价是很大的。为了避免这种内存映射 I/O 的情况，硬件必须有选择性的禁用缓存，例如，在每个页面上禁用缓存，这个功能为硬件和操作系统增加了额外的复杂性，因此必须选择性的进行管理。

第二点，如果仅仅只有一个地址空间，那么所有的内存模块(memory modules)和所有的 I/O 设备都必须检查所有的内存引用来推断出谁来进行响应。

## 直接内存访问
无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为直接内存访问(Direct Memory Access) 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备。

现代操作系统实际更为复杂，但是原理是相同的。如果硬件有DMA 控制器，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。

不管 DMA 控制器的物理地址在哪，它都能够独立于 CPU 从而访问系统总线，如上图所示。它包含几个可由 CPU 读写的寄存器，其中包括一个内存地址寄存器，字节计数寄存器和一个或多个控制寄存器。控制寄存器指定要使用的 I/O 端口、传送方向（从 I/O 设备读或写到 I/O 设备）、传送单位（每次一个字节或者每次一个字）以及在一次突发传送中要传送的字节数。

为了解释 DMA 的工作原理，我们首先看一下不使用 DMA 该如何进行磁盘读取。

首先，控制器从磁盘驱动器串行地、一位一位的读一个块（一个或多个扇区），直到将整块信息放入控制器的内部缓冲区。

读取校验和以保证没有发生读错误。然后控制器会产生一个中断，当操作系统开始运行时，它会重复的从控制器的缓冲区中一次一个字节或者一个字地读取该块的信息，并将其存入内存中。

## 文件的物理结构
文件的物理结构研究的是 已分配给文件的磁盘块在磁盘中如何组织起来的，分为连续分配、链式分配和索引分配3种。

我们知道文件可以分为逻辑上有结构的文件（记录式文件）和逻辑上无结构的文件（流式文件），但是即使是逻辑上无结构的文件在物理上也是有结构的。

类似于内存分页，磁盘中的存储单元也会被分为一个个物理块。很多操作系统中，磁盘块的大小与内存块、页面的大小相同，例如内存块如果一个块大小是1K，那么磁盘块的大小也会为1K或者1K的倍数。为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。

和内存地址类似，文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。每个文件的逻辑块号从0开始。

接下来介绍物理块的分配方式，我们需要关注这几个问题：每种分配方式如何实现逻辑块号到物理块号的映射，根据一个逻辑块号读取一个物理块需要的IO次数是多少，当文件块数增加时（即文件的修改和追加内容）是否方便扩展文件。

### 连续分配
连续分配方式要求每个文件在磁盘上占有一组连续的块。

已知一个文件打开后，它的信息如文件名、起始块号和长度就载入到内存中了，根据文件标识符就能获取这些信息。

Q1：如何实现文件的逻辑块号到物 理块号的转变？

如果用户想读取逻辑块号i中的文件内容。那么 目标数据的 物理块号 = 起始物理块号 + 逻辑块号。

Q2：读取一个物理块需要的IO次数是多少？

连续分配就行数组一样支持随机访问第i号逻辑块，所以根据一个逻辑块号访问一个块的IO次数是1次。

连续分配的优点：

从磁盘的物理特性来说，读取某个磁盘块时，需要先移动磁头到这个磁盘块的开始位置。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。因此连续分配的文件在顺序读取多个逻辑上连续块的情况下速度最快。

连续分配的缺点：

物理上连续分配的文件A占用了连续的三个块。若此时文件A要拓展多一个磁盘块。由于采用连续结构， 因此只能将文件A全部迁移到有4个连续空闲块的绿色区域，开销很大。

此外连续分配无法充分利用磁盘碎片，也容易产生磁盘碎片，因此磁盘利用率高。可以用紧凑技术（将已使用的磁盘空间集中在一边，将未使用的块集中在另一边，把小的空闲磁盘碎片连成一片大的空闲空间）来处理碎片，但是需要耗费很大的时间代价。

### 链接分配之隐式链接
文件块按照链式存储，每个块离散的存储在磁盘中，且每个块会记录下一个块的指针。一个文件的索引节点中记录了文件存放的起始物理块号 和 结束物理块号。

PS：文件索引节点存储着文件除文件名之外的所有基本信息，如文件的起始物理地址、读写权限、创建/修改时间等。一个文件只对应有一个索引节点，一个目录保存着该目录下所有第一层文件的所有索引节点的地址。

Q1：如何实现文件的逻辑块号到物理块号的转变？

如果要读取 i 号逻辑块，要将起始的9号物理块（0号逻辑块）读入内存，由此知道1号逻辑块存放的物理块号2，然后读入2号物理块，再找到2号逻辑块的存放位置……以此类推直到找到 i 号逻辑块。

Q2：读取一个物理块需要的IO次数是多少？

读入i号逻辑块，总共需要 i+1 次磁盘 I/O。读取一个逻辑块的平均IO次数是 n/2。

Q3：扩展性如何？

若要为文件扩展新的磁盘块，可以在磁盘中随便找一个空闲磁盘块，挂到文件磁盘块链表的链尾，不会有碎片问题， 外存利用率高。

隐式链接分配的优点：很方便文件拓展；不会有碎片问题故而外存利用率高。

隐式链接分配的缺点：只支持顺序访问不支持随机访问；查找效率低，为O(n)复杂度；每个磁盘块要保存指向下一个盘块的指针也需要耗费少量的存储空间。

读取一个逻辑块的IO次数：平均 n/2 次，n是文件的总盘块数。

### 链接分配之显式链接
文件块按照链式存储，每个块离散存储，但不记录下一个块的指针。所有物理块的下一个块物理地址统一存储在一个文件分配表 FAT 中。文件索引节点记录文件存放的起始物理块号，但不记录结束物理块号。

一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的，不占空间的。

Q1：如何实现文件的逻辑块号到物理块号的转变？

假设我们的目标逻辑块号是 3，已知逻辑块0的物理块号是2，则查询内存中的FAT[2] = 5（逻辑块号1），再找 FAT[5] = 0（逻辑块号2），再找 FAT[0] = 1（逻辑块号3）。这样我们就得知逻辑块号为3的物理块号是1。

FAT表本质是一个数组，因此访问 FAT[k]的复杂度是O(1)。

Q2：读取一个物理块需要的IO次数是多少？

逻辑块号转换成物理块号的过程不需要读磁盘操作。因此IO次数为1，就是直接读取目标物理块的那次IO操作。所以显式链接支持随机访问。

Q3：扩展性如何？

不会产生外部碎片，也可以很方便地对文件进行拓 展。

显式链接分配的优点：很方便文件拓展；不会有碎片问题，外存利用率高；支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。

显式链接分配的缺点：文件分配表的需要占用一定的存储空间（1T的磁盘，FAT表可能占几十到上百M，而且几百兆是要直接载入内存的，这点很糟糕）。

### 索引分配
索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。一个文件中的索引表本身占用的磁盘块称为索引块。文件数据占用的磁盘块称为数据块。

假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2 -> 5 -> 13 -> 9 。7号磁盘块作为“aaa”的索引块， 索引块中保存了索引表的内容。

可以用固定的长度表示磁盘块号（如：假设磁盘总容量为1TB=2^40B，磁盘块大小为1KB，则共有 2^30个磁盘块，则可用 4B 表示磁盘块号），索引表中的“逻辑块号可以是隐含的。

Q1：如何实现文件的逻辑块号到物 理块号的转变？

用户给出要访问的逻辑块号 i。

首先根据索引块的起始物理块号将整个索引表从外存读入内存（索引表可能占了多个索引块的大小），查找索引表[i] 得到 i 号 逻辑块的物理块号。

索引分配方式可以支持随机访问。

Q2: 扩展性如何？

文件拓展也很容易实现，只需要给文件分配一个空闲块，并增加一个索引表项即可。

但是索引表本身需要占用一定的存储空间。

Q3：如果一个文件的大小超过了256 块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？有3种解决方法：①链接方案；②多层索引；③混合索引

链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。

假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256 个索引项。

若一个文件大小为 256*256KB = 65,536 KB = 64MB

那么该文件共有 256*256 个数据块，也就需要 256 个索引块来存储索引表，这些索引块用链表连起来。

若想要访问文件的最后一个逻辑块， 就必须找到最后一个索引块（第256 个索引块），而各个索引块之间是用指针链接起来的，因此必须先顺序地从磁盘读入前 256 个索引块到内存中。一共要发生257次IO操作。该索引方式的缺点是读取一个逻辑块会发生太多次磁盘IO。

多层索引：将索引表分层，使第一层索引块指向第二层的索引块。还可根据再建立第三层、第四层索引块。顶层索引表只占一个索引块，非底层的索引表表项记录指向的下一层索引表的开始地址，底层的索引表表项指向数据块地址。

采用 K 层索引结构，则访问一个数据块只需要 K + 1 次 读磁盘操作，相比于链接方案而言文件数据寻址节省了很多次磁盘IO。

该索引方式的缺点是一个只占几个数据块的小文件，由于索引表的多层级，读取一个逻辑块也要发生多次磁盘IO。

混合索引：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接 指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。

## 磁盘结构
一个磁盘的盘面被分为一圈圈的 磁道 ，一个磁道又被分为一个个 扇区 ，一条指定磁道上的一个扇区就是一个 磁盘块 。一个盘面的磁道大概有几千到几万条。

最中间的白色同心圆放着一个马达用来转动盘面，另外还有可移动的磁头。磁头只能在同一扇区内的不同磁道上移动，只有马达转动盘面才可以让磁头到达另一个扇区的磁道。让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。

一个磁盘包含多个盘面，通过一个盘臂组装在一起。盘臂长着多个 磁头 ，每个盘面对应一个磁头。所有的磁头都 是连在同一个 磁臂上的，因此所有磁头只能“共进退”。但磁盘只读取/写入某一个激活了的磁头所划过的地方。

所有盘面的相同磁道组成 柱面 。一个物理块号实际上由是一个（柱面号，盘面号，扇区号）的三元组信息定义的。块号可以转换成（柱面号，盘面号，扇区号） 的地址形式。 还有一种固定头磁盘，它的每个盘面的每个磁道都有一个磁头，磁头无法移动：

## 磁盘调度算法
一次磁盘读写操作所需的时间 = 寻道时间 + 延迟时间 + 传输时间

寻道时间（TS）：在读/写数据前，将磁头移动到指定磁道所花的时间。它又包括：

①启动磁头臂是需要时间的。假设耗时为 s；

②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一 个磁道耗时为 m，总共需要跨越 n 条磁道。

则：

寻道时间 TS = s + m*n

延迟时间（TR）：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。

设磁盘转速为 r （单位：转/秒，或 转/分），则平均所需的延迟时间是转二分之一圈的时间 TR = (1/2)*(1/r) = 1/2r

传输时间（Tt）：磁头从磁盘读出/写入数据的开始位置划到结束位置所经历的时间，假设磁盘转速为 r，此次读/写的字节数为 b，每个磁道上的字节数为 N。则：传输时间Tt = (1/r) * (b/N) = b/(rN)

延迟时间和传输时间都与磁盘转速有关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间，只能优化寻道时间，也就是说它只能优化磁头跨越磁道的条数。

下面介绍具体的磁盘调度算法，假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、 150、38、184 号磁道。

### 先来先服务（FCFS）
根据进程请求访问磁盘的先后顺序进行调度。按照 FCFS 的规则，按照请求到达的顺序，磁头需要依次移动到 55、58、39、18、90、160、150、 38、184 号磁道。

磁头总共移动了 45+3+19+21+72+70+10+112+146 = 498 个磁道。

响应一个请求平均需要移动 498/9 = 55.3 个磁道（平均寻找长度）。

优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去。

缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。

### 最短寻找时间优先（SSTF）
SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。其本质是贪心算法的思想，只是选择眼前最优，但是总体未必最优。

假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、 150、38、184 号磁道。

磁头总共移动了 (100-18) + (184-18) = 248 个磁道。

响应一个请求平均需要移动 248/9 = 27.5 个磁道（平均寻找长度）。

优点：性能较好，平均寻道时间短。

缺点：可能产生“饥饿”，新来的较近的磁道请求插队导致之前那些较远的磁道请求无法得到处理。

### 扫描算法（SCAN）
SSTF 算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。

为了防止这个问题， 规定只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算（SCAN）的思想，也叫电梯算法。

磁头总共移动了 (200-100) + (200-18) = 282 个磁道。

响应一个请求平均需要移动 282/9 = 31.3 个磁道（平均寻找长度）。

优点：性能较好，平均寻道时间较短，不会产生饥饿现象

缺点：①只有到达最边上的磁道时才能改变磁头移动方向，因此会造成多余的磁道跨越。

②SCAN算法对于各个位置磁道的响应频率不平均，两边的磁道响应快，中间磁道慢。

为了解决这两个缺点，提出了C-LOOK调度算法。

### C-LOOK 调度算法
该算法是 **边移动边观察算法（LOOK算法 ）**和 循环扫描算法（C-SCAN算法） 的结合。

如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，这就是LOOK算法的思想。

只有磁头从盘片的圆心磁道到边缘磁道方向移动时才处理磁道访问请求，而从边缘磁道返回到圆心磁道的过程直接快速移动不处理任何请求。这就是C-SCAN算法的思想。

C-LOOK算法思想则是如果磁头移动的方向上已经没有 磁道访问请求了，就可以立即让磁头返回，返回的过程不处理请求，并且磁头只需要返回到有磁道访问请求的位置即可。

## 顺序IO和随机IO
顺序IO是指读写的多个块在物理上是连续的，具体的物理表现为要读写的多个块在磁盘的同一磁道上或者相邻磁道的相邻扇区，磁头无需多次寻道（表现为磁头不用移动或只用移动一丢丢）就能读写这些块。

随机IO是指要读写的多个块在物理上是离散存储的，具体的物理表现为要读写的多个块在磁盘的多个不同的磁道上，磁头需要多次寻道才能读取他们。

我们知道磁头寻道是磁盘操作成本最高的部分。因此如果操作系统某个时刻瞬间发出的n次磁盘IO操作是顺序IO，它会很快的完成。如果随机IO，由于需要寻道，因此会比顺序IO慢很多。

所以同样是n次IO，多次顺序IO比多次随机IO要快很多。



















