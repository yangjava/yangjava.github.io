---
layout: post
categories: [Lucene]
description: none
keywords: Lucene
---
# Lucene源码索引文件结构正向
Lucene保存了从Index到Segment到Document到Field一直到Term的正向信息，也包括了从Term到Document映射的反向信息，还有其他一些Lucene特有的信息。

## 正向信息
Index –> Segments (segments.gen, segments_N) –> Field(fnm, fdx, fdt) –> Term (tvx, tvd, tvf)

上面的层次结构不是十分的准确，因为segments.gen和segments_N保存的是段(segment)的元数据信息(metadata)，其实是每个Index一个的，而段的真正的数据信息，是保存在域(Field)和词(Term)中的。

## Lucene索引文件
以下描述在Lucene JavaDoc里有详细的介绍，为方便理解，介绍如下：

| 名称                  | 扩展名        | 简要描述                             | 相关源码                       |
|---------------------|------------|----------------------------------|----------------------------|
| Segment File        | segments_N | commit点信息，其中N是一个36进制表示的值         | SegmentInfos               |
| Lock File           | write.lock | 文件锁，避免多个writer同时写；默认和索引文件一个目录。   |                            |
| Segment Info        | .si        | segment的元数据信息，指明这个segment都包含哪些文件 | Lucene70SegmentInfoFormat  |
| Compound File       | .cfs, .cfe | 如果启用compound功能，会压缩索引到2个文件内       | Lucene50CompoundFormat     |
| Fields              | .fnm       | 存储有哪些Field,以及相关信息                | Lucene60FieldInfosFormat   |
| Field Index         | .fdx       | Field数据文件的索引                     | Lucene50StoredFieldsFormat |
| Field Data          | .fdt       | Field数据文件                        | Lucene50StoredFieldsFormat |
| Term Dictionary     | .tim       | Term词典                           | BlockTreeTermsWriter       |
| Term Index          | .tip       | 指向Term词典的索引                      | BlockTreeTermsWriter       |
| Frequencies         | .doc       | 保留包含每个Term的文档列表                  | Lucene50PostingsWriter     |
| Positions           | .pos       | Term在文章中出现的位置信息                  | Lucene50PostingsWriter     |
| Payloads            | .pay       | offset偏移/payload附加信息             | Lucene50PostingsWriter     |		
| Norms               | .nvd, .nvm | .nvm保存加权因子元数据；.nvd存储加权数据         | Lucene70NormsFormat        |		
| Per-Document Values | .dvd, .dvm | .dvm存文档正排元数据；.dvd存文档正排数据         | Lucene70DocValuesFormat    |		
| Term Vector Index   | .tvx       | 指向tvd的offset                     | Lucene50TermVectorsFormat  |		
| Term Vector Data    | .tvd       | 存储term vector信息                  | Lucene50TermVectorsFormat  |		
| Live Documents      | .liv       | 活着的文档列表。位图形式                     | Lucene50LiveDocsFormat     |		
| Point Values        | .dii, .dim | 多维数据，地理位置等信息，用于处理数值型的查询          | Lucene60PointsFormat       |		

## 段的元数据信息(segments_N)
一个索引(Index)可以同时存在多个segments_N(至于如何存在多个segments_N，在描述完详细信息之后会举例说明)，然而当我们要打开一个索引的时候，我们必须要选择一个来打开，那如何选择哪个segments_N呢？

Lucene采取以下过程：
其一，在所有的segments_N中选择N最大的一个。基本逻辑参照SegmentInfos.getLastCommitGeneration(File[] files)，其基本思路就是在所有以segments开头，并且不是segments.gen的文件中，选择N最大的一个作为genA。
其二，打开segments.gen，其中保存了当前的N值。其格式如下，读出版本号(Version)，然后再读出两个N，如果两者相等，则作为genB。
其三，在上述得到的genA和genB中选择最大的那个作为当前的N，方才打开segments_N文件。

## segments_N的具体格式
```
Files:
segments_N: Header, LuceneVersion, Version, NameCounter, SegCount, MinSegmentLuceneVersion, <SegName, SegID, SegCodec, DelGen, DeletionCount, FieldInfosGen, DocValuesGen, UpdatesFiles>SegCount, CommitUserData, Footer
Data types:
Header --> IndexHeader
LuceneVersion --> Which Lucene code Version was used for this commit, written as three vInt: major, minor, bugfix
MinSegmentLuceneVersion --> Lucene code Version of the oldest segment, written as three vInt: major, minor, bugfix; this is only written only if there's at least one segment
NameCounter, SegCount, DeletionCount --> Int32
Generation, Version, DelGen, Checksum, FieldInfosGen, DocValuesGen --> Int64
SegID --> Int8ID_LENGTH
SegName, SegCodec --> String
CommitUserData --> Map<String,String>
UpdatesFiles --> Map<Int32, Set<String>>
Footer --> CodecFooter
Field Descriptions:
Version counts how often the index has been changed by adding or deleting documents.
NameCounter is used to generate names for new segment files.
SegName is the name of the segment, and is used as the file name prefix for all of the files that compose the segment's index.
DelGen is the generation count of the deletes file. If this is -1, there are no deletes. Anything above zero means there are deletes stored by LiveDocsFormat.
DeletionCount records the number of deleted documents in this segment.
SegCodec is the name of the Codec that encoded this segment.
SegID is the identifier of the Codec that encoded this segment.
CommitUserData stores an optional user-supplied opaque Map<String,String> that was passed to IndexWriter.setLiveCommitData(Iterable).
FieldInfosGen is the generation count of the fieldInfos file. If this is -1, there are no updates to the fieldInfos in that segment. Anything above zero means there are updates to fieldInfos stored by FieldInfosFormat .
DocValuesGen is the generation count of the updatable DocValues. If this is -1, there are no updates to DocValues in that segment. Anything above zero means there are updates to DocValues stored by DocValuesFormat.
UpdatesFiles stores the set of files that were updated in that segment per field.
```
其中N作为后缀，是36进制的数字, 实现方式为：Long.toString(gen, Character.MAX_RADIX)。

```
segments_N: Header, LuceneVersion, Version, NameCounter, SegCount, MinSegmentLuceneVersion, <SegName, SegID, SegCodec, DelGen, DeletionCount, FieldInfosGen, DocValuesGen, UpdatesFiles>SegCount, CommitUserData, Footer
```
segments_N里通过SegName记录了这索引里所有.si文件名。

## segment格式（.si）
格式：Lucene86SegmentInfoFormat
```
Lucene 8.6 Segment info format.
Files:
.si: Header, SegVersion, SegSize, IsCompoundFile, Diagnostics, Files, Attributes, IndexSort, Footer
Data types:
Header --> IndexHeader
SegSize --> Int32
SegVersion --> String
SegMinVersion --> String
Files --> Set<String>
Diagnostics,Attributes --> Map<String,String>
IsCompoundFile --> Int8
IndexSort --> Int32 count, followed by count SortField
SortField --> String sort class, followed by a per-sort bytestream (see SortFieldProvider.readSortField(DataInput))
Footer --> CodecFooter
Field Descriptions:
SegVersion is the code version that created the segment.
SegMinVersion is the minimum code version that contributed documents to the segment.
SegSize is the number of documents contained in the segment index.
IsCompoundFile records whether the segment is written as a compound file or not. If this is -1, the segment is not a compound file. If it is 1, the segment is a compound file.
The Diagnostics Map is privately written by IndexWriter, as a debugging aid, for each segment it creates. It includes metadata like the current Lucene version, OS, Java version, why the segment was created (merge, flush, addIndexes), etc.
Files is a list of files referred to by this segment.
```
由于一个segment文件，就是一个独立的子索引，其中Files是一个列表，里面存储了本segment所有相关的索引文件。类似长这样：
```
_8qh.dii
_8qh.dim
_8qh.fdt
_8qh.fdx
_8qh.fnm
_8qh_Lucene50_0.doc
_8qh_Lucene50_0.pos
_8qh_Lucene50_0.tim
_8qh_Lucene50_0.tip
_8qh_Lucene70_0.dvd
_8qh_Lucene70_0.dvm
_8qh.si	
```
IndexSort作为新加入的一个特性，也直接体现在了.si文件里。IndexSort可以加速排序，极大提升性能。

## Field info格式（.fnm）
一个段(Segment)包含多个域，每个域都有一些元数据信息，保存在.fnm文件中，.fnm文件的格式如下：

格式：Lucene60FieldInfosFormat
```
Lucene 6.0 Field Infos format.
Field names are stored in the field info file, with suffix .fnm.
FieldInfos (.fnm) --> Header,FieldsCount, <FieldName,FieldNumber, FieldBits,DocValuesBits,DocValuesGen,Attributes,DimensionCount,DimensionNumBytes> FieldsCount,Footer
Data types:
Header --> IndexHeader
FieldsCount --> VInt
FieldName --> String
FieldBits, IndexOptions, DocValuesBits --> Byte
FieldNumber, DimensionCount, DimensionNumBytes --> VInt
Attributes --> Map<String,String>
DocValuesGen --> Int64
Footer --> CodecFooter
Field Descriptions:
FieldsCount: the number of fields in this file.
FieldName: name of the field as a UTF-8 String.
FieldNumber: the field's number. Note that unlike previous versions of Lucene, the fields are not numbered implicitly by their order in the file, instead explicitly.
FieldBits: a byte containing field options.
The low order bit (0x1) is one for fields that have term vectors stored, and zero for fields without term vectors.
If the second lowest order-bit is set (0x2), norms are omitted for the indexed field.
If the third lowest-order bit is set (0x4), payloads are stored for the indexed field.
IndexOptions: a byte containing index options.
0: not indexed
1: indexed as DOCS_ONLY
2: indexed as DOCS_AND_FREQS
3: indexed as DOCS_AND_FREQS_AND_POSITIONS
4: indexed as DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
DocValuesBits: a byte containing per-document value types. The type recorded as two four-bit integers, with the high-order bits representing norms options, and the low-order bits representing DocValues options. Each four-bit integer can be decoded as such:
0: no DocValues for this field.
1: NumericDocValues. (DocValuesType.NUMERIC)
2: BinaryDocValues. (DocValuesType#BINARY)
3: SortedDocValues. (DocValuesType#SORTED)
DocValuesGen is the generation count of the field's DocValues. If this is -1, there are no DocValues updates to that field. Anything above zero means there are updates stored by DocValuesFormat.
Attributes: a key-value map of codec-private attributes.
PointDimensionCount, PointNumBytes: these are non-zero only if the field is indexed as points, e.g. using org.apache.lucene.document.LongPoint
lucene.experimental

```
存储了Document所包含的FieldName以及Field的内部表示FieldNumber（可以理解为ID）。 同时，每个Field相关索引配置，都通过byte来存储保存下来。

其中DocValueBits里，不同类型的Field, 处理DocValue数据是不一样的，此处暂时按下不表。

- Header是fnm文件的版本号
- FieldsCount 域的数目一个数组的域(Fields)
- FieldInfo
- FieldName：域名，如"title"，"modified"，"content"等。
- FieldBits:一系列标志位，表明对此域的索引方式
  - 最低位：1表示此域被索引，0则不被索引。所谓被索引，也即放到倒排表中去。
    - 仅仅被索引的域才能够被搜到。
    - Field.Index.NO则表示不被索引。
    - Field.Index.ANALYZED则表示不但被索引，而且被分词，比如索引"hello world"后，无论是搜"hello"，还是搜"world"都能够被搜到。
    - Field.Index.NOT_ANALYZED表示虽然被索引，但是不分词，比如索引"hello world"后，仅当搜"hello world"时，能够搜到，搜"hello"和搜"world"都搜不到。
    - 一个域出了能够被索引，还能够被存储，仅仅被存储的域是搜索不到的，但是能通过文档号查到，多用于不想被搜索到，但是在通过其它域能够搜索到的情况下，能够随着文档号返回给用户的域。
    - Field.Store.Yes则表示存储此域，Field.Store.NO则表示不存储此域。
  - 倒数第二位：1表示保存词向量，0为不保存词向量。
      - Field.TermVector.YES表示保存词向量。
      - Field.TermVector.NO表示不保存词向量。
  - 倒数第三位：1表示在词向量中保存位置信息。
      - Field.TermVector.WITH_POSITIONS
  - 倒数第四位：1表示在词向量中保存偏移量信息。
      - Field.TermVector.WITH_OFFSETS
  - 倒数第五位：1表示不保存标准化因子
      - Field.Index.ANALYZED_NO_NORMS
      - Field.Index.NOT_ANALYZED_NO_NORMS
  - 倒数第六位：是否保存payload

要了解域的元数据信息，还要了解以下几点：
- 位置(Position)和偏移量(Offset)的区别
    - 位置是基于词Term的，偏移量是基于字母或汉字的。
- 索引域(Indexed)和存储域(Stored)的区别
    - 一个域为什么会被存储(store)而不被索引(Index)呢？在一个文档中的所有信息中，有这样一部分信息，可能不想被索引从而可以搜索到，但是当这个文档由于其他的信息被搜索到时，可以同其他信息一同返回。
    - 举个例子，读研究生时，您好不容易写了一篇论文交给您的导师，您的导师却要他所第一作者而您做第二作者，然而您导师不想别人在论文系统中搜索您的名字时找到这篇论文，于是在论文系统中，把第二作者这个Field的Indexed设为false，这样别人搜索您的名字，永远不知道您写过这篇论文，只有在别人搜索您导师的名字从而找到您的文章时，在一个角落表述着第二作者是您。
- payload的使用
    - 我们知道，索引是以倒排表形式存储的，对于每一个词，都保存了包含这个词的一个链表，当然为了加快查询速度，此链表多用跳跃表进行存储。
    - Payload信息就是存储在倒排表中的，同文档号一起存放，多用于存储与每篇文档相关的一些信息。当然这部分信息也可以存储域里(stored Field)，两者从功能上基本是一样的，然而当要存储的信息很多的时候，存放在倒排表里，利用跳跃表，有利于大大提高搜索速度。
## Field Data格式（.fdx, .fdt）
格式如下所示：Lucene60FieldInfosFormat
```

```
由于fdt正排信息很多，在存到磁盘的时候，使用LZ4算法进行了压缩。每个Chunk大小16KB(1<<14), Doc个数不能超过128个。在fdx中每个Block有1024个Chunk。

CompressDocs是压缩后进行存储的，为了方便理解，可以认为就是一系列的Doc构成的。每个Doc又包含FieldNumAndType和实际的Field Value。

其中FieldNumAndType是一个VLong: 低3位表示Field Type, 其余高位用来表示FieldNumber. 可见Lucene为了最大程度的节省空间，做了很多的Trick.