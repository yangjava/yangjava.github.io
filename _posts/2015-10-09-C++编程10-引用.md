---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++编程指南-引用

## 引用——给变量起个好听好记的绰号
在现实世界中，我们每个人基本上都会有好几个称呼：

大锤——妈妈叫的小名；

贾君鹏——户口本上的大名；

鹏程万里——网上自己取的昵称；

胖子——朋友给取的绰号。

虽然这些称呼各不相同，但实际上指的是同一个人。在C++世界中，也有这样的现象，一个变量除了定义时所用到的变量名之外，为了便于使用还可能有多个名字。虽然这些名字各不相同，但实际上指的是同一个变量同一个数据，通过这些名字，我们都可以访问到这个变量。人在现实世界中的多个称呼被称为绰号，而变量在C++世界中的多个名字则被更专业地称为引用。引用的本质，就是变量的别名，通俗地讲，也就是变量的绰号。对变量的引用的任何操作，实际上就是对变量本身的操作，就像不管是叫你的小名，还是叫你的绰号，都是在叫你这个人本身。

在C++中，为某个变量定义引用的语法格式如下：

数据类型& 引用名 = 变量名;

其中，数据类型跟要引用的变量的数据类型相同；其后的“&”符号表示定义的是一个引用；引用名跟变量名相似，也就是某个数据的第二个名字；而等号后面的变量名，也就是这个引用所要关联的变量本身。例如，定义一个整型变量的引用：
```
// 首先定义一个整型变量

int nValue = 1;

// 定义一个整型引用nRef并将它跟整型变量nValue关联起来

int& nRef = nValue;
```
这样，就定义了nRef是变量nValue的引用。建立引用和变量的关联后，接下来，任何对引用nRef的操作都相当于操作变量nValue本身。例如：
```
// 通过变量直接修改变量的值
nValue = 1;
cout<<"通过变量直接修改后，"<<endl;
cout<<"变量的值为"<<nValue<<endl;
cout<<"引用的值为"<<nRef<<endl;

 
// 通过引用修改变量的值
nRef = 2;
cout<<"通过引用间接修改后，"<<endl;
cout<<"变量的值为"<<nValue<<endl;
cout<<"引用的值为"<<nRef<<endl;
```
程序编译运行后可以得到下面这样的输出结果：

通过变量直接修改后，

变量的值为1

引用的值为1

通过引用间接修改后，

变量的值为2

引用的值为2

从输出结果中可以看到，无论是通过变量名nValue直接修改数据还是通过引用nRef间接修改数据，都是对变量nValue中所保存数据的修改，从而验证了对一个变量的引用的操作，也就是对这个变量本身的操作。

这里需要注意的是，引用在定义的时候必须初始化，将其与某个变量关联起来，否则会产生一个编译错误。这就像给一个人取绰号，只有这个人存在了，我们才能给他取绰号。如果连人都不存在，那么绰号何从谈起？

大家可能已经注意到，前面介绍的指针跟引用有一些相似的地方：它们就像一对孪生兄弟，都是某个变量的指代，都可以以一种间接的方式访问它们所指代的变量。虽然是孪生兄弟，但肯定还是有细微的差别，那么，指针和引用的差别又在哪里呢？从使用规则上，指针和引用就有很大的不同。

初始化的要求不同。引用在定义的时候必须初始化，而指针则没有这一强制要求，我们可以在定义指针的时候完成其初始化，也可以在定义完成后的任何合适的时候完成初始化。正是因为指针没有初始化的强制要求，这往往导致我们可能错误地使用尚未初始化的指针，从而产生非常严重的错误。例如：
```
int x = 0;
int* pInt;     // 指针在定义时可以不进行初始化，这时它指向一个随机的地址

*pInt = 1;       // 使用尚未初始化的指针可能会导致严重错误

pInt = &x;       // 在合适的时机完成指针的初始化

int& rInt = x;   // 引用在定义的时候必须初始化，rInt是变量x的引用
```
跟变量关联的紧密性不同。引用只是变量的别名，不可能存在空的引用，也就是说引用必须与某个合法的事先存在的变量关联，而指针则可以为空指针（nullptr），不与任何变量建立关联。

对重新关联的要求不同。引用一旦被初始化，与某个变量建立关联成为其引用，就不能再改变这种引用关系而跟其他的变量关联。引用跟它所关联的变量之间的关系是从一而终、固定不变的，而指针则可以随时改变所指向的变量，有点水性杨花，说变就变。例如：
```
// 定义另外一个整型变量
int y = 1;
// 这条语句不是改变rInt关联的变量，将其关联到y，
// 而是对其进行赋值，此时引用rInt和变量x的值都是1
rInt = y;
// 重新改变指针pInt所指向的变量，从x变为y
pInt = &y;
```
取绰号的目的是什么？没错，是为了让别人称呼起来更加方便。引用是变量的绰号，它的意义也同样是为了让它所关联的变量使用起来更加方便。在进行普通计算的时候，大都是变量自己亲自出马，无须引用出场，但是到了变量作为函数参数，或者作为函数返回值，尤其是一些大腕（大体积数据）需要在函数之间进行频繁传递的时候，就该引用这个替身上场了。跟指针相似，它们都是数据的某种指代。当需要在函数间传递数据时，传递数据的引用要比传递数据本身轻松得多，但效果却是完全一样的。所以，引用的主要应用就是在函数间传递函数的参数和返回值。同样值得注意的是，跟指针一样，我们也不能将函数内局部变量的引用作为返回值返回。例如：
```
// 给整型数加1
void Increase( int& nVal )
{
    nVal += 1;
}

 
int nInt = 1;
Increase( nInt ); // 变量nInt的值变为2
```
这里利用了一个整型引用作为Increase()函数的形式参数，当用一个整型变量作为实际参数调用它时，实际上是用这个整型变量对引用参数进行初始化，让两者建立了关联。这样，在函数内部对引用参数的操作也就相当于操作实际参数变量本身，这样就同时实现了函数数据的传入和传出。

回顾一下前面学习的内容，现在我们已经知道以下三种传递函数参数和返回值的方式：

传值。传值是指直接将实际参数的值复制给形式参数，完成参数的传递。

传指针。传指针是指将指向需要传递的数据的指针作为参数进行传递。

传引用。传引用是指将需要传递的数据的引用作为参数进行传递。

没有选择，很苦恼，但是选择太多，会更加苦恼。传递函数参数和返回值的方式这么多，那么它们有何差别？遇到具体情况我们又该如何选择？不用迷惑，下面的例子将比较这三种在函数间传递数据的方式，教会我们如何选择：
```
// 通过传值来传入参数和传出返回值
int FuncByValue(int x)
{
    x = x + 1;
    return x;
}

// 通过传指针来传入参数和传出返回值
int* FuncByPointer(int* p)
{
	*p = *p + 1;
	return p;
}

 

// 通过传引用来传入参数和传出返回值
int& FuncByRef(int& r)
{
	r = r + 1;
	return r;
}

int main()
{
    int n = 0;
    cout<<"n的初始值, n = "<<n<<endl;
 
    // 调用传值方式的函数，变量n的值不发生改变
    FuncByValue( n );
    cout<<"传值, n = "<<n<<endl;

    // 调用传指针的函数，实现数据的同时传入传出
    // 变量n的值发生改变
    FuncByPointer( &n );
    cout<<"传指针, n = "<<n<<endl;

 
    // 调用传引用的函数，实现数据的同时传入传出
    // 变量n的值发生改变
    FuncByRef( n );
    cout<<"传引用, n = "<<n<<endl;


    return 0;
}
```
编译运行程序后可以得到这样的输出结果：

n的初始值, n = 0

传值, n = 0

传指针, n = 1

传引用, n = 2

从程序的输出结果可以分析这三种传递参数方式的区别：在函数FuncByValue()中，其内部的形式参数x只是外部实际参数n的一份拷贝，函数内部对x的运算不能改变函数外部n的值，所以输出n的值仍然为0，与初始值相同；在函数FuncByPointer()中，指针p是指向外部变量n的指针，在函数内部改变指针p所指向的数据的值，实际上就是改变函数外部变量n的值，所以输出n的值为1；在函数FuncByRef()中，函数内部的引用r跟函数外部变量n相关联，它们其实可以看作是同一个数据，在函数内部改变r的值同样也会修改函数外部n的值，所以最终输出n的值为2。

对比以上三种传递参数的方式可以发现：传引用的性质跟传指针相似，都是以传递函数外部数据的某种指代来代替传递数据本身，既可以传入数据也可以传出数据；同时，传引用又跟传值的书写形式相似，它可以直接使用变量作为实际参数调用函数，在函数内部引用的使用方式也跟普通变量的使用方式一样。这样，传引用既有与传指针相同的高效灵活——节省空间，提高效率，可以用做参数的传入和传出；同时又跟传值保持了相同的书写形式——让引用在函数中使用起来更加简单自然，代码的可读性也更高。可以说，传引用同时具备了传指针和传引用两者的优点。综合起来，在传递小体积参数时，比如某个int类型数据，如果只是传入数据，选择传值方式。如果同时需要传出数据，选择传引用方式；在传递大体积参数时，比如某个大体积的对象，则优先选择传引用方式。