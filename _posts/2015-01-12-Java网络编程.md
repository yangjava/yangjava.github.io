---
layout: post
categories: [Java]
description: none
keywords: Java
---
# Java网络编程
与网络编程有关的基本API位于Java.NET包中，其中包含基本的网络编程实现，该包是网络编程的基础。Java.NET包既包含基本的网络编程类，也包含封装后专门处理WEB相关的处理类。

## UDP协议网络程序
UDP（User Datagram Protocol）是一种无连接的协议，每个数据包都是一个独立的信息，包括完整的源地址或目的地址。由于UDP在网络上是以任何可能的路径传往目的地的，因此能否到达目的地、到达目的地的时间及内容的正确性都是不能被保证的。使用UDP时，每个数据包中都给出了完整的地址信息，无须再建立发送方和接收方的连接。但使用UDP传输数据是有大小限制的，每个被传输的数据包必须限定在64KB之内。UDP是一个不可靠的协议，发送方所发送的数据包不一定以相同的次序到达接收方。在java.net包中提供了两个类：DatagramSocket和DatagramPacket，用于支持数据包通信。DatagramSocket类用于在程序之间建立传送数据包的通信连接，DatagramPacket类用于表示一个数据包。

### DatagramPacket类
DatagramPacket类的主要构造方法如下：
```
public DatagramPacket(byte[] buf,int length)
public DatagramPacket(byte[] buf,int length,InetAddress address,int port)
public DatagramPacket(byte[] buf,int offset,int length)
public DatagramPacket(byte[] buf,int offset,int length,InetAddress address,int port)
public DatagramPacket(byte[] buf,int offset,int length,SocketAddress address) throws SocketException
```

DatagramPacket类的常用方法如下：
```
public InetAddress getAddress()
说明：返回发送或接收数据包的主机地址。

public byte[] getData()
说明：返回数据包内容。

public int getLength()
说明：返回接收或发送的数据长度。

public int getPort()
说明：返回发送或接收数据包的远程主机端口。

public void setAddress(InetAddress iaddr)
说明：设置发送或接收数据包的主机地址。

public void setData(byte[] buf)
说明：设置数据包内容。

public void setLength(int length)
说明：设置接收或发送的数据长度。

public void setPort(int iport)
说明：设置发送或接收数据包的远程主机端口。
```

### DatagramSocket类
DatagramSocket类的主要构造方法如下：
```
public DatagramSocket(int port) throws SocketException
public DatagramSocket(int port,InetAddress laddr) throws SocketException
public DatagramSocket(SocketAddress bindaddr) throws SocketException
```

DatagramSocket类的常用方法如下：
```
public void connect(InetAddress address, int port)
说明：建立套接字连接。

public void disconnect()
说明：断开套接字连接。

public InetAddress getInetAddress()
说明：返回已连接套接字的地址。

public InetAddress getLocalAddress()
说明：返回套接字绑定的本地地址。

public int getLocalPort()
说明：返回套接字绑定的本地端口。

public int getPort()
说明：返回已连接套接字的端口。

public void receive(DatagramPacket p) throws IOException
说明：接收数据包。

public void send(DatagramPacket p) throws IOException
说明：发送数据包。
```

### 创建UDP服务器端程序
使用DatagramSocket和DatagramPacket类创建一个UDP服务器端程序。 服务器端接收客户端发出来的空数据包（代表客户端发出请求），由接收的数据包获得客户端的IP地址和端口号。然后将服务器端的当前时间以数据包的形式发给客户端，当超过10个客户端请求后，服务器端自动关闭。

```java
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.text.SimpleDateFormat;
import java.util.Date;
public class UDPServer {
     private DatagramSocket socket = null;
     private int counter = 1;
     public UDPServer() throws IOException {
          socket = new DatagramSocket(9080);
     }
     public void run() {
          SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
          try {
               do {
                    byte[] buf = new byte[19];
                    DatagramPacket packet = new DatagramPacket(buf,
 buf.length);
                    socket.receive(packet);
                    String time = formatter.format(new Date());
                    buf = time.getBytes();
                    InetAddress address = packet.getAddress();
                    int port = packet.getPort();
                    packet = new DatagramPacket(buf, buf.length, address,
port);
                    socket.send(packet);
               } while (counter < 10);
          } catch (IOException e) {
               e.printStackTrace();
          }
          socket.close();
     }
     public static void main(String[] args) {
          try {
               System.out.println("服务器端已经启动!");
               new UDPServer().run();
               System.out.println("服务器端已经关闭！");
               System.exit(0);
          } catch (IOException e) {
               e.printStackTrace();
          }
     }
}

```

### 创建UDP客户端程序
使用DatagramSocket和DatagramPacket类创建一个UDP客户端程序。 客户端首先发送请求数据包（空的数据包），然后等待接收服务器端传回来的带有服务器当前时间的数据包，显示服务器端发送时的时间之后关闭。

```java
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
public class UDPClient {
     private DatagramSocket socket = null;
     private String serverIP = "127.0.0.1";
     public UDPClient() throws SocketException {
          socket = new DatagramSocket();
     }
     public void setServerIP(String serverIP) {
          this.serverIP = serverIP;
     }
     public void run() {
          try {
               byte[] buf = new byte[19];
               InetAddress address = InetAddress.getByName(serverIP);
               DatagramPacket packet = new DatagramPacket(buf,
buf.length,address, 9080);
               socket.send(packet);
               packet = new DatagramPacket(buf, buf.length);
               socket.receive(packet);
               String received = new String(packet.getData());
               System.out.println("服务器端时间:" + received);
               socket.close();
          } catch (UnknownHostException e) {
               e.printStackTrace();
          } catch (SocketException e) {
               e.printStackTrace();
          } catch (IOException e) {
               e.printStackTrace();
          }
     }
     public static void main(String[] args) {
          try {
               System.out.println("客户端启动，请求获取服务器当前时间的信息...");
               new UDPClient().run();
               System.out.println("客户端已获得服务器当前时间，自动关闭！");
          } catch (SocketException e) {
               e.printStackTrace();
          }
          }
}
```

## TCP协议网络程序
TCP（Tranfer Control Protocol）是一种面向连接的、保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的、无差错的数据流。发送方和接收方成对的两个套接字之间必须建立连接，一旦两个套接字连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。与UDP不同，TCP对传输数据的大小没有限制。TCP是一个可靠的协议，其确保接收方完全正确地获取发送方所发送的全部数据。在java.net包中提供了两个类：Socket和ServerSocket，分别用于表示双向连接的客户端和服务器端。

### Socket类
Socket类的主要构造方法如下：
```
public Socket(InetAddress address,int port) throws IOException
public Socket(InetAddress address,int port,InetAddress localAddr,int localPort) throws IOException
public Socket(String host,int port) throws UnknownHostException,IOException
```

Socket类的常用方法如下：
```
public InetAddress getInetAddress()
说明：返回套接字连接的主机地址。

public InetAddress getLocalAddress()
说明：返回套接字绑定的本地地址。

public InputStream getInputStream() throws IOException
说明：获得该套接字的输入流。

public int getLocalPort()
说明：返回套接字绑定的本地端口。

public int getPort()
说明：返回套接字连接的远程端口。

public OutputStream getOutputStream() throws IOException
说明：返回该套接字的输出流。

public int getSoTimeout() throws SocketException
说明：返回该套接字最长等待时间。

public void setSoTimeout(int timeout) throws SocketException
说明：设置该套接字最长等待时间。

public void shutdownInput() throws IOException
说明：关闭输入流。

public void shutdownOutput() throws IOException
说明：关闭输出流。

public void close() throws IOException
说明：关闭套接字。
```

### ServerSocket类
ServerSocket类的主要构造方法如下：
```
public ServerSocket(int port) throws IOException
public ServerSocket(int port,int backlog) throws IOException
public ServerSocket(int port,int backlog,InetAddress bindAddr) throws IOException
```

ServerSocket类的常用方法如下：
```
public Socket accept() throws IOException
说明：监听并接受客户端Socket连接。

public InetAddress getInetAddress()
说明：返回服务器套接字的本地地址。

public int getLocalPort()
说明：返回该套接字监听的端口。

public int getSoTimeout() throws SocketException
说明：返回该套接字最长等待时间。

public void setSoTimeout(int timeout) throws SocketException
说明：设置该套接字最长等待时间。

public void close() throws IOException
说明：关闭套接字。
```

### 创建TCP服务器端程序
使用ServerSocket类创建一个TCP服务器端程序。 使用ServerSocket监听9080端口，等待客户端的连接请求。有客户端建立连接后，接收客户端的信息，然后断开与客户端的连接。当客户端连接次数超过10后，关闭服务器端套接字。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
public class ServerSocketDemo {
     private ServerSocket ss;
     private Socket socket;
     private BufferedReader in;
     private int counter = 1;
     public void run() {
          try {
               ss = new ServerSocket(9080);
               do {
                    socket = ss.accept();
                    in = new BufferedReader(new InputStreamReader(socket
                              .getInputStream()));
                    String message = in.readLine();
                    System.out.println("接收到客户端" + counter + "发送的消息:" + message);
                    in.close();
                    socket.close();
                    counter++;
               } while (counter < 10);
               ss.close();
          } catch (IOException e) {
               e.printStackTrace();
          }
     }
     public static void main(String[] args) {
          ServerSocketDemo demo = new ServerSocketDemo();
          System.out.println("服务器端已经启动!");
          demo.run();
          System.out.println("服务器端已经关闭！");
          System.exit(0);
     }
}
```

### 创建TCP客户端程序
使用Socket类创建一个TCP客户端程序。 使用Socket连接到地址为127.0.0.1的服务器端，端口为9080。输入一条要发送到服务器端的信息，发送后如果套接字没有关闭，就关闭套接字。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
public class ServerSocketDemo {
     private ServerSocket ss;
     private Socket socket;
     private BufferedReader in;
     private int counter = 1;
     public void run() {
          try {
               ss = new ServerSocket(9080);
               do {
                    socket = ss.accept();
                    in = new BufferedReader(new InputStreamReader(socket
                              .getInputStream()));
                    String message = in.readLine();
                    System.out.println("接收到客户端" + counter + "发送的消息:" + message);
                    in.close();
                    socket.close();
                    counter++;
               } while (counter < 10);
               ss.close();
          } catch (IOException e) {
               e.printStackTrace();
          }
     }
     public static void main(String[] args) {
          ServerSocketDemo demo = new ServerSocketDemo();
          System.out.println("服务器端已经启动!");
          demo.run();
          System.out.println("服务器端已经关闭！");
          System.exit(0);
     }
}
```

## HTTP协议网络程序
HTTP是一个属于应用层的面向对象的协议，适用于分布式超媒体信息系统。HTTP协议是基于请求／响应范式的。一个客户机与服务器建立连接后，发送一个请求给服务器，请求的格式为统一资源标识符、协议版本号，后面是MIME信息（包括请求修饰符、客户机信息和可能的内容）。服务器接收到请求后，给予相应的响应信息，其格式为信息的协议版本号、一个成功或错误的代码，后面是MIME信息（包括服务器信息、实体信息和可能的内容）。

### URL类
URL（Uniform Resource Locator）是统一资源定位器的简称，表示Internet上某一资源的地址，可以访问Internet上的各种网络资源。

URL的格式如下：
```
协议名://资源名
```
其中，协议名为获取资源所使用的传输协议，如http、ftp、file等；资源名包括主机名、端口号和文件名。

在Java中有一个与URL同名的类，用于表示URL，存在于java.net包中。其构造方法如下：
```
public URL(String spec) throws MalformedURLException
public URL(String protocol,String host,int port,String file) throws MalformedURLException
public URL(String protocol,String host,int port,String file,URLStreamHandler handler) throws MalformedURLException
public URL(String protocol,String host,String file) throws MalformedURLException
public URL(URL context,String spec) throws MalformedURLException
public URL(URL context,String spec,URLStreamHandler handler) throws MalformedURLException
```
URL类中定义了一些方法用解析URL，如用于获取该URL协议名的getProtocol方法、用于获取该URL主机名的getHost方法、用于获取该URL端口号的getPort方法、用于获取该URL文件名的getFile方法等。

下面示例演示了如何构造和解析URL对象。
```java
import java.net.MalformedURLException;
import java.net.URL;
public class URLDemo {
     public static void main(String[] args) {
          URL url = null;
          try {
               url = new URL("http://www.url.org:8080/demo/info/");
          } catch (MalformedURLException e) {
               e.printStackTrace();
          }
          if (url != null) {
               System.out.println("协议名为" + url.getProtocol());
               System.out.println("主机名为" + url.getHost());
               System.out.println("文件名为" + url.getFile());
               System.out.println("端口号为" + url.getPort());
          }
     }
}
```
这段程序代码的运行结果如下：
```
协议名为http
主机名为www.url.org
文件名为/demo/info/
端口号为8080
```

除此之外，还可以通过URL类中定义的openStream方法获得InputStream流，从而读取数据。例如：
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
public class URLStream {
     public static void main(String[] args) {
          try {
               URL url= new URL("http://www.microsoft.com/");
               BufferedReader in = new BufferedReader(new InputStreamReader(url
                         .openStream()));
               String inputLine;
               while ((inputLine = in.readLine()) != null)
                    System.out.println(inputLine);
               in.close();
          } catch (IOException e) {
               e.printStackTrace();
          }
     }
}
```
执行结果将返回www.microsoft.com对应页面html代码。

### URLConnection类
在java.net包中还有一个URLConnection类，其提供了更多的方法。URLConnection类是一个抽象类，可以通过URL类的openConnection方法获得。

通过URLConnection类不仅可以读取网上数据，也可以输出数据，还提供了检查HTTP头的方法。由于方法太多，在此就不一一列举了，感兴趣的读者可以参考JDK相关文档。这里只给出一个简单的例子说明其主要方法的使用。
```java
import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public class URLConnectionDemo {
     public static void main(String[] args) {
          try {
               URL url = new URL("http://www.microsoft.com/");
               URLConnection conn = url.openConnection();                                   System.out.println("ConnectTimeout:"+
conn.getConnectTimeout());               System.out.println("ReadTimeout:"+
conn.getReadTimeout());
               System.out.println("ContentType"+
conn.getContentType());
               System.out.println("HeaderField Detail:");
               Map map = conn.getHeaderFields();
               Set set = map.entrySet();
               Iterator it = set.iterator();
               while(it.hasNext()){
                    Map.Entry me = (Map.Entry)it.next();
                    System.out.println(me.getKey()+" "+me.getValue());
               }
          } catch (IOException e) {
               e.printStackTrace();
          }
     }
}
```

这段程序代码的运行结果如下：
```
ConnectTimeout:0
ReadTimeout:0
ContentTypetext/html; charset=utf-8
HeaderField Detail:
X-Powered-By [ASP.NET]
Content-Length [22613]
X-AspNet-Version [2.0.50727]
Date [Tue, 13 Dec 2010 10:05:17 GMT]
null [HTTP/1.1 200 OK]
Server [Microsoft-IIS/6.0]
Content-Type [text/html; charset=utf-8]
P3P [CP="ALL IND DSP COR ADM CONo CUR CUSo IVAo IVDo PSA PSD TAI TELo OUR SAMo CNT COM INT NAV ONL PHY PRE PUR UNI"]
Cache-Control [private]
```