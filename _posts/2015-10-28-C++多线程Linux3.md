---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++多线程Linux 线程清理和控制函数和线程和进程的启动和终止比较

## 线程清理和控制
```
#include<pthread.h>
void pthread_cleanup_push(void (*rtn)(void*),void* arg);
void pthread_cleanup_pop(int execute);
返回：成功返回0，否则返回错误编号
这个是一组是成对出现的
```
参数
rtn：用户定义的清理函数指针
arg：调用清理函数传递的参数
execute：值1时执行线程清理函数，值为0不执行线程清理函数
触发线程调用清理函数的动作 有三种情况
调用pthread_exit
响应取消请求--- 进程中的其他线程调用pthread_cancel此线程被取消了
用非零execute参数调用pthread_cleanup_pop时
```
#include<pthread.h>
#include<stdlib.h>
#include<stdio.h>

//定义线程清理函数
void clean_fun(void *arg){
    char *s = (char*)arg;
    printf("clean_func: %s\n",s);
}

//定义线程执行函数
void* th_fun(void *arg){
    int execute = (int)arg;
    pthread_cleanup_push(clean_fun,"first clean func");
    pthread_cleanup_push(clean_fun,"second clean func");
    printf("threadd running %ls\n",pthread_self());
    pthread_cleanup_pop(execute);
    pthread_cleanup_pop(execute);
    return (void*)0;
}

int main(void){
    int err;
    pthread_t th1,th2;
    if((err = pthread_create(&th1,null,th_fun,(void*)1)!=0){
        printf("pthread create error");
    }
    pthread_join(th1,null);
    printf("th1(%lx) finished\n",th1);
       
    if((err = pthread_create(&th2,null,th_fun,(void*)1)!=0){
        printf("pthread create error");
    }
    pthread_join(th2,null);
    printf("th2(%lx) finished\n",th2);
}
```

线程和进程的启动和终止的比较

进程	线程
fork()	pthread_create()
return/exit()/_exit()	return/pthread_exit()
wait()	pthread_join()
atexit()	pthread_clean_push/pthread_clean_pop()

## 线程初始化和销毁
线程属性函数
```
#include<pthread.h>
//定义线程属性pthread_attr_t是线程属性的结构体名
pthread_attr_t attr;
//线程属性初始化  参数就是线程结构体的指针
int pthread_attr_init(pthread_attr_t *attr)
//线程属性的销毁
int pthread_arrt_destroy(pthread_attr_t *attr)
返回：成功返回0 否则返回错误编号
```
线程属性结构
线程的分离状态 重点学习
```
typedef struct{
    int                 etachstate;  //线程的分离状态  重点学习
    int                 schedpolicy; //线程调度策略
    structsched_param   schedparam;  //线程的调度参数
    int                 inheritsched;//线程的继承性
    int                 scope;       //线程的作用域
    size_t              guardsize;   //线程栈末尾的警戒缓存区大小
    int                 stackaddr_set;//线程的栈设置
    void*               stackaddr;    //线程的栈的位置
    size_t              stacksize;    //线程栈的大小
}pthread_attr_t;
```

## 设置和获取线程属性中的分离属性
```
#include<pthread.h>
//获取线程的分离属性值
int pthread_attr_getdetachstat(const pthread_attr_t *attr,int *detachstate)
 //改变线程的分离属性值
int pthread_attr_setdetachstat(const pthread_attr_t *attr,int detachstate)
```
属性
const pthread_attr_t *attr 线程结构体的指针
*detachstate 将获取分离属性的值放到此处
detachstate 设置分离属性，取值有两种如下：


detachstate取值
PTHREAD_CREATE_JOINABLE(默认值) 正常启动线程
PTHREAD_CREATE_DETACHED 以分离状态启动线程


以默认方式启动的线程，在线程结束后不会自动释放占有的系统资源，要在主控线程中调用pthread_join()后才会释放
以分离状态启动的线程，在线程结束后会自动释放所占有的系统资源
分离属性在网络通讯中使用的较多

以上的代码实现
```
#include<pthread.h>
#include<stdio.h>
#include<stdlib.h>
​
//线程执行函数
void* th_fun(void *arg){
    int sum =0;
    for(int i =1;i<=100;i++){
        sum +=i;
    }
    return (void*)sum;
}
//输出线程属性
void out_state(pthread_attr_t *attr){
    int state;
    //获取分离属性的值
    if((pthread_attr_getdetachstat(attr,&state))!=0){
        perror("getdetachstat error/n");
    }else{
        if(state == PTHREAD_CREATE_JOINABLE){
            printf("joinable state/n");
        }else if(state == PTHREAD_CREATE_DETACHED){
            printf("detached state/n");
        }else{
            printf("erroe state/n");
        }
    }
}
int main(void){
    int err;
    
    //定义线程标识符
    pthread_t default_th,detach_th;
    
    //定义线程属性
    pthread_attr_t attr;
    
    //对线程属性初始化
    pthread_attr_init(&attr);
    
    //输出线程属性
    out_state(&attr);
    
    //创建子线程 取分离属性的默认值，以正常方式启动子线程
    if((err = pthread_create(&default_th,&attr,th_fun,(void*)0)!=0){
        printf("pthread create error");
    }
    int res;
    if((err = pthread_join(default_th,(void*)&res))!=0){
        perror("pthread join error");
    }else{
        printf("default return is %d\n",(int)res);
    }
       
    printf("-------------------------------------------/n")
    //以分离状态启动子线程
       
    //设置分离属性为分离状态
    pthread_attr_setdetachstat(&atrr,PTHREAD_CREATE_DETACHED);
    //输出线程属性
    out_state(&attr);
    if((err = pthread_create(&detach_th,&attr,th_fun,(void*)0)!=0){
        printf("pthread create error");
    }
    if((err = pthread_join(detach_th,(void*)&res))!=0){
        perror("pthread join error");
    }else{
        printf("default return is %d\n",(int)res);
    }
       
    //销毁线程属性
    pthread_arrt_destroy(&attr);
    printf("0x%lx finished\n",pthread_self());
    //主控线程休眠1秒
    Sleep(1000);
}
```