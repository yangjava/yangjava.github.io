---
layout: post
categories: [DataStructure]
description: none
keywords: DataStructure
---
# 中文分词算法

## 分词
接下来来看看分析器的一个比较重要的功能，分词。所谓分词，就是为了便于倒排索引的查询而将一个句子切分为一个一个的term，切分的最好标准就是每个词尽量符合它在句子中语义，但实际上往往是很难达到的。大家可以试想一下，如果是一句英文的句子，那么一种简单的分词方式可以用split(" ")，这样英文中的每个单词就是一个term。但是如果是一句中文，我们能够每个字一个term吗？如果这样，那搜素出来的肯定牛头不对马嘴。因为汉语中的单词通常是词组，词组才是组成确定语义的单位。因而如何分词就是需要注意的问题了。

关于中文分词，目前大概有这样几种方法：
### 基于字符串匹配的分词方法。
比较著名的几个开源项目有IkAnalyzer和paoding。

这种分词方法简单来讲就是用待分词的句子与词典中的词进行匹配，找出最合适的匹配。这种方式实现的分词，优点是快速；但制约因素是词典本身要好，而且不在词典中的词就无法匹配，因为是纯粹匹配，碰上歧义时分词器本身也不认识到底应该识别哪一个，因而消除歧义的能力较差。比如知乎上的这样一段测试文本，中间有很多歧义的部分：“工信处女干事每月经过下属科室都要亲口交代24口交换机等技术性器件的安装工作”。这样的识别对这类分词器而言是比较大的挑战。

分词按照方向可以分为正向或者逆向，按照匹配的贪婪程度，可以分为最大匹配，最少次数划分（有分词理论），最细粒度匹配。之所以会有这些划分，是因为基于字符串匹配的算法通常能够解决一类问题，但是另一类会差一些。而按照这样的划分，能够给予分词一定的启发式规则。

以上面的句子为例，如果随意划分，那么开头就会是"工信/处女/干事..."，显然是有问题的。

按照最大匹配划分，就是"工信处/女/干事"，但是最大匹配划分也有问题，matrix67的文中有个例子"北京大学生前来应聘"会被划分为"北京大学/生前/来/应聘"，这也是有问题的。

所以有逆向的匹配，比如上面这句，就可以匹配成"北京/大学生/前来/应聘"。

另一种划分方式，就是最细粒度划分，还是以最初的歧义句子为例，它可以被最细粒度划分为"工信/处女/干事/每月/月经/经过..."，可以看到它并没有消除歧义，只是增加了搜索到这个句子的词。

以上这些方式实际上都是可以举出反例的，其实就是让中国人来听，汉语也只有76%的准确度。

讲讲几个开源项目IkAnalyzer, paoding和mmseg。

IkAnalyzer是用的正向迭代最细粒度切分算法以及一个智能分词法，目前IkAnalyzer实际上是比较活跃的，作者也经常更新。

paoding实际上在2010年更新了一版支持lucene3.0之后就销声匿迹了。

mmseg的算法也挺有意思，它有下面4条启发式的消除歧义规则：

1）备选词组合的长度之和最大。
2）备选词组合的平均词长最大；
3）备选词组合的词长变化最小；
4）备选词组合中，单字词的出现频率统计值最高。
最开始它从左到右扫描一遍，识别出3个词的不同组合，然后用上面4条规则匹配出最好的一个词组，然后再次用这4条规则匹配剩下的词，这样消歧能力有明显的提高。参考中有篇文章介绍mmseg，不过居然是96年发表的

## 基于统计和机器学习的分词。
比如CRF，HMM(隐式马尔科夫模型)，MEMM(最大熵隐马模型)。

这种分词方式在最初需要提供一个训练集去喂，这个训练集就是已经标注好的分词词组，然后在分词阶段通过构建模型来计算各种可能分法的概率，通过概率来最终判断。实际上，这是目前公认的比较准确的方式。CRF即条件随机场(Conditional Random Field)，在《数学之美》中已经对其描述过。可以想象，这个训练集对于分词的准确性也是非常重要的。CRF比隐马模型好在，隐马模型由于简化，每个观察值只考虑到了当前状态，而条件随机场则是考虑到了前后的状态。通俗的讲，隐马模型对于现在的输出也只考虑现在的条件；而CRF对于现在的输出需要考虑过去，现在和未来的条件。如图，上面是隐马模型，对于观测值x2，只取决于产生的状态y2；下图则是条件随机场，x2不仅取决于y2，还取决于y1以及y3.


CRF最初是被用来对一个句子做句法成分分析的，比如：我爱地球，通过条件随机场能判断出句子成分是：主语/谓语/宾语。而这个判断的过程是一个分类的过程。如果我们将这个分类换成一个4标记B, S, M, E的方式

词首，常用B表示
词中，常用M表示
词尾，常用E表示
单子词，常用S表示
同样是“我爱地球”，每个字会被分类为"我/S爱/S地/B球/E"，从而正确的区分出每个单词。而这个划分用的是著名的维特比算法。维特比算法是动态规划算法，并不特别难。这里具体就不描述了。可以参考相关资料。


















