---
layout: post
categories: [Gateway]
description: none
keywords: Gateway
---
# 网关Gateway源码3路由

## Route加载相关类关系图
根据上图，我们可以得出一个简单的伪代码逻辑：
```
// 组合所有的RouteDefinitionLocator，方便统一读取全部的Route配置
// 被@Primary注解，没错，它就是所有DefinitionLocator的话事人
CompositeRouteDefinitionLocator compositeDefinitionLocator = 
              // 读取yml配置的RouteDefinition，仅支持读取
    composite(new PropertiesRouteDefinitionLocator(), 
              // 读取注册中心配置的RouteDefinition，仅支持读取
              new DiscoveryClientRouteDefinitionLocator(),
              // 内存里配置的RouteDefinition，支持保存和删除
              new InMemoryRouteDefinitionRepositry()
    );

// 通过持有组合出来的DefinitionLocator引用，可以查出 RouteDefinition列表
// 然后将RouteDefintions转成Route列表，以此拥有了加载Route列表的能力
RouteDefinitionRouteLocator baseLocator = 
    new RouteDefinitionRouteLocator(compositeDefinitionLocator);

// 自定义的一些RouteLocator用于扩展
RouteLocator customLocator0 = () -> createLambdaRouteLocator();
RouteLocator customLocator1 = () -> createLambdaRouteLocator();
....

// 将baseLocator和customLocators组合起来，得到compositeLocator
CompositeRouteLocator compositeLocator = 
    composite(baseLocator, customeLocator0, customLocator1...);

// 最后的人生赢家，直接持有compositeLocator使唤，在真实代码里被@Primary注解
// 所以如果要按类型@Autowired RouteLocator，那就是它了
CachingRouteLocator finalLocator = new CachingRouteLocator(compositeLocator);
```
关于RouteDifinition、PredicateDefiniton、FilterDefinition这些，在上一篇已经提过就不再赘述了。关于RouteDifinitionRepository需要额外提一下。

## RouteDifinitionRepository
一看到Repository，第一印象就想起了JPA里的Repository。妹有错，它就是针对不同存储器存储RouteDefinition进行的数据源抽象。分别继承了RouteDefinitionLocator和RouteDefinitionWriter：
```
public interface RouteDefinitionRepository
		extends RouteDefinitionLocator, RouteDefinitionWriter {

}
```
RouteDefinitionLocator已经不用再多说了，RouteDefinitionWriter看到这个Writer就知道它有写入RouteDefinition的功能：
```
public interface RouteDefinitionWriter {

	Mono<Void> save(Mono<RouteDefinition> route);

	Mono<Void> delete(Mono<String> routeId);

}
```
可知，RouteDefinitionRepository，就是把一些RouteDefinition写入指定的存储器，支持做增删查操作，比如InMemoryRouteDefinitionRepository就实现了基于本地内存LinkedHashMap的RouteDefinitionRepository：

同理，我们也可以通过实现这个扩展接口，以支持将RouteDefinition保存到各种不同的存储器进行管理，比如：mysql、注册中心等。

结合ApplicationEventPublisherAware和ApplicationListener<RefreshRoutesEvent>，还可以实现运行时动态新增路由规则等功能。其实各种配置中心动态修改配置，推送到客户端，也是这么实现的。可以参考CachingRouteDefinitionLocator和CachingRouteLocator。

为啥前面没提到过CachingRouteDefinitionLocator呢？因为它的作用被CachingRouteLocator代替了，现在只能在测试类里看到使用过的痕迹，就不用管了。

