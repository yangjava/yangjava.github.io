---
layout: post
categories: Redis
description: none
keywords: Redis
---

## **Redis配置文件**

上面两小节，设置使用守护线程启动、设置密码，都需要修改redis.conf，说明redis.conf是Redis核心的配置文件，本小节我们来看一下redis.conf中一些常用配置：

| 配置                          | 作用                                                         | 默认                               |
| ----------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| bind                          | 当配置了bind之后：只有bind指定的ip可以直接访问Redis,这样可以避免将Redis服务暴露于危险的网络环境中，防止一些不安全的人随随便便通过远程访问Redis如果bind选项为空或0.0.0.0的话，那会接受所有来自于可用网络接口的连接 | 127.0.0.1                          |
| protected-mode                | protected-mode是Redis3.2之后的新特性，用于加强Redis的安全管理，当满足以下两种情况时，protected-mode起作用：bind未设置，即接收所有来自网络的连接密码未设置当满足以上两种情况且protected-mode=yes的时候，访问Redis将报错，即密码未设置的情况下，无密码访问Redis只能通过安装Redis的本机进行访问 | yes                                |
| port                          | Redis访问端口，由于Redis是单线程模型，因此单机开多个Redis进程的时候会修改端口，不然一般使用大家比较熟悉的6379端口就可以了 | 6379                               |
| tcp-backlog                   | 半连接队列的大小，对半连接队列不熟的可以看我以前的文章[TCP：三次握手、四次握手、backlog及其他](http://www.cnblogs.com/xrq730/p/6910719.html) | 511                                |
| timeout                       | 指定在一个client空闲多少秒之后就关闭它，0表示不管            | 0                                  |
| tcp-keepalive                 | 设置tcp协议的keepalive，从Redis的注释来看，这个参数有两个作用：发现死的连接从中间网络设备的角度看连接是否存活 | 300                                |
| daemonize                     | 这个前面说过了，指定Redis是否以守护进程的方式启动            | no                                 |
| supervised                    | 这个参数表示可以通过upstart和systemd管理Redis守护进程，这个具体和操作系统相关，资料也不是很多，就暂时不管了 | no                                 |
| pidfile                       | 当Redis以守护进程的方式运行的时候,Redis默认会把pid写到pidfile指定的文件中 | /var/run/redis_6379.pid            |
| loglevel                      | 指定Redis的日志级别，Redis本身的日志级别有notice、verbose、notice、warning四种，按照文档的说法，这四种日志级别的区别是：debug，非常多信息，适合开发/测试verbose，很多很少有用的信息（直译，读着拗口，从上下文理解应该是有用信息不多的意思），但并不像debug级别这么混乱notice，适度的verbose级别的输出，很可能是生产环境中想要的warning，只记录非常重要/致命的信息 | notice                             |
| logfile                       | 配置log文件地址,默认打印在命令行终端的窗口上                 | ""                                 |
| databases                     | 设置Redis数据库的数量，默认使用0号DB                         | 16                                 |
| save                          | 把Redis数据保存到磁盘上，这个是在RDB的时候用的，介绍RDB的时候专门说这个 | save 900 1save 300 10save 60 10000 |
| stop-writes-on-bgsave-error   | 当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了 | yes                                |
| rdbcompression                | 是否在RBD的时候使用LZF压缩字符串，如果希望省点CPU，那就设为no，不过no的话数据集可能就比较大 | yes                                |
| rdbchecksum                   | 是否校验RDB文件，在RDB文件中有一个checksum专门用于校验       | yes                                |
| dbfilename                    | dump的文件位置                                               | dump.rdb                           |
| dir                           | Redis工作目录                                                | ./                                 |
| slaveof                       | 主从复制，使用slaveof让一个节点称为某个节点的副本，这个只需要在副本上配置 | 关闭                               |
| masterauth                    | 如果主机使用了requirepass配置进行密码保护，使用这个配置告诉副本连接的时候需要鉴权 | 关闭                               |
| slave-serve-stale-data        | 当一个Slave与Master失去联系或者复制正在进行中，Slave可能会有两种表现：如果为yes，Slave仍然会应答客户端请求，但返回的数据可能是过时的或者数据可能是空的如果为no，在执行除了INFO、SLAVEOF两个命令之外，都会应答"SYNC with master in progres"错误 | yes                                |
| slave-read-only               | 配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis   | yes                                |
| slave-priority                | 从站优先级是可以从redis的INFO命令输出中查到的一个整数。当主站不能正常工作时，redis sentinel使用它来选择一个从站并将它提升为主站。  低优先级的从站被认为更适合于提升，因此如果有三个从站优先级分别是10， 100， 25，sentinel会选择优先级为10的从站，因为它的优先级最低。  然而优先级值为0的从站不能执行主站的角色，因此优先级为0的从站永远不会被redis sentinel提升。 | 100                                |
| requirepass                   | 设置客户端认证密码                                           | 关闭                               |
| rename-command                | 命令重命名，对于一些危险命令例如：flushdb（清空数据库）flushall（清空所有记录）config（客户端连接后可配置服务器）keys（客户端连接后可查看所有存在的键）          作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是是：rename-command FLUSHALL ""也可以保留命令但是不能轻易使用，重命名这个命令即可：rename-command FLUSHALL abcdefg这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown command | 关闭                               |
| maxclients                    | 设置同时连接的最大客户端数量，一旦达到了限制，Redis会关闭所有的新连接并发送一个"max number of clients reached"的错误 | 关闭，默认10000                    |
| maxmemory                     | 不要使用超过指定数量的内存，一旦达到了，Redis会尝试使用驱逐策略来移除键 | 关闭                               |
| maxmemory-policy              | 当达到了maxmemory之后Redis如何移除数据，有以下的一些策略：volatile-lru，使用LRU算法，移除范围为设置了失效时间的allkeys-lru，根据LRU算法，移除范围为所有的volatile-random，使用随机算法，移除范围为设置了失效时间的allkeys-random，使用随机算法，移除范围为所有的volatile-ttl，移除最近过期的数据noeviction，不过期，当写操作的时候返回错误注意，当写操作且Redis发现没有合适的数据可以移除的时候，将会报错 | 关闭，noeviction                   |
| appendonly                    | 是否开启AOF，关于AOF后面再说                                 | no                                 |
| appendfilename                | AOF文件名称                                                  | appendonly.aof                     |
| appendfsync                   | 操作系统实际写数据到磁盘的频率，有以下几个选项：always，每次有写操作都进行同步，慢，但是最安全everysec，对写操作进行累积，每秒同步一次，是一种折衷方案no，当操作系统flush缓存的时候同步，性能更好但是会有数据丢失的风险当不确定是使用哪种的时候，官方推荐使用everysec，它是速度与数据安全之间的一种折衷方案 | everysec                           |
| no-appendfsync-on-rewrite     | aof持久化机制有一个致命的问题，随着时间推移，aof文件会膨胀，当server重启时严重影响数据库还原时间，因此系统需要定期重写aof文件。重写aof的机制为bgrewriteaof（另外一种被废弃了，就不说了），即在一个子进程中重写从而不阻塞主进程对其他命令的处理，但是这依然有个问题。bgrewriteaof和主进程写aof，都会操作磁盘，而bgrewriteaof往往涉及大量磁盘操作，这样就会让主进程写aof文件阻塞。针对上述问题，可以使用此时可以使用no-appendfsync-on-rewrite参数做一个选择：no，最安全，不丢失数据，但是需要忍受阻塞yes，数据写入缓冲区，不造成阻塞，但是如果此时redis挂掉就会丢失数据，在Linux操作系统默认设置下，最坏场景下会丢失30秒数据 | no                                 |
| auto-aof-rewrite-percentage   | 本次aof文件超过上次aof文件该值的百分比时，才会触发rewrite    | 100                                |
| auto-aof-rewrite-min-size     | aof文件最小值，只有到达这个值才会触发rewrite，即rewrite由auto-aof-rewrite-percentage+auto-aof-rewrite-min-size共同保证 | 64mb                               |
| aof-load-truncated            | redis在以aof方式恢复数据时，对最后一条可能出问题的指令的处理方式： yes，log并继续no，直接恢复失败 | yes                                |
| slowlog-log-slower-than       | Redis慢查询的最低条件，单位微妙，即查询时间>这个值的会被记录 | 10000                              |
| slowlog-max-len               | Redis存储的慢查询最大条数，超过该值之后会将最早的slowlog剔除 | 128                                |
| lua-time-limit                | 一个lua脚本执行的最大时间，单位为ms                          | 5000                               |
| cluster-enabled               | 正常来说Redis实例是无法称为集群的一部分的，只有以集群方式启动的节点才可以。为了让Redis以集群方式启动，就需要此参数。 | 关闭                               |
| cluster-config-file           | 每个集群节点应该有自己的配置文件，这个文件是不应该手动修改的，它只能被Redis节点创建且更新，每个Redis集群节点需要不同的集群配置文件 | 关闭，nodes-6379.conf              |
| cluster-node-timeout          | 集群中一个节点向其他节点发送ping命令时，必须收到回执的毫秒数 | 关闭，15000                        |
| cluster-slave-validity-factor | 如果该项设置为0，不管Slave节点和Master节点间失联多久都会一直尝试failover。比如timeout为5，该值为10，那么Master与Slave之间失联50秒，Slave不会去failover它的Master | 关闭，10                           |
| cluster-migration-barrier     | 当一个Master拥有多少个好的Slave时就要割让一个Slave出来。例如设置为2，表示当一个Master拥有2个可用的Slave时，它的一个Slave会尝试迁移 | 关闭，1                            |
| cluster-require-full-coverage | 有节点宕机导致16384个Slot全部被覆盖，整个集群是否停止服务，这个值一定要改为no | 关闭，yes                          |

以上把redis.conf里面几乎所有的配置都写了一遍（除了ADVANCED CONFIG部分），给大家作为参考吧。

①、bind:绑定redis服务器网卡IP，默认为127.0.0.1,即本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind选项为空的话，那会接受所有来自于可用网络接口的连接。

②、port：指定redis运行的端口，默认是6379。由于Redis是单线程模型，因此单机开多个Redis进程的时候会修改端口。

③、timeout：设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接。默认值为0，表示不关闭。

④、tcp-keepalive ：单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测。

具体配置详解：

①、daemonize:设置为yes表示指定Redis以守护进程的方式启动（后台启动）。默认值为 no

②、pidfile:配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/redis/run/redis_6379.pid 文件里面

③、loglevel ：定义日志级别。默认值为notice，有如下4种取值：

debug（记录大量日志信息，适用于开发、测试阶段）

verbose（较多日志信息）

notice（适量日志信息，使用于生产环境）

warning（仅有部分重要、关键信息才会被记录）

④、logfile ：配置log文件地址,默认打印在命令行终端的窗口上

⑤、databases：设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select <dbid> 命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。默认值是 16，也就是说默认Redis有16个数据库。

①、save：这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘。默认如下配置：

```
save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存
save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存
save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存
```

当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save ""

②、stop-writes-on-bgsave-error ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了

③、rdbcompression ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。

④、rdbchecksum ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。

⑤、dbfilename ：设置快照的文件名，默认是 dump.rdb

⑥、dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。

①、slave-serve-stale-data：默认值为yes。当一个 slave 与 master 失去联系，或者复制正在进行的时候，slave 可能会有两种表现：

1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候

2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，slave 都将返回一个 "SYNC with master in progress" 的错误

②、slave-read-only：配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes。

③、repl-diskless-sync：主从数据复制是否使用无硬盘复制功能。默认值为no。

④、repl-diskless-sync-delay：当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。 这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段 时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5。

⑤、repl-disable-tcp-nodelay：同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。 Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。

①、rename-command：命令重命名，对于一些危险命令例如：

flushdb（清空数据库）

flushall（清空所有记录）

config（客户端连接后可配置服务器）

keys（客户端连接后可查看所有存在的键）

作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是是：

- rename-command FLUSHALL ""

也可以保留命令但是不能轻易使用，重命名这个命令即可：

- rename-command FLUSHALL abcdefg

这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown command。

②、requirepass:设置redis连接密码

比如: requirepass 123 表示redis的连接密码为123.

①、maxclients ：设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件。 描述符数-32（redis server自身会使用一些），如果设置 maxclients为0 。表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息

①、maxmemory：设置Redis的最大内存，如果设置为0 。表示不作限制。通常是配合下面介绍的maxmemory-policy参数一起使用。

②、maxmemory-policy ：当内存使用达到maxmemory设置的最大值时，redis使用的内存清除策略。有以下几种可以选择：

1）volatile-lru  利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )

2）allkeys-lru  利用LRU算法移除任何key

3）volatile-random 移除设置过过期时间的随机key

4）allkeys-random 移除随机ke

5）volatile-ttl  移除即将过期的key(minor TTL)

6）noeviction noeviction  不移除任何key，只是返回一个写错误 ，默认选项

③、maxmemory-samples ：LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)。随意你可以选择样本大小进行检，redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数。

①、appendonly：默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式， 可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。默认值为no。

②、appendfilename ：aof文件名，默认是"appendonly.aof"

③、appendfsync：aof持久化策略的配置；no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据

④、no-appendfsync-on-rewrite：在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。  设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。

⑤、auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。

⑥、auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。

⑦、aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象 redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes。

①、lua-time-limit：一个lua脚本执行的最大时间，单位为ms。默认值为5000.

①、cluster-enabled：集群开关，默认是不开启集群模式。

②、cluster-config-file：集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。 这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件。请确保与实例运行的系统中配置文件名称不冲突。默认配置为nodes-6379.conf。

③、cluster-node-timeout ：可以配置值为15000。节点互连超时的阀值，集群节点超时毫秒数

④、cluster-slave-validity-factor ：可以配置值为10。在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了， 导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period   如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移

⑤、cluster-migration-barrier ：可以配置值为1。master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。

⑥、cluster-require-full-coverage：默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。 设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。

**Redis性能测试**

之前说过Redis在make之后有一个redis-benchmark，这个就是Redis提供用于做性能测试的，它可以用来模拟N个客户端同时发出M个请求。首先看一下redis-benchmark自带的一些参数：

| 参数  | 作用                                                         | 默认值          |
| ----- | ------------------------------------------------------------ | --------------- |
| -h    | 服务器名称                                                   | 127.0.0.1       |
| -p    | 服务器端口                                                   | 6379            |
| -s    | 服务器Socket                                                 | 无              |
| -c    | 并行连接数                                                   | 50              |
| -n    | 请求书                                                       | 10000           |
| -d    | SET/GET值的字节大小                                          | 2               |
| -k    | 1表示keep alive，0表示重连                                   | 1               |
| -r    | SET/GET/INC使用随机Key而不是常量，在形式上key样子为mykey_ran:000000012456-r的值决定了value的最大值 | 无              |
| -p    | 使用管道请求                                                 | 1，即不使用管道 |
| -q    | 安静模式，只显示query/sec值                                  | 无              |
| --csv | 使用csv格式输出                                              | 无              |
| -l    | 循环，无限运行测试                                           | 无              |
| -t    | 只运行使用逗号分割的命令的测试                               | 无              |
| -I    | 空闲模式，只打开N个空闲线程并且等待                          | 无              |
