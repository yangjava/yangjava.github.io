---
layout: post
categories: Redis
description: none
keywords: Redis
---

## **Redis的事务**

最后，本文简单说一下Redis的事务机制，首先Redis的事务是由DISCARD、EXEC、MULTI、UNWATCH、WATCH五个命令来保证的：

| 命令    | 描述                                                         | 用法                |
| ------- | ------------------------------------------------------------ | ------------------- |
| DISCARD | （1）取消事务（2）如果正在使用WATCH命令监视某个/某些key，那么取消所有监视，等同于执行UNWATCH | DISCARD             |
| EXEC    | （1）执行所有事务块内的命令（2）如果某个/某些key正处于WATCH命令监视之下且事务块中有和这个/这些key相关的命令，那么**EXEC命令只在这个/这些key没有被其他命令改动的情况下才会执行并生效**，否则该事务被打断 | EXEC                |
| MULTI   | （1）标记一个事务块的开始（2）事务块内的多条命令会按照先后顺序被放入一个队列中，最后**由EXEC命令原子性地执行** | MULTI               |
| UNWATCH | （1）取消WATCH命令对所有key的监视（2）如果WATCH之后，EXEC/DISCARD命令先被执行了，UNWATCH命令就没必要执行了 | UNWATCH             |
| WATCH   | （1）监视一个/多个key，如果在事务执行之前这个/这些key被其他命令改动，那么事务将被打断 | WATCH key [key ...] |

看到开启事务之后，所有的命令返回的都是QUEUED，即放入队列，而不是直接执行。

接着简单说一下事务，和数据库类似的，事务保证的是两点：

- **隔离**，所有命令序列化、按顺序执行，事务执行过程中不会被其他客户端发来的命令打断
- **原子性**，事务中的命令要么全部执行，要么全部不执行

另外，Redis的事务并不支持回滚，这个其实网上已经说法挺多了，大致上是两个原因：

- Redis命令只会因为语法而失败（且这些问题不能再入队时被发现），或是命令用在了错误类型的键上面，也就是说，从实用性角度来说，失败的命令是由于编程错误造成的，而这些错误应该在开发的过程中被发现而不应该出现在生产环境中
- Redis内部可以保持简单且快速，因为不需要对回滚进行支持

总而言之，对Redis来说，回滚无法解决编程错误带来的问题，因此还不如更简单、更快速地无回滚处理事务。