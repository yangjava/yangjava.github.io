---
layout: post
categories: [JVM]
description: none
keywords: JVM
---
# HotSpot的JNI调用详解
本地方法又称JNI（Java Native Interface）调用，即通过java方法调用使用本地代码如C/C++实现的方法，通过本地方法Java可以获取底层操作系统提供的能力，如文件读写，网络I/O，利用GPU计算等，可以借助其他语言实现Java本身并不直接支持的特性，如利用C/C++的开源库来实现Java的协程，可以借助底层语言如汇编实现对性能要求较高的功能，除此之外还可以通过本地方法与JVM本身，任一Java对象交互，如ClassLoader中通过启动类加载器加载核心类库，JVM的监控等。

## HelloWorld
JNI接口又称本地方法，在Java代码中JNI接口通过native关键字标识，接口定义完后使用javah命令生成头文件，然后使用C/C++实现头文件中的方法，并将其编译成windows上ddl文件或者Linux上的so文件等动态链接库。测试用例如下：
```
package jni;
 
 
public class HelloWorld {
 
    static
    {
        System.loadLibrary("HelloWorld");
    }
 
    public native static void say(String content);
 
    public static void main(String[] args) {
         HelloWorld.say("JNI native Hello World!");
    }
}
```

## javah命令
javah命令就是用来给JNI接口生成符合JNI调用规范的头文件的，在命令行执行javah -h可查看其使用帮助，如下:

为了避免通过选项指定查找路径和输出路径，可进入到包含目标class文件的目录下执行javah命令， 如图中的test-classes目录，因为javah默认在当前目录下查找目标class，并将结果头文件默认放到当前目录。执行javah -jni -v -o HelloWorld.h jni.HelloWorld生成头文件

头文件的内容如下：
```

/* DO NOT EDIT THIS FILE - it is machine generated */
//jni.h是JNI调用C++相关方法的头文件，由JVM定义
#include <jni.h>
/* Header for class jni_HelloWorld */
 
#ifndef _Included_jni_HelloWorld
#define _Included_jni_HelloWorld
//宏定义，表示如果是C++环境，即JNI调用默认是通过C实现的,C++环境需要通过extern C的方式
//告诉编译器这是一段C代码
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     jni_HelloWorld
 * Method:    say
 * Signature: (Ljava/lang/String;)V
 */
//JNIEXPORT和JNICALL都是宏定义
JNIEXPORT void JNICALL Java_jni_HelloWorld_say
  (JNIEnv *, jclass, jstring);
 
#ifdef __cplusplus
}
#endif
#endif
```
JNIEXPORT和JNICALL的宏定义位于jni_md.h中，该头文件通过jni.h引入的

## 动态链接库
动态链接库是运行期按需加载链接的共享函数库，在Linux上典型的如实现C标准函数库的glibc对应的动态链接库文件为lib目录下的libc.so，在windows上就是dll后缀的文件，dll是Dynamic Link Library的缩写，通常位于C:\Windows\System32目录下。 JVM依赖的动态链接库文件通常位于JAVA_HOME\jre\bin目录下。

应用程序可以从动态链接库中根据方法名查找对应方法的实现，对C/C++而言就是获取对应方法的指针，然后通过指针调用方法，如ClassLoader类的load_zip_library方法的实现，代码如下：
```
void ClassLoader::load_zip_library() {
  assert(ZipOpen == NULL, "should not load zip library twice");
  //首先确保java依赖的本地基础库文件已经加载
  os::native_java_library();
  char path[JVM_MAXPATHLEN];
  char ebuf[1024];
  void* handle = NULL;
  //获取动态链接库的地址，并加载下面的zip库
  if (os::dll_build_name(path, sizeof(path), Arguments::get_dll_dir(), "zip")) {
    handle = os::dll_load(path, ebuf, sizeof ebuf);
  }
  //如果加载失败抛出异常
  if (handle == NULL) {
    vm_exit_during_initialization("Unable to load ZIP library", path);
  }
  //从动态链接库中查找对应方法的实现，ZipOpen等是方法指针的别名
  ZipOpen      = CAST_TO_FN_PTR(ZipOpen_t, os::dll_lookup(handle, "ZIP_Open"));
  ZipClose     = CAST_TO_FN_PTR(ZipClose_t, os::dll_lookup(handle, "ZIP_Close"));
  FindEntry    = CAST_TO_FN_PTR(FindEntry_t, os::dll_lookup(handle, "ZIP_FindEntry"));
  ReadEntry    = CAST_TO_FN_PTR(ReadEntry_t, os::dll_lookup(handle, "ZIP_ReadEntry"));
  ReadMappedEntry = CAST_TO_FN_PTR(ReadMappedEntry_t, os::dll_lookup(handle, "ZIP_ReadMappedEntry"));
  GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, os::dll_lookup(handle, "ZIP_GetNextEntry"));
  Crc32        = CAST_TO_FN_PTR(Crc32_t, os::dll_lookup(handle, "ZIP_CRC32"));
 
  //如果查找方法实现失败
  if (ZipOpen == NULL || FindEntry == NULL || ReadEntry == NULL ||
      GetNextEntry == NULL || Crc32 == NULL) {
    vm_exit_during_initialization("Corrupted ZIP library", path);
  }
 
  //从libjava.dll查找CanonicalizeEntry，不过从1.3开始不再使用，所以未检查是否加载成功
  void *javalib_handle = os::native_java_library();
  CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, os::dll_lookup(javalib_handle, "Canonicalize"));
}
```
ZipOpen等实际都是方法指针的别名，其定义如下：
```
// Entry points in zip.dll for loading zip/jar file entries

typedef void * * (JNICALL *ZipOpen_t)(const char *name, char **pmsg);
typedef void (JNICALL *ZipClose_t)(jzfile *zip);
typedef jzentry* (JNICALL *FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
typedef jboolean (JNICALL *ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
typedef jboolean (JNICALL *ReadMappedEntry_t)(jzfile *zip, jzentry *entry, unsigned char **buf, char *namebuf);
typedef jzentry* (JNICALL *GetNextEntry_t)(jzfile *zip, jint n);
```
zip库可在JAVA_HOME\jre\bin目录下找到

## 实现JNI接口
因为默认情况下jni_md.h跟jni.h不在同一个目录下，但是jni.h引入jni_md.h是假定两者在同一个目录的，如下：
```
#ifndef _JAVASOFT_JNI_H_
#define _JAVASOFT_JNI_H_

#include <stdio.h>
#include <stdarg.h>

/* jni_md.h contains the machine-dependent typedefs for jbyte, jint
   and jlong */

#include "jni_md.h"

#ifdef __cplusplus
extern "C" {
#endif
```
因此会导致代码及后面的编译报错，需要将jni_md.h从include下面的平台子目录中拷贝到include中

拷贝完成代码中属于jni_md.h定义的宏如JNIEXPORT就不会报错了，接着写实现类即可，如下：
```
 
#include "HelloWorld.h"
#include <stdio.h>
 
//生成的头文件中方法定义是省略了参数名的，实现方法时需要加上参数名
JNIEXPORT void JNICALL Java_jni_HelloWorld_say
  (JNIEnv * env, jclass arg, jstring instring)
 {
   //将java的String对象指向的字符串拷贝一份
   const jbyte *str =
        (const jbyte *)env->GetStringUTFChars(instring, JNI_FALSE);
   //打印字符串
    printf("Java_jni_HelloWorld_say->%s\n",str);
    //释放str指向的字符串内存
    env->ReleaseStringUTFChars(instring, (const char *)str);
    return;
 }
```
实现类命名为HelloWorld.cpp，跟HelloWorld.h在同一个目录下

## JNIEnv RegisterNatives
上述通过javah生成的头文件中C函数名是固定的，必须符合特定的规范，那么有没有办法自定义C的函数名，并程序控制Java方法与本地方法实现的绑定？答案是JNIEnv对象的RegisterNatives方法。该方法的定义在jdk/src/share/javavm/export/jni.h中
```
 jint (JNICALL *RegisterNatives)
      (JNIEnv *env, jclass clazz, const JNINativeMethod *methods,
       jint nMethods);
```
其中methods是JNINativeMethod数组指针， JNINativeMethod的定义在同一个jni.中
```
typedef struct {
    char *name;
    char *signature;
    void *fnPtr;
} JNINativeMethod;
```
其中name表示java方法名字符串的指针，signature表示方法描述符字符串的指针，fnPtr是该java方法对应的本地方法实现的函数指针。那么问题来了，怎样获取方法描述符字符串了？答案是javap -s命令

descriptor就是对应方法的方法描述符字符串了。

与RegisterNatives方法相对的是UnregisterNatives，用于卸载某个类的本地方法，从而允许该类的本地方法重新链接到一个新的动态链接库，其方法定义如下：
```
 jint (JNICALL *UnregisterNatives)
      (JNIEnv *env, jclass clazz);
```
具体来说RegisterNatives有两种用法，一种是JDK的标准用法，在Java类中定义一个本地registerNatives方法，用javah生成对应的本地方法头文件，在registerNatives方法中完成其他本地方法的注册，典型的如java.lang.Object类，其定义的registerNatives方法如下：
```
public class Object {

    private static native void registerNatives();
    static {
        registerNatives();
    }
```
registerNatives的本地方法实现在jdk/src/share/native/java/lang/Object.c中，如下图：
```
static JNINativeMethod methods[] = {
    {"hashCode",    "()I",                    (void *)&JVM_IHashCode},
    {"wait",        "(J)V",                   (void *)&JVM_MonitorWait},
    {"notify",      "()V",                    (void *)&JVM_MonitorNotify},
    {"notifyAll",   "()V",                    (void *)&JVM_MonitorNotifyAll},
    {"clone",       "()Ljava/lang/Object;",   (void *)&JVM_Clone},
};

JNIEXPORT void JNICALL
Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)
{
    (*env)->RegisterNatives(env, cls,
                            methods, sizeof(methods)/sizeof(methods[0]));
}

```
第二种不通过javah生成头文件， 利用JVM加载库文件会回调库文件中的JNI_OnLoad方法来实现本地方法的注册，JNI_OnLoad方法的定义也在jni.h中，如下图：
```
/* Defined by native libraries. */
JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM *vm, void *reserved);
```
HelloWorld.cpp的实现如下：
```
#include "jni.h"
#include <stdio.h>
 
JNIEXPORT void JNICALL say_hello_world
  (JNIEnv * env, jclass arg, jstring instring);
 
JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM *vm, void *reserved){
	    JNIEnv* env;
	    //判断当前JDK判断是否大于1.6
		if (vm->GetEnv((void **)&env, JNI_VERSION_1_6) != JNI_OK) {
			 return -1;
		}
		JNINativeMethod nm[1];
		nm[0].name = "say";
		nm[0].signature = "(Ljava/lang/String;)V";
		nm[0].fnPtr = (void*)say_hello_world;
		//查找特定类
		jclass cls = env->FindClass("jni/HelloWorld");
		if (cls == NULL){
		    return JNI_ERR;
		}
		//注册本地方法
		if(env->RegisterNatives(cls, nm, 1)<0){
			return JNI_ERR;
		}
		//返回当前库文件要求的最低JDK版本
		return JNI_VERSION_1_6;
}
 
JNIEXPORT void JNICALL say_hello_world
  (JNIEnv * env, jclass arg, jstring instring)
 {
   //将java的String对象指向的字符串拷贝一份
   const jbyte *str =
        (const jbyte *)env->GetStringUTFChars(instring, JNI_FALSE);
   //打印字符串
    printf("Java_jni_HelloWorld_say->%s\n",str);
    //释放str指向的字符串内存
    env->ReleaseStringUTFChars(instring, (const char *)str);
    return;
 }
```
linux上JDK依赖的库文件在JAVA_HOME/jre/lib/amd64下，其中java这个库文件就是JDK中所有本地方法对应的库文件 libjava.so


