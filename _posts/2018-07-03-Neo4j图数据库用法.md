---
layout: post
categories: [Neo4j]
description: none
keywords: Neo4j
---
# Neo4j图数据库用法

## 图数据库基本使用
Cypher是Neo4J的声明式图形查询语言，允许用户不必编写图形结构的遍历代码，就可以对图形数据进行高效的查询。Cypher的设计目的类似SQL，适合于开发者以及在数据库上做点对点模式（ad-hoc）查询的专业操作人员。其具备的能力包括： - 创建、更新、删除节点和关系 - 通过模式匹配来查询和修改节点和关系 - 管理索引和约束等。

### 创建节点

格式：
```
create (Variable:Lable1:Lable2{Key1:Value1,Key2：Value2})
```
例如：
```
CREATE (n)  
CREATE (a),(b)
// 创建空节点

CREATE (n:Person)
CREATE (n:Person:Swedish)  ---(此为节点同时创建两个标签)
CREATE (n:西游:金箍棒{name:'如意金箍棒',title:'神兵'}) ---(举例)
// (注释:Person节点标签,Swedish节点标签 )

create (n:Person { name: 'Tom Hanks', born: 1956 }) return n;
//该结点标签为Preson（也就是这个结点的名字），结点有两个属性：name和born，属性所对的值分别为：‘Tom Hanks’和‘1956’.
```
关于return语句，创建结点后，没有return，界面上将不会出现创建的结点，只会显示有没有创建成功。

### 创建关系
语法结构：
```
StartNode-[Variable:RelationshipType{Key1:Value1,Key2:Value2}] -> EndNode
```
注：在创建关系的时候，需要指定关系类型。

- 创建没有任何属性的关系
```
match (a:Person),(b:Movie)
where a.name = 'Robert Zemeckis' AND b.title = 'Forrest Gump'  
//找到label分别为‘Person’和‘Movie’的两个结点，且a结点的属性name为'Robert Zemeckis'、b结点的属性
// name为'Forrest Gump'。找到后，用a表示Person这个结点，b表示Movie这个结点。
 
create (a)-[r:DIRECTED]->(b)
//创建a->b的一个关系，关系用变量r表示，DIRECTED表示关系的类型
 
return r;
//类似于可视化关系的意思
```

- 创建关系并设置关系的属性
```
match (a:Person),(b:Movie)
where a.name = 'Tom Hanks' AND b.title = 'Forrest Gump'
create (a)-[r:ACTED_IN { roles:['Forrest'] }]->(b)
return r;
```

### 查询结点
match：用于查询数据库；where：用于对查询语句进行约束。

- 查询整个数据库
```
match(n) return n;
```

- 查询born属性小于1955的结点
```
match(n) where n.born<1955 return n;
```

- 查询指定label的结点
```
match(n:movie) return n;
```

- 查询指定属性的结点
```
match(n{name:"Tom Thanks"}) return n;
```

### 查询关系
在Cypher中，关系分为三种：
- 符号"--"，表示有关系，忽略关系的类型和方向；
- 符号"-->"和"<--"表示有方向的关系。

- 查询跟指定结点有关系的结点
```
//查询所有跟Movie有关系的结点，并返回
match(n)--(m:Movie) 
return n;
```

- 查询有向关系的结点
```
match (n:Person { name: 'Tom Hanks' })-->(movie)
return n,movie;
```

- 获取关系类型
```
match (n:Person { name: 'Tom Hanks' })-[r]->(movie)
return r,type(r);
```

- 查询特定的关系类型
```
match (n:Person { name: 'Tom Hanks' })-[r:ACTED_IN{roles:['Forrest']}]->(movie)
return r,type(r);
```

### 更新图形
set：用于对更新结点的标签和实体的属性；

remove：用于移除实体的属性和结点的标签。

- 创建一个完整的Path
```
create p =(vic:Worker:Person{ name:'vic',title:"Developer" })-[:WORKS_AT]->(neo)<-[:WORKS_AT]-(michael:Worker:Person { name: 'Michael',title:"Manager" })
return p
```
neo结点没有任何属性，但是有一个ID值，可以通过ID值为neo结点设置属性和标签。

注意：由于Path是由节点和关系构成的，当路径中的关系或节点不存在时，Neo4j会自动创建。

- 通过ID为结点增加属性
```
match (n)
where id(n)=4
set n.name = 'neo'
return n;
```

- 通过ID为结点增加标签
```
match (n)
where id(n)=4
set n:Company
return n;
```

- 为关系增加属性
```
match (n)<-[r]-(m)
where id(n)=7 and id(m)=8
set r.team='Azure'
return r;
```

### Merge
通过merge匹配搜索结果
匹配模式：一个节点有Person标签，并且具有name属性；如果数据库不存在该模式，那么创建新的节点；如果存在该模式，那么绑定该节点；
```
merge (michael:Person { name: 'Michael Douglas' })
return michael;
```
merge 一个标签为：Person，属性name为：Michael Douglas的结点，因为数据库中没有该结点，所以创建一个满足上述条件的结点。即merge语句就相当于create和match语句。
```
merge (n:Person)
return n;
```
merge一个标签为：Person的结点，因为数据库中有标签为Person的结点，所以merge语句回返回所有标签为Person的结点。

- merge与on create
检查节点是否存在，如果不存在则创建它并设置属性。
```
merge (keanu:Person { name: 'Keanu Reeves' })
on create set keanu.created = timestamp()
return keanu.name, keanu.created
```

- merge与on match
匹配结点，并在找到的结点上设置属性。
```
merge (n:Person)
on match set n.found = TRUE , n.lastAccessed = timestamp()
return n,n.name, n.found, n.lastAccessed
```
该语句回匹配所有标签为Person的结点，并为这些结点设置found和lastAccessed两个属性。

- merge与on create、on match一起
```
merge (n:Person { name: 'Keanu Reeves' })
on create set n.created = timestamp()
on match set n.lastSeen = timestamp()
return n,n.name, n.created, n.lastSeen
```
相当于匹配一个标签为Person、name属性为Keanu Reeves的结点，然后为匹配到的结点的设置created、lastSeen这两个属性。

- merge与关系
```
match (n:Person)
merge (n)-[:WORKS_AT]->(m:Movie)
return n,m;
```
查找标签为Person的结点，merge (n)-[:WORKS_AT]->(m:Movie)，如果能找到标签为Person的结点指向标签为Movie的结点，且关系属性为WORKS_AT，就返回符合条件的path；否则创建。

- 与实体有关的函数

id()函数，返回结点或关系的ID
```
match (n:Company {name:'neo'})
return id(n);
```

```
match (n:Person {name:'vic'})-[r]->(m:Company)
return id(r);
```

type()函数，返回关系类型
```
match (n:Person {name:'vic'})-[r]->(m:Company)
return type(r);
```

label()函数，返回结点的标签
```
match (n:Person {name:'vic'})-[r]->(m:Company)
return labels(n);
```

### with的用法
把with后面结果集当成一个查询结果、在这个结果基础上再做where条件的筛选

比如下面这个语句：查询所有电影集、每个电影至少有8个以上的演员参演。
```
with o,count(r) as count_r，以这个为结果集、然后在此基础上筛选出count_r大于8的
```

### 查询节点多层关系语句
查询所有下级节点，包含c节点
```
MATCH (c:标签{键:"值"})-[r*0..]->(result) return result
```

查询所有下级节点，不包含c节点
```
MATCH (c:标签{键:"值"})-[r*1..]->(result) return result
```

遍历到第三层
```
MATCH (c:标签{键:"值"})-[r*3..]->(result) return result
```

向上遍历
```
MATCH (c:标签{键:"值"})<-[r*3..]-(result) return result
```
语法[r**0..2]是一个范围参数，用于指定距给定节点的最小和最大关系距离，关系类型为r。

### 查询两节点有效的路径
路径长度（5个节点之内），一般都会做限制，否则数据库一但内容过多就会卡死

- 所有路径（不准确）
最容易想到的就是这样写，但是结果是不准确的。
```
match p = (a)-[r*..5]-(b)
where a.name = '刘备' and b.name='刘禅'
return p
```

我们可以把每条路径中的节点名称抽取出来看看
```
match p = (a)-[r*..5]-(b)
where a.name = '刘备' and b.name='刘禅'
return extract(n in nodes(p)| n.name)
```
问题就是在一条路径(p)中，有重复人员的出现。那么解决方案就是，去掉路径(p)中有重复人员的路径(p)
```
// 相当于遍历nodes, 每得到一个node就在nodes中找一下他自己有几个，如果不等于1就不要了
and ALL( n1 in nodes(p) where size(filter(n2 in nodes(p) where id(n1) = id(n2)))=1 )
// 新版本neo4j 不支持fliter函数 用[]代替
and ALL( n1 in nodes(p) where size([n2 in nodes(p) where id(n1) = id(n2)])=1 )
```

最终方案
```
match p = (a)-[r*..5]-(b)
where a.name = '刘备' and b.name='刘禅'
and ALL( n1 in nodes(p) where size(filter(n2 in nodes(p) where id(n1) = id(n2)))=1 )
return p
 
// 新版
match p = (a)-[r*..5]-(b) 
where a.name = '刘备' and b.name='刘禅' 
and ALL( n1 in nodes(p) where size([n2 in nodes(p) where id(n1) = id(n2)])=1 ) 
return p
```





## 删除数据
如果数据库中的数据量并不大，节点数相对较少，我们可以通过命令行直接删除节点。此类操作起到清空数据库的效果，但是不会删除数据库

这里列举两种常用的删除数据的用法：
- 删除对应节点及其所有关系。也就是说，只要符合键值对 { property-name：value } 条件的节点都会被删除
```
match (n {<property-name>:<value>} ) detach delete (n)
```
示例：
```text
//创建节点
merge(t:Test{id:01,name:"hh"})
merge(t:test{id:02,name:"hh"})

//name为hh的两个节点及其关系都会删除
match (n{name:"hh"}) detach delete (n)
```
- 删除所有节点及其所有关系
此命令不用筛选条件，直接将数据库中的所有节点及关系全部删除
```
match (n) detach delete (n)
```
删除数据库
如果数据库中的数据量很大，节点数非常多，通过命令行删除会比较慢，那么我们可以通过物理方式直接删除数据库。 此类操作直接删除了数据库，数据当然都被清空了
首先，我们需要关闭 Neo4j 数据库的运行。然后找到 Neo4j 数据库的存放目录，也就是 <NEO4J_HOME>/data/ 。 如果忘记了 NEO4J_HOME 可以去环境变量中查看
- 3.x版
Neo4j 的 3.x 版本下有一个 databases 文件夹，进入这个文件夹，里面有一个 graph.db 的文件夹和一个 store_lock 文件。 这个 graph.db 文件夹就是我们当前使用的数据库，直接删除即可。
- 4.x版
Neo4j 的 4.x 版本下有一个 databases 文件夹和一个 transactions 文件夹，两个文件夹下都有 graph.db。 我们将这两个文件夹下的 graph.db 都删除即可。

