---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL记录格式
关于物理记录的存储格式，以便更好地理解InnoDB在页面内对物理记录的管理方法。

## 页面格式
InnoDB将数据划分为若干页，以页作为磁盘与内存交互的基本单位，一般页的大小为16KB。这样的话，一次性至少读取1页数据到内存中或者将1页数据写入磁盘。通过减少内存与磁盘的交互次数，从而提升性能。

这一种典型的缓存设计思想，一般缓存的设计基本都是从时间维度或者空间维度进行考量的：
- 时间维度：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为热点数据缓存都属于这种思路的实现。
- 空间维度：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。InnoDB的数据页和操作系统的页缓存则是这种思路的体现。

## 行格式
MySQL是以记录(一行数据)为单位向数据表中插入数据的，这些记录在磁盘上的存放方式称为行格式。

MySQL支持的4种行格式：
- Compact
- Redundant（比较老，本文就不具体介绍了）
- Dynamic
- Compressed

指定行格式
```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```
下面来说一说各个行格式的区别

## 从源码入手了解行格式
在MySQL中，行格式有三种存储方式，如下。
- Server层的格式，这种格式与存储引擎没有关系，即适用于所有存储引擎的格式，这种格式是操作数据时必然要经过的一种格式，也是Row模式下Binlog存储所使用的一种格式。
- 索引元组格式，这种格式是InnoDB存储引擎在存取记录时一种记录格式的中间状态，它要么是从Server层格式转换而来，要么是转换为Server层的格式。它是InnoDB在内存中存储的一种元组格式，也是内存中的一种用来存储所有列数据的数据结构，同一个表中，不同索引对应的元组是不同的，这种元组格式是与索引一一对应的。
- 物理存储记录格式，这种格式就是本节要重点介绍的一条记录在物理页面中的存储格式，即所谓的Compact格式。这种格式与上面的索引元组格式是一一对应的，每次存取，都是从Server层格式先转换为索引元组格式，然后再转换为在页面上的索引记录物理格式。而取数据也是一样，从索引页面中的物理格式转换为索引的元组格式，然后再转换为Server层格式，再做进一步处理。

### Innodb行格式
Innodb行格式有四种：redundant、compact、compressed、dynamic，参考源码：rem0types.h/rec_format_enum。其中redundant为旧格式，compact、compressed、dynamic为新格式，新旧格式在记录存储格式上差异较大。接来下会详细介绍不同格式下记录的存储方式。

compact & compressed & dynamic
Compressed和Dynamic是Compact的变种形式。他们基本没什么本质上的区别，唯一的区别就是对于行溢出的处理不同。Compressed在数据页只存储一个指向溢出页的地址，所有的实际数据都存放在溢出页中。

而Compressed还可以是zlib算法对行数据进行压缩，因此对于BLOB，TEXT，VARCHAR这类大长度类型的数据能够非常有效的存储
```
/* REC_ANTELOPE_MAX_INDEX_COL_LEN is measured in bytes and is the maximum
indexed field length (or indexed prefix length) for indexes on tables of
ROW_FORMAT=REDUNDANT and ROW_FORMAT=COMPACT format.
Before we support UTF-8 encodings with mbmaxlen = 4, a UTF-8 character
may take at most 3 bytes.  So the limit was set to 3*256, so that one
can create a column prefix index on 256 characters of a TEXT or VARCHAR
column also in the UTF-8 charset.
This constant MUST NOT BE CHANGED, or the compatibility of InnoDB data
files would be at risk! */
#define REC_ANTELOPE_MAX_INDEX_COL_LEN		768

/** Maximum indexed field length for table format UNIV_FORMAT_B and
beyond.
This (3072) is the maximum index row length allowed, so we cannot create index
prefix column longer than that. */
#define REC_VERSION_56_MAX_INDEX_COL_LEN	3072

/** Innodb row types are a subset of the MySQL global enum row_type.
They are made into their own enum so that switch statements can account
for each of them. */
enum rec_format_enum {
	REC_FORMAT_REDUNDANT	= 0,	/*!< REDUNDANT row format */
	REC_FORMAT_COMPACT	= 1,	/*!< COMPACT row format */
	REC_FORMAT_COMPRESSED	= 2,	/*!< COMPRESSED row format */
	REC_FORMAT_DYNAMIC	= 3	/*!< DYNAMIC row format */
};
```
本文的讨论中我们默认使用Compact格式。在文件rem/rem0rec.cc的头部注释描述了记录的物理结构。

每个记录都存在rec header，描述如下（参阅文件include/rem0rec.ic）
```
/*			PHYSICAL RECORD (NEW STYLE)
			===========================

The physical record, which is the data type of all the records
found in index pages of the database, has the following format
(lower addresses and more significant bits inside a byte are below
represented on a higher text line):

| length of the last non-null variable-length field of data:
  if the maximum length is 255, one byte; otherwise,
  0xxxxxxx (one byte, length=0..127), or 1exxxxxxxxxxxxxx (two bytes,
  length=128..16383, extern storage flag) |
...
| length of first variable-length field of data |
| SQL-null flags (1 bit per nullable field), padded to full bytes |
| 4 bits used to delete mark a record, and mark a predefined
  minimum record in alphabetical order |
| 4 bits giving the number of records owned by this record
  (this term is explained in page0page.h) |
| 13 bits giving the order number of this record in the
  heap of the index page |
| 3 bits record type: 000=conventional, 001=node pointer (inside B-tree),
  010=infimum, 011=supremum, 1xx=reserved |
| two bytes giving a relative pointer to the next record in the page |
ORIGIN of the record
| first field of data |
...
| last field of data |

The origin of the record is the start address of the first field
of data. The offsets are given relative to the origin.
The offsets of the data fields are stored in an inverted
order because then the offset of the first fields are near the
origin, giving maybe a better processor cache hit rate in searches.

The offsets of the data fields are given as one-byte
(if there are less than 127 bytes of data in the record)
or two-byte unsigned integers. The most significant bit
is not part of the offset, instead it indicates the SQL-null
if the bit is set to 1. */

/* CANONICAL COORDINATES. A record can be seen as a single
string of 'characters' in the following way: catenate the bytes
in each field, in the order of fields. An SQL-null field
is taken to be an empty sequence of bytes. Then after
the position of each field insert in the string
the 'character' <FIELD-END>, except that after an SQL-null field
insert <NULL-FIELD-END>. Now the ordinal position of each
byte in this canonical string is its canonical coordinate.
So, for the record ("AA", SQL-NULL, "BB", ""), the canonical
string is "AA<FIELD_END><NULL-FIELD-END>BB<FIELD-END><FIELD-END>".
We identify prefixes (= initial segments) of a record
with prefixes of the canonical string. The canonical
length of the prefix is the length of the corresponding
prefix of the canonical string. The canonical length of
a record is the length of its canonical string.

For example, the maximal common prefix of records
("AA", SQL-NULL, "BB", "C") and ("AA", SQL-NULL, "B", "C")
is "AA<FIELD-END><NULL-FIELD-END>B", and its canonical
length is 5.

A complete-field prefix of a record is a prefix which ends at the
end of some field (containing also <FIELD-END>).
A record is a complete-field prefix of another record, if
the corresponding canonical strings have the same property. */
```

## COMPACT行格式
一行数据被分为了两个部分，一部分是记录的额外信息，一部分是记录的真实数据。

### 记录额外信息
变长字段字节数列表
varchar(X)和char(X)的区别是什么，相信大家都非常清楚，char是定长的，varchar是变长的，变长字段中存储多少字节的数据不是固定的，所以InnoDB在存储数据的时候，会把这些数据占用的真实字节数也保存下来，也就是变长字段是占用了两部分空间来存储的：
- 真实的数据内容
- 占用的字节数
在COMPACT行格式中，把所有的变长字段所占用的字节数逆序排放在变长字段字节数列表中。

我们先前创建了一张表，还准备了两条数据，现在我们来看下第一条数据中的变长字段字节数列表是什么酱紫的。

表中有四个字段，其中x，y，t三个字段都是变长字段，所以这三个字段的字节数需要保存在变长字段字节数列表，数据表采用的字符集是ascii，所以每一个字符占用的字节数是1，下面我们来看下第一条数据各个变长字段所占用的字节数：

由于数据的长度都比较小，用一个字节就可以表示，但是如果变长字段占用的字节数比较多，就要用两个字节来表示了，到底使用一个字节来表示，还是用两个字节来表示，InnoDB有着自己的一套规则。在说这个规则之前，要先说明下规则中用到的三个变量：

W：指定字符集下，一个字符最多需要占用的字节数。比如，ascii字符集的W是1，GBK字符集的W是2，utf-8字符集的W是3。
M：最多可以存储多少个字符，varchar(50)的M就是50。
L：实际存储字符占用了多少字节。
W*M：指定字段类型、字符集下，存储的字符串最多占用的字节数。

下面就是规则了：

如果M*W<=255，那么用一个字节表示字符串所占用的字节数。
如果M*W>255，则分为两种情况：
2.1 如果L<=127，则用一个字节来表示字符串所占用的字节数。
2.2 如果L>127，则用两个字节来表示字符串所占用的字节数。
光看规则是不是觉得很绕，总结一下，该可变字段允许存储的最大字节数(W*M)>255，且真实存储的字节数(L)超过127，就用两个字节来表示字符串所占用的字节数，否则用一个字节来表示字符串所占用的字节数。

我们建的表采用的字符集是ascii编码的，一个字符所占用的字节固定是1，如果我们采用utf-8字符集，一个字段所占用的字节就不是固定的了，而是一个范围：1-3，所以如果我们采用这样的字符集，char(m)虽然是定长字段，但是也会被加入到变长字段字节数列表中。

## NULL值列表
我待过一家公司，对表设计有非常明确的规定，其中有一条是任何字段都不允许为NULL，问原因，DBA只是淡淡的说了句，允许为NULL会额外占用一些空间。我也没有继续追究下去，就按照规定来呗。下面我就来揭秘为什么会有这个蛋疼的规定。

如果表中有字段允许为NULL，InnoDB就会开辟一块空间来标识每个字段实际存储的数据是不是为NULL，如果表中的字段都不允许为NULL，那么这块空间就不复存在了。

那么InnoDB开辟出来的那块空间具体是怎么回事呢，接下去往下看。

每个允许存储为NULL的字段对应一个二进制位：

如果字段实际存储的数据不为NULL，二进制是0。
如果字段实际存储的数据是NULL，二进制是1。
这里和变长字段字节数列表是一样的，是逆序排放的。

我们新建的hero表有三个字段都允许为NULL，所以存在NULL值列表。

## 记录头信息
记录头信息中包含的内容很多，我先随便列举几条：

delete_mask ：标识此条数据是否被删除。
next_record：下一条数据的位置。
record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录
...
还有其他的，或者更具体的解释等以后用到了再说吧。

## 记录真实数据
对于hero表来说，记录真实数据部分除了我们定义的四个字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。

row_id
如果我们建表的时候指定了主键或者唯一约束列，那么就没有row_id隐藏字段了。如果既没有指定主键，又没有唯一约束，那么InnoDB就会为记录添加row_id隐藏字段。row_id不是必需的，占用6个字节。

trx_id
事务Id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用6个字节。

roll_pointer
这条数据上一个版本的指针。roll_pointer是必需的，占用7个字节。

## 源码
可以通过一个最普遍的插入操作来跟踪InnoDB的记录格式，因为在插入时，系统接收到的是公共的MySQL记录格式record（即Server层格式），它没有涉及任何存储引擎，也就是说不管当前这个表对应的存储引擎是什么，记录格式是一样的。对于插入，MySQL函数对应的是ha_w rite_row，具体到InnoDB存储引擎，实际调用的函数是ha_innobase::w rite_row。在这里，InnoDB首先会将接收到的record记录转换为自己的一个元组tuple（索引元组格式），这其实是与record对应的InnoDB的表示方式，它是一个内存的、逻辑的记录，在系统将其真正地写入到页面之前，这条记录的存在方式都是这个tuple。

下面主要从源码的角度来研究InnoDB如何将一个tuple转换为它的物理存储记录，主要研究代码的实现逻辑及记录的格式。

在某一个页面插入一个元组（一条记录），实现这个操作的函数是page_cur_tuple_insert，它的参数就是一个dtuple_t*类型的tuple。在这里，它首先要分配一片空间来存储将要转换过来的物理记录，所以，这里需要先计算空间的大小，计算方法如下。

•首先，每条记录都包括下面两部分：REC_N_NEW_EXTRA_BYTES+UT_BITS_IN_BYTES (n_null)，前面表示的是这种格式固定长度的extra部分，这部分用来存储的内容在后面会给出；后面表示的是所有字段中哪些字段的值是null，当然这里只存储那些nullable属性的字段，如果创建表的时候指定为notnull的话，就不会被存储，此处是用一个位来表示一个字段的null属性。这部分被系统代码命名为extra_size变量值。

•统计每一个列中数据的长度，在统计这个信息的时候，又有多种情况，主要分定长字段和变长字段。对于定长字段而言，它的长度直接就是数据类型的长度，比如int类型的就是4个字节、rowid列就是6个字节等，没有其他附加长度；对于变长字段而言，除了数据内容本身的长度外，还需要计算其数据长度的存储空间。且如果变长字段的字义长度大于255个字节，或者字段的数据类型为BLOB，就需要用2个字节来存储这个字段的长度；如果定义长度小于128个字节，或者小于256个字节且类型不是BLOB类型，那么这个字段的数据长度用一个字节来存储，除了上面2种情况之外，都用2个字节来存储。在这一部分中，用来存储变长字段数据长度的空间大小也被InnoDB计算到extra_size中。

所以现在可以知道，一个InnoDB的记录包括两部分，一部分是extra_size，另一部分是数据内容，这2部分的总长度就是上面计算出来的结果，这里把它定义为record_size。

接下来，申请空间，进行元组到物理存储记录的转换工作。

转换函数为rec_convert_dtuple_to_rec_new，参数有申请好的记录空间buf、元组和索引的内存结构。源码如下。

在上面的代码中，可以看到有一行操作是rec=buf+extra_size，变量rec表示的是数据内容（列数据）存储的开始位置，extra_size就是上面计算方法中所说的extra_size。

那么，真正执行转换的是接下来调用的rec_convert_dtuple_to_rec_comp函数，下面是精简之后的代码。










































































































