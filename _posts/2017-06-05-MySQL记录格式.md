---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL记录格式
关于物理记录的存储格式，以便更好地理解InnoDB在页面内对物理记录的管理方法。

## 页面格式
关于页面格式，我们平常也会接触到，比如通过一条简单的命令，就可以看到创建的表使用的是什么类型的格式，如下。

可以看到，第四列Row_format中对应的就是当前表使用的行格式存储类型。目前用得比较多的存储格式就是Compact，这是InnoDB从MySQL 5.0版本中引入的，从名字可以看出，这是一种紧凑的、可以节省空间的格式。一般而言，对于B+树方式的存储，一个页面存储越多的数据，一次IO就可以处理越多的记录，性能就会越高。所以，这里只介绍Compact类型的记录格式。

## 从源码入手了解行格式
在MySQL中，行格式有三种存储方式，如下。
- Server层的格式，这种格式与存储引擎没有关系，即适用于所有存储引擎的格式，这种格式是操作数据时必然要经过的一种格式，也是Row模式下Binlog存储所使用的一种格式。
- 索引元组格式，这种格式是InnoDB存储引擎在存取记录时一种记录格式的中间状态，它要么是从Server层格式转换而来，要么是转换为Server层的格式。它是InnoDB在内存中存储的一种元组格式，也是内存中的一种用来存储所有列数据的数据结构，同一个表中，不同索引对应的元组是不同的，这种元组格式是与索引一一对应的。
- 物理存储记录格式，这种格式就是本节要重点介绍的一条记录在物理页面中的存储格式，即所谓的Compact格式。这种格式与上面的索引元组格式是一一对应的，每次存取，都是从Server层格式先转换为索引元组格式，然后再转换为在页面上的索引记录物理格式。而取数据也是一样，从索引页面中的物理格式转换为索引的元组格式，然后再转换为Server层格式，再做进一步处理。

可以通过一个最普遍的插入操作来跟踪InnoDB的记录格式，因为在插入时，系统接收到的是公共的MySQL记录格式record（即Server层格式），它没有涉及任何存储引擎，也就是说不管当前这个表对应的存储引擎是什么，记录格式是一样的。对于插入，MySQL函数对应的是ha_w rite_row，具体到InnoDB存储引擎，实际调用的函数是ha_innobase::w rite_row。在这里，InnoDB首先会将接收到的record记录转换为自己的一个元组tuple（索引元组格式），这其实是与record对应的InnoDB的表示方式，它是一个内存的、逻辑的记录，在系统将其真正地写入到页面之前，这条记录的存在方式都是这个tuple。

下面主要从源码的角度来研究InnoDB如何将一个tuple转换为它的物理存储记录，主要研究代码的实现逻辑及记录的格式。

在某一个页面插入一个元组（一条记录），实现这个操作的函数是page_cur_tuple_insert，它的参数就是一个dtuple_t*类型的tuple。在这里，它首先要分配一片空间来存储将要转换过来的物理记录，所以，这里需要先计算空间的大小，计算方法如下。

•首先，每条记录都包括下面两部分：REC_N_NEW_EXTRA_BYTES+UT_BITS_IN_BYTES (n_null)，前面表示的是这种格式固定长度的extra部分，这部分用来存储的内容在后面会给出；后面表示的是所有字段中哪些字段的值是null，当然这里只存储那些nullable属性的字段，如果创建表的时候指定为notnull的话，就不会被存储，此处是用一个位来表示一个字段的null属性。这部分被系统代码命名为extra_size变量值。

•统计每一个列中数据的长度，在统计这个信息的时候，又有多种情况，主要分定长字段和变长字段。对于定长字段而言，它的长度直接就是数据类型的长度，比如int类型的就是4个字节、rowid列就是6个字节等，没有其他附加长度；对于变长字段而言，除了数据内容本身的长度外，还需要计算其数据长度的存储空间。且如果变长字段的字义长度大于255个字节，或者字段的数据类型为BLOB，就需要用2个字节来存储这个字段的长度；如果定义长度小于128个字节，或者小于256个字节且类型不是BLOB类型，那么这个字段的数据长度用一个字节来存储，除了上面2种情况之外，都用2个字节来存储。在这一部分中，用来存储变长字段数据长度的空间大小也被InnoDB计算到extra_size中。

所以现在可以知道，一个InnoDB的记录包括两部分，一部分是extra_size，另一部分是数据内容，这2部分的总长度就是上面计算出来的结果，这里把它定义为record_size。

接下来，申请空间，进行元组到物理存储记录的转换工作。

转换函数为rec_convert_dtuple_to_rec_new，参数有申请好的记录空间buf、元组和索引的内存结构。源码如下。

在上面的代码中，可以看到有一行操作是rec=buf+extra_size，变量rec表示的是数据内容（列数据）存储的开始位置，extra_size就是上面计算方法中所说的extra_size。

那么，真正执行转换的是接下来调用的rec_convert_dtuple_to_rec_comp函数，下面是精简之后的代码。










































































































