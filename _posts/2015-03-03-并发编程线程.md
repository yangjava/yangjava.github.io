---
layout: post
categories: [JUC]
description: none
keywords: JUC
---
# 并发编程线程
在引入线程的操作系统中,线程是进程中的一个实体,是CPU调度和分派的基本单位。

## 线程的实现方式
现代操作系统中一般不止一个线程在运行，当启动了一个Java虚拟机（JVM）时，从操作系统开始就会创建一个新的进程（JVM进程），JVM进程中将会派生或者创建很多线程。

- 继承 `Thread` 类。
- 实现 `Runnable` 接口
- 使用匿名内部类创建线程
- 使用 `Callable` 和 `Future` 接口创建线程

实现 `Runnable` 和 `Callable` 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。

### 继承Thread类创建线程类
- 定义Thread类的子类，并重写该类的run方法，因为 Thread 类也实现了 Runable 接口。该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
- 创建Thread子类的实例，即创建了线程对象。
- 调用线程对象的start()方法来启动该线程。当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。

示例代码如下：
```
public class Main {

    public static void main(String[] args) {
        // 创建Thread子类的实例，即创建了线程对象。
        ThreadExtends threadExtends = new ThreadExtends();
        // 调用线程对象的start()方法来启动该线程。
        threadExtends.start();
        System.out.println(Thread.currentThread().getName());
    }

}

/**
 * 定义Thread类的子类，并重写该类的run方法，因为 Thread 类也实现了 Runnable 接口。
 */
class ThreadExtends extends Thread {
    @Override
    public void run() {
        for (int i = 0; i <= 5; i++) {
            System.out.println(this.getName() + ":" + i);
        }
    }
}
```
在main函数里面创建了一个Thread类的子类的实例，然后调用该实例的start方法启动了线程。需要注意的是，当创建完thread对象后该线程并没有被启动执行，直到调用了start方法后才真正启动了线程。

其实调用start方法后线程并没有马上执行而是处于就绪状态，这个就绪状态是指该线程已经获取了除CPU资源外的其他资源，等待获取CPU资源后才会真正处于运行状态。一旦run方法执行完毕，该线程就处于终止状态。

不能通过Thread实现类对象的run()去启动一个线程，此时只是主线程调用方法而已，并没有启动线程，要启动线程，必须通过Start()方法

一个线程只能够执行一次start()，start()中会判断threadStatus的状态是否为0，不为0则抛出异常，所以一个线程调用两次start()会报异常
```
        threadExtends.start();
        threadExtends.start();
        
Exception in thread "main" java.lang.IllegalThreadStateException
	at java.lang.Thread.start(Thread.java:708)
	at com.demo.Main.main(Main.java:12)
```
使用继承方式的好处是，在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread()方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码，而Runable则没有这个限制。

### 实现Runnable接口
需要实现 run() 方法。 通过 Thread 调用 start() 方法来启动线程。
- Runnable接口应由任何类实现，其实例将由线程执行。 该类必须定义一个无参数的方法，称为run 。
- 该接口旨在为希望在活动时执行代码的对象提供一个通用协议。此类整个只有一个 run() 抽象方法

```
package com.concurrency.thread;

/**
 * 步骤：1、定义一个线程类 A 实现于 java.lang.Runnable 接口（注意：A类不是线程类,没有 start()方法，不能直接 new A 的实例启动线程）
 * 　　　2、在 A 类中覆盖 Runnable 接口的 run() 方法
 * 　　　3、在 run() 方法中编写需要执行的操作
 * 　　　4、在 main 方法（线程）中，创建线程对象，并启动线程
 * 　　　　　　创建线程类：Thread t = new Thread( new A类() ) ；
 * 　　　　　　调用 start() 方法启动线程：t.start();
 */
public class ThreadInterface {

    public static void main(String [] args){
        //此程序存在线程的安全问题，打印车票时，会出现重票、错票，后面线程同步会讲到
        Window window=new Window();
        Thread thread1=new Thread(window,"窗口一");
        Thread thread2=new Thread(window,"窗口二");
        Thread thread3=new Thread(window,"窗口三");
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
class Window implements  Runnable{
    int ticket=10;
    @Override
    public void run(){
        while (true){
            if(ticket > 0){
                try {
                    Thread.currentThread().sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"售票，票号为："+ticket--);
            }else {
                break;
            }
        }
    }
}

```
哪个方式好？实现的方式优于继承的方式
- 避免java单继承的局限性
- 如果多个线程要操作同一份资源，更适合使用实现的方式

### 使用匿名内部类创建线程

```
public static void main(String[] args) {
    for(int i = 0 ; i < 10 ; i++){
        System.out.println("玩游戏"+i);
        if(i==5){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    for(int i = 0 ; i < 10 ;i++){
                        System.out.println("播放音乐"+i);
                    }
                }
            }).start();
        }
    }
}
```

### 使用Callable和Future接口创建线程
使用Callable和Future接口创建线程。 与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

```
public class ThreadTest {
    public static void main(String[] args) {
        Callable<Integer> myCallable = new MyCallable();    // 创建MyCallable对象
        FutureTask<Integer> ft = new FutureTask<Integer>(myCallable); //使用FutureTask来包装MyCallable对象
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
            if (i == 30) {
                Thread thread = new Thread(ft);   //FutureTask对象作为Thread对象的target创建新的线程
                thread.start();                      //线程进入到就绪状态
            }
        }
        System.out.println("主线程for循环执行完毕..");
        try {
            int sum = ft.get();            //取得新创建的新线程中的call()方法返回的结果
            System.out.println("sum = " + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class MyCallable implements Callable<Integer> {
    private int i = 0;

    // 与run()方法不同的是，call()方法具有返回值
    @Override
    public Integer call() {
        int sum = 0;
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
            sum += i;
        }
        return sum;
    }
}
```
如上代码中的MyCallable类实现了Callable接口的call()方法。在main函数内首先创建了一个FutrueTask对象（构造函数为CallerTask的实例），然后使用创建的FutrueTask对象作为任务创建了一个线程并且启动它，最后通过 futureTask.get()等待任务执行完毕并返回结果。

### 实现接口 VS 继承 Thread

实现接口会更好一些，因为:

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。

## 线程的生命周期
Java 语言中线程有六种状态，这些状态定义在Thread.State枚举类中：
- NEW 初始状态
- RUNNABLE 可运行状态/运行状态
- BLOCKED 阻塞状态
- WAITING 无时限等待
- TIMED_WAITING 有时限等待
- TERMINATED 终止状态

这看上去挺复杂，状态类型也比较多，但其实在操作系统层面，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。 也就是说，只要Java 线程处于这三种状态之一，那么这个线程就永远没有CPU 的使用权。

### NEW(初始状态)
新建状态（New）：当我们创建一个新的线程实例时，线程就处于新建状态。这时候线程的start()方法还未被调用，线程对象还未开始执行。在这个状态下，Java虚拟机（JVM）已经为此线程分配了必要的内存。

使用 new 创建一个线程，仅仅只是在堆中分配了内存空间。新建状态下，线程还没有调用 start()方法启动，只是存在一个线程对象而已。

示例如下:
````
Thread t = new Thread(); // 线程此时处于New状态
````

### RUNNABLE(可运行状态/运行状态)
就绪状态（Runnable）：当线程对象调用了start()方法后，该线程就处于就绪状态。就绪状态的线程在获得CPU时间片后就可以开始运行。这个状态的线程位于可运行线程池中，等待被线程调度选中，获得CPU的使用权。
```
t.start(); // 线程此时处于Runnable状态
```

运行状态（Running）：线程获取到CPU时间片后，就进入运行状态，开始执行run()方法中的代码。值得注意的是，代码执行的实际速度和效率与处理器的速度以及多核处理器的核数有关。
```
public void run() {
    System.out.println("Thread is running.");
}
// 如果此时这个方法正在执行，那么线程就处于Running状态
```

### BLOCKED(阻塞状态) 
阻塞状态（Blocked）：当一个线程试图获取一个内部的对象锁（也就是进入一个synchronized块），而该锁被其他线程持有，则该线程进入阻塞状态。阻塞状态的线程在锁被释放时，将会进入就绪状态。

正在运行的线程因为某种原因放弃 CPU，暂时停止运行，就会进入阻塞状态。此时 JVM 不会给线程分配 CPU，知道线程重新进入就绪状态，才有机会转到 运行状态。
```
synchronized(object) {
    // 如果此时object的锁被其他线程持有，那么线程就处于Blocked状态
}
```
注意：阻塞状态只能先进入就绪状态，不能直接进入运行状态

### WAITING(无时限等待)
等待状态（Waiting）：线程通过调用其自身的wait()方法、join()方法或LockSupport.park()方法，或者通过调用其他线程的join()方法，可以进入等待状态。在等待状态的线程不会被分配CPU时间片，它们只能通过被其他线程显式唤醒进入就绪状态。
```
t.wait();  // 线程此时处于Waiting状态
t.join();  // 线程此时处于Waiting状态
```

| 进入方法                              | 退出方法                                 |
|-----------------------------------|--------------------------------------|
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                           |
| LockSupport.park() 方法             | -                                    |


### TIMED_WAITING(有时限等待) 
超时等待状态（Timed Waiting）：当线程调用了sleep(long ms)，wait(long ms)，join(long ms)，或者LockSupport.parkNanos(), LockSupport.parkUntil()等具有指定等待时间的方法，线程就会进入超时等待状态。当超时时间到达后，线程会自动返回到就绪状态。
```
Thread.sleep(1000); // 线程此时处于Timed Waiting状态
```

睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。

| 进入方法                             | 退出方法                                        |
|----------------------------------|---------------------------------------------|
| Thread.sleep() 方法                | 时间结束                                        |
| 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll() |
| 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕                           |
| LockSupport.parkNanos() 方法       | -                                           |
| LockSupport.parkUntil() 方法       | -                                           |

### TERMINATED(终止状态)
终止状态（Terminated）：当线程的run()方法执行完毕，或者线程中断，线程就会进入终止状态。在这个状态下，线程已经完成了它的全部工作。
```
// 当run()方法执行完毕，线程处于Terminated状态
public void run() {
    System.out.println("Thread is running.");
}
```
- 正常终止，执行完 run() 方法，正常结束
- 强制终止，如调用 stop() 方法或 destory() 方法
- 异常终止，执行过程中发生异常

这些状态之间的转换，通过各种方法的调用来实现。接下来我们将看到这些状态转换的具体情况。
## 线程状态转换
线程状态的转换是非常重要的一部分，了解状态之间的转换有助于我们更好地理解和掌握线程的行为。下面，我们来看看Java中各种线程状态的转换情况。

### 新建状态转就绪状态(从 NEW 到 RUNNABLE 状态)
当线程对象被创建后，其进入新建状态。此时，通过调用线程对象的start()方法，可以让线程进入就绪状态，等待系统的线程调度器进行调度。
```
Thread t = new Thread(); // 新建状态
t.start(); // 调用start()方法，线程进入就绪状态
```
Java 刚创建出来的Thread 就是NEW 状态的。NEW 状态的线程，不会被操作系统调度，因此不会被执行。Java 线程要执行，就必须转换到RUNNABLE 状态，从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start() 方法就可以了 。

### 就绪状态转运行状态
线程调度器从就绪队列中选择一个线程，分配给它CPU资源，这个线程就由就绪状态变为运行状态。

### 运行状态转就绪状态
当一个运行状态的线程调用了yield()方法，或者该线程的运行时间超过了系统规定的时间片，线程就会释放CPU资源，自己由运行状态变回就绪状态，重新等待系统调度。
```
Thread.yield(); // 调用yield()方法，线程从运行状态进入就绪状态
```

### 运行状态转阻塞状态
当一个运行状态的线程试图获取一个被其他线程持有的对象锁时，该线程就会进入阻塞状态。
```
synchronized(object) {
// 如果此时object的锁被其他线程持有，那么线程就从运行状态进入阻塞状态
}
```
只有一种场景会触发这种转换，就是线程等待synchronized 的隐式锁。synchronized 修饰的代码块、方法同一时刻只能有一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从RUNNABLE 转换到 BLOCKED 状态。 而当等待的线程获取到了synchronized 的隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。

如果你熟悉操作系统生命周期的话，可能会有个疑问：线程调用阻塞API 时，是否会转换到BLOCKED 状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在JVM 层面，Java 线程的状态不会发生变化，也就是说 Java 线程的状态会依然保持 RUNNABLE 状态。 JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。

而我们平时所谓的Java 在调用阻塞式 API 时， 线程会阻塞，指的是操作系统线程的状态，并不是Java 线程的状态。

### 阻塞状态转就绪状态
当一个阻塞状态的线程获取到了被其他线程释放的对象锁，该线程就由阻塞状态变为就绪状态，重新等待系统调度。

### 运行状态转等待状态
当一个运行状态的线程调用了wait()，join()或LockSupport.park()方法时，该线程就会进入等待状态。等待状态的线程需要依赖其他线程的通知才能够返回到就绪状态。
```
t.wait(); // 调用wait()方法，线程从运行状态进入等待状态
t.join(); // 调用join()方法，线程从运行状态进入等待状态
```
- 获得synchronized 隐式锁的线程，调用无参数的Object.wait()方法。
- 调用无参数的 Thread.join() 方法。其中的 join() 是一种线程同步方法，例如有一个线程对象 thread A，当调用 A.join() 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。
- 调用 LockSupport.park() 方法。 其中的 LockSupport 对象，也许你有点陌生，其实 Java 并发包中的锁，都是基于它实现的。调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。

### 等待状态转就绪状态
当一个等待状态的线程被其他线程调用notify()或notifyAll()唤醒，或者被其他线程中断，或者等待的时间到期，该线程就由等待状态转为就绪状态。
```
t.notify(); // notify()方法被调用，线程从等待状态进入就绪状态
```

### 运行状态转超时等待状态(RUNNABLE 与 TIMED_WAITING 的状态转换)
当一个运行状态的线程调用了具有超时参数的sleep()，wait()，join()，或LockSupport.parkNanos()，LockSupport.parkUntil()方法时，该线程就会进入超时等待状态。
```
Thread.sleep(1000); // 调用sleep()方法，线程从运行状态进入超时等待状态
```
- 调用带有超时参数的Thread.sleep(long millis) 方法；
- 获得synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法；
- 调用带超时参数的 Thread.join(long millis) 方法；
- 调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；
- 调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。
- 超时等待状态转就绪状态
当一个超时等待状态的线程等待的时间到期，或者被其他线程唤醒或中断，该线程就由超时等待状态转为就绪状态。

### 任何状态转终止状态
当线程完成任务或者因异常退出时，就会进入终止状态。

通过了解以上线程的状态转换，可以更加深入理解线程的运行机制，为多线程编程提供理论基础。

## 线程生命周期示例
下面的Java代码实例演示了一个线程从创建到终止的整个过程：
```
// 创建一个继承了Thread类的ExampleThread类
class ExampleThread extends Thread {
    private Object lock; // 创建一个私有的Object对象，它将在同步代码块中被使用作为锁

    // 构造函数，接受一个Object类型的参数
    public ExampleThread(Object lock) {
        this.lock = lock; // 将传入的对象赋值给lock
    }

    // 重写Thread类的run方法
    @Override
    public void run() {
        // 同步代码块，只有获取到lock对象的锁才能执行
        synchronized(lock) {
            try {
                // 输出线程名和状态
                System.out.println(Thread.currentThread().getName() + " is running");
                // 让线程睡眠1秒，此时线程进入TIMED_WAITING状态
                Thread.sleep(1000);

                // 输出线程名和状态
                System.out.println(Thread.currentThread().getName() + " is waiting");
                // 调用wait()方法，线程释放lock锁，进入WAITING状态
                lock.wait();

                // 线程被唤醒，获取到lock锁，输出线程名和状态
                System.out.println(Thread.currentThread().getName() + " is running again");
            } catch (InterruptedException e) {
                // 线程被中断，输出线程名和状态，然后线程将结束
                System.out.println(Thread.currentThread().getName() + " is interrupted and will terminate");
            }
        }
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        // 创建一个共享的锁对象
        Object lock = new Object();

        // 创建一个新的线程（NEW状态）
        Thread t1 = new ExampleThread(lock);
        System.out.println(t1.getName() + " is created");

        // 启动新的线程（READY/RUNNABLE状态）
        t1.start();

        // 让主线程睡眠2秒，这样新线程就可以先运行
        Thread.sleep(2000);

        // 唤醒等待的线程（将进入READY/RUNNABLE状态）
        synchronized(lock) {
            lock.notify();
        }

        // 让主线程再睡眠1秒，这样被唤醒的线程可以完成运行
        Thread.sleep(1000);
    }
}
```
这个代码示例演示了Java线程从创建（NEW状态），到就绪和运行（READY/RUNNABLE状态），再到等待（WAITING状态），被唤醒后再次运行，最后终止（TERMINATED状态）的整个过程。


## 常用方法介绍
### sleep()
使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。

例如有两个线程同时执行(没有synchronized)一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完毕后，低优先级的线程才能够执行；但是高优先级的线程sleep(500)后，低优先级就有机会执行了。
总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。

### join()
join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。
thread.join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。

### yield()
该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。

### wait()和notify()、notifyAll()
这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。

wait()方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。当调用notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。

notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。

### stop() 和 interrupt() 方法的主要区别是什么呢？
stop() 方法会真的杀死线程，不给线程喘息的机会， 如果线程持有 ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。

所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。 而 interrupt() 方法就温柔多了，interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。

当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。 上面我们提到转换到 WAITING、TIMED_WAITING 状态的触发条件，都是调用了类似 wait()、join()、sleep() 这样的方法，我们看这些方法的签名，发现都会 throws InterruptedException 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法。

当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在 java.nio.channels.Selector 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 的 java.nio.channels.Selector 会立即返回。

上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的 interrupt() 方法，那么线程 A 可以通过 isInterrupted() 方法，检测是不是自己被中断了。


















