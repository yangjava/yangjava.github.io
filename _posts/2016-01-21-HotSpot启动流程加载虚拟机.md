---
layout: post
categories: [JVM]
description: none
keywords: JVM
---
## HotSpot启动流程加载虚拟机
VM是Java程序运行的环境,同时是一个操作系统的一个应用程序进程,因此它有自己的生命周期,也有自己的代码和数据空间。

## JVM工作原理
JVM体系主要是两个JVM的内部体系结构分为三个子系统和两大组件，分别是：类装载器（ClassLoader）子系统、执行引擎子系统和GC子系统，组件是内存运行数据区域和本地接口。

JVM工作原理和特点主要是指操作系统装入JVM，是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境.
- 创建JVM装载环境和配置
- 装载JVM.dll
- 初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例
- 调用JNIEnv实例装载并处理class类。

JVM装入环境，JVM提供的方式是操作系统的动态连接文件．

既然是文件那就一个装入路径的问题，Java是怎么找这个路径的呢？

当你在调用Java test的时候，操作系统会在path下在你的Java.exe程序，Java.exe就通过下面一个过程来确定JVM的路径和相关的参数配置了。

下面基于Windows的实现的分析：
- 首先查找jre路径，Java是通过GetApplicationHome api来获得当前的Java.exe绝对路径，c:\j2sdk1.4.2_09\bin\Java.exe,那么它会截取到绝对路径c:\j2sdk1.4.2_09\，判断c:\j2sdk1.4.2_09\bin\Java.dll文件是否存在， 
- 如果存在就把c:\j2sdk1.4.2_09\作为jre路径， 如果不存在则判断c:\j2sdk1.4.2_09\jre\bin\Java.dll是否存在，如果存在这c:\j2sdk1.4.2_09\jre作为jre路径．如果不存在调用GetPublicJREHome查HKEY_LOCAL_MACHINE\Software\JavaSoft\Java Runtime Environment\“当前JRE版本号”\JavaHome的路径为jre路径。
- 然后装载JVM.cfg文件JRE路径+\lib+\ARCH（CPU构架）+\JVM.cfg ，ARCH（CPU构架）的判断是通过Java_md.c中GetArch函数判断的，该函数中windows平台只有两种情况：WIN64的‘ia64’，其他情况都为‘i386’。
以我的为例：C:\j2sdk1.4.2_09\jre\lib\i386\JVM.cfg.主要的内容如下：
```
-client KNOWN
-server KNOWN
-hotspot ALIASED_TO -client
-classic WARN
-native ERROR
-green ERROR
```
在我们的jdk目录中jre\bin\server和jre\bin\client都有JVM.dll文件存在，而Java正是通过JVM.cfg配置文件来管理这些不同版本的JVM.dll的．通过文件我们可以定义目前jdk中支持那些JVM,前面部分（client）是JVM名称，后面是参数，KNOWN表示JVM存在，ALIASED_TO表示给别的JVM取一个别名，WARN表示不存在时找一个JVM替代，ERROR表示不存在抛出异常．

在运行Java XXX是，Java.exe会通过CheckJVMType来检查当前的JVM类型，Java可以通过两种参数的方式来指定具体的JVM类型，一种按照JVM.cfg文件中的JVM名称指定，第二种方法是直接指定，它们执行的方法分别是“Java -J”、“Java -XXaltJVM=”或“Java -J-XXaltJVM=”。如果是第一种参数传递方式，CheckJVMType函数会取参数‘-J’后面的JVM名称，然后从已知的JVM配置参数中查找如果找到同名的则去掉该JVM名称前的‘-’直接返回该值；而第二种方法，会直接返回“-XXaltJVM=”或“-J-XXaltJVM=”后面的JVM类型名称；如果在运行Java时未指定上面两种方法中的任一一种参数，CheckJVMType会取配置文件中第一个配置中的JVM名称，去掉名称前面的‘-’返回该值。CheckJVMType函数的这个返回值会在下面的函数中汇同jre路径组合成JVM.dll的绝对路径。如果没有指定这会使用JVM.cfg中第一个定义的JVM.可以通过set _Java_LAUNCHER_DEBUG=1在控制台上测试．

最后获得JVM.dll的路径，JRE路径+\bin+\JVM类型字符串+\JVM.dll就是JVM的文件路径了，但是如果在调用Java程序时用-XXaltJVM=参数指定的路径path,就直接用path+\JVM.dll文件做为JVM.dll的文件路径．

## 装载JVM.dll
通过第一步已经找到了JVM的路径，Java通过LoadJavaVM来装入JVM.dll文件．装入工作很简单就是调用Windows API函数：

LoadLibrary装载JVM.dll动态连接库．然后把JVM.dll中的导出函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs挂接到InvocationFunctions变量的CreateJavaVM和GetDefaultJavaVMInitArgs函数指针变量上。JVM.dll的装载工作宣告完成。

初始化JVM，获得本地调用接口，这样就可以在Java中调用JVM的函数了．调用InvocationFunctions－>CreateJavaVM也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例．

## 运行Java程序．
Java程序有两种方式一种是jar包，一种是.class：

运行jar,Java -jar XXX.jar运行的时候，Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例,然后调用Java类Java.util.jar.JarFileJNIEnv中方法getManifest()并从返回的Manifest对象中取getAttributes("Main-Class")的值即jar包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。

之后会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。

然后调用JNIEnv实例的GetStaticMethodID方法查找装载的class主类中“public static void main(String[] args)”方法，并判断该方法是否为public方法，然后调用JNIEnv实例的CallStaticVoidMethod方法调用该Java类的main方法。
## 启动
调用java.c/JLI_Launch方法。位置：jdk/src/share/bin/java.c
```
// InvocationFuntions是个重要的结构体，其中包含了创建JVM会被调用的三个函数指针。
typedef struct {
    CreateJavaVM_t CreateJavaVM;    //指向负责创建JavaVM和JNIEnv结构的函数指针
    GetDefaultJavaVMInitArgs_t GetDefaultJavaVMInitArgs;  //指向获取默认JVM初始参数的函数指针
    GetCreatedJavaVMs_t GetCreatedJavaVMs;  //指向获取JVM的函数指针
} InvocationFunctions;

/*
 * Entry point.
 */
 // java入口函数，解析参数、创建环境、加载jvm动态库
int
JLI_Launch(int argc, char ** argv,              /* main argc, argc */
        int jargc, const char** jargv,          /* java args */
        int appclassc, const char** appclassv,  /* app classpath */
        const char* fullversion,                /* full version defined */
        const char* dotversion,                 /* dot version defined */
        const char* pname,                      /* program name */
        const char* lname,                      /* launcher name */
        jboolean javaargs,                      /* JAVA_ARGS */
        jboolean cpwildcard,                    /* classpath wildcard*/
        jboolean javaw,                         /* windows-only javaw */
        jint ergo                               /* ergonomics class policy */
)
{
    int mode = LM_UNKNOWN;    //启动模式  默认为0   其他参考：java.h 中LaunchMode枚举定义
    char *what = NULL;
    char *cpath = 0;
    char *main_class = NULL;  //带有main函数的class文件
    int ret;
    InvocationFunctions ifn;  //函数指针结构体包括：创建jvm、获取jvm启动参数、获取创建的jvm
    jlong start, end;         //启动结束时间
    char jvmpath[MAXPATHLEN]; //jvm路径
    char jrepath[MAXPATHLEN]; //jre路径
    char jvmcfg[MAXPATHLEN];  //jvm配置

    _fVersion = fullversion;
    _dVersion = dotversion;
    _launcher_name = lname;
    _program_name = pname;
    _is_java_args = javaargs;
    _wc_enabled = cpwildcard;
    _ergo_policy = ergo;

    InitLauncher(javaw);  //初始化启动器，window下注册启动异常时弹出ui选择调试器
    DumpState();          //判断是否定义环境变量_JAVA_LAUNCHER_DEBUG，是的话打印调试信息
    if (JLI_IsTraceLauncher()) { //打印命令行参数
        int i;
        printf("Command line args:\n");
        for (i = 0; i < argc ; i++) {
            printf("argv[%d] = %s\n", i, argv[i]);
        }
        AddOption("-Dsun.java.launcher.diag=true", NULL); //增加配置参数
    }

    /*
     * Make sure the specified version of the JRE is running.
     *
     * There are three things to note about the SelectVersion() routine:
     *  1) If the version running isn't correct, this routine doesn't
     *     return (either the correct version has been exec'd or an error
     *     was issued).
     *  2) Argc and Argv in this scope are *not* altered by this routine.
     *     It is the responsibility of subsequent code to ignore the
     *     arguments handled by this routine.
     *  3) As a side-effect, the variable "main_class" is guaranteed to
     *     be set (if it should ever be set).  This isn't exactly the
     *     poster child for structured programming, but it is a small
     *     price to pay for not processing a jar file operand twice.
     *     (Note: This side effect has been disabled.  See comment on
     *     bugid 5030265 below.)
     */
    //选择jre的版本,这个函数实现的功能比较简单，就是选择正确的jre版本来作为即将运行java程序的版本。
    //选择的方式
    //1.环境变量设置了_JAVA_VERSION_SET，那么代表已经选择了jre的版本，不再进行选择
    //2.可以从jar包中读取META-INF/MAINFEST.MF中获取,查看mian_class
    //3.运行时给定的参数来搜索不同的目录选择jre_restrict_search
    //最终会解析出一个真正需要的jre版本并且判断当前执行本java程序的jre版本是不是和这个版本一样，如果不一样调用linux的execv函数终止当前进出并且使用新的jre版本重新运行这个java程序，但是进程ID不会改变。
    SelectVersion(argc, argv, &main_class);
    //确定一下jvm的信息并且初始化相关信息，为后面的jvm执行准备环境
    //1.首先查找jre路径，通过GetApplicationHome来获得
    //2.推断JAVA_DLL文件位置，JVM.cfg文件
    //3.根据JVM.cfg获取JVM_DLL位置,可以通过-XXaltJVM或者JDK_ALTERNATE_VM指定JVM_DLL
    CreateExecutionEnvironment(&argc, &argv,
                               jrepath, sizeof(jrepath),
                               jvmpath, sizeof(jvmpath),
                               jvmcfg,  sizeof(jvmcfg));
    //初始设置函数指针为无效指针
    ifn.CreateJavaVM = 0;
    ifn.GetDefaultJavaVMInitArgs = 0;
    //如果时debug的话，记录启动时间
    if (JLI_IsTraceLauncher()) {
        start = CounterGet();
    }
    //动态加载JVM_DLL这个共享库，把hotspot的接口爆露出来，例如JNI_CreateJavaVM函数
    //填充到ifn结构体中
    if (!LoadJavaVM(jvmpath, &ifn)) {
        return(6);
    }
    //debug模式下记录加载java vm虚拟机时间
    if (JLI_IsTraceLauncher()) {
        end   = CounterGet();
    }
    //打印加载javavm时间
    JLI_TraceLauncher("%ld micro seconds to LoadJavaVM\n",
             (long)(jint)Counter2Micros(end-start));

    ++argv;
    --argc;
    //是否有参数
    if (IsJavaArgs()) {
        /* Preprocess wrapper arguments */
        // 解析参数
        TranslateApplicationArgs(jargc, jargv, &argc, &argv);
        if (!AddApplicationOptions(appclassc, appclassv)) {
            return(1);
        }
    } else {
        /* Set default CLASSPATH */
        // 设置环境变量中的classpath路径
        cpath = getenv("CLASSPATH");
        if (cpath == NULL) {
            cpath = ".";
        }
        SetClassPath(cpath);
    }

    /* Parse command line options; if the return value of
     * ParseArguments is false, the program should exit.
     */
    // 解析命令行参数，如果解析失败则程序退出.如-version，-help等参数在该方法中解析的
    if (!ParseArguments(&argc, &argv, &mode, &what, &ret, jrepath))
    {
        return(ret);
    }

    /* Override class path if -jar flag was specified */
    // 如果-jar参数指定的话，重写classpath值
    if (mode == LM_JAR) {
        SetClassPath(what);     /* Override class path */
    }

    /* set the -Dsun.java.command pseudo property */
    //  解析形如-Dsun.java.command=的命令行参数
    SetJavaCommandLineProp(what, argc, argv);

    /* Set the -Dsun.java.launcher pseudo property */
    // 解析形如-Dsun.java.launcher.*的命令行参数
    SetJavaLauncherProp();

    /* set the -Dsun.java.launcher.* platform properties */
    SetJavaLauncherPlatformProps();
    //进行一系列处理，最终创建一个jvm的虚拟机并调用java运行入口函数
    return JVMInit(&ifn, threadStackSize, argc, argv, mode, what, ret);
}
```

## 加载VM模块
加载VM是非常重要的一个工作。它是一个平台相关的实现，我们看下 windows版本的实现吧。

share/windows/bin/java_md.c
```
/*
 * Load a jvm from "jvmpath" and initialize the invocation functions.
 */
jboolean
LoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)
{
    HINSTANCE handle;

    JLI_TraceLauncher("JVM path is %s\n", jvmpath);

    /*
     * The Microsoft C Runtime Library needs to be loaded first.  A copy is
     * assumed to be present in the "JRE path" directory.  If it is not found
     * there (or "JRE path" fails to resolve), skip the explicit load and let
     * nature take its course, which is likely to be a failure to execute.
     *
     */
    LoadMSVCRT();

    /* Load the Java VM DLL */
    // windows 中是通过路径加载dll文件实现
    if ((handle = LoadLibrary(jvmpath)) == 0) {
        JLI_ReportErrorMessage(DLL_ERROR4, (char *)jvmpath);
        return JNI_FALSE;
    }

    /* Now get the function addresses */
    // 获取虚拟机操作内存地址
    ifn->CreateJavaVM =
        (void *)GetProcAddress(handle, "JNI_CreateJavaVM");
    ifn->GetDefaultJavaVMInitArgs =
        (void *)GetProcAddress(handle, "JNI_GetDefaultJavaVMInitArgs");
    if (ifn->CreateJavaVM == 0 || ifn->GetDefaultJavaVMInitArgs == 0) {
        JLI_ReportErrorMessage(JNI_ERROR1, (char *)jvmpath);
        return JNI_FALSE;
    }

    return JNI_TRUE;
}

```
可见，最重要的工作是被封装到 JRE 中的，应用层面只是调用JRE的方法即可。在windows中通过加载msvcrt模块完成工作，然后抽取vm的两个方法签名到ifn中，以便后续实用。