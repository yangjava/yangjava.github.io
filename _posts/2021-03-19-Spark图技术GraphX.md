---
layout: post
categories: [Spark]
description: none
keywords: Spark
---
# Spark图技术GraphX


## GraphX概述
图计算是计算机领域中的一个重要分支，在社交网络、电子商务、地图导航等领域中有着非常广泛的应用。在许多应用场景中，例如 Twitter、Facebook、微博、微信等都是大数据产生的地方，而且数据内部都存在着较高的关联度。利用图论中的理论与方法将这些关联度较高的数据转换为图数据，可以更加方便、准确地对其进行分析与处理。然而基于并行计算模式的传统大数据处理工具，对于独立性强的数据能够实现非常高的并行度与良好的可扩展性，但是对于关联度较高的图数据却面临着较大的挑战。为此涌现出一批面向大数据的图计算框架，例如Giraph、GraphLab、GraphX等。

本章所介绍的GraphX是Spark框架上的图计算组件。得益于Spark中RDD和DAG等概念，GraphX是一种基于内存的分布式图计算模型，不仅适用于处理大数据背景下具有较多迭代次数的计算任务，还能与Spark上的其他组件Spark SQL、MLlib、Spark Stream ing进行无缝集成。

但是如果仅从计算速度这一层面进行对比，GraphX比GraphLab慢2~3倍。例如对包含15亿条边的图执行PageRank算法，Giraph、GraphX、GraphLab性能对比如图5.1所示。导致GraphX计算性能存在差距的原因主要有两方面：GraphX跑在 JVM上，而 GraphLab则是基于 C++开发的；GraphLab不受Spark框架的限制，可以通过Threads共享内存，而GraphX即便在同一台机器上也有通信开销。

然而，若从整个图处理与应用的流程（构建图，合并图，最终结果的查询与展示）来看，GraphX的综合性能更具有竞争性。当面向超大规模的数据时， GraphX运行时间的增长要慢于 GraphLab，而且其可扩展性要更好一些；从整个图计算的 Pipeline来看，GraphX的总体运行时间要少于GraphLab+Spark

综合考虑GraphX的特性，越来越多的数据企业选择GraphX进行海量数据的图计算，例如腾讯、淘宝等。腾讯 QQ有着国内最大的用户关系链，用户彼此间的共同好友是进行社交网络分析的一项基本指标，也是其他复杂指标的基础。腾讯借助短短百行左右的 GraphX核心代码，在高配置的TDW-Spark集群上仅用两个半小时便完成了之前需要两天的全量共同好友计算。这标志着QQ千亿级别的关系链计算进入了小时级别时代。淘宝同样采用GraphX作为分布式图计算平台，实现了之前很多受限于计算能力而无法实现的模型。这些模型不仅广泛应用于用户网络中的社区发现、用户影响力评估、能量传播、标签传播等方面，提高了用户的黏性和活跃度；还应用到推荐领域中的标签推理、人群划分、年龄段预测、商品交易时序跳转等方面，提高了推荐的丰富度和准确性。

## GraphX基本原理

### 图计算模型处理流程
面向大数据的图计算模型都是对图数据进行分布式存储、并行计算和数据传输。通过操作图中顶点的数据以及与之相关联的边上的数据，产生消息并发送给相邻顶点。消息通过网络或其他方式传输，顶点在收到消息或状态后进行更新，生成新的图数据

图计算模型的一种处理流程：首先读取Wikipedia原始数据；然后转换成Link Table形式表视图；通过分析表中蕴含的关系将其转换为Hyperlinks图视图；在此基础上应用PageRank算法对图中顶点的重要性进行评估；最后再以表的形式对计算结果进行表示与存储。

由此可见，图计算模型的处理流程大致分为以下几步：
- 第1步，读取原始数据。数据既可以来自于HDFS、Hive、Hbase、关系型数据库，也可以来自于Spark上的其他组件，例如Spark Streaming、Spark SQL。
- 第2步，将原始数据转换成表视图。
- 第3步，将表视图转换成图视图。
- 第4步，在图视图上执行图计算算法。
- 第5步，将得到的结果再转换成表视图，便于表示与用户查询。

整个流程涉及了原始数据、图视图与表视图，以及两种视图的转换。GraphX也遵循这一处理流程，但是其与传统的大数据图计算模型相比存在着一些明显的区别。

## GraphX定义
GraphX是Spark框架上的图计算组件，通过对Spark中的RDD进行继承与扩展，引入了弹性分布式属性图（Resilient Distributed Porperty Graph），并针对该图提供了丰富的API。

GraphX基于Spark中的RDD、DAG、高容错性等概念和特性，实现了图计算的高效性与健壮性。GraphX是一种基于内存的分布式的图计算库与图计算框架，用户不仅可以直接使用GraphX提供的经典图计算算法库，还可以针对不同的业务需求开发相应的GraphX应用程序。

### GraphX的特点

#### 基于内存实现了数据的复用与快速读取

具有较多迭代次数是图计算算法的一个重要特点。在海量数据背景下，如何保证图计算算法的执行效率是所有图计算模型面对的一个难题。基于MapReduce的图计算模型在进行迭代计算过程中，中间数据的操作都是基于磁盘展开的，如图5.4所示，这使得数据的转换和复制开销非常大，其中包括序列化开销等。除此之外，许多与图结构信息相关的数据无法进行重用，这使得系统不得不反复读取一些相同的数据对图进行重构。相对于传统的图计算模型，GraphX得益于Spark中的RDD和任务调度策略，能够对图数据进行缓存和Pipline操作，实现了图结构的复用与快速运算。

#### 统一了图视图与表视图
传统图计算模型都是将表视图和图视图分别进行实现的，这意味着图计算模型要针对不同的视图分别进行维护，而且视图间的转换也比较烦琐。GraphX通过弹性分布式属性图统一了表视图和图视图，即两种视图对应同一物理存储但是各自具有独立的操作，这使得操作更具灵活性和高效性。基于GraphX执行图计算任务，一方面用户不必再对不同的组件进行学习、部署、维护和管理，降低运维成本；另一方面更有利于实现基于内存的Pipeline操作。

此外，在GraphX中还提出了一种路由表（routing table）。该表描述了图存储时的一些元数据信息，记录了顶点所在的物理位置以及顶点间的关系。利用该路由表能够极大地提高图计算的执行效率。

#### 能与Spark框架上的组件无缝集成

仅从图计算性能方面对比，目前性能最好的模型仍是GraphLab。但是单一组件或单一性能无法决定整个系统的综合处理能力。尤其是在大数据背景下，任何数据处理业务都需要同一平台上的多个组件通过相互协作来完成，例如海量数据的获取、表示、存储、分析、查询、可视化以及数据通信等各环节对应着一系列专用的组件。然而不同组件之间在集成性方面存在着很大差异。由于GraphX是Spark上的一个组件，能与Spark Stream ing、Spark SQL和SparkMLlib等进行无缝衔接，例如可以利用SparkSQL进行ETL，然后将处理后的数据传给GraphX进行计算；或者GraphX与MLlib结合对图数据进行深度挖掘，这些都是Spark一栈式解决方案的具体应用，而Giraph、GraphLab等则不具备这一特点。因此在Spark平台上进行图计算，首选GraphX。

## GraphX设计与实现

### 弹性分布式属性图
基于Spark中的RDD和图论中的相关概念，GraphX通过弹性分布式属性图对图数据进行表示与处理，并为弹性分布式属性图提供了丰富的API。区别于图论中的简单图，GraphX中的弹性分布式属性图具有以下特征：

- 图中的顶点和边都带有属性（数据）。
- 是分布式的、基于内存的、具有较好的容错性。
- 图中数据是高度受限的，即只可读不可写的。
- 是有向图，即两个顶点之间的边有方向。
- 是多重图，即两个顶点间可有多条边。

为方便说明，在不混淆的情况下，后续章节将弹性分布式属性图简称为图。

### 图的数据模型
数据是操作的对象，数据的组织形式对图计算的实现有着非常重要的影响。GraphX定义了图的数据模型，即给出了图数据的具体组织形式（如何表示与存储图中的顶点、图中的边、顶点上的数据、边上的数据、顶点和边之间的关系），并在此基础上给出了图的存储模型和一系列并行操作。

在GraphX中用一个三元组G=（V,E,P）抽象地表示一个图，其中V代表顶点集，E代表边集，P是顶点属性与边属性的集合。在这个三元组中，GraphX 用64位长整型作为ID唯一标识图中的每个顶点，因此V可视为一个长整型的集合；图中每一条边都关联两个顶点，因此E可视为顶点ID序对的集合；而P中包含的属性既可以是简单的数据类型，也可以是n元祖、列表、数组以及用户自定义的各种复杂的数据类型。

为了具体表示和存储图，GraphX中定义了相应的类与伴生对象。

VertexRDD
由于图中的每一个顶点均由顶点ID和属性两部分构成，因此可将其形式化地描述为一个二元组（VertexId，VD），其中Vertex Id为64位长整型，VD表示顶点数据的数据类型。为了表示顶点的集合，GraphX定义了继承自RDD[（Vertex Id，VD）]的抽象类VertexRDD[VD]和其伴生对象。

Edge与EdgeRDD

为了表示边，GraphX定义了样例类Edge和其伴生对象。

Edge中含有三个成员字段：srcId表示源顶点ID，是一个64位长整型；dstId表示目标顶点ID，是一个64位长整型；attr表示边属性，ED则表示边属性的数据类型。在此基础上，GraphX将图中的每一条边用一个Edge类型的实例进行表示。

为了表示边集，GraphX进一步定义了抽象类EdgeRDD和其伴生对象。

abst ract class EdgeRDD[ED] extends RDD[Edge[ED]]

## 图的存储模型
在海量数据背景下，一张图可能包含上亿个顶点，数亿条边，甚至更多。若将TB级、PB级的图数据存储在一个物理节点上并进行迭代计算通常是不现实的。GraphX在存储方面同样采用了分布式的思想，先将一张图分解出若干子图，然后再对每张子图进行分布式存储和并行计算。因此，首先需要解决的问题就是子图的切分方式与切分策略。

### 图的切分方式

在划分子图时，可分为基于边和基于点两种切分方式，如图 5.8所示。2013年，GraphLab 2.0将子图的切分方式由边切分转换为点切分，使得其在性能上获得了大幅提升，目前基于点的切分方式已被业界广泛接受并使用。

边切分：图中每个顶点都存储一次，但有的边会被切断分到两个节点上。这样做的好处是节省存储空间；缺点是对图进行基于边的计算时，对于一条两个顶点位于两个不同物理节点上的边来说，需要跨节点进行数据通信，这对网络I/O性能要求很高。GraphX中的图均为多重图，使得这一缺点尤为突出。

点切分：图中每条边只存储一次，都只会出现在一个节点上。相邻顶点多的顶点可能会被复制到多个节点上，虽然增加了存储开销，但是却可以大幅减少内网通信量。

由于磁盘价格的下降，存储空间不再是难题，而内网的通信性能相对进展较慢，这使得在进行分布式计算时内网带宽是更加有限的资源，即时间比空间更宝贵。因此在大数据背景下更倾向于采用空间换时间的策略。另一方面，在绝大多数图计算应用场景中，网络都是“无尺度网络”，遵循幂律分布，不同顶点的相邻顶点数量相差非常悬殊。在这种情况下采用边切分方式会导致图计算时需要大量的数据通信，使得内网带宽更加捉襟见肘，于是边切分存储方式被渐渐抛弃了。

### 图的切分策略

GraphX以点切分的方式对图进行切分，并提出了4种具体的切分策略，其整体思路都是基于顶点1D确定分区值。

（1）1D分区法

1D分区法基于源顶点ID计算分区值，该方法将所有源顶点相同的边放在一个分区中。

case object EdgePartitionID extends PartitionStrategy {

####  随机顶点切分法（Randowm Vertex Cut）

使用源顶点ID和目标顶点ID计算哈希值，再由这个哈希值与一个很大的素数进行模运算，得到最终的分区值。该方法可以将两个顶点之间方向相同的边存储在一个分区中。

#### 正则随机顶点切分法（Canonical Random Vertex Cut）

使用源顶点ID和目标顶点ID得到分区值，但是区别于随机顶点分区法，在计算哈希值的时候先将源顶点ID和目标顶点ID进行由小到大的排序，然后再求哈希值，最后再利用哈希值与一个很大的素数进行模运算，得到最终的分区值。该方法可以将两个顶点之间的所有边都放在同一个分区中，而无论边的方向如何。

#### 2D分区法（Edge Partition）

在这种方法中，通常将分区数p设为一个整数t的平方值，并且在计算分区值的时候引入了行值和列值，最终确定分区数。

## GraphX模型框架
GraphX是非常出色的图计算框架和图计算库。用户不仅可以使用GraphX设计自己的图计算算法，还可以直接使用GraphX中提供的很多经典的图计算算法（算法库主要是通过兼容Pregel实现的，提供了很多Pregel API）。GraphX模型框架分为三个层次：算法层、模型层和实现层，如图5.10所示。在算法层中，主要是兼容Pregel的算法库；在模型层中，定义了Graph、GraphImpl、GraphOps三个重要的类。Graph是抽象类，其中定义了图上的一系列基本操作；GraphImpl是Graph抽象类的实现类，里面有对Graph中抽象方法的具体实现；GraphOps类中不仅定义了图上的基本操作，还提供了一些经典图计算算法，例如 pageRank、triangleCount等。GraphImpl通过隐式转换可以调用GraphOps中的操作。
























