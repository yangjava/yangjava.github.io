---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++编程指南-Lambda表达式

## 用Lambda表达式编写更简单的函数
如果说函数指针是函数的一件西服，规规矩矩大大方方，那么函数对象就可以说是函数的一件貂皮大衣，雍容华贵仪态万方。但是，人不可能总是穿西服或者貂皮大衣啊，有时候还需要一件简约清凉的衬衣。函数也不例外，它也有另外一件马甲——Lambda表达式，也就是函数的衬衣。我们之所以说Lambda表达式是函数的衬衣，是因为它的形式足够简单，简单到连函数名字都没有而成为匿名函数（anonymous function）。顾名思义，所谓匿名函数，就是这个函数只有函数体、参数和返回值类型，而没有函数名。而在C++中，我们正是用Lambda表达式来表达匿名函数。

## 最简单直接的函数表达形式：Lambda表达式
虽然函数指针和函数对象被广泛地应用在STL算法中以实现算法的自定义，但是，这两件马甲在某些情况下也会显出不适宜的地方。首先，函数或者函数对象类定义的地方和使用的地方是相互分离的，如果想在使用函数的地方查看它的定义，则不得不跋山涉水、翻山越岭，在多个代码文件之间跳转查找。这样会打断代码的流程，使代码不够流畅自然，同时也会影响开发的效率。另外，STL算法中应用的函数数量非常多，但往往都是一些小函数，只有简单的数据操作。如果我们使用普通函数或者函数对象来表达这些函数，则会导致程序代码的的膨胀，使得程序中充斥着碎片化的函数而难以管理和维护。这就象炎炎夏日却穿着西装甚至是貂皮大衣，怎么看怎么不合适。为了解决这些问题，C++为函数精心缝制了一件新马甲：Lambda表达式，一件简约而清凉的衬衣。在作用上，Lambda表达式跟函数指针和函数对象相同，它同样可以方便地应用于STL算法中，对算法进行自定义。在使用上，Lambda表达式可以在使用函数的地方对其进行定义，使整个代码更加自然流畅。更方便的是，可以在Lambda表达式中直接访问Lambda表达式之外的数据，这样就避免了复杂的参数传递，也解决了函数执行过程中状态数据的保存问题，为数据的操作带来很大的便利。而在语法形式上，相对于函数指针或函数对象复杂的语法形式，Lambda表达式使用非常简单的语法就可以完成定义，降低了Lambda表达式的使用难度，避免了函数对象或函数指针因过于复杂而可能带来的错误。

在前面的章节中，我们利用函数对象完成了对容器中Student对象身高的统计。问题虽然解决了，但是程序稍显臃肿（穿上貂皮大衣能不臃肿吗？），即然是臃肿，那“优雅”就更谈不上了。下面还是先来看看Lambda表达式这件新马甲是如何让程序恢复“优雅”的：
```
// 定义变量，用于保存函数执行过程中的状态数据
int nTotalHeight = 0;
int nCount = 0;
// 在for_each()算法中使用Lambda表达式，统计身高
for_each( vecStu.begin(), vecStu.end(), 
 [&](const Student& st) // Lambda表达式
{
 nTotalHeight += st.GetHeight(); // 直接访问外部数据，累计身高
 ++nCount;
});
if( 0 != nCount )
{
cout<<nCount<<"个学生的平均身高是："
 <<(float)nTotalHeight/nCount<<endl;
}
```
短短的几行代码，就完成了原来需要一个函数对象类才能完成的工作。除了鼓掌，想不到还能用别的什么方式来表达我们的赞叹之情。

在这段代码中，我们在for_each()算法原来放置函数指针或函数对象的第三个参数位置，使用一对中括号“[ ]”来表示一个Lambda表达式的开始，其后的“(const Student& st)”就是这个表达式的参数。因为返回值无关紧要，我们这里省略了Lambda表达式的返回值类幸。当for_each()算法循环遍历容器中的每一个Student对象时，它就会将Student对象作为参数调用Lambda表达式，从而将Student对象传递到Lambda内部。因为“[]”中括号中是“&”符号，所以在Lambda表达式内部可以以引用的形式直接访问外部的任何变量，所以我们用成员函数获得Student对象的身高并直接累加到nTotalHeight变量，实现了函数执行过程中状态数据的保存。for_each()算法执行完毕后，nTotalHeight和nCount都已经保存了统计的数据，进行简单的计算并将结果输出就“优雅”地完成了整个统计工作。

## Lambda表达式的定义与使用
在上面的例子中，我们已经见识过了Lambda表达式的简洁。具体而言，在C++中定义一个Lambda表达式的语法格式如下：
```
[变量使用说明符号](参数列表) -> 返回值数据类型
{
 // 函数体 
}
```
其中，中括号“[ ]”表示Lambda表达式的开始，用来告诉编译器接下来的代码就是Lambda表达式。在中括号中，可以指定Lambda表达式对当前作用域（也就是Lambda所在的大括号“{}”范围）中的变量的捕捉方式，所以这个中括号也可以称为“捕捉列表（capture list）”。如果我们希望在Lambda表达式内部以传值（复制）的方式使用当前作用域中的所有变量，则使用“[=]”表示，这就意味着Lambda表达式内访问到的变量只是外部同名变量的一个副本，在Lambda表达式内部对变量的修改不会影响到外部的同名变量。换句话说，也就是在Lambda内部只能读取外部变量的值但却没法对其进行修改。如果试图修改，将导致一个编译错误。如果中括号留空，默认情况下也表示以传值方式使用Lambda表达式外部的变量。例如：
```
vector<int> v = {51,82,73,44,58};
int nAdd = 10;
// 为容器中小于60的分数加上10分
for_each(v.begin(), v.end(), 
// “[=]”表示以传值的方式使用Lambda外部的变量 
// 因为要修改容器中的数据，所以参数采用引用形式 
[=](int& x)   
{
nAdd = 20; // 试图修改外部变量会导致编译错误
if(x < 60)
{
 x += nAdd; // 只读访问nAdd
}
 
});
```
如果想在Lambda表达式内部对外部变量进行修改，则可以使用“[&]”代替“[=]”作为Lambad表达式的开始，这表示Lambda表达式将以传引用的方式捕捉当前作用域内的变量。这就意味着Lambda表达式内部的变量都是外部同名变量的引用，所以在Lambda表达式中对这些变量的修改将直接影响到当前作用域中变量本身。例如：
```
int nTotal = 0;
for_each(v.begin(), v.end(), 
 [&](int x)  // “[&]”表示以传引用的方式使用Lambda外部的变量
{
 nTotal += x;  // 修改变量的值
});
cout<<"容器中数据的总和是："<<nTotal<<endl;
```
这里，在Lambda表达式内部，我们将容器中的数据累加到nTotal变量上，因为Lambda表达式是以传引用的形式来捕捉外部变量，所以这个累加实际上操作的是Lambda表达式外部的局部变量nTotal。这样，也就实现了数据从Lambda表达式内部向外部的传递，最后我们可以看到统计结果。

如果需要与Lambda表达式传递多个数据，而同时各个数据的传递方式又各不相同，那么可以在中括号中的第一个位置用“&”作为Lambda表达式的默认传递方式，而那些需要以传值方式进行传递的变量，则可以单独在中括号中列出。例如，我们希望在统计成绩的同时修正成绩：
```
int nAdd = 10;
int nTotal = 0;
for_each(v.begin(), v.end(), 
 [&, nAdd](int& x)  // 默认采用传引用访问，nAdd使用传值访问
{
if( x < 60 )
{
 x += nAdd; // 传值访问nAdd，只能读取
}
nTotal += x; // 默认采用传引用访问nTotal，可以写入
});
cout<<"容器中所有数据的总和是"<<nTotal<<endl;
```
在Lambda表达式用“[]”中括号对捕捉变量的方式进行说明后，就是它的参数列表。它的参数列表跟普通函数的参数列表类似，主要用于接收STL算法传递进来的数据，所以其参数的个数由具体的算法决定，而参数的类型则由容器中所保存数据的类型决定，至于参数的传递形式，到底是传值还是传引用，则由我们是否需要修改容器中的数据决定。例如，上面的Lambda表达式应用在for_each()算法中，这就决定了它只能有一个参数，用以接收算法传递给它的单个数据；而容器中保存的是int类型的数据，所以参数的类型也应该是int类型。至于参数的传递方式，如果我们需要修改容器中的数据，就使用传引用方式（比如第一个例子），否则直接使用传值方式（比如第二个例子）。

在完成参数列表的定义后，接下来就是Lambda表达式的返回值类型了。在大多数情况下，Lambda表达式所表达的只是对数据的简单处理，不需要返回值，这时可以省略返回值类型的定义。如果某些算法需要Lambda表达式有返回值，则可以在参数列表后使用“->”符号来定义它的返回值类型。例如，count_if()算法就要求与之配合的函数具有bool类型的返回值以决定当前数据是否需要统计在内，所以，当Lambda表达式应用在count_if()算法中时，就需要定义返回值类型：
```
// 统计容器中的及格分数int nPass = count_if(vecScore.begin(),vecScore.end(),
 [=](int x) -> bool  // 定义Lambda表达式的返回值类型为bool类型
{
 // 判断分数是否及格
 return x > 60;
});
```
这里，我们定义Lambda表达式的返回值为bool类型，这样在count_if()算法的执行的过程中，它会逐个地将容器中的数据传递给Lambda表达式进行判断。如果x大于60，也就是“x > 60”的值为true，Lambda表达式返回true，也就表示这个数据符合统计条件应该统计在内。反之，Lambda表达式返回false，表示当前数据不应统计在内。count_if()算法正是根据Lambda表达式的返回值来判断当前数据是否应该统计在内。从这里我们可以看到，Lambda表达式的定义非常灵活，没有函数名，返回值类型也可有可无。另外它的使用也非常方便，它可以以多种方式捕捉当前区域的变量，省去了函数调用过程中的数据传递。同时，定义它的位置也就是使用它的位置，“所见即所得”。所以，Lambda特别适合于运用在STL算法中，用以表达那些对数据的简单操作。例如上面的例子，使用Lambda表达式，短短几行代码就可以实现，极尽“优雅”。而如果要使用函数指针或者函数对象来实现，少则十几行代码，多则几十行代码，把简单的事情搞得异常复杂，又何谈“优雅”？所以，在那些只需要对数据进行简单操作的地方，让函数换上Lambda表达式这件马甲就对了。

## 知道更多：定义可以使用Lambda表达式的函数
在上面的例子中，我们都是将Lambda表达式应用在STL算法中以表达对数据的处理过程，既然Lambda表达式这么好用，那么，我们是否也可以定义自己的可以接受Lambda表达式的函数呢？答案是肯定的。在C++中，我们使用STL中的function类模版来表示一个函数。当我们以某种返回值类型以及参数个数和类型特化这个类模板后，得到的是可以代表相应类型函数的模板类。然后使用这个模板类类型作为函数的参数类型，这个函数就可以接受拥有相应返回值和参数的函数指针或者函数对象为实际参数，进而可以在函数内部调用这些通过function类型参数传递进来的函数以实现对函数的自定义。从本质上讲，Lambda表达式的实质也是一个函数。既然function类型的参数可以接受函数指针和函数对象，自然也可以接受相应类型的Lambda表达式。
例如，在前面的例子中我们实现了一个mycount_if()算法，它可以接受一个函数指针作为参数，下面我们就用function类模板对它进行改写，使其不仅可以接受函数指针为参数，同时还可以接受相应类型的函数对象或Lambda表达式为参数：_
```
#include <functional> // 引入function类模板所在的头文件
 
// 可以接受Lambda表达式的mycount_if()算法
int mycount_if(const vector<int>& v, // 需要统计的容器
   // 将函数指针类型更换为function<bool(int)>类型，
// 表示它可以接受一个返回值为bool类型，同时拥有一个int类型参数
// 的函数指针或函数对象，自然也可以是相应类型的Lambda表达式 
function<bool(int)> is) 
{
  // 函数体无需进行任何修改…
}
// …
// 在mycount_if()算法中应用Lambda表达式
int nPass = mycount_if(vecScore,
  // 一个返回值为bool类型，同时拥有一个int类型参数的Lambda表达式
[=](int x) -> bool 
 {
 return x >= 60; // 判断分数是否及格
 });
```
借助function类模板，我们也能定义可以使用Lambda表达式的函数，从而将函数的部分业务逻辑留给函数的使用者去灵活地实现，使之可以适应更多的需求，大大地增加了函数的通用性。
总结起来，函数的这三件马甲：西装——指向普通函数的函数指针、貂皮大衣——函数对象以及衬衣——Lambda表达式，在本质上，它们都是函数，虽然它们的表现形式不同，但它们所表达的都是一个对数据的处理过程，都可以接收数据，然后对数据进行处理并最终返回结果数据。就像人们总是在春秋穿西装，而在冬天穿貂皮大衣在夏天穿衬衣一样，不同的函数应用场景也要求函数换上不同的马甲。一般而言，普通函数最为常见，主要用以表达一个纯粹的数据处理过程。而如果这个数据处理过程需要记住一些过程中的状态数据，就该换上拥有成员变量的函数对象这件马甲。而如果这个数据处理过程非常简单同时又不需要反复使用，则应该换上简单到连名字都没有的Lambda表达式这件马甲。看天穿衣，是人的基本常识；根据应用场景的不同选择合适的函数马甲，却是程序员的智慧。