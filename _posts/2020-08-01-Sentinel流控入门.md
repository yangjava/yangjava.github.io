---
layout: post
categories: [Sentinel]
description: none
keywords: Sentinel
---
# Sentinel流控入门
Sentinel是阿里巴巴开源的一款 轻量级流量控制、熔断降级工具，它提供了实时的流量控制，熔断降级等功能，能够帮助我们实现服务的高可用性和稳定性。

## 关于 Sentinel
Sentinel 是阿里巴巴开源的一款针对分布式系统的流量控制、熔断降级的框架。在微服务架构的系统中，请求流量复杂多样，可能会因为某一个服务异常而导致整体服务不可用，这时候需要熔断降级，而`Sentinel`就提供了这样的解决方案。

## Sentinel 的历史
- 2012 年，Sentinel 诞生，主要功能为入口流量控制。
- 2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。
- 2018 年，Sentinel 开源，并持续演进。
- 2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 C++ 原生版本，同时针对 Service Mesh 场景也推出了 Envoy 集群流量控制支持，以解决 Service Mesh 架构下多语言限流的问题。
- 2020 年，推出 Sentinel Go 版本，继续朝着云原生方向演进。
- 2021 年，Sentinel 正在朝着 2.0 云原生高可用决策中心组件进行演进；同时推出了 Sentinel Rust 原生版本。同时我们也在 Rust 社区进行了 Envoy WASM extension 及 eBPF extension 等场景探索。
- 2022 年，Sentinel 品牌升级为流量治理，领域涵盖流量路由/调度、流量染色、流控降级、过载保护/实例摘除等；同时社区将流量治理相关标准抽出到 OpenSergo 标准中，Sentinel 作为流量治理标准实现。

## Sentinel 的作用和优势
Sentinel 可以针对服务方法调用、HTTP 请求、Dubbo 服务等，进行实时的流量控制、熔断降级，确保服务高可用，同时还可以提供实时的监控和报警功能。

Sentinel 有以下一些优势：
- 丰富的应用场景和细粒度的控制
Sentinel 支持多种应用场景，包括熔断降级、流量控制、系统保护、热点参数限流等，而且可以实现细粒度的控制；
- 强大的实时监测机制
Sentinel 提供了实时的监测、报警机制，能够对系统运行情况进行实时检测和通知，发现问题更加及时；
- 易于扩展
Sentinel 为开发者提供了简单易用的扩展接口，开发者可以方便的实现自定义的控制和监测逻辑；
- 易于集成
Sentinel 支持多种开发框架，包括 Spring Cloud、Dubbo、Feign 等，开发者可以很方便的将 Sentinel 集成到自己的应用中；

## 快速开始
Sentinel 的使用可以分为两个部分:
- 核心库（Java 客户端）
不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持（见 主流框架适配）。
- 控制台（Dashboard）
Dashboard 主要负责管理推送规则、监控、管理机器信息等。

引入 Sentinel 依赖。如果您的应用使用了 Maven，则在 pom.xml 文件中加入以下代码即可：
```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-core</artifactId>
    <version>1.8.6</version>
</dependency>
```

### 定义资源
资源 是 Sentinel 中的核心概念之一。最常用的资源是我们代码中的 Java 方法。 当然，您也可以更灵活的定义你的资源，

例如，把需要控制流量的代码用 Sentinel API SphU.entry("HelloWorld") 和 entry.exit() 包围起来即可。
在下面的例子中，我们将 System.out.println("hello world"); 作为资源（被保护的逻辑），用 API 包装起来。
参考代码如下:
```
public static void main(String[] args) {
    // 配置规则.
    initFlowRules();

    while (true) {
        // 1.5.0 版本开始可以直接利用 try-with-resources 特性
        try (Entry entry = SphU.entry("HelloWorld")) {
            // 被保护的逻辑
            System.out.println("hello world");
	} catch (BlockException ex) {
            // 处理被流控的逻辑
	    System.out.println("blocked!");
	}
    }
}
```
您也可以通过我们提供的 注解支持模块，来定义我们的资源，类似于下面的代码：
```
@SentinelResource("HelloWorld")
public void helloWorld() {
    // 资源中的逻辑
    System.out.println("hello world");
}
```
这样，helloWorld() 方法就成了我们的一个资源。注意注解支持模块需要配合 Spring AOP 或者 AspectJ 一起使用。

### 定义规则
接下来，通过流控规则来指定允许该资源通过的请求次数，例如下面的代码定义了资源 HelloWorld 每秒最多只能通过 20 个请求。
```
private static void initFlowRules(){
    List<FlowRule> rules = new ArrayList<>();
    FlowRule rule = new FlowRule();
    rule.setResource("HelloWorld");
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    // Set limit QPS to 20.
    rule.setCount(20);
    rules.add(rule);
    FlowRuleManager.loadRules(rules);
}
```

## 启动 Sentinel 控制台
Sentinel 开源控制台支持实时监控和规则管理。
在Sentinel的官网下载最新的控制台jar包，然后在控制台目录下执行以下命令启动控制台：
```
java -jar sentinel-dashboard-1.8.2.jar  
```
启动成功后，可以通过浏览器访问http://localhost:8080/#/dashboard/home查看控制台页面。

客户端需要引入 Transport 模块来与 Sentinel 控制台进行通信。
```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-transport-simple-http</artifactId>
    <version>1.8.6</version>
</dependency>
```
启动时加入 JVM 参数 -Dcsp.sentinel.dashboard.server=consoleIp:port 指定控制台地址和端口。
```
-Dcsp.sentinel.dashboard.server=http://localhost:8080
```
或者客户端配置参数
```
-Dcsp.sentinel.dashboard.server=http://localhost:8080 -Dcsp.sentinel.api.port=8719
```
其他重要的参数
- Dproject.name 指定应用的名称。若未指定，则默认解析 main 函数的类名作为应用名。实际项目使用中建议手动指定应用名。
- Dcsp.sentinel.app.type 指定应用的类型，默认为0 (APP_TYPE_COMMON) 。如果是网关gateway，则为1
- Dcsp.sentinel.api.port=8719 本地启动 HTTP API Server 的端口号

## SpringCloud使用Sentinel
引入 Sentinel 依赖,在SpringCloud上Gateway配置流控
```
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <spring-cloud.version>Hoxton.SR9</spring-cloud.version>
        <spring-boot.version>2.3.2.RELEASE</spring-boot.version>
        <spring-cloud-alibaba.version>2.2.6.RELEASE</spring-cloud-alibaba.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-sentinel-gateway</artifactId>
        </dependency>
    </dependencies>
    
    <dependencyManagement>

        <dependencies>

            <!--Springboot -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-parent</artifactId>
                <version>${spring-boot.version}</version>
                <!--以下两个配置为引用程序版本将有springBoot来进行管理-->
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- SpringCloud -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- SpringCloud Alibaba -->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

```

### 注册应用到 Sentinel 控制台
在应用启动类上添加注解@EnableSentinel注解，然后在配置文件中配置应用名称和Sentinel控制台的地址：
```yaml
spring:  
  cloud:  
    sentinel:  
      transport:  
        dashboard: http://localhost:8080  
      datasource:  
        ds1:  
          nacos:  
            server-addr: localhost:8848  
            dataId: sentinel  
            groupId: DEFAULT_GROUP  
            data-type: json  
```

## 网关流控控制台
Sentinel 1.6.3 引入了网关流控控制台的支持，用户可以直接在 Sentinel 控制台上查看 API Gateway 实时的 route 和自定义 API 分组监控，管理网关规则和 API 分组配置。

集成网关流控控制台，在 API Gateway 端，用户只需要在原有启动参数的基础上添加如下启动参数即可标记应用为 API Gateway 类型：

注：通过 Spring Cloud Alibaba Sentinel 自动接入的 API Gateway 整合则无需此参数 -Dcsp.sentinel.app.type=1 ，参见 Sentinel整合Gateway控制台不显示API管理

添加正确的启动参数并有访问量后，我们就可以在 Sentinel 上面看到对应的 API Gateway 了。我们可以查看实时的 route 和自定义 API 分组的监控和调用信息，并针对其配置规则：

## 编写并测试 Sentinel 规则
Sentinel提供了多种限流降级策略，本文以流控规则为例进行演示。

在需要限流的方法上添加@SentinelResource注解，然后配置流控规则：
```
@GetMapping("/hello")  
@SentinelResource(value = "hello", blockHandler = "blockHandler")  
public String hello() {  
    return "Hello, World!";  
}  
  
public String blockHandler(BlockException e) {  
    return "请求过于频繁，请稍后重试！";  
}  
```
在控制台的流控规则页面添加对应的规则，设置好阈值和统计窗口等参数，然后测试该接口。

## 新增网关流控规则
我们点到请求链路，再点右边的+流控，就可以新增网关流控规则，对里面的参数进行解释：
- API类型：默认就是Route ID类型，如果是这种类型，就代表你要针对整个路由id进行限流，比如你把QPS阈值设置成了10，那么属于这个路由id的微服务中的所有接口在单位时间内加起来只能被访问10次，显然这并不合理，因为我们要限流，肯定不会针对整个微服务都统一限流，而是需要针对接口限流，这个时候就需要第二种API类型：API分组，但要用API分组这种类型，你必须先点击API管理创建API分组，请往下看
- API名称：API名称其实就是你在yml中配置的路由id，路由id就是你在yml中配置的这个横杠 id
- 阈值类型：不解释
- QPS阈值：不解释
- 间隔：表示当达到限流后，你指定时间内的所有请求都会被拒绝
- 流控方式：快速失败，匀速排队，之前就讲过
- Burst size：burst是激增的意思，表示在流量激增的情况下允许的最大流量，比如你把QPS阈值设置为了10，平时超过10就会限流，但是如果你把Burst size设置为了15，突然流量超出了，到达了13，此时也不会限流，除非是继续超过15了，才会被限流，相当于Burst size就是一个流量激增下的扩容的参数；

### API管理
点击API管理后，右边有一个新增自定义API：
这里的API名称你可以随便填：
匹配模式有三种：精确，前缀，正则
- 精确匹配
精确匹配，匹配串是/msb/get，也就是说，我使用API分组类型对这个api创建好限流规则后，你的uri必须是 网关服务地址/msb/get，才能触发我建好的限流规则
- 前缀匹配
前缀匹配是针对你有参数的请求的，比如你的接口是/msb/login/{username}，你要对这个接口限流，你就可以用前缀匹配，在匹配传那里你就要填/msb/login/**，**表示匹配所有，只要前缀是/msb/login/；
注意：前面不能少斜杠，也就是/msb前面的斜杠必须要有，否则匹配不上
- 正则匹配：为什么要有正则匹配？
你看下面两个接口（前面有/msb），假如你要用前缀匹配的方式，那么你的匹配串就要写成/msb/login/星星，显然/msb/login/**也包含了/msb/login/v1/{username}，这样就会导致这两个接口共用一套限流规则了，我下面那个接口就是想要一个单独的规则呢，该怎么办呢？我用精确匹配也不行，因为它有username参数，username是多变的，无法用精确匹配，这个时候就必须使用正则匹配

## Sentinel整合Gateway控制台不显示API管理
在Spring Cloud Gateway整合Sentinel时，发现API管理这个菜单没有显示。

### 查看源码页面
在控制台对应的页面sidebar.html中，我们发现这个菜单时通过entry.isGateway这个条件语句来判断的，那么肯定是因为这个判断了不是网关，所以才不显示。
然后在sidebar.js中，发现在查询客户端注册的信息时，appType为0，而只有当appType为1、11、12时，这里才会认为是网关。

### 查看客户端源码
首先看下心跳发送器SimpleHttpHeartbeatSender，这个类负责提供基本的 API 来向控制台发送心跳请求。可以看到我们发出心跳时，appType是0，那么控制台接受到的肯定也是0，则不会认为这个一个网关应用了。

在SentinelConfig配置类中，我们看到，appType没有配置时，默认为0。但是我们在Cloud Sentinel包中的SentinelSCGAutoConfiguration自动配置类中，发现有设置appType为11。

那么结合以上分析，可以猜到，应该是在心跳比SentinelSCGAutoConfiguration先加载，所以控制台获取的的appType为0了。

实际Debug发现，果然如此。

### 解决方案
既然找到了是因为心跳优先发送了appType，那么我们需要事先在发送心跳之前配置appType。
- 配置JVM启动参数
可以在IDEA中，或者java -jar配置启动参数
```
-Dcsp.sentinel.app.type=1
```

- 启动类直接设置系统参数
```
public static void main(String[] args) {
    System.setProperty("csp.sentinel.app.type", "1");
    SpringApplication.run(GatewayApp.class);
}
```

## 进阶使用

### Sentinel Dashboard 使用详解
Sentinel Dashboard是Sentinel的可视化监控平台，可以用于实时监控应用的流量、延迟、异常等指标，并对应用进行限流降级等操作。

Sentinel客户端首先向Sentinel Dashboard注册。Sentinel Dashboard返回一个token给客户端，客户端将使用该token连接Sentinel。

应用程序将使用token连接Sentinel，Sentinel客户端将返回连接成功信息。Sentinel客户端将实时推送metrics数据到Sentinel Dashboard，Sentinel Dashboard将监控和管理应用程序。

### 入门级规则配置详解（流控规则、降级规则、热点参数限流）
Sentinel是一款开源的流量控制和降级框架，提供多种限流降级策略，包括流控规则、降级规则、热点参数限流等。

下面将逐一介绍这些规则。

### 流控规则
流控规则用于限制系统的流量，可以通过设置QPS流量控制和线程数流量控制等方式来控制系统的访问速度。

在Sentinel Dashboard中，可以通过以下步骤来配置和管理流控规则：

设置流控模式 ：可以选择直接拒绝、Warm Up、匀速排队等模式。
设置阈值 ：可以设置QPS、线程数等阈值来限制流量。
设置流控策略 ：可以选择按照调用关系、链路入口等策略来限制流量。
查看已有规则 ：可以查看已经存在的流控规则，并进行管理和修改。

### 降级规则
降级规则用于应对系统的异常情况，可以通过设置异常比例降级、异常数降级和慢调用降级等方式来降低系统的负载。

在Sentinel Dashboard中，可以通过以下步骤来配置和管理降级规则：

设置降级模式 ：可以选择异常比例、异常数和慢调用三种模式。
设置阈值 ：可以设置异常比例、异常数和慢调用时间等阈值来触发降级。
设置降级策略 ：可以选择返回特定的错误信息、调用备用服务等策略来处理降级情况。
查看已有规则 ：可以查看已经存在的降级规则，并进行管理和修改。

### 热点参数限流
热点参数限流用于对热点参数进行限流，可以有效避免某些参数被过多地请求。在Sentinel Dashboard中，可以通过以下步骤来配置和管理热点参数限流规则：

设置参数 ：可以选择需要进行限流的参数。
设置阈值 ：可以设置QPS、线程数等阈值来限制热点参数的访问速度。
设置限流策略 ：可以选择直接拒绝、匀速排队等策略来处理热点参数限流。
查看已有规则 ：可以查看已经存在的热点参数限流规则，并进行管理和修改。
在使用这些规则时，需要注意参数设置和阈值设置等细节，以避免规则的误判或限流不准确等问题。

通过Sentinel Dashboard的可视化界面，可以方便地进行规则的配置和管理， 提高系统的稳定性和可靠性 。

### 资源名与 URL 匹配规则
Sentinel的资源名和URL匹配规则是限流降级策略的重要组成部分，可以根据业务需求定义合适的匹配规则。

资源名 ：可以是一个具体的业务方法、一个接口URL或者一个Dubbo服务等。
URL 匹配规则 ：支持Ant匹配和正则匹配两种方式，可以根据具体需求进行选择。
Dubbo服务 ：Sentinel支持对Dubbo服务进行限流降级操作，需要在Dubbo配置文件中添加Sentinel的拦截器配置。
在定义资源名和URL匹配规则时，需要注意 合理性和精确性 ，以避免出现误判或限流不准确等问题。

应用程序通过 Sentinel 客户端向 Sentinel 发送配置请求，Sentinel 返回配置结果。应用程序根据配置结果使用 Sentinel 进行限流降级。

在这个过程中，应用程序需要注意合理性和精确性，以避免出现误判或限流不准确等问题。

## Spring Cloud Alibaba Sentinel 整合

### Sentinel Starter 简介
Sentinel Starter是Spring Cloud Alibaba Sentinel的快速入门依赖，提供了自动化配置和默认规则等能力，可以简化Sentinel在Spring Cloud中的使用。

在使用Sentinel Starter时，只需要添加依赖并在配置文件中配置相应的参数，即可快速实现Sentinel的限流降级功能。

### 使用 Sentinel Starter 整合 Spring Cloud 微服务
在Spring Boot项目中添加以下依赖：
```
<dependency>  
    <groupId>com.alibaba.cloud</groupId>  
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>  
</dependency>  
```
在application.yml配置文件中添加以下配置：
```
spring:  
  cloud:  
    sentinel:  
      transport:  
        dashboard: localhost:8080 # Sentinel控制台地址  
        port: 8719  
      datasource:  
        ds1:  
          nacos:  
            server-addr: localhost:8848 # Nacos配置中心地址  
            dataId: $ {spring.application.name}-sentinel # Sentinel配置数据ID  
            groupId: DEFAULT_GROUP  
            data-type: json  
            rule-type: flow,degrade # Sentinel规则类型  
```
在代码中添加注解 @EnableSentinel ，开启 Sentinel 功能。
```java
@SpringBootApplication  
@EnableDiscoveryClient  
@EnableFeignClients  
@EnableCircuitBreaker  
@EnableSentinel // 开启 Sentinel 功能  
public class ProductServiceApplication {  
    public static void main(String[] args) {  
        SpringApplication.run(ProductServiceApplication.class, args);  
    }  
}  
```
使用注解 @SentinelResource 对需要进行限流和降级的接口进行配置。
```
@RestController  
public class ProductController {  
  
    @Autowired  
    private ProductService productService;  
  
    @GetMapping("/products/{id}")  
    @SentinelResource(value = "products/{id}", blockHandlerClass = ProductControllerBlockHandler.class, blockHandler = "handleBlock")  
    public Product getProduct(@PathVariable Long id) {  
        return productService.getProduct(id);  
    }  
}  
```
其中，@SentinelResource 注解中的 value 参数为资源名称，blockHandlerClass 和 blockHandler 分别指定了限流或降级时的处理类和方法。

## 主流框架的适配
sentinel也对一些主流的框架进行了适配，使得在使用主流框架时，也可以享受到sentinel的保护。目前已经支持的适配器包括以下这些：
- Web Servlet
- Dubbo
- Spring Boot / Spring Cloud
- gRPC
- Apache RocketMQ
其实做适配就是通过那些主流框架的扩展点，然后在扩展点上加入sentinel限流降级的代码即可。拿Servlet的适配代码看一下，具体的代码是：
```java
public class CommonFilter implements Filter {

    /**
     * Specify whether the URL resource name should contain the HTTP method prefix (e.g. {@code POST:}).
     */
    public static final String HTTP_METHOD_SPECIFY = "HTTP_METHOD_SPECIFY";
    /**
     * If enabled, use the default context name, or else use the URL path as the context name,
     * {@link WebServletConfig#WEB_SERVLET_CONTEXT_NAME}. Please pay attention to the number of context (EntranceNode),
     * which may affect the memory footprint.
     *
     * @since 1.7.0
     */
    public static final String WEB_CONTEXT_UNIFY = "WEB_CONTEXT_UNIFY";

    private final static String COLON = ":";

    private boolean httpMethodSpecify = false;
    private boolean webContextUnify = true;

    @Override
    public void init(FilterConfig filterConfig) {
        httpMethodSpecify = Boolean.parseBoolean(filterConfig.getInitParameter(HTTP_METHOD_SPECIFY));
        if (filterConfig.getInitParameter(WEB_CONTEXT_UNIFY) != null) {
            webContextUnify = Boolean.parseBoolean(filterConfig.getInitParameter(WEB_CONTEXT_UNIFY));
        }
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest sRequest = (HttpServletRequest) request;
        Entry urlEntry = null;

        try {
            String target = FilterUtil.filterTarget(sRequest);
            // Clean and unify the URL.
            // For REST APIs, you have to clean the URL (e.g. `/foo/1` and `/foo/2` -> `/foo/:id`), or
            // the amount of context and resources will exceed the threshold.
            UrlCleaner urlCleaner = WebCallbackManager.getUrlCleaner();
            if (urlCleaner != null) {
                target = urlCleaner.clean(target);
            }

            // If you intend to exclude some URLs, you can convert the URLs to the empty string ""
            // in the UrlCleaner implementation.
            if (!StringUtil.isEmpty(target)) {
                // Parse the request origin using registered origin parser.
                String origin = parseOrigin(sRequest);
                String contextName = webContextUnify ? WebServletConfig.WEB_SERVLET_CONTEXT_NAME : target;
                ContextUtil.enter(contextName, origin);

                if (httpMethodSpecify) {
                    // Add HTTP method prefix if necessary.
                    String pathWithHttpMethod = sRequest.getMethod().toUpperCase() + COLON + target;
                    urlEntry = SphU.entry(pathWithHttpMethod, ResourceTypeConstants.COMMON_WEB, EntryType.IN);
                } else {
                    urlEntry = SphU.entry(target, ResourceTypeConstants.COMMON_WEB, EntryType.IN);
                }
            }
            chain.doFilter(request, response);
        } catch (BlockException e) {
            HttpServletResponse sResponse = (HttpServletResponse) response;
            // Return the block page, or redirect to another URL.
            WebCallbackManager.getUrlBlockHandler().blocked(sRequest, sResponse, e);
        } catch (IOException | ServletException | RuntimeException e2) {
            Tracer.traceEntry(e2, urlEntry);
            throw e2;
        } finally {
            if (urlEntry != null) {
                urlEntry.exit();
            }
            ContextUtil.exit();
        }
    }

    private String parseOrigin(HttpServletRequest request) {
        RequestOriginParser originParser = WebCallbackManager.getRequestOriginParser();
        String origin = EMPTY_ORIGIN;
        if (originParser != null) {
            origin = originParser.parseOrigin(request);
            if (StringUtil.isEmpty(origin)) {
                return EMPTY_ORIGIN;
            }
        }
        return origin;
    }

    @Override
    public void destroy() {

    }

    private static final String EMPTY_ORIGIN = "";
}

```
通过Servlet的Filter进行扩展，实现一个Filter，然后在doFilter方法中对请求进行限流控制，如果请求被限流则将请求重定向到一个默认页面，否则将请求放行给下一个Filter。

## 规则持久化，动态化
Sentinel 的理念是开发者只需要关注资源的定义，当资源定义成功，可以动态增加各种流控降级规则。

Sentinel 提供两种方式修改规则：
- 通过 API 直接修改 ( loadRules)
- 通过 DataSource适配不同数据源修改

通过 API 修改比较直观，可以通过以下三个 API 修改不同的规则：
```
FlowRuleManager.loadRules(List<FlowRule> rules);// 修改流控规则
DegradeRuleManager.loadRules(List<DegradeRule> rules);// 修改降级规则
SystemRuleManager.loadRules(List<SystemRule> rules);// 修改系统规则
```

## DataSource 扩展
上述 loadRules() 方法只接受内存态的规则对象，但应用重启后内存中的规则就会丢失，更多的时候规则最好能够存储在文件、数据库或者配置中心中。

DataSource 接口给我们提供了对接任意配置源的能力。相比直接通过 API 修改规则，实现 DataSource 接口是更加可靠的做法。

官方推荐通过控制台设置规则后将规则推送到统一的规则中心，用户只需要实现 DataSource 接口，来监听规则中心的规则变化，以实时获取变更的规则。

DataSource 拓展常见的实现方式有：
- 拉模式：客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 SQL、文件，甚至是 VCS 等。这样做的方式是简单，缺点是无法及时获取变更；
- 推模式：规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。