---
layout: post
categories: Sentinel
description: none
keywords: Sentinel
---
# Sentinel流控入门
Sentinel是阿里巴巴开源的一款 轻量级流量控制、熔断降级工具，它提供了实时的流量控制，熔断降级等功能，能够帮助我们实现服务的高可用性和稳定性。

## 关于 Sentinel
Sentinel 是阿里巴巴开源的一款针对分布式系统的流量控制、熔断降级的框架。在微服务架构的系统中，请求流量复杂多样，可能会因为某一个服务异常而导致整体服务不可用，这时候需要熔断降级，而`Sentinel`就提供了这样的解决方案。

## Sentinel 的历史
- 2012 年，Sentinel 诞生，主要功能为入口流量控制。
- 2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。
- 2018 年，Sentinel 开源，并持续演进。
- 2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 C++ 原生版本，同时针对 Service Mesh 场景也推出了 Envoy 集群流量控制支持，以解决 Service Mesh 架构下多语言限流的问题。
- 2020 年，推出 Sentinel Go 版本，继续朝着云原生方向演进。
- 2021 年，Sentinel 正在朝着 2.0 云原生高可用决策中心组件进行演进；同时推出了 Sentinel Rust 原生版本。同时我们也在 Rust 社区进行了 Envoy WASM extension 及 eBPF extension 等场景探索。
- 2022 年，Sentinel 品牌升级为流量治理，领域涵盖流量路由/调度、流量染色、流控降级、过载保护/实例摘除等；同时社区将流量治理相关标准抽出到 OpenSergo 标准中，Sentinel 作为流量治理标准实现。

## Sentinel 的作用和优势
Sentinel 可以针对服务方法调用、HTTP 请求、Dubbo 服务等，进行实时的流量控制、熔断降级，确保服务高可用，同时还可以提供实时的监控和报警功能。

Sentinel 有以下一些优势：
- 丰富的应用场景和细粒度的控制
Sentinel 支持多种应用场景，包括熔断降级、流量控制、系统保护、热点参数限流等，而且可以实现细粒度的控制；
- 强大的实时监测机制
Sentinel 提供了实时的监测、报警机制，能够对系统运行情况进行实时检测和通知，发现问题更加及时；
- 易于扩展
Sentinel 为开发者提供了简单易用的扩展接口，开发者可以方便的实现自定义的控制和监测逻辑；
- 易于集成
Sentinel 支持多种开发框架，包括 Spring Cloud、Dubbo、Feign 等，开发者可以很方便的将 Sentinel 集成到自己的应用中；

## 快速开始
Sentinel 的使用可以分为两个部分:
- 核心库（Java 客户端）
不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持（见 主流框架适配）。
- 控制台（Dashboard）
Dashboard 主要负责管理推送规则、监控、管理机器信息等。

引入 Sentinel 依赖。如果您的应用使用了 Maven，则在 pom.xml 文件中加入以下代码即可：
```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-core</artifactId>
    <version>1.8.6</version>
</dependency>
```

### 定义资源
资源 是 Sentinel 中的核心概念之一。最常用的资源是我们代码中的 Java 方法。 当然，您也可以更灵活的定义你的资源，

例如，把需要控制流量的代码用 Sentinel API SphU.entry("HelloWorld") 和 entry.exit() 包围起来即可。
在下面的例子中，我们将 System.out.println("hello world"); 作为资源（被保护的逻辑），用 API 包装起来。
参考代码如下:
```
public static void main(String[] args) {
    // 配置规则.
    initFlowRules();

    while (true) {
        // 1.5.0 版本开始可以直接利用 try-with-resources 特性
        try (Entry entry = SphU.entry("HelloWorld")) {
            // 被保护的逻辑
            System.out.println("hello world");
	} catch (BlockException ex) {
            // 处理被流控的逻辑
	    System.out.println("blocked!");
	}
    }
}
```
您也可以通过我们提供的 注解支持模块，来定义我们的资源，类似于下面的代码：
```
@SentinelResource("HelloWorld")
public void helloWorld() {
    // 资源中的逻辑
    System.out.println("hello world");
}
```
这样，helloWorld() 方法就成了我们的一个资源。注意注解支持模块需要配合 Spring AOP 或者 AspectJ 一起使用。

### 定义规则
接下来，通过流控规则来指定允许该资源通过的请求次数，例如下面的代码定义了资源 HelloWorld 每秒最多只能通过 20 个请求。
```
private static void initFlowRules(){
    List<FlowRule> rules = new ArrayList<>();
    FlowRule rule = new FlowRule();
    rule.setResource("HelloWorld");
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    // Set limit QPS to 20.
    rule.setCount(20);
    rules.add(rule);
    FlowRuleManager.loadRules(rules);
}
```

## 启动 Sentinel 控制台
Sentinel 开源控制台支持实时监控和规则管理。
在Sentinel的官网下载最新的控制台jar包，然后在控制台目录下执行以下命令启动控制台：
```
java -jar sentinel-dashboard-1.8.2.jar  
```
启动成功后，可以通过浏览器访问http://localhost:8080/#/dashboard/home查看控制台页面。

客户端需要引入 Transport 模块来与 Sentinel 控制台进行通信。
```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-transport-simple-http</artifactId>
    <version>1.8.6</version>
</dependency>
```
启动时加入 JVM 参数 -Dcsp.sentinel.dashboard.server=consoleIp:port 指定控制台地址和端口。
```
-Dcsp.sentinel.dashboard.server=http://localhost:8080
```
或者客户端配置参数
```
-Dcsp.sentinel.dashboard.server=http://localhost:8080 -Dcsp.sentinel.api.port=8719
```
其他重要的参数
- Dproject.name 指定应用的名称。若未指定，则默认解析 main 函数的类名作为应用名。实际项目使用中建议手动指定应用名。
- Dcsp.sentinel.app.type 指定应用的类型，默认为0 (APP_TYPE_COMMON) 。如果是网关gateway，则为1
- Dcsp.sentinel.api.port=8719 本地启动 HTTP API Server 的端口号

## SpringCloud使用Sentinel
引入 Sentinel 依赖
```
<dependency>  
    <groupId>com.alibaba.cloud</groupId>  
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>  
</dependency>  
```

### 注册应用到 Sentinel 控制台
在应用启动类上添加注解@EnableSentinel注解，然后在配置文件中配置应用名称和Sentinel控制台的地址：
```yaml
spring:  
  cloud:  
    sentinel:  
      transport:  
        dashboard: localhost:8080  
      datasource:  
        ds1:  
          nacos:  
            server-addr: localhost:8848  
            dataId: sentinel  
            groupId: DEFAULT_GROUP  
            data-type: json  
```
编写并测试 Sentinel 规则
Sentinel提供了多种限流降级策略，本文以流控规则为例进行演示。

在需要限流的方法上添加@SentinelResource注解，然后配置流控规则：
```
@GetMapping("/hello")  
@SentinelResource(value = "hello", blockHandler = "blockHandler")  
public String hello() {  
    return "Hello, World!";  
}  
  
public String blockHandler(BlockException e) {  
    return "请求过于频繁，请稍后重试！";  
}  
```
在控制台的流控规则页面添加对应的规则，设置好阈值和统计窗口等参数，然后测试该接口。

## 进阶使用

### Sentinel Dashboard 使用详解
Sentinel Dashboard是Sentinel的可视化监控平台，可以用于实时监控应用的流量、延迟、异常等指标，并对应用进行限流降级等操作。

Sentinel客户端首先向Sentinel Dashboard注册。Sentinel Dashboard返回一个token给客户端，客户端将使用该token连接Sentinel。

应用程序将使用token连接Sentinel，Sentinel客户端将返回连接成功信息。Sentinel客户端将实时推送metrics数据到Sentinel Dashboard，Sentinel Dashboard将监控和管理应用程序。

### 入门级规则配置详解（流控规则、降级规则、热点参数限流）
Sentinel是一款开源的流量控制和降级框架，提供多种限流降级策略，包括流控规则、降级规则、热点参数限流等。

下面将逐一介绍这些规则。

### 流控规则
流控规则用于限制系统的流量，可以通过设置QPS流量控制和线程数流量控制等方式来控制系统的访问速度。

在Sentinel Dashboard中，可以通过以下步骤来配置和管理流控规则：

设置流控模式 ：可以选择直接拒绝、Warm Up、匀速排队等模式。
设置阈值 ：可以设置QPS、线程数等阈值来限制流量。
设置流控策略 ：可以选择按照调用关系、链路入口等策略来限制流量。
查看已有规则 ：可以查看已经存在的流控规则，并进行管理和修改。

### 降级规则
降级规则用于应对系统的异常情况，可以通过设置异常比例降级、异常数降级和慢调用降级等方式来降低系统的负载。

在Sentinel Dashboard中，可以通过以下步骤来配置和管理降级规则：

设置降级模式 ：可以选择异常比例、异常数和慢调用三种模式。
设置阈值 ：可以设置异常比例、异常数和慢调用时间等阈值来触发降级。
设置降级策略 ：可以选择返回特定的错误信息、调用备用服务等策略来处理降级情况。
查看已有规则 ：可以查看已经存在的降级规则，并进行管理和修改。

### 热点参数限流
热点参数限流用于对热点参数进行限流，可以有效避免某些参数被过多地请求。在Sentinel Dashboard中，可以通过以下步骤来配置和管理热点参数限流规则：

设置参数 ：可以选择需要进行限流的参数。
设置阈值 ：可以设置QPS、线程数等阈值来限制热点参数的访问速度。
设置限流策略 ：可以选择直接拒绝、匀速排队等策略来处理热点参数限流。
查看已有规则 ：可以查看已经存在的热点参数限流规则，并进行管理和修改。
在使用这些规则时，需要注意参数设置和阈值设置等细节，以避免规则的误判或限流不准确等问题。

通过Sentinel Dashboard的可视化界面，可以方便地进行规则的配置和管理， 提高系统的稳定性和可靠性 。

### 资源名与 URL 匹配规则
Sentinel的资源名和URL匹配规则是限流降级策略的重要组成部分，可以根据业务需求定义合适的匹配规则。

资源名 ：可以是一个具体的业务方法、一个接口URL或者一个Dubbo服务等。
URL 匹配规则 ：支持Ant匹配和正则匹配两种方式，可以根据具体需求进行选择。
Dubbo服务 ：Sentinel支持对Dubbo服务进行限流降级操作，需要在Dubbo配置文件中添加Sentinel的拦截器配置。
在定义资源名和URL匹配规则时，需要注意 合理性和精确性 ，以避免出现误判或限流不准确等问题。

应用程序通过 Sentinel 客户端向 Sentinel 发送配置请求，Sentinel 返回配置结果。应用程序根据配置结果使用 Sentinel 进行限流降级。

在这个过程中，应用程序需要注意合理性和精确性，以避免出现误判或限流不准确等问题。

## Spring Cloud Alibaba Sentinel 整合

### Sentinel Starter 简介
Sentinel Starter是Spring Cloud Alibaba Sentinel的快速入门依赖，提供了自动化配置和默认规则等能力，可以简化Sentinel在Spring Cloud中的使用。

在使用Sentinel Starter时，只需要添加依赖并在配置文件中配置相应的参数，即可快速实现Sentinel的限流降级功能。

### 使用 Sentinel Starter 整合 Spring Cloud 微服务
在Spring Boot项目中添加以下依赖：
```
<dependency>  
    <groupId>com.alibaba.cloud</groupId>  
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>  
</dependency>  
```
在application.yml配置文件中添加以下配置：
```
spring:  
  cloud:  
    sentinel:  
      transport:  
        dashboard: localhost:8080 # Sentinel控制台地址  
        port: 8719  
      datasource:  
        ds1:  
          nacos:  
            server-addr: localhost:8848 # Nacos配置中心地址  
            dataId: $ {spring.application.name}-sentinel # Sentinel配置数据ID  
            groupId: DEFAULT_GROUP  
            data-type: json  
            rule-type: flow,degrade # Sentinel规则类型  
```
在代码中添加注解 @EnableSentinel ，开启 Sentinel 功能。
```java
@SpringBootApplication  
@EnableDiscoveryClient  
@EnableFeignClients  
@EnableCircuitBreaker  
@EnableSentinel // 开启 Sentinel 功能  
public class ProductServiceApplication {  
    public static void main(String[] args) {  
        SpringApplication.run(ProductServiceApplication.class, args);  
    }  
}  
```
使用注解 @SentinelResource 对需要进行限流和降级的接口进行配置。
```
@RestController  
public class ProductController {  
  
    @Autowired  
    private ProductService productService;  
  
    @GetMapping("/products/{id}")  
    @SentinelResource(value = "products/{id}", blockHandlerClass = ProductControllerBlockHandler.class, blockHandler = "handleBlock")  
    public Product getProduct(@PathVariable Long id) {  
        return productService.getProduct(id);  
    }  
}  
```
其中，@SentinelResource 注解中的 value 参数为资源名称，blockHandlerClass 和 blockHandler 分别指定了限流或降级时的处理类和方法。

## 主流框架的适配
sentinel也对一些主流的框架进行了适配，使得在使用主流框架时，也可以享受到sentinel的保护。目前已经支持的适配器包括以下这些：
- Web Servlet
- Dubbo
- Spring Boot / Spring Cloud
- gRPC
- Apache RocketMQ
其实做适配就是通过那些主流框架的扩展点，然后在扩展点上加入sentinel限流降级的代码即可。拿Servlet的适配代码看一下，具体的代码是：
```java
public class CommonFilter implements Filter {

    /**
     * Specify whether the URL resource name should contain the HTTP method prefix (e.g. {@code POST:}).
     */
    public static final String HTTP_METHOD_SPECIFY = "HTTP_METHOD_SPECIFY";
    /**
     * If enabled, use the default context name, or else use the URL path as the context name,
     * {@link WebServletConfig#WEB_SERVLET_CONTEXT_NAME}. Please pay attention to the number of context (EntranceNode),
     * which may affect the memory footprint.
     *
     * @since 1.7.0
     */
    public static final String WEB_CONTEXT_UNIFY = "WEB_CONTEXT_UNIFY";

    private final static String COLON = ":";

    private boolean httpMethodSpecify = false;
    private boolean webContextUnify = true;

    @Override
    public void init(FilterConfig filterConfig) {
        httpMethodSpecify = Boolean.parseBoolean(filterConfig.getInitParameter(HTTP_METHOD_SPECIFY));
        if (filterConfig.getInitParameter(WEB_CONTEXT_UNIFY) != null) {
            webContextUnify = Boolean.parseBoolean(filterConfig.getInitParameter(WEB_CONTEXT_UNIFY));
        }
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest sRequest = (HttpServletRequest) request;
        Entry urlEntry = null;

        try {
            String target = FilterUtil.filterTarget(sRequest);
            // Clean and unify the URL.
            // For REST APIs, you have to clean the URL (e.g. `/foo/1` and `/foo/2` -> `/foo/:id`), or
            // the amount of context and resources will exceed the threshold.
            UrlCleaner urlCleaner = WebCallbackManager.getUrlCleaner();
            if (urlCleaner != null) {
                target = urlCleaner.clean(target);
            }

            // If you intend to exclude some URLs, you can convert the URLs to the empty string ""
            // in the UrlCleaner implementation.
            if (!StringUtil.isEmpty(target)) {
                // Parse the request origin using registered origin parser.
                String origin = parseOrigin(sRequest);
                String contextName = webContextUnify ? WebServletConfig.WEB_SERVLET_CONTEXT_NAME : target;
                ContextUtil.enter(contextName, origin);

                if (httpMethodSpecify) {
                    // Add HTTP method prefix if necessary.
                    String pathWithHttpMethod = sRequest.getMethod().toUpperCase() + COLON + target;
                    urlEntry = SphU.entry(pathWithHttpMethod, ResourceTypeConstants.COMMON_WEB, EntryType.IN);
                } else {
                    urlEntry = SphU.entry(target, ResourceTypeConstants.COMMON_WEB, EntryType.IN);
                }
            }
            chain.doFilter(request, response);
        } catch (BlockException e) {
            HttpServletResponse sResponse = (HttpServletResponse) response;
            // Return the block page, or redirect to another URL.
            WebCallbackManager.getUrlBlockHandler().blocked(sRequest, sResponse, e);
        } catch (IOException | ServletException | RuntimeException e2) {
            Tracer.traceEntry(e2, urlEntry);
            throw e2;
        } finally {
            if (urlEntry != null) {
                urlEntry.exit();
            }
            ContextUtil.exit();
        }
    }

    private String parseOrigin(HttpServletRequest request) {
        RequestOriginParser originParser = WebCallbackManager.getRequestOriginParser();
        String origin = EMPTY_ORIGIN;
        if (originParser != null) {
            origin = originParser.parseOrigin(request);
            if (StringUtil.isEmpty(origin)) {
                return EMPTY_ORIGIN;
            }
        }
        return origin;
    }

    @Override
    public void destroy() {

    }

    private static final String EMPTY_ORIGIN = "";
}

```
通过Servlet的Filter进行扩展，实现一个Filter，然后在doFilter方法中对请求进行限流控制，如果请求被限流则将请求重定向到一个默认页面，否则将请求放行给下一个Filter。

## 规则持久化，动态化
Sentinel 的理念是开发者只需要关注资源的定义，当资源定义成功，可以动态增加各种流控降级规则。

Sentinel 提供两种方式修改规则：
- 通过 API 直接修改 ( loadRules)
- 通过 DataSource适配不同数据源修改

通过 API 修改比较直观，可以通过以下三个 API 修改不同的规则：
```
FlowRuleManager.loadRules(List<FlowRule> rules);// 修改流控规则
DegradeRuleManager.loadRules(List<DegradeRule> rules);// 修改降级规则
SystemRuleManager.loadRules(List<SystemRule> rules);// 修改系统规则
```

## DataSource 扩展
上述 loadRules() 方法只接受内存态的规则对象，但应用重启后内存中的规则就会丢失，更多的时候规则最好能够存储在文件、数据库或者配置中心中。

DataSource 接口给我们提供了对接任意配置源的能力。相比直接通过 API 修改规则，实现 DataSource 接口是更加可靠的做法。

官方推荐通过控制台设置规则后将规则推送到统一的规则中心，用户只需要实现 DataSource 接口，来监听规则中心的规则变化，以实时获取变更的规则。

DataSource 拓展常见的实现方式有：
- 拉模式：客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 SQL、文件，甚至是 VCS 等。这样做的方式是简单，缺点是无法及时获取变更；
- 推模式：规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。