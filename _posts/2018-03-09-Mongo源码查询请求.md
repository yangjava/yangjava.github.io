---
layout: post
categories: [Mongodb]
description: none
keywords: MongoDB
---
# Mongo源码查询请求


## mongodb查询请求
首先进入mongo的查询请求部分.mongo的查询请求部分归纳起来很简单就是将请求分装成一个Message结构,然后将其发送到服务端,等待服务端的相应数据,取得数据最后显示结果。

下面来看具体流程分析吧。当我们点击db.coll.find({x:1})时，我们首先来到了mongo/shell/dbshell.cpp
```
            if (!wascmd) {
                try {
                    lastLineSuccessful = scope->exec(code.c_str(), "(shell)", false, true, false);
                    if (lastLineSuccessful) {
                        scope->exec(
                            "shellPrintHelper( __lastres__ );", "(shell2)", true, true, false);
                    }
                } catch (std::exception& e) {
                    std::cout << "error:" << e.what() << std::endl;
                    lastLineSuccessful = false;
                }
            }
```
下面进入javascript代码,其在mongo/shell/collection.js。
```
DBCollection.prototype.find = function(query, fields, limit, skip, batchSize, options) {
    var cursor = new DBQuery(this._mongo,
                             this._db,
                             this,
                             this._fullName,
                             this._massageObject(query),
                             fields,
                             limit,
                             skip,
                             batchSize,
                             options || this.getQueryOptions());

    {
        const session = this.getDB().getSession();

        const readPreference = session._getSessionAwareClient().getReadPreference(session);
        if (readPreference !== null) {
            cursor.readPref(readPreference.mode, readPreference.tags);
        }

        const readConcern = session._getSessionAwareClient().getReadConcern(session);
        if (readConcern !== null) {
            cursor.readConcern(readConcern.level);
        }
    }

    return cursor;
};
```

那么我们继续前进来到DBClientConnection::query函数，该函数只是简单调用了DBClientBase::query函数.
```
unique_ptr<DBClientCursor> DBClientBase::query(const NamespaceStringOrUUID& nsOrUuid,
                                               Query query,
                                               int nToReturn,
                                               int nToSkip,
                                               const BSONObj* fieldsToReturn,
                                               int queryOptions,
                                               int batchSize,
                                               boost::optional<BSONObj> readConcernObj) {
                                               // 根据传入的参数创建一个DBClientCursor对象
    unique_ptr<DBClientCursor> c(new DBClientCursor(this,
                                                    nsOrUuid,
                                                    query.obj,
                                                    nToReturn,
                                                    nToSkip,
                                                    fieldsToReturn,
                                                    queryOptions,
                                                    batchSize,
                                                    readConcernObj));
    // 创建Message并向服务端发送查询请求return c;                                                
    if (c->init())
        return c;
    return nullptr;
}
```

```
bool DBClientCursor::init() {
    invariant(!_connectionHasPendingReplies);
    Message toSend = _assembleInit();
    //构建将要发送的查询请求这是一个Message,具体来说Message负责发送数据,具体的数据是在MsgData中
    verify(_client);
    Message reply;
    try {
        _client->call(toSend, reply, true, &_originalHost);
    } catch (const DBException&) {
        // log msg temp?
        LOGV2(20127, "DBClientCursor::init call() failed");
        // We always want to throw on network exceptions.
        throw;
    }
    //实际的发送数据,同时这里发送了数据后会调用recv接收数据
    if (reply.empty()) {
        // log msg temp?
        LOGV2(20128, "DBClientCursor::init message from call() was empty");
        return false;
    }
    dataReceived(reply);
    return true;
}
```
_assembleInit是创建一个message结构，若是第一次请求那么请求操作为dbQuery,若不是则请求操作为dbGetmore。
```
Message DBClientCursor::_assembleGetMore() {
    invariant(cursorId);
    if (_useFindCommand) {
        std::int64_t batchSize = nextBatchSize();
        auto gmr = GetMoreRequest(ns,
                                  cursorId,
                                  boost::make_optional(batchSize != 0, batchSize),
                                  boost::make_optional(tailableAwaitData(),
                                                       _awaitDataTimeout),  // awaitDataTimeout
                                  _term,
                                  _lastKnownCommittedOpTime);
        auto msg = assembleCommandRequest(_client, ns.db(), opts, gmr.toBSON());
        // Set the exhaust flag if needed.
        if (opts & QueryOption_Exhaust && msg.operation() == dbMsg) {
            OpMsg::setFlag(&msg, OpMsg::kExhaustSupported);
        }
        return msg;
    } else {
        // Assemble a legacy getMore request.
        return makeGetMoreMessage(ns.ns(), cursorId, nextBatchSize(), opts);
    }
}
```

来看看MsgData的具体结构,消息的定义在message.h文件中。
```
struct Layout {
    int32_t messageLength;  // total message size, including this
    int32_t requestID;      // identifier for this message
    int32_t responseTo;     // requestID from the original request
    //   (used in responses from db)
    int32_t opCode;
};
```

```
┌──────────────────────────────────────────────┐
│  messageLength(包含整个message结构的长度)        │
├──────────────────────────────────────────────┤
│  id(请求标识)                                  │
├──────────────────────────────────────────────┤
│  responseTo(响应ID)                           │
└──────────────────────────────────────────────┘
```