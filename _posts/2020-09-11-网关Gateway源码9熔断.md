---
layout: post
categories: [Gateway]
description: none
keywords: Gateway
---
# 网关Gateway源码9熔断

## 概述
HystrixGatewayFilterFactory通过构造一个GatewayFilter的匿名内部类实例，来生产熔断过滤器（Route级别的熔断），要启用这个filter，需要引入Hystrix依赖：
```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
```
yml配置示例：
```
spring:
  cloud:
    gateway:
      routes:
      # 姑且假设是路由到用户服务吧
      - id: user-service
        uri: lb://user-service
        order: 10000
        predicates:
        - Path=/user/**
        filters:
        - RewritePath=/user/(?<path>.*), /$\{path}
        # 指定使用HystrixGatewayFilterFactory生成filter
        - name: Hystrix
          args:
            # 指定hystrix command的名称
            name: hystrixCmd
            # 注意fallbackUri要以forward开头
            fallbackUri: forward:/fallback
```
熔断返回示例：
```
@RestController
@RequestMapping("/fallback")
public class FallbackController {

    @RequestMapping("")
    public String fallback(){
        return "error";
    }
}
```

## HystrixGatewayFilterFactory核心源码解析
```
public GatewayFilter apply(Config config) {
    // 1.第一次创建 filter config时，是没有这个setter字段的，它是用于构造HystrixCommand
    if (config.setter == null) {
        // 这里的name实际是我们在yml配置的filter的args参数中的name，比如：hystrixCmd
        Assert.notNull(config.name,
            "A name must be supplied for the Hystrix Command Key");
        // 这里是把HystrixGatewayFilterFactory这个类名作为HystrixCommandGroup的key
        HystrixCommandGroupKey groupKey = HystrixCommandGroupKey.Factory
            .asKey(getClass().getSimpleName());
        // 通过我们配置的hystrix命令名作为HystrixCommand的key
        HystrixCommandKey commandKey = HystrixCommandKey.Factory.asKey(config.name);
        // groupKey和commandKey为参数来构造一个setter
        config.setter = Setter.withGroupKey(groupKey).andCommandKey(commandKey);
    }

    // 真正开始生产熔断功能的GatewayFilter
    return new GatewayFilter() {
        @Override
        public Mono<Void> filter(ServerWebExchange exchange,
                GatewayFilterChain chain) {
            return Mono.deferWithContext(context -> {
                // 1.用config里的参数构造一个RouteHystrixCommand
                RouteHystrixCommand command = new RouteHystrixCommand(
                // 这里的createCommandSetter实际直接返回了config.setter
                // 估计是打算以后扩展这个方法，加些额外的操作
                createCommandSetter(config, exchange), config.fallbackUri,
                        exchange, chain, context);

		return Mono.create(s -> {
                    // 2.使用Observable<HystrixCommand>订阅
                    //   订阅的三项内容分别是onNext、onError、onComplete
                    Subscription sub = command.toObservable().subscribe(s::success,
                            s::error, s::success);
                    // 3.Mono取消时，取消Observable<HystrixCommand>的订阅，结束HystrixCommand的执行
                    s.onCancel(sub::unsubscribe);
                    // 4.对异常情况的处理
                }).onErrorResume((Function<Throwable, Mono<Void>>) throwable -> {
                    // a.Hystrix自己的运行时异常
                    if (throwable instanceof HystrixRuntimeException) {
                        HystrixRuntimeException e = (HystrixRuntimeException) throwable;
                        HystrixRuntimeException.FailureType failureType = e
			    .getFailureType();
                        // 根据异常类型的不同，返回不同的错误内容
			switch (failureType) {
			    // I.超时
			    case TIMEOUT:
			        return Mono.error(new TimeoutException());
			    // II.服务不可用
			    case SHORTCIRCUIT:
				return Mono.error(new ServiceUnavailableException());
                            // III.执行HystrixCommand发生异常
                            case COMMAND_EXCEPTION: {
                                Throwable cause = e.getCause();
                                if (cause instanceof ResponseStatusException
                                    || AnnotatedElementUtils.findMergedAnnotation(
                                                cause.getClass(), ResponseStatus.class) != null) {
				    return Mono.error(cause);
				}
                            }
                            // 这三种异常情况以外，则break，走默认的异常返回逻辑
                            default:break;
			}
	            }
                    // b.异常的默认返回
                    return Mono.error(throwable);
                // Mono.then()参数为空，返回空Mono，不再向后发射数据
                }).then();
            });
        }
}
```

代码是有点长，主体逻辑其实没有多少，比如onErrorResume就占了一大段，但它只是做根据异常类型返回不同的结果。简而言之，通过yml里配置的HystrixCommand名称、fallbackuri、HystrixGatewayFilterFactory类名、过滤器链，去构造出了一个HystrixCommand。通过订阅监控HystrixCommand的执行情况，来实现集成Hystrix熔断。

们分析了HystrixGatewayFilterFactory实现熔断过滤器的原理，比较枯燥，不像最初的几篇那么有趣了。一方面是因为它的代码没有太多的设计模式可讲，一方面是核心逻辑确实比较简单，其实最难理解的地方反而是一些Hystrix和Reactor的api。