---
layout: post
categories: [Linux]
description: none
keywords: Linux
---
# Linux内核源代码结构
Linux内核是操作系统中最核心的部分，它负责管理计算机硬件资源，并提供对应用程序和其他系统组件的访问接口。它控制着计算机的内存、处理器、设备驱动程序和文件系统等关键功能。作为开源软件，Linux内核由全球各地的开发者共同维护和改进，不断增强其性能、安全性和功能。许多流行的操作系统都基于Linux内核，如Ubuntu、Debian、CentOS等。

## Linux内核的特征
- Linux内核组织形式为整体式结构
Linux内核是面向过程的，每一个模块单独编译，最后链接成一个独立的目标程序。这种结构最大的特点是内部结构简单，子系统容易进行访问，因此内核的工作效率比较高。基于过程的结构有助于不同业务的成员进行基于不同业务的开发，基于这种角度，linux内核又是开放式的开发，它允许任何人对其不同模块进行完善和再次开发。
- 进程调度方式简单而有效
可以说linux追求效率方面领先，体现在调度方式上也是别具一格，对于用户进程linux采用简单的动态优先级调用方式。对内核的例程，比如中断服务程序、设备驱动程序等采用一种独特的机制，就是我们所讲的软中断机制，这种机制保证内核例程以一种高效的机制运行。
- 支持内核线程(或称为守护进程)
内核线程是在后台运行而业务终端和登录shell和它结合在一起的进程。有许多标准的内核线程，其中有一些是周期运行的来完成一些特定的任务。而其余的部分它是连续运行的等待处理某些特定的事件。内核线程可以说是用户进程，但它和一般用户进程又不一样，它像内核一样不被放出，因此运行效率比较高。
- 支持多种平台的虚拟内存管理
内存管理是和硬件平台相互关联的一部分。为了支持不同的平台，又要保证虚拟管理存储技术的一个通用性。那linux虚拟内存管理为不同硬件平台提供统一的接口。因为我们把linux内核移植到一个新的硬件平台并不是一个很困难的事情。
- 虚拟文件系统
虚拟文件系统不仅为多种逻辑文件统一了一个接口，而且为各种硬件设备提供了统一的接口，作为一种特殊的文件。
- 模块机制
模块机制可以使内核保持独立而又容易扩展。使内核很容易增加一个模块，比如一个新的设备驱动程序，不需要重新编译内核，同时模块机制可以把一个模块按照需要添加到内核，或者把一个模块从内核当中卸载下来。这使得我们可以开发需要定制自己的内核。
- 增加系统调用。
满足特殊的需求，一般来讲系统调用是操作系统设计者提供给用户使用内核工具的一个内核接口。但是linux开放源代码也允许我们自己设计自己的系统调用。然后把它加入到系统里面去。
- 面向对象。
网络部分面向对象的思想使得我们现代linux内核支持多种协议、多种网卡驱动程序变得更加容易。

## Linux内核组成为五大部分
- 进程调度
控制进程对cpu的访问，当要选择下一个运行的程序，是调度程序选择下一个要运行的程序，可运行程序是等待cpu资源的进程。如果某个进程在等待其他资源，那么这个进程是不可运行进程，需要通过调度进程去运行，它有个选择调度算法选择新的进程。
- 内存管理
允许多个进程安全的共享主存储区。
- 虚拟文件系统
隐藏各种各样不同硬件的具体细节，为所有设备提供了一个统一的接口。NFS支持多到10种不同的文件系统。也就是linux比较有特色的一部分，虚拟文件系统还可以分为逻辑文件系统和设备驱动程序。
- 网络接口
对各种网络标准协议的存取和各种网络硬件的支持，网络接口可以分为网络协议和网络驱动程序两个部分，网络协议负责实现每种可能的网络传输协议，硬件驱动程序负责驱动每种可能的网络硬件。
- 进程间通讯
支持进程各种通讯机制。

## 系统数据结构
task_struct：代表一个进程数据结构指针形成一个task数组。
mm_struct：代表进程的虚拟内存。
inode：代表虚拟文件系统中的文件、目录等对应的索引节点(inode)。

## linux内核源码目录组织结构

### linux内核版本说明
Linux内核版本有两种:稳定版本和开发版本，Linux内核版本号由3组数字组成，第一组数字，第二组数字，第三组数字。第一组数字代表目前发布的内核主版本；第二组数字:偶数表示稳定版本，奇数开发中版本；第三组数字：错误修补次数。

例如：Linux 3.6.34
- 第一组数字：3，主版本号
- 第二组数字：6，次版本号，表示稳定版本（因为它是偶数）
- 第三组数字：34，修订版本号，表示修改的次数，头两个数字全在一起可以描述内核系列。

### linux内核目录说明
- arch目录: 不同平台体系相关代码就在这里，每种体系结构对应一个子目录。
- block目录:块设备驱动。是以数据块方式接收和发送这些数据的设备，这里面的纯代码是为以前的版本，一部分是为drivers目录，另外一部分是为fs这个目录。从2.6版本以上就慢慢分成了3个部分。
- certs目录: 与认证和签名相关的代码。
- crypto目录:内核常用加密、压缩算法等代码。
- Documentation目录:描述模块功能和协议规范代码；
- Driver目录:驱动程序(USB总线驱动、PCI总线、显卡驱动等等)；
- firmware目录:主要是一些二进制固件;存放系统需要最底层的信息，比如cpu所需源代码等。
- fs目录:虚拟文件系统代码。内核中支持的所有原始文件系统各自为一个子目录，比如ext2 ext3 ntfs fat等等。
- include目录:内核源码依赖绝大部分头文件就在这里。
- init目录:内核初始化代码，联系到内核各个组件入口。
- ipc目录:进程间通信实现，比如共享内存、信号量、匿名管道等；
- kernel目录:内核核心代码，包括进程管理、IRQ、时间等；
- lib目录:C标准库的子集，方便内核代码使用。
- mm目录:内存管理相关实现。
- net目录:网络协议的相关代码，比如TCP、IPV6、IPV4、WiFi、以太网实现等等
- samples目录:内核实例代码。
- scripts目录:编译和配置内核所需脚本；perl bash等。
- security目录:内核安全模型相关代码；如selinux
- sound目录:声卡驱动源码；
- tools目录:与内核交互的工具；主要是方便在用户态的时候测试一些内核相关的功能，就是内核交互。
- usr目录:用户打包和压缩内核的实现源码。
- virt目录:/kvm虚拟化目录相关支持实现。

不同文件分析:
- COPYING:许可和授权信息。
- CREDITS:贡献者列表
- Kbuild:内核设定脚本
- Kconfig:开发人员配置内核时所用到的文件
- MAINTAINERS:目前维护者列表
- MakeFile:编译内核的主要文件。
- ReadMe:编译内核的相关信息提供给开发者。
- REPORTING-BUGS:提供给开发者如何报告问题的信息

kernel/sched/路径下：
- autogroup.* - 用于实现autogroup，将属于同一个会话（session）的task自动分配到同一个进程组。有助于提高IO密集型任务的性能。
- clock.c - 实现高精度调度时钟。
- completion.c - 实现完成量（类似信号量），它允许一个线程告诉另一个线程某个工作已经完成。
- core.c - 调度器核心功能，例如__schedule()函数实现。
- cpuacct.c - 实现cpu accounting。会自动生成报告来显示cgroup中任务所使用的CPU资源。
- cpudeadline.* - 实现cpu heap，被deadline.c使用。
- cpufreq.c - 和cpufreq相关的调度代码。cpufreq可以动态地提供刚好足够的主频给CPU。
- cpufreq_schedutil.c
- cpupri.* - cpu priority management，进程优先级。
- cputime.c - cpu accounting cgroup controller。
- deadline.c - deadline调度器类。
- fair.c 调度器类。
- debug.c
- idle.c idle调度器类。
- isolating.c CPU隔离
- loadavg.c 负载均衡。
- membarrier.c 内存屏障。
- pelt.* - Per-entity load tracking，基于过去的调度信息来预测未来该进程对CPU的需求.
- psi.c - Pressure Stall Information 提供了一种评估系统资源压力的方法。
- rt.c - RT调度器类。
- stats.* - 实现/proc/schedstat，用于展示有关scheduler性能相关的统计信息。
- stop_task.c - stop task相关功能。
- swait.c - (simple wait queue) implementation。
- topology.c 和cpu topology (smp) 有关。
- wait.c - wait queue相关。
- wait_bit.c

## 为什么要学习linux内核
- 提升研发出高水平软件
对技术提升有巨大参考价值，站在巨人的肩膀上，尤其对各种驱动的开发起到一个博采众长的参考作用。 我们只要认真的钻研，就一定能吃透他们牛逼的思想。为能够自己研究出解压芯片，路由器等设备提供借鉴，打破一些外来的技术封锁。
- 开发自己的操作系统
为嵌入式系统提供一个极有吸引力的选择。以内核为基础的完全内核手册，支持多种计算机硬件，比如x86，arm等等现有的这些芯片，连源代码都全部公开，任何人员都可以修改，开发人员也可以为操作系统进行定制。它也有个好处，不用像windows操作系统一样有后台的威胁，这就是linux操作系统的好处。为开发嵌入式操作系统提供广泛的开发前景，比如数字家电，机顶盒，多媒体手机等。还有智能沟通设备，比如pos机、atm机等等。
- 有助于计算机科学领域研究
- Linux系统性能优化

## 6个内核底层原理开发技术

### 进程管理专题

（一）操作系统与汇编基础

Linux操作系统进程分析
计算机基础技术
进程原理
Linux特性与内核版本
进程特征与调度算法
死锁产生必要条件
进程状态及转换
进程调度策略与调度依据
存储器结构与分区存储管理
主存储器结构及技术指标
分配策略与分区回收
页表与交换技术
物理内存与虚拟内存
段式存储管理与页式存储管理
文件管理基础架构
x86_ ARM处理器架构
x86架构整体部件分析
ARM处理器架构分析
64位通用寄存器结构
汇编基础与寻址方式
SMP架构与NUMA架构
ARM Cortex-A9处理器架构
ARM常用指令系统详解


（二）进程管理基础

Linux内核源码组织结构分析
Linux内核(五大子系统关系)
内核源码目录结构详解
如何快速掌握阅读内核源码方法与技巧
进程原理与生命周期及系统调用
写时复制原理
进程内存布局
进程堆栈管理
系统调用实现
调度器及CFS调度器
实时调度类及SMP和NUMA
task_ struct数据结构分析
进程内核do_ fork() /kernel_ clone()函数分析
RCU机制及内存优化屏障
内核内存布局和堆管理
实战操作:内核数据结构(链表和红黑树)

（三）进程调度模块

进程调度策略
SCHED_ DEADLINE
SCHED_ FIFO
SCHED_ RR
SCHED_ NORMAL
四种进程优先级
调度优先级
静态优先级
正常优先级
实时优先级
五大调度类解析
stop_ sched_ class
idle_ shced_ class
dI_ sched_ class
rt_ sched_ class
cfs_ sched_ class
多核调度分析
调度组与调度域
负载计算与均衡算法
SMP调度类处理器负载均衡
实战操作:进程优先级与调度策略
实战操作: QEMU调试L inux内核
实战操作:动手编译自己Linux内核
实战操作:进程间通信实现

### 内存管理专题

（一）内存管理基础部分

虚拟地址空间布局架构
内存管理架构
用户虚拟地址空间布局
内核地址空间布局
SMP/NUMA模型组织
物理内存组织结构与模型
系统调用sys_ mmap/sys_ munmap
物理内存组织三级结构
页表/页表缓存原理
处理器缓存机制及SMP缓存一致性
内存分配器(bootmem/ memb lock)
bootmem分配器原理
memblock分配器原理及分配流程
伙伴系统算法与实现
伙伴系统原理机制
分配页和释放页实现
块分配器(SIab/S1ub/Slob)原理实现
内存映射
数据结构分析
系统调用实现
创建/删除内存映射
实战操作:SIab块分配器实现
实战操作:进程地址空间在内核(VMA实现)

（二）内存管理进阶部分

brk/kmalloc/vmalloc(系统调用分析)
不连续内存分配器原理
页表缓存(TLB)与巨型页
TLB表项格式及管理
ASID原理/VMID原理
处理器对巨型页的支持
标准巨型页原理及查看
LRU算法与反向映射
缺页异常分析
写时复制缺页异常
do_ page_ fault函数分析
文件映射缺页中断
匿名页面缺页异常
内存反碎片技术
内存碎片整理算法
虚拟可移动区域技术原理
内存检测与死锁检测
内核调优参数
/proc/sys/kernel/
/proc/sys/ vm/
/proc/sys/fs/
内存屏障与内核互斥原理
编译器屏障
处理器屏障
ARM64处理器内存屏障分析
内存与Kasan工具分析
五大常见内存访问错误
Kasan内核检测工具应用
页回收原理机制
发起页回收
计算扫描页数
收缩活动页链表
回收不活动页
页交换与回收slab缓存
缓存着色
内存缓存数据结构
空闲对象链表及着色
内核调试方法printk/oops分析
实战操作:内存池原理及实现
实战操作:perf性能分析工具
perf原理机制与安装配置
perf采集数据命令29种工具应用
perf采集数据至火焰图分析

### 网络协议栈专题
（一）网络基础架构

sk_ _buff与net_ device详解.
套接字缓冲区管理数据
从套接字缓冲区获取TCP首部
sk_ buff及net_ device结构分析
TCP/UDP/ICMP协议栈分析
套接字分析
发送与接收UDP数据包分析
发送与接收TCP数据包分析
发送/接收1CMP/IPv4/IPv6消息.
传输层分析
流控制传输协议(SCTP)
数据报拥塞控制协议(DCCP)
IPsec(互联网安全协议)
IPsec基础知识
XFRM框架/策略/状态
传输模式/隧道模式/IPsec高可靠性
IPv4策略路由选择
FIB信息_缓存_下一跳
生成及接收1CMPv4重定向消息
无线子系统分析
MAC帧结构分析
扫描/身份验证/关联
mac80211接收与传输实现
高吞吐量(802.11n)
网状网络(802.11s)
IPv4重定向消息/FIB表
Netfilter内核防火墙报文处理
Netfilter框架简介
数据包选择Iptables
数据包过滤
NAT(网络地址转换)
连接跟踪与数据包操纵
十Iptables基础/表和链及过滤规则
Netfilter5种挂接点详解
注册Netfi Iter钩子回调函数源码分析
NAT钩子回调函数分析
实战操作:内核NetI ink套接字及实战
数据结构设计与API系统调用
内核模块与用户应用程序设计

（二）网络协议栈架构

Linux内核邻接子系统分析
创建与释放邻居AP1接口分析.
ARP协议(IPv4)发送与接收请求分析
高级路由选择
组播路由选择
策略路由选择
多路径路由选择
接收/发送(IPv4和1Pv6)数据包
InfiniBand栈的架构
RDMA(远程直接内存访问)结构
Inf iniBand组件与编址
InfiniBand功能与数据包
NIC数据包接收与发送分析
NIC实现原理与NIC分类
NIC数据包发送与接收流程分析
eBPF原理与实现
eBPF工作原理详解
eBPF开发环境搭建
eBPF如何在内核运行与交互
实战操作:epoll内核原理与实现
实战操作:内核防火墙iptables实现
实战操作:eBPF实践分析
进程跟踪
内核跟踪
性能优化

### 设备驱动专题
（一）设备驱动基础架构

i/0体系结构
系统总线(PC1、 ISA、SCSI、 USB等)
与外设交互及控制设备
访问设备详解
内核块设备详解
块设备1/0操作集合及源码分析
通用磁盘及分区源码分析
Linux设备模型
深度剖析LDM
LDM数据结构分析
设备驱动程序原理与实现
kobject结构分析
kobj_ type/内核对象集合
设备模型和sysfs
sysfs文件及属性
轮询sysfs属性文件
资源分配
资源管理
i/0内存分析
i/0端口 分析
字符设备操作
主设备与次设备
打开设备文件
分配与注册字符设备
写文件操作实现
open/release方法
read/write
iiseek/poll方法
填充file_ operations结 构体
实战操作:USB设备驱动实现
USB体系架构设计
驱动程序数据结构结构
make及USB设备驱动测试
实战操作:PC1设备驱动实现
实战操作:TTY设备驱动实现

（二）NIC网络接口卡

数据结构
套接字缓冲区
网络设备接口
缓冲区管理与并发控制
网络吞吐量
协议性能
驱动程序性能
实战操作:NIC网卡驱动架构实现
NIC网卡驱动的recv与sk_ buff
NIC网卡open与stop的实现
NIC编译与用户态协议栈

### 文件系统专题
（一）虚拟文件系统

文件系统类型与文件模型研究
磁盘文件系统(DF)
网络文件系统(NF)
inode
链接
API编程接口
VFS数据结构
超级块(super_ block)
挂载描述符 (mount结构体)
索引结点(inode结构体)
目录项缓存(dentry结构体)
（二）文件系统调用

打开/关闭文件
创建/删除文件
读/写文件实现
文件回写技术原理/接口实现
（三）挂载文件系统

系统调用mount处理流程
绑定挂载/挂载命名空间
挂载/注册rootfs文件系统
无持久文件系统
proc文件系统
proc数据结构
初始化及装载proc
管理proc数据项
数据读写实现
系统控制机制
sysfs文件系统
sysfs数据结构
装载文件系统
文件和目录操作
向sysfs添加数据内容
实战操作:procfs文件系统实现
实战操作: sysfs文件系统实现
（四）磁盘文件系统

Ext2文件系统
Ext2物理结构
Ext2数据结构分析
Ext2文件系统操作
Ext4_ 日志JBD2
Ext4文件系统特性
Ext4文件系统数据结构
Ext4_日志JBD2
（五）数据同步

内核定时器
原子操作与屏障
自旋锁机制
自旋锁的实现与变体
spin_ lock()/raw_ spin_ lock() 函数分析
互斥锁
mutex数据结构分析
互斥锁的快速与慢速通道
乐观自旋锁等待机制
mutex_ unlock() 函数分析
读写锁与RCU
实战操作:同步管理RCU实现

### 内核组件专题
（一）内核活动组件

中断处理流程及IRQ
irq_ _desc数据结构分析
开启_禁止中断
软硬中断分析
中断控制器及域详解
tasklet_等待队列工作队列
审计规则及数据结构分析
（二）开源社区

如何参与开源社区
如何提交Linux内核补丁
管理员Bugzilla参数配置及如何管理用户
在Gitee创建一个开源项目

## 内核难点与学习方法
1、知识点多，关系错综复杂。
2、每一个知识点的难度都很难。
3、代码量很大，内核有几百万行。
4、操作系统相关的知识。
5、程序结构上的很多规范要求

## 内核适宜的工程师人群
Linux 内核优化、内存管理 ，内核开发岗位、定制化自己OS
深入系统内核研究、网络安全逆向分析
提升自己能力，为了更好做应用层开发提供核心依据
跳槽面试大厂（腾讯、华为、中兴、中微、中芯等等）
从事业务开发多年，对底层原理理解不够深入的在职工程师
从事嵌入式方向开发，想转入内核开发的在职工程师
从事Qt/MFC等桌面开发的，薪资多年涨幅不大的在职工程师
从事非开发岗位（算法岗，运维岗，测试岗），想转内核开发岗位的在职工程师

## 阅读源代码
(1)系统的启动和初始化

在基于 Intel 的系统上，当 loadlin.exe 或 LILO 把内核装入到内存并把控制权传递给内核时，内核开始启动。关于这一部分，看 arch/i386/kernel/head.S ，head.S 进行特定结构的设置，然后跳转到 init/main.c 的 main()例程。

(2)内存管理

内存管理的代码主要在/mm，但特定结构的代码在 arch/*/mm。缺页中断处理的代码在mm/memory.c ，而内存映射和页高速缓存器的代码在 mm/filemap.c。缓冲器高速缓存是在mm/buffer.c 中实现，而交换高速缓存是在 mm/swap_state.c 和 mm/swapfile.c 中实现。

(3)内核

内核中，特定结构的代码在 arch/*/kernel，调度程序在 kernel/sched.c，fork 的代码在 kernel/fork.c，task_struct 数据结构在 include/linux/sched.h 中。

(4)PCI

PCI 伪驱动程序在 drivers/pci/pci.c ，其定义在 include/linux/pci.h。每一种结构都有一些特定的 PCI BIOS 代码，Intel 的在 arch/alpha/kernel/bios32.c。

(5)进程间通信

所 有 System V IPC 对 象 权 限 都 包 含 在 ipc_perm 数 据 结 构 中 ， 这 可 以 在include/linux/ipc.h 中找到 System V 消息是在 ipc/msg.c 中实现, 共享内存在 ipc/shm.c中，信号量在 ipc/sem.c 中，管道在 ipc/pipe.c 中实现。

(6)中断处理

内 核 的 中 断 处 理 代 码 是 几 乎 所 有 的 微 处 理 器 所 特 有 的 。 中 断 处 理 代 码 在arch/i386/kernel/irq.c 中，其定义在 include/asm-i386/irq.h 中。

(7)设备驱动程序

Linux 内核源代码的很多行是设备驱动程序。Linux 设备驱动程序的所有源代码都保存在/driver，根据类型可进一步划分为：

/block块设备驱动程序如 ide(在 ide.c)。如果想看包含文件系统的所有设备是如何被初始化的，应当看drivers/block/genhd.c 中的 device_setup()，device_setup()不仅初始化了硬盘，当一个网络安装 nfs 文件系统时，它也初始化网络。块设备包含了基于 IDE 和 SCSI的设备。

/char

这是看字符设备(如 tty，串口及鼠标等)驱动程序的地方。

/cdrom

Linux 的所有 CDROM 代码都在这里，如在这儿可以找到 Soundblaster CDROM 的驱动程序。注意 ide CD 的驱动程序是 ide-cd.c，放在 drivers/block；SCSI CD 的驱动程序是 scsi.c，放在 drivers/scsi。

/pci

这是 PCI 伪驱动程序的源代码，在这里可以看到 PCI 子系统是如何被映射和初始化的。

/scsi

在这里可以找到所有的 SCSI 代码及 Linux 所支持的 scsi 设备的所有设备驱动程序。

/net

在这里可以找到网络设备驱动程序，如 DECChip 21040 PCI 以太网驱动程序在 tulip.c中。

/sound

这是所有声卡驱动程序的所在地。

(8)文件系统

EXT2 文 件 系 统 的 源 代 码 全 部 在 fs/ext2/ 目 录 下 ， 而 其 数 据 结 构 的 定 义 在include/linux/ ext2_fs.h,ext2_fs_i.h 及 ext2_fs_sb.h 中。虚拟文件系统的数据结构include/linux/fs.h 中描述，而代码是在 fs/*中。缓冲区高速缓存与更新内核的守护进程的实现是在 fs/buffer.c 中。

(9)网络

网络代码保存在/net 中，大部分的 include 文件在 include/net 下，BSD 套节口代码在net/socket.c 中，IP 第 4 版本的套节口代码在 net/ipv4/af_inet.c。一般的协议支持代码(包括 sk_buff 处理例程)在 net/core 下，TCP/IP 联网代码在 net/ipv4 下，网络设备驱动程序在/drivers/net 下。

(10)模块

内核模块的代码部分在内核中，部分在模块包中，前者全部在 kernel/modules.c 中，而 数 据 结 构 和 内 核 守 护 进 程 kerneld 的 信 息 分 别 在 include/linux/module.h 和include/linux/kerneld.h 中。如果想看 ELF 目标文件的结构，它位于 include/linux/elf.h中。


















