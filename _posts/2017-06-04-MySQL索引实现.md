---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL索引实现
索引，这是日常工作必须要打交道的一个概念。我们所了解的大多数数据库，其索引都是通过B树或类B树实现的，今天的主题InnoDB，正是索引中的一员，所以从这个角度来看，索引和B树，就可以等同起来。不过，更加精确地讲，InnoDB是使用B+树来实现其索引功能的。

## B+树及B树的区别
首先，关于什么是B树，或者B+树，在教科书或网上有很多相关介绍，可以直接获取，但它们之间的区别，一般都是理论方面的，从数据库应用的角度去解释可能更加容易理解。经总结，这两种数据结构的不同之处有如下五点。
- B树中的同一键值不会出现多次，它有可能出现在叶子节点上，也有可能出现在内节点上；而B+树的键一定会出现在叶子节点上，同时也有可能在非叶子节点中重复出现。简单来说，B+树的内节点存储的都是键值，键值对应的具体数据都存储在叶子节点上。
- 由于B树的每一个节点都存储了真实的数据，会导致每一个节点存储的数据量变小，所以整个B树的层数就会相对变高，当数据量变大之后，维护代价是比较大的，而且层数越高，搜索或修改的性能就会越低；而在B+树的内节点中，只存储键值，相对而言，一个内节点存储的记录个数比B树多很多。由于B+树是横向扩展的，所以随着其中数据量的增长，最终会成长为一个矮胖子，不像B树一样是纵向扩展，最终只会变成一个瘦高个子。这样整体而言，B+树在搜索时，从上到下直到叶子节点只需要遍历层数个节点而已，因此性能会比较高。
- B树的查询效率与键在B树中的位置有关，（在叶子节点的时候）最大时间复杂度与B+树相同，最小时间复杂度为1（在根节点的时候）；而B+树的复杂度对某个建成的树是固定的。
- B树中，键的位置不固定，且在整个树结构中只出现一次，虽然可以节省存储空间，但却使得插入、删除等操作复杂度明显增加。而且性能不平衡，有可能会很快找到合适的位置，也有可能需要做比较多的IO操作才能找到。而B+树相对来说是一种较好的折中，因为内节点相对叶子节点而言，相当于是一个索引，在插入的过程中，只需要通过在每一层搜索一个节点，依次找到叶子节点之后，在叶子节点处做插入操作即可，只是在遇到一个节点存储满了的情况下会进行B+树分裂，但总体而言性能还是比较稳定。
- B树中，所有的数据都只存储一份；而B+树中，除了存储了所有数据的叶子节点外，还有只存储键值数据的内节点，所以，在占用空间量方面，B+树比B树会多占用一些空间，这部分空间就是B+树内节点的所有空间，但B+树通过这种方式提高了整体性能，更适合于性能要求很高的文件检索。

## 索引的设计
数据库是用来存储数据的工具，存进去，是为了更方便地取出来，而且越快越好，这样对性能的要求就非常高了。在计算机上运行一个任务，一般有三部分涉及性能，分别是内存大小、CPU及磁盘的速度，而索引是一种存储方式，与它相关的最重要的部分就是磁盘，所以磁盘性能的高低，直接影响了在数据库中查找数据的效率。

磁盘的性能与读写顺序有关，对于普通的机械硬盘，顺序读写会比随机读写快很多，这里涉及的机械硬盘的存储原理在很多相关书籍中都有介绍，此处不再赘述。在加快数据库中数据的读写速度时，需要尽可能地避免随机读写，也就是说尽可能地读取连续的数据，这样性能自然就会好一些。

除了硬盘读写顺序的影响之外，还需要考虑读写操作本身的效率，因为在读写时，有些数据是必须要操作的，也就是真正需要的那部分数据，这部分数据被称为有效数据，这部分数据之外被同时读写的数据，被称为无效数据。索引的设计，必须要尽可能地降低无效数据的读写访问。

关系型数据库的结构有如下三个特点。
- 数据都是以行为单位一行一行存放的，一行中包括一个表（聚簇索引）或者一个索引（二级索引）中定义的所有列，多行数据可以连续一起存储。
- 一行数据中，一般都会有一个键，以及其他附属的列，可以称之为值，可以简单理解为一行数据就是一个键值对。有些人可能会有一个疑问，如果不定义主键怎么办。没关系，InnoDB已经替你想到了这一点，它会在内部加上一个主键，即我们所熟知的Row ID值，这样就有了一个默认的键，相应表中所有用户定义的列就是值了，也照样形成了一个键值对。
- 在键值对中，键值可以排序，还可以组合键值。

综合以上三个特点，以及B+树的特点，这哥俩感觉就是天生一对，所以设计存储方式如下。
- 将磁盘空间或存储文件划分为许多大小相同的块（Block）或者页（Page），而在一个块中，可以存储多个数据行，多个数据行在一个块内的存储格式可以先不用考虑，这样设计就迎合了磁盘顺序读取性能比较高的特性，因为读取一条数据时，也很有可能读取其周边的数据，这对于相对固定的块来说，一次顺序IO就可以读取很多数据出来，在性能提高上是非常适合的，而如果不通过块来管理行的话，行为单位的管理就会非常碎，IO也会非常随机，性能就变得差了。
- 在一个块内，所有数据行的组织管理也是需要讲究的。因为数据有可能经常会变，并且它的大小是相对固定的，有可能会存储满，所以内部是通过链表或数组的方式来管理的。
- 前面已经提到，每行数据就是一个键值对，并且键可以排序，在一个块内，所有的行数据也可以有序，这样利用经典的二分查找算法就可以很快地根据指定的键来找到对应的键值对数据或一定范围内的很多数据。
- 一个块的问题解决之后，如何形成一棵B+树呢？现在很容易想到，可以让一个块作为一个B+树的节点，这样通过块来承载数据，通过B+树这个数据结构来组织不同块之间的关系，最终形成一个矮矮胖胖的B+树结构。
- 因为行是一个键值对，而B+树的特点是通过在内节点中只存储键来提高搜索性能，这两个特性正好匹配。很自然地，在B+树中，内节点存储了行数据中的键，而叶子节点存储所有的行数据。通过内节点的键值及一个位置信息，内节点与下层节点或叶子节点之间的指针，就可以找到其孩子节点了。

现在，这个B+树（索引）的雏形就出来了。这里所说的块，其实就是一个页面，B+树所用到的块，就是被一个段，或簇所管理的。

## 聚簇索引和二级索引
在查询数据时，一般都会在经常被查询的字段上建立一个索引，这正是利用了索引中被排序的键值。通过内节点的索引功能及叶子节点中数据的有序性，利用二分查找的方法，极大地提高了查找的性能，所以索引在数据库中的作用是至关重要的。

一个表可以建立多个索引，但每一个表都有一个索引是存储了所有数据的，这个索引一般被称为“聚簇索引（Clustered Index）”。聚簇索引在一个表中只有一个，且是建立在主键上面的，这个主键所包含的列可以是被隐藏的Rowid列，也可以是自增列，还可以是明确定义的不含NULL值的组合列等。

除了聚簇索引之外的所有索引，都被称为二级索引（Secondary Index，又称为辅助索引），那么很明显，二级索引可以有多个，并且一般没有上限，想建多少都可以。不过，如果两个索引建立在同样的列，或者列组合上面，那么这两个索引就被称为重复索引或冗余索引，这在MySQL中一般都会以一个警告给出，通过show warnings可以看到如下的警告信息。

从上面的特性我们可以知道，在一个表中，聚簇索引占用的空间肯定是最大的，因为它是存储了全部数据的，而二级索引是建立在某几个需要经常查询的列上面的，除了这几个列之外，剩下的就是用来“回表”的指针信息了，所以相对而言，二级索引的占用空间都会比聚簇索引小很多，特别是在一个表的列数很多或是这些列中包含大字段的情况下，因为我们一般都不会在大字段上直接建立索引。那这样比较下来，在我们统计一个表总的精确行数时（查COUNT*），一些优化器就会选择表中最小的索引来作为统计的目标索引，因为它占用空间最小，IO也会最小，性能相应更快一些。

上面说到了“回表”，所谓回表，就是在使用二级索引时，因为二级索引只存储了部分数据，如果根据键值查找到的数据不能包括全部目标数据，就需要通过二级索引的指针，也就是键值对中的值，来找到聚簇索引的全部数据，然后根据完整的数据取出所需要的列的过程。这种在二级索引中不能找到所有需要的数据列的现象，被称为非覆盖索引，反之称为覆盖索引。因为回表本身是需要去另一个索引（聚簇索引）中查找数据的，性能必然会受到影响，那为了尽可能地提高性能就需要尽量减少回表次数，所以可以试着将出现频率非常高的语句中所有使用到的列以合适的顺序建一个二级索引，这样所有需要的列都被这个二级索引覆盖了，就不需要回表了，从而在一定程度上提高了性能。这虽然是一个好的做法，但需要去权衡，因为需要考虑语句中涉及的列数、这条语句出现的频率及这个索引最终的大小。最坏的情况是建一个和聚簇索引差不多大的二级索引，这样一方面是占用空间比较大，另一方面是维护这个二级索引会对这个表的整体修改性能造成一定的影响。所以，需要权衡各个方面，然后再决定要怎样做。

上面还说到，在统计总行数的时候，可以直接使用二级索引来做，是因为有一个很明显且很重要的前提：每个二级索引与聚簇索引的总行数是一样的，并且是一对一的关系。只不过在每一个索引中，数据行的排列顺序不同，可以想象二级索引行与聚簇索引行之间都有虚线相连，并且二级索引中的每一行都有且只有一条虚线指向聚簇索引中的一行数据，而聚簇索引的每一行，都会有相同个数的虚线指进来，这个数目就是二级索引的个数。至于二级索引与聚簇索引究竟是如何对应起来的，后面会进行详细讲述。

关于二级索引的个数，虽然没有限制，但可以想象一下，任何事物都是有两面性的：建一个索引，是为了提高性能，但这是以降低写入性能为代价的。因为所有索引，在表需要写入数据时，都需要去维护索引数据以保证所有索引都是最新、最准确的，所以可想而知，索引越多，写入性能也就越差，对索引上锁的时间也会越长。更严重的是，如果有唯一索引，为了保证唯一这个特性，每次修改都会去检查唯一性，在RR隔离级别下，经常会造成死锁，所以在建索引时一定要仔细权衡，建出来的索引要个个为精，个个有用，这样才能保证在最大程度提高性能的情况下，最小程度地影响对表的修改。

## 二级索引指针
现在已经知道，聚簇索引存储了所有数据，二级索引只存储了部分数据，但二级索引是为了提高性能建立的，所以经常会被使用到。那如果二级索引中的数据不能满足需求怎么办？这就用到了上面提到的“回表”，二级索引中每行记录中的指针也就发挥了作用。

关于聚簇索引及二级索引列之间的逻辑关系，分类如下。
- 自定义主键的聚簇索引。
索引结构：[主键列][TRXID][ROLLPTR][其他建表创建的非主键列]。
参与记录比较的列：主键列。
内节点Key列：[主键列]+PageNo指针。

- 未定义主键的聚簇索引。
索引结构：[ROW ID][TRXID][ROLLPTR][其他建表创建的非主键列]。
参与记录比较的列：只ROW ID一列而已。
内节点Key列：[ROW ID]+PageNo指针。

- 自定义主键的二级唯一索引。
索引结构：[唯一索引列][主键列]。
参与记录比较的列：[唯一索引列][主键列]。
内节点Key列：[唯一索引列]+PageNo指针。

- 自定义主键的二级非唯一索引。
索引结构：[非唯一索引列][主键列]。
参与记录比较的列：[非唯一索引列][主键列]。
内节点Key列：[非唯一索引列][主键列]+PageNo指针。

- 未定义主键的二级唯一索引。
索引结构：[唯一索引列][ROW ID]。参与记录比较的列：[唯一索引列][ROW ID]。
内节点Key列：[唯一索引列]+PageNo指针。

- 未定义主键的二级非唯一索引。
索引结构：[非唯一索引列][ROW ID]。参与记录比较的列：[非唯一索引列][ROW ID]。
内节点Key列：[非唯一索引列][ROW ID]+PageNo指针。
以上六种情况讲清楚了聚簇索引记录包含的列、二级索引记录包括的列，以及在非叶子节点中分别包含的列。因为索引是用来检索数据的，所以也解释了用来检查记录时，在二级索引及聚簇索引中，参与比较记录大小的列分别是什么，以及唯一索引与非唯一索引的区别等。

这里特别关注一下二级唯一索引的元组逻辑顺序。在二级唯一索引中，作为索引本身的索引列，就是上面所说的“键”，当这个元组需要回表时，在元组中存储的聚簇索引列信息，就是我们所说的“值”，这两者组合起来就形成了键值对。而对于二级非唯一索引而言，因为只有索引列本身再加上主键列才能保证索引记录是唯一的，所以这二者合起来才能构成我们所说的“键”，而“值”就为空了，也就是说，二级非唯一索引中，在记录构成方面，非叶子节点只是比叶子节点多了一个PageNo指针信息。

从上面可以看到，在二级索引元组中，首先存储的就是每个索引定义的索引列，接着就是这条记录对应的聚簇索引的主键列的值，而主键列是唯一的，所以二级索引回表时对应的记录也是唯一的，这样就形成了一种指针的效果。

不过有一点需要注意一下，二级索引回表时对应的聚簇索引，如果是用户自定义的，有可能是自增列，也有可能是有逻辑意义的单列或者组合列的聚簇索引；如果用户没有自定义，则InnoDB会自动给聚簇索引分配一个主键列，不过是隐藏的列，即我们所熟知的Rowid列。基于此，如果是用户自定义的聚簇索引，则二级索引指针指向的就是聚簇索引所包含的列；如果没有自定义主键，那该指针就指向Rowid列。

## 神奇的B+树网络
现在已经知道聚簇索引及二级索引中存储的内容了，但这仅局限于一条记录，或者是一个页面内的存储管理，而这些页面是如何构成一颗B+树的呢？

图8.1所示的就是一个具有两层节点的B+树，也是我们俗称的索引，是一个已经成型并且内容基本完善的树形结构。在图8.1中，所有页面都已经被随机编号，所以可以认定所编的号码就是页面号，其中根页面号为第20号。

很明显，在两层树形结构中，除了20号根页面之外，其他节点（页面）都是叶子节点，或者说只有根页面才是内节点了。

从图8.1中可以看到，一条记录都被分成了两个部分，对于内节点而言（这里指的只是根页面了），一条记录所包含的内容，实质上是只有Key的，但在存储的时候，InnoDB还是把pageno这个指针信息，以列的形式存进去了，只是在实际使用时并不将其计算在内，所以并不影响索引查询，这也可以理解为一个键值对的存储。而对于叶子节点而言，键值对的内容就发生了变化，因为叶子节点中的记录是不会再有指针指向其他页面的，并且它是存储了索引中完整数据的，这个键值对就包含了索引列的值（Key）以及索引中的其他列。当然这里还要区分聚簇索引和二级索引，如果是聚簇索引，那data部分存储的就是除主键列之外的其他所有列组合，而如果是二级索引，则这里存储的就是这行记录对应的主键列组合，用于回表。

在每一层的最左边节点页面的最左边位置，都有一个M in记录，这是为了能很好地组织树形结构的指针，InnoDB发明的一个虚拟记录。它和其他内节点中的记录一样，也是两部分，第一部分就是一个标记，标明它是最小记录M in即可，而第二部分就是一个pageno指针，指向下一层中最左边的记录，也就是用来指向存储比本页面中所有Key都小的记录页面。而对于其他节点中的M in记录，就是用来判断当前搜索是否已经到了一个页面的边界处的。

每一个页面都有一个页面头及页面尾，这两部分用来管理及标记页面状态、页面中的数据如何存储、有没有空闲空间、以什么顺序存储，以及如何解析并找到想要的数据等。所以，这两部分非常重要，之后会在第8章中来解释页面格式。

另外还可以看到，所有叶子节点，从左到右，从小到大，都是以双向链表链在一起的。我们已经知道，叶子节点是存储了索引中所有数据的，而内节点只存储了Key信息，也就是说，如果想要遍历全表，只需要找到叶子节点最左边的节点，从左到右，就可以取出索引中所有的数据了，并且是天然排序的，这对于一些统计工作，比如计算表的总行数，或者是查询全表，是非常有用的。

细心的同学可能已经注意到，在图8.1中，根节点中的键值，比如10、16、25这三条记录，在叶子节点中也同样存在，并且是在这三条记录分别指向的下层页面中。更神奇的是，它们都是下层页面的第一条记录（除M in之外）。其实这不用奇怪，原因有如下三点。

•内节点中存储的这三条记录，只存储了Key，不存储索引中的其他数据，它只起到索引的作用，除此之外，别无他用。

•叶子节点中，除了第1条记录在上层中有重复存储，其他记录不会有这样的现象，如果说浪费空间的话，浪费不会太多；

•这正是前面所讲的B+树的特点，为了提高性能，可以损失一些存储空间。可以想象一下，这样的树形结构，如果达到了四层的话会是什么样的效果。

不妨来算一算，假设每一个内节点页面可以存储1000条Key，那如果将这棵树存满的话，总数据存储量可以像如下这样计算。

•第一层根页面，只有一个页面，存储的Key是1000个；

•第二层内节点，上层1000个Key，这层就是1001个页面，相应的Key个数为1000*1001；

•第三层内节点，上层是1000*1001个Key，这层就是1000*1001+1个页面，相应的Key个数为(1000*1001+1)*1000；

•第四层为叶子节点，上层是(1000*1001+1)*1000个Key，这层就是(1000*1001+1)* 1000+1个页面。而叶子节点可以存储的数据量就不一定了，肯定不会达到1000个，假

设是256个，则整个树存满之后，可以存储的数据量就是((1000*1001+1)*1000+1)* 256=256256256256条记录，这可是千亿级别的记录啊！这么大数据量的MySQL单表存储应该没太有机会处理过。

通过计算，已经发现，一个只有4层的B+树，可以存储这么巨大的数据量，每层之间都是相差千倍，这棵树要有多矮，多胖啊！简单算了一下，如果把每条记录想象为1mm的正方体的话，把这些记录连起来，可以绕地球旋转6.4圈，太神奇了！

现在应该清楚了吧，这就是B+树的魅力！如果想要在千亿级别的表中查找一个记录的话只需要4个页面的IO即可完成最终数据的定位，在叶子节点中，只需要做一次内存级的二分查找即可找到具体的数据记录，这效率高得惊人。同时可以想象一下，如果改为使用B树存储千亿级别的数据，那会是一个什么样的景象，毫无疑问，IO数量已经完全不是一个量级了，这里就不做过多讨论了。

## InnoDB索引的插入过程
现在已经知道B+树的组织结构及不同层之间是如何关联的了，但这是建立在一个已经创建好的B+树的认识上面的，至于这个B+树从小到大、从无到有、从简到繁的过程是什么样子的，可能目前还没有一个比较深入的了解，那么这一节就通过模拟一组数据的插入过程，来了解索引的建立过程。

首先来做一些假设，如下。

•每个页面（包括内节点和叶子节点）最多可以插入三条记录，插入第四条的时候，就会导致分裂。

•插入数据为键值对，但我们只关注键，值可以不用关注，就简单地以data代替即可。

•插入的数据序列为：10，20，5，8，23，22，50，21，53，40，9。

•为了简单明了一些，Key就是一个简单的INT类型的数字。

•假设根节点页面号为100。

现在来做第一次插入过程。此时，索引中还没有数据，所以这个B+树只有一个空的根节点，因为一个页面只能存储三个Key，首先将10，20，5插入进去，然后在页面内做数据排序，所以这3个Key插入之后，B+树应该是如图8.2所示的样子。

根据假设，根页面现在已经插入满了，但还有很多数据需要插入，此时如果再继续插入，则需要将根页面分裂（根节点的分裂），分裂过程如下。

1.首先，创建一个新的叶子节点，假设申请出来的页面是101号。这里为什么创建一个新的叶子节点是有讲究的，因为我们已经知道，B+树的内节点与叶子节点实际上是通过不同的段来组织的，所以什么时候应该从什么段中取节点是需要注意的。这里从叶子节点取，是因为现在的根节点同时还是叶子节点，里面存储的数据都是全部的数据，而不只是Key，所以此时需要叶子节点这么一个角色来将根节点的数据拿过来，让其成为真正的属于内节点的根节点。这里还有一点需要注意的是，在分裂过程中，根节点始终是不会变的，不管变成多大的树，根节点的页面号始终如一。

2.然后，将原根页面的全部记录复制到新页面中，原根页面的最小虚记录要指向新叶子节点，同时将原根页面中的记录全部删除。

3.最后，将根页面的M in记录指针指向新的叶子节点100号页面，这样就构成一个B+树形结构了。

这样变换之后，新的B+树结构如图8.3所示。

而此时根节点分裂是完成了，但是我们要插入的Key——8还没有插入进去，所以还需要继续插入，重新插入8的时候，可以想到，通过定位直接会找到第101号页面，在这个页面内插入时，发现还是没有空间，而此时这个页面是属于叶子节点的，所以这就涉及了又一次分裂——叶子节点的分裂，步骤如下。

1.首先，要再创建一个新的叶子节点，假设页面号为102。

2.将101号页面的一部分数据移到102号页面中，这里的一部分一般是指一半，这里可以假设每次移过去1条。

3.101号页面和102号页面这都是叶子节点，一般称为兄弟关系，它们需要组成双向链表。

4.将一半数据移到102号页面之后，102号页面的数据就只有Key为20这条记录（注意这里是叶子节点，是完整记录），那么此时这个页面就需要与根节点挂上关系，需要做的就是将20这条记录的Key取出来，然后再加上一个指针信息，这里就是102号页面，组成一条新的记录插入到根页面中，那么至此这条记录就算指向了对应的儿子节点102了。

这样，叶子节点分裂并重新调整之后的B+树如图8.4所示。

但是，可能有同学还在问，Key为8这条记录怎么还没有插入进去呢？是的，上面都在处理分裂的事，还没来得及做其他事呢，不过现在可以了，在分裂之后，插入Key（8）就非常简单了。从根页面开始搜索，因为8比20小，所以还是从M in这个记录上找对应的叶子节点，找到的就是101号页面，然后在这个页面上做插入操作，这次已经满足插入的条件了，因为是排序的，所以插入到5和10的中间（这是为了可以简单直白地看到，其实内部的排序组织不是这样的），这样，101号页面的数据就是5、8、10这三条记录了。

继续插入数据，接下来要插入的数据是23，同样从根节点开始搜索，这个是大于Key（20）的，所以找到的相应叶子节点为102号页面，这个页面还有足够的空间，直接将Key（23）插入即可。继续插入Key（22）这条记录，同样的道理，插入完成之后，102号页面的数据包括20、22、23三条记录。此时的B+树结构及数据如图8.5所示。

继续插入数据，此时插入的记录为Key（50），因为它是大于20的，所以找到应该插入的叶子节点页面为102。但此时发现102号页面已经满了，那就继续分裂吧，分裂属于叶子节点的分裂，上面已经做过了。同样地，先新建一个叶子节点页面，假设是103号页面，然后再移动一条记录Key（23）到103号页面，再将103号页面与根节点产生父子关系，也就是在根节点插入记录（Key：23，pageno：103），这样根页面就产生了一个新的孩子节点103。同时，103号节点也就成了102节点的兄弟节点，需要用双向链表链起来，这样变换之后，新的B+树结构如图8.6所示。

分裂之后，重新再次插入数据Key（50），首先在根页面中搜索，发现他比Key（23）大，所以最终会插入到103号页面中，也就是Key（23）之后。

此时再插入下一个数据Key（21），这就很简单了，直接插入到102号页面，插入之后，这个页面也就满了。

继续插入下一个数据Key（53），同样的道理，插入到103号页面，插入之后，103号页面的数据为23、50、53，很明显，也已经满了。

那么，继续插入下一个数据Key（40），同样因为它比Key（23）大，所以它需要插入到103号页面，但已经满了，所以此时再次发生叶子节点分裂的情况，这次就不细说了，假设这次申请的叶子节点为104号，分裂并插入之后的样子如图8.7所示。

继续插入下一个数据Key（9），在根页面中，因为比Key（20）小，所以找到了101号插入目标页，但此时该页面已经满了，明显需要再次做叶子节点的分裂。同样地，创建一个新的叶子节点页面105，移数据，使其成为兄弟节点，都做完之后，将105号页面中唯一一条Key （10）（从101号页面中移过来的一条）与根节点产生父子关系，创建一个索引记录（Key：10，pageno：105），并且插入到根页面中，不过此时发现有点惨，根页面已经满了，很明显可以想到，需要做根页面的分裂了。

我们先看一下目前的B+树（不能称为一个完整的B+树），如图8.8所示。

可以看到，105号页面现在是没有父亲的，所以需要通过分裂来为它找到一个父亲。

此时要做的工作是将记录（Key：10，pageno：105）插入到根节点，而根节点已经满了，所以需要再创建一个新的节点。新的节点应该创建在内节点页面上，因为要存储的数据是索引数据，而不是叶子节点的数据。假设这个节点的页面号为106，这里需要注意，由于根页面始终是根页面，因此还是要将根页面的全部数据移动到106号页面中，相当于从101到105号这5个页面的父节点都变为106号了，而100号页面的最小节点也会指向106号页面。此时的B树，已经形成了3层的结构，样子如图8.9所示。

此时，继续做上面分裂之前的操作，也就是将数据（Key：10，pageno：105）写入106号页面中，但依然是满的，所以还需要继续分裂。不过此时的分裂，不叫叶子节点分裂，也不叫根节点分裂，而是叫内节点的分裂。内节点和叶子节点的分裂方法差不太多，依然是创建一个新的节点，比如107号页面，然后作为106号页面的兄弟，移1条记录到107之后，将索引记录（Key：53,pageno：107）插入根页面中。这样，新的B+树结构就是如图8.10所示这样的。

上面一步完成之后，继续在106号页面插入索引数据（Key：10，pageno：105）。此时，经过上面两次的分裂，已经成功找到了合适的空间可以放下这条记录了，直接将这条记录插入106号页面中，放在Key（20）之前，则此时106号页面的数据就包括Key（10，20，23三条记录了，分别指向了105、102、103号页面，从而使105号节点也成功地找到了自己的“爸爸”。新的B+树结构如图8.11所示。

关于B+树的插入过程，就是这个样子，基本到了三层的话，就可以见到全部场景了，整个插入过程也都明确了。

不过别忘了，插入操作还没有完成，上面只是将索引指针记录插入到了内节点，两层节点分裂完成之后，又回到了插入Key（9）的操作上，因为这条记录还没有插入完成。此时很明显，还是会找到第101号页面，并且此时已经有足够的空间，直接插入即可，将所有数据插入完成之后的完整B+树索引如图8.12所示。

此时再回头看看，要插入的数据序列是：10、20、5、8、23、22、50、21、53、40、9，此时可以看一下这张图，从左到右把所有记录都读取出来，序列为：5、8、9、10、20、21、22、23、40、50、53。很明显可以看到，相当于是给原始插入序列排了一次顺序，并且包含了全部数据，这也正是如果想要全表查询的话，在InnoDB内部，会直接定位到最左边的叶子节点上，然后依次从左到右将所有记录取出来的缘故，而这也正是我们所介绍的B+树的特性。

## 一个页面至少要存储几条记录
有人问过我这样一个问题：为什么InnoDB数据页面中最少存储2条记录？一下子把我问住了，知道是这样，但从没有问过自己这是为什么。经过一番思考，知道了其中缘由，现在结合上面所讲的B+树插入过程，分析一下这个问题的原因。

现在已经明白B+树如何插入数据了，此时再做一些假设，如下。

•在极端情况下，每一个页面中只能插入一条记录。

•插入的数据就是1、2、3。

通过上面的实验，已经了解到，如果一个页面的数据量不能存储到2条记录，则这个B+树就不能称为B+树，因为它不能起到一个索引的作用，其实就是一个双向链表，但比双向链表占用的空间大很多。

页面中存储记录条数这个问题在数据库中是如上这样解释的，但归根到底，其实还是因为B+树的特性所造成的，如果不存储至少2条记录，那么这个B+树是没有意义的，形不成一个有效的索引。

## 页面结构管理
这里只讲述关于B+树节点页面的细节，因为在InnoDB中，以B+树节点这样的角色存在的页面是最多的，还有一些其他用途的，比如回滚段、系统管理页面、簇描述页等格式都是不相同的，这些就不再叙述了。

InnoDB的页面内容。为了不引起误解，也为了更形象地展示图中内容的关系，制定了以下两条约定。
- 空闲空间和用户记录之间都是紧挨着的，这里的每条记录和可重用空间、空闲空间都分开，是为了更清楚地展示图中的内容。
- 将一个页面想象为一张纸，在存储完一行内容之后，可以换行，每条记录的长度大小不定。

## 文件管理头信息
页面最开始位置存储了长度为38字节的“文件管理头信息”，这是每个页面都必须要有的内容。下面看一下文件管理头中存储了哪些内容，先看一下在代码中定义的宏，如下。
可以看到，文件头信息最终到FIL_PAGE_DATA指示的位置便结束了。在这个位置之后所存储的信息，分别做如下详细的解释。
- FIL_PAGE_SPACE_OR_CHKSUM：长度为4，偏移为0，从注释中可以看到，在MySQL 4.0.14版本之前，这个位置是用来存储Spaceid的，但都是为0的，在之后的版本中，存储了本页面的CHECKSUM值，用来校验这个页面是不是完整，是不是被损坏了。
- FIL_PAGE_OFFSET：长度为4，偏移为4，表示的是这个页面在当前表空间中的页面号，也就是以16KB（默认）为单位，在页面内的偏移位置。页面号是从0开始计数的。
- FIL_PAGE_PREV：长度为4，偏移为8，用来存储当前叶子节点的上一个页面，如果已经是最左边的节点，则这里存储为FIL_NULL。
- FIL_PAGE_NEXT：长度为4，偏移为12，用来存储当前叶子节点的下一个页面，如果已经是最右边的节点，则这里存储为FIL_NULL。
- FIL_PAGE_LSN：长度为8，偏移为16，用来存储当前页面最后一次被修改时，对应日志的LSN值，这个值在第11章会详细介绍，与日志、页面刷盘、检查点等有密切关系。
- FIL_PAGE_TYPE：长度为2，偏移为24，用来存储当前页面是什么类型的页面，本节要介绍的类型为FIL_PAGE_INDEX。
- FIL_PAGE_FILE_FLUSH_LSN：长度为8，偏移为26，用来存储当前InnoDB存储引擎最大的被FLUSH到的LSN值，在数据库正常关闭，或者做检查点的时候，都会将当前最新FLUSH的日志LSN写一次，以保证在日志文件被删除，或者修改大小的时候，还可以找到一个正确的LSN值。从上面代码对应的注释中可以看到，这个值只会被定义在每个表空间的第0号页面中，也就是说只有第0号页面中的这个值是有效的，其他所有页面的这个位置存储的数据才都是0。
- FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID：长度为4，偏移为34，在MySQL 4.1.x版本之后，用来标识当前页面属于哪一个表空间。可以反过来想一下，如果没有这个值，那么当多个表同时缓存在Buffer Pool中，并且在同一个页面号出现时，就没办法区分它们对应的是哪个表空间了，所以这个值是用来对应是哪一个表空间文件的。

## 最小记录和最大记录
在InnoDB存储引擎中，每一个B+树索引页面都会有两个特殊的记录，分别是“最大记录”和“最小记录”，它们的作用是用来限定一个页面中，数据记录的边界。“最小记录”是比任何一个记录都小的记录，而“最大记录”是比任何一个记录都大的记录，这两个信息有点类似页面头信息，是固定位置并且固定大小的两条虚拟记录。

通过上面的讲述，现在已经知道，在索引内节点中，每一层最左边页面上的最小记录，都是用来承担索引作用的，它指向的孩子节点中的数据，在索引本身排序属性下，比本节点中的数据都小。从图8.19中可以看到这一点，这也是B+树的特性。在InnoDB中，使用了这个最小记录来承担这个责任。

另外，还有一个作用就是在遍历页面数据时，通过槽不断从前到后，或者从后到前找数据的过程中，只要找到了最大记录，或者最小记录，则说明这次搜索，已经到了本页面的边界，数据已经遍历完了，这样就起到一个标记作用。

最大记录和最小记录都占用了13个字节，不过这里有5个字节的浪费空间。实际上，如果只是用来标记最大记录或最小记录的话，则只需要8个字节即可，但作为一个记录，它还需要包括5个字节的记录头信息，所以每条记录还需要加上这5个字节，只不过对于它们而言，这5个字节的记录头信息并没有什么用，是浪费的。

## 页面数据空间管理
现在已经知道针对一个没有插入任何数据的B+树页面来说，已经存储的数据长度是38+56+ 13+13=120字节。在这之后，除了页面最后的8个字节用来存储页尾信息，其余空间都是空闲的，属于用户空间，而此时PAGE_HEAP_TOP指向的位置就是偏移38+56+13+13=120的位置。

在不断插入数据的过程中，如果要插入这个页面，则系统都会从这个页面的HEAP中申请需要的空间大小。比如目前是在偏移120的这个位置，要插入的记录长度为23，则申请之后，新的PAGE_HEAP_TOP指向的就是偏移143的位置。如果继续插入，则继续申请，继续更新PAGE_HEAP_TOP的值。可以看一下这块逻辑的代码，如下。

从代码中可以看到，只要页面中有空间，就会从堆Heap中申请，这就是一个页面空间利用的逻辑。

这是空间的分配，那如果记录被删除并PURGE了，则系统会将这个记录对应的空间，通过PAGE_FREE来管理，每次在页面中删除记录之后，都会将新删除记录对应空间的NEXT指向原来PAGE_FREE指向的空间，然后再将PAGE_FREE指向新被删除的空间首地址，这样就通过这个链表管理起来了。因为在页面记录中，都会在记录的首地址前两个字节的位置存储当前记录的下一条记录，用来将记录之间做一个单向链表，那么自然而然被删除的空间也可以通过这个指针形成一个单链表，将所有的可重用空间串起来，最终通过PAGE_FREE管理起来。

## 经典的槽管理
讲清楚所有页面空间方面的问题之后，来讲一个最重要的问题，那就是在页面内部是如何来组织所有记录的。可能有人会问，如果从偏移120的位置开始申请插入一个记录10，紧接着又插入一个20，那如果再插入一个15，此时页面内部的顺序是如何处理的，难道要将20向后平移吗？

类似这样的问题，在这一小节重会一一揭晓答案。

InnoDB的槽与其他数据库，比如达梦的页面槽是不一样的，达梦的槽，是每一行记录对应一个槽，但InnoDB是多条记录对应一个槽，槽的作用是用来在页面内进行数据搜索的，因为查找一条数据时，是用B+树来保证通过树形结构找到一个记录所在的页面，而在页面内部真正找到这条记录是通过槽来完成的。

槽本身是排序的，存储的位置从图8.19所示的页面图中可以看到，是在页面的最后位置，槽的长度与页面内存储的记录数有关系，一个槽占用两个字节。槽中数据的增长是以高字节到低字节的顺序存储的，最高位的槽代表的是页面内索引顺序最小的记录，而最低位的槽代表的是索引顺序最大的记录，也就是说，在页面内，是通过槽位置的顺序，来表示所有记录的顺序的，可以将槽理解为一个以下标值为元素值的可自由扩展的数组。那么很自然地，这个数组是有顺序的，并且在不断增删改的过程中，都会修改这个数组，该平移的平移，该删除的删除，需要保证的是，每次操作完成之后，槽数组还是有序的。

上面说了，可以把槽理解为一个以下标为元素值的数组。当然，数组的真实元素值不会是下标，真正的值就是页面内槽所对应的记录在页面内的偏移量。所以，如果页面内数据发生了改变，只需要修改槽的位置即可变相地修改页面内数据的大小关系了。

图8.21也是一个页面的示例图，主要侧重于槽与记录的关系。我们已经知道，在每条记录开始位置之前的两个字节，是用来存储下一条记录的指针信息的，所以在每一个槽指向的最后一条记录前面，为了体现它会指向下一个槽的第一条记录，都会有一个指向说明框，用来说明指向的值是多少、位置是多少。

在图8.21中可以看到，槽中存储的数据是没有顺序的，因为它们是槽所对应的第一个记录在页面内的偏移位置，比如第0号槽中存储的是989，这说明本页面中最小的记录在偏移为989的位置存储，从页面中可以看到，这个槽用箭头指向的位置就是989，对应的值是1，其他都比1大，所以这里是最小的，而这个槽对应的数据包括1、2、3、4四个值，通过链表连接起来，值为4的记录指向的下一个记录为偏移289位置的6，这个位置正好是第1号槽，那么值为4的记录也就是第0号槽的最后一条记录。第1号槽包括的数据有6、9、11、15这四个值。依次类推，可以从槽数据出发，找到页面中的所有记录，并且数据都是排序的，只是槽本身存储的数据是无序的。

讲清楚这一点之后，假设现在要搜索25这个值，利用二分查找的办法，low（二分查找最低位标识）就是0，up就是槽的个数，当前位置的值是3（以0开始），二分值是1（0+3/2），那就从第1号槽中去搜索，这个槽对应的数据是从6到15，显然不能满足。此时，向up的方向继续二分查找，此时的up还是3，low就变为上一次的二分值1了，二分之后，新的二分值为2（1+3/2），即从第2号槽中找，也就是位置为1603所指示的记录，我们发现这个槽对应的数据为22到39之间，此时22还是小于25，则继续二分，此时up为3，low为上一个二分值2，但此时up-low已经不满足大于1的条件了，所以查找结束，然后系统会从当前的low和up之间去找具体的值。很明显，25是不存在的，但如果存在，也会是在第2号槽中。

可以看一下实现这段逻辑的代码，在函数page_cur_search_w ith_match中，下面只看代码段。

从上面可以看到，InnoDB代码也是使用了我们很熟悉的二分查找来实现了页面的数据搜索功能，理论加实践才是硬道理。

## 页面尾部
除了文件尾部信息，页面内其他信息都已经讲过了，那么本小节就专门来讲述这最后的8个字节。

这8个字节承载的作用非常重要，应该叫作“前后呼应”，在页面最前面的位置，也就是偏移为FIL_PAGE_SPACE_OR_CHKSUM的位置，存储了页面校验的CHECKSUM值，而这里为了验证页面的修改是不是完整。在最后8字节的前4个字节中，存储了相同的内容，用来与前面的值对比，再加上读取页面时，会根据页面内容重新计算一个CHECKSUM值出来，将这三者做比较，如果相同则说明这个页面是正确的，否则说明有数据异常，或者写入断裂等问题，这就需要通过InnoDB的特性——两次写来保证了。在这8个字节的后面4个字节中，存储了当前页面最新被修改的LSN值，也就是文件头信息中的FIL_PAGE_LSN值，也是用来校验的，意义与前者类似。

综上所述，就是我们所熟知的InnoDBBuffer页的所有内容及管理方式，知道这些之后，应该会对日常的MySQL运维有所帮助。

## 页面重组

前面已经知道，一个页面在管理的过程中，都会涉及数据的不断插入和不断删除，并且在插入数据时，都会去已经删除的可重用链表中找合适的空间，如果能放得下，就会将新的记录放到这部分空间中。但久而久之，如果写入删除频繁，则很有可能会造成页面空间管理非常碎的情况，所有的空闲空间大小加起来，可以存储很多数据，但是从FREE链表中，找不到任何可以放得下一条记录的位置，这种现象就叫作页面碎片。

页面碎片太多了，一般会造成如下三个问题。
- 空间占用比较高，但索引数据比较少。
- 在使用这个表的时候，会导致大量的无效IO，因为很多空间都是碎片。
- 数据库整体性能变差。

一般可以通过下面的语句来查看一个表的空间使用率。

从上面输出的信息可以很明显地看出来，Data_free的大小是11008999424，而Data_length为36716544。通过计算，表碎片率达到99.8%，当然，不能完全说这是碎片，也有很多情况是一个大表在数据被删除后没及时回收空间造成的。

已经被删除数据的表本应该被及时处理回收空间，否则占用的空间完全属于浪费。这种情况，一般都会去做一个空的改表操作，比如直接使用al ter table tablename engine innodb，就可以将这个表的空间收回来，相当于重组一次表。

而对于页面也是一样的道理，在数据库向某一个页面插入时，如果找不到大小合适的页面空间，就会去做一次页面重组操作。重组的方式很简单，就是新建一个BufferPool页面，然后将碎片页面的数据一条一条地插入到新的页面，因为复制记录的时候，是从小到大进行的，所以插入的数据也是一直往后追加的。插入完成之后，将原来的Buffer Pool页面释放掉，使新的内存空间对应上这个页面，这样就做了一次重组。由于新页面中所有数据都是连续插入进去的，这样使得空间完全没有浪费的情况，最后一条记录后面的空间都在PAGE_HEAP_TOP下面管理着，属于未使用空间，如此便实现了页面的重组操作。

## 索引页面的回收
之前已经介绍过，在数据插入时，B+树会不断地分裂，从而导致这棵树会变成一个矮胖子，那么数据如何被删除呢？B+树会做什么样的操作呢？在这一节将会揭晓答案。

传统B+树的数据删除，一般都会有一个所谓的填充因子，来控制页面数据的删除比例，如果数据量小于这个填充因子所表示的数据量，就会有节点合并，这与分裂是相对应的，其实际操作起来比较复杂，情况也比较多，这方面的资料可以参考一些书籍来详细了解一下。在这一节中，会专门针对InnoDB的实现，来讲述页面的回收机制。

关于InnoDB记录删除，分下面三种情况。

1.InnoDB在删除数据时，都会先检查当前页面剩余的记录数，如果只剩下一条记录，就直接将这个页面从B+树中摘除，也只有这种情况，InnoDB才会回收一个页面，这正是与上面所讲的传统B+树的删除算法的不同所在。InnoDB的页面根本不存在合并这么一说，只有当页面剩下的数据只剩下1条，并且这条数据正好又是要被删除的记录时，这个页面才会被回收。当然，这个页面不能是根页面，根页面可以是空闲的，即可以是空表。当然，如果这一步中，这个页面只剩下最后一条记录，则可以直接将页面从B+树中摘除，下面两个也就不需要了。

2.如果要删除记录所在的页面为内节点，并且要删除的记录为本页面中的最左边记录，也就是最小记录的下一条记录，则说明此时的记录删除所影响的还有其父亲节点的指针。因为每个内节点的最左边记录，都会在其父亲节点的某个位置存储着，并指向这个要删除的记录，所以此时需要更新其父亲节点的这条记录。

3.做完上面两件事之后，就可以放心地将本页面中要删除的记录删除。删除之后，记录删除的操作就完成了。

接下来，详细讲述一下上面步骤中的第一步，看看是如何从一个B+树中摘除一个页面的。

1.首先判断当前页面的兄弟节点，如果没有任何兄弟了，就将本节点直接删除。但在这种情况下，如果一层只有一个节点，并且是空的，则这棵B+树就是空的，这样就会递归地将整个B+树释放掉，最后只剩下一个空的根节点。

2.根据本节点，找到其父节点，并且找到指向被删除节点的指针索引记录，然后用上面所述的删除记录步骤，将这条记录删除，这样有可能会产生递归作用。

3.删除上层索引记录之后，将本节点从兄弟双向链表中摘除。

4.将被删除的页面归还到本表空间的簇管理链表中去。

这是删除一个节点的步骤，在上面删除记录时，还有一个重要的问题没有讲述，那就是第二步中删除最左边记录时导致的父亲节点中索引指针记录的更新。这也比较容易理解，操作步骤如下。

1.还是一样，根据当前要删除的记录，找到父亲节点中的索引指针记录，然后通过一样的递归删除方法，将这条记录删除。

2.根据被删除记录的下一条记录，构造一个新的索引指针记录，指向的孩子节点不会改变。

3.将上面构造的指针记录，插入到当前节点的父亲节点中。这样就相当于更新了父亲节点中的索引指针记录，从而维护了B+树本身的特性。

上面所讲述的是在事务提交时，将已经打了删除标志的记录做PURGE的时候，才会从B+树中真正删除记录的操作，步骤列得比较简单，但也说明了整体的B+树退化的过程。

从上面的回收机制中可以看到，相比传统的B+树数据删除算法而言，页面不做合并操作会相对简单一些，容易操作。但也有缺点，那就是删除数据时，如果随机性比较大，就会导致B+树的空间浪费或碎片比较明显，有些页面可能长期都会处于填充因子以下，占用的空间比较大，但实际存储的数据没有多少。所以，对于InnoDB存储引擎的数据库表来说，需要经常做一些巡检，可以直接使用上面提到的语句al ter table tablename engine innodb来整理，空闲空间比较大的可以常做改表操作，以便回收一些空间。

至此，B+树索引潮起又潮落，算是讲述完毕了，希望能帮助各位同学。













































































































