---
layout: post
categories: [Java]
description: none
keywords: Java
---
# Stream分组
Stream是Java8的一个新特性，主要用户集合数据的处理，如排序、过滤、去重等等功能。利用Stream.collect()来对List进行分组。

## 

Person类Person.java：
```java
@Data
@ToString
public class Person {
    /**
     * id
     */
    private Integer id;
    /**
     * 年龄
     */
    private Integer age;
    /**
     * 类型
     */
    private String type;
    /**
     * 姓名
     */
    private String name;
    /**
     * 性别
     */
    private String gender;
}
```

## 利用单个字段进行分组
如上面的Person类，如果对于其中的某一个字段进行分组（如gender），则比较简单，我们可以利用Stream.collect()和Collectors.groupingBy结合，即可进行分组groupingBy，代码如下：
```
public class TestGroupingBy {

    public static void main(String[] args) {

        List<Person> personList = Arrays.asList(
                new Person().setId(1).setAge(18).setType("student").setName("user - 1").setGender("male"),
                new Person().setId(2).setAge(20).setType("student").setName("user - 2").setGender("male"),
                new Person().setId(3).setAge(18).setType("student").setName("user - 3").setGender("male"),
                new Person().setId(4).setAge(18).setType("student").setName("user - 4").setGender("male"),
                new Person().setId(5).setAge(35).setType("teacher").setName("user - 5").setGender("male"),
                new Person().setId(6).setAge(35).setType("teacher").setName("user - 6").setGender("male"),
                new Person().setId(7).setAge(20).setType("student").setName("user - 7").setGender("male"),
                new Person().setId(8).setAge(20).setType("student").setName("user - 8").setGender("female"),
                new Person().setId(9).setAge(20).setType("student").setName("user - 9").setGender("female"),
                new Person().setId(10).setAge(20).setType("student").setName("user - 10").setGender("female")
        );

        Map<String, List<Person>> groupingMap = personList.stream().collect(Collectors.groupingBy(Person::getGender));
}
```
其中的groupingMap ，类型为Map<String, List<Person>>，第一个泛型为String即分组字段（本例中为gender字段）的类型，第二个泛型为List<Person>及分组结果的类型。

## 利用多个字段进行分组
上面的例子是按单个字段分组，如果需要按照多个字段，如gender、age、type三个字段进行分组，同样也可以可以利用Stream.collect()和Collectors.groupingBy结合的方式进行分组，不过该方式中调用Collectors.groupingBy时需要多次嵌套调用，测试代码如下：
```
public class TestGroupingBy {

    public static void main(String[] args) {

        List<Person> personList = Arrays.asList(
                new Person().setId(1).setAge(18).setType("student").setName("user - 1").setGender("male"),
                new Person().setId(2).setAge(20).setType("student").setName("user - 2").setGender("male"),
                new Person().setId(3).setAge(18).setType("student").setName("user - 3").setGender("male"),
                new Person().setId(4).setAge(18).setType("student").setName("user - 4").setGender("male"),
                new Person().setId(5).setAge(35).setType("teacher").setName("user - 5").setGender("male"),
                new Person().setId(6).setAge(35).setType("teacher").setName("user - 6").setGender("male"),
                new Person().setId(7).setAge(20).setType("student").setName("user - 7").setGender("male"),
                new Person().setId(8).setAge(20).setType("student").setName("user - 8").setGender("female"),
                new Person().setId(9).setAge(20).setType("student").setName("user - 9").setGender("female"),
                new Person().setId(10).setAge(20).setType("student").setName("user - 10").setGender("female")
        );

        // 多字段嵌套分组
        Map<String, Map<Integer, Map<String, List<Person>>>> groupingMap = personList.stream().collect(
                Collectors.groupingBy(Person::getGender, 
                        Collectors.groupingBy(Person::getAge, 
                                Collectors.groupingBy(Person::getType)
                        )
                )
        );

    }
}
```
其中groupingMap类型为Map<String, Map<Integer, Map<String, List<Person>>>>，是一个嵌套了三层的Map，对应的泛型String/Integer/String分别为对应分组字段的类型，最后一层Map的value类型为List<Person>为实际分组后的数据集合类型

可以看到，原先的List数据，按照gender/age/type三个属性，分成了三层的Map，对于这种多层的Map代码上处理起来会有一些不方便。并且如果分组字段更多的话，所嵌套的Collectors.groupingBy也会更加多，代码书写起来也不太优雅。

## 利用Collectors.groupingBy与Function结合进行多字段分组
查看Collectors.groupingByAPI会发现，其中一种用法是第一个参数为Function

简单翻译一下就是：一种将输入元素映射到键的分类函数。即需要定义一个函数Function，该函数将元素对象映射到一个键的集合里。代码示例如下：
```
public class TestGroupingBy {

    public static void main(String[] args) {

        List<Person> personList = Arrays.asList(
                new Person().setId(1).setAge(18).setType("student").setName("user - 1").setGender("male"),
                new Person().setId(2).setAge(20).setType("student").setName("user - 2").setGender("male"),
                new Person().setId(3).setAge(18).setType("student").setName("user - 3").setGender("male"),
                new Person().setId(4).setAge(18).setType("student").setName("user - 4").setGender("male"),
                new Person().setId(5).setAge(35).setType("teacher").setName("user - 5").setGender("male"),
                new Person().setId(6).setAge(35).setType("teacher").setName("user - 6").setGender("male"),
                new Person().setId(7).setAge(20).setType("student").setName("user - 7").setGender("male"),
                new Person().setId(8).setAge(20).setType("student").setName("user - 8").setGender("female"),
                new Person().setId(9).setAge(20).setType("student").setName("user - 9").setGender("female"),
                new Person().setId(10).setAge(20).setType("student").setName("user - 10").setGender("female")
        );

        // 定义一个函数Function，该函数将元素对象映射到一个键的集合里
        Function<Person, List<Object>> compositeKey = person ->
                Arrays.asList(person.getGender(), person.getAge(), person.getType());

        // 分组
        Map<List<Object>, List<Person>> groupingMap =
                personList.stream().collect(Collectors.groupingBy(compositeKey, Collectors.toList()));

    }
}
```
groupingMap数据仅仅只有一层，但是其键值Key却是一个List，里面包含了分组字段的值。由于Map只有一层，用该方式分组的结果，对于我们业务也是比较友好，代码里对数据处理起来也是比较方便的。

## List转Map
第一种（会出现键重复异常）：
```
//以id为主键转为map
Map<Long, User> map = list.stream().collect(Collectors.toMap(User::getId,Function.identity()));
```
第二种（针对第一种方法会出现情况）：
```
//给出key重复时，使用哪个key作为主键，以下代码中的(key1, key2) -> key2)代表key1和key2键重复时返回key2做主键
Map<Long, User> map = list.stream().collect(Collectors.toMap(User::getId, Function.identity(), (key1, key2) -> key2));
```
第三种（只返回对象里某个属性时）：
```
// 不想返回对象，只返回对象里某个属性时 采用这种方式
Map<Long, String> map = list.stream().collect(Collectors.toMap(User::getId, User::getAge, (key1, key2) -> key2));
```
第四种（以某个属性分组）：
```
Map<Integer, List> map = list.stream().collect(Collectors.groupingBy(User::getId));
```

## map 里面的key值的改变
举例，将map的首字母小写
```
HashMap<String, String> posNoticesMap = new HashMap<>();
posNoticesMap.put("SDSD","sdsad");

Map<String, String> newMap = posNoticesMap.entrySet().stream().collect(Collectors.toMap(entry -> StringUtils.uncapitalize(entry.getKey()), entry -> entry.getValue()));
```
