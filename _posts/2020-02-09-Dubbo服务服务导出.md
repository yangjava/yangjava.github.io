---
layout: post
categories: [Dubbo]
description: none
keywords: Dubbo
---
# Dubbo服务发布流程

## 服务导出
参数解析并非是重头戏，在上面一系列的解析结束后，Dubbo 开始进行服务导出的操作。我们这里假设使用zk作为注册中心，协议为dubbo。
在默认情况下，Dubbo同时支持本地导出和远程协议导出，我们可以通过ServiceConfig 的setScope 方法进行配置，scope 的取值有四种情况：
- none ：表示不导出服务，
- remote ：表示只导出远程服务，
- local ：表示只导出本地服务。
- null ：在默认情况下为null，会同时导出本地服务和远程服务

### 本地服务导出
本地服务导出并不需要与注册中心交互，也不需要开启远程服务，所以其实现比较简单，将某些参数限制，指定协议类型为injvm。
```java
    private void exportLocal(URL url) {
    	// 如果 URL 的协议头等于 injvm，说明已经导出到本地了，无需再次导出
        if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {
            URL local = URL.valueOf(url.toFullString())
            		// 设置协议为  injvm
                    .setProtocol(Constants.LOCAL_PROTOCOL)
                    // 设置host为127.0.0.1
                    .setHost(LOCALHOST)
                    // 设置端口为0
                    .setPort(0);
            // 创建 Invoker，并导出服务，这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法
            Exporter<?> exporter = protocol.export(
                    proxyFactory.getInvoker(ref, (Class) interfaceClass, local));
            // 添加到暴露的服务集合中
            exporters.add(exporter);
            logger.info("Export dubbo service " + interfaceClass.getName() + " to local registry");
        }
    }
```
因为Dubbo SPI 的原因，这里协议设置为 injvm，会使用 InjvmProtocol 来进行服务暴露。

## 远程服务导出
相较于本地服务导出，远程服务导出需要考虑到协议类型，notify 通知等方面，所以逻辑就显得复杂许多。
```java
		// 如果存在服务注册中心
      if (registryURLs != null && !registryURLs.isEmpty()) {
          for (URL registryURL : registryURLs) {
          	// 是否动态，该字段标识是有自动管理服务提供者的上线和下线，若为false 则人工管理
              url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));
              // 1. 加载 Dubbo 监控中心配置
              URL monitorUrl = loadMonitor(registryURL);
              // 如果监控中心配置存在，则添加注册中心的 URL。key 为 monitor
              if (monitorUrl != null) {
                  url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());
              }
       
           		// 代理配置解析
              String proxy = url.getParameter(Constants.PROXY_KEY);
              if (StringUtils.isNotEmpty(proxy)) {
                  registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);
              }
				// 2. 远程服务导出
              Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
              DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);

              Exporter<?> exporter = protocol.export(wrapperInvoker);
              // 将暴露的服务保存到 exporters中，exporters 保存了本机暴露出的服务
              exporters.add(exporter);
          }
      } else {
      		// 3. 直连方式，不存在服务注册中心,直连方式是和上面的区别就是不经过注册中心注册，并不订阅注册中心节点。
          Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
          DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
		 // 由于没有注册中心，这里会直接根据服务指定的协议，如Dubbo，则会直接使用 DubboProtocol 来暴露服务。
          Exporter<?> exporter = protocol.export(wrapperInvoker);
          exporters.add(exporter);
      }
```
这里需要注意Dubbo在这里区分了存在注册中心和不存在注册中心的情况，因为 Dubbo允许不使用注册中心而通过服务之间直接连接的方式来调用服务。其区别就是直连方式不会经过 Dubbo的 各种容错机制。

我们这里仍以上一篇的 URL 为例，这里为了方便描述，URL 做了简化，registryURL 和 URL 如下：
```java
// 注册中心 URl
registryURL  = registry://localhost:2181/org.apache.dubbo.registry.RegistryService&registry=zookeeper
// 要暴露的服务 URL
url = dubbo://localhost:9999/com.kingfish.service.DemoService
```

### 注册监控中心
对监控中心的处理并不复杂，通过loadMonitor 生成一个关于监控中心的 URL ，并追加到 url 上。 loadMonitor 方法是完成监控URL的生成过程，并不复杂，这里篇幅问题不再展开。
```java
  // 1. 加载 Dubbo 监控中心配置
   URL monitorUrl = loadMonitor(registryURL);
   // 如果监控中心配置存在，则添加
   if (monitorUrl != null) {
       url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());
   }
```
我们假设为存在 localhost:8080 的监控中心，则此时 URL 变为(URL 有简化) ：
```java
dubbo://localhost:9999/com.kingfish.service.DemoService
	&monitor=http://localhost:8080?interface=org.apache.dubbo.monitor.MonitorService
```

### 服务的暴露
服务提供者导出服务具体使用的是下列代码：
```java
	// 1. 生成代理类
	 Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
     DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
	// 2. 暴露服务
     Exporter<?> exporter = protocol.export(wrapperInvoker);
     // 将暴露的服务保存到 exporters中，当消费者调用时，提供者可以从中获取已经暴露的服务
     exporters.add(exporter);

```
这里的 Invoker 是 通过JavassistProxyFactory#getInvoker 方法生成的匿名 AbstractProxyInvoker 类。从这里开始，慢慢进入了服务导出的核心内容，下面我们来继续具体分析这个过程。

### 生成代理对象
该部分代码如下，其中Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠拢，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。
```java
 Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
```
这里需要注意：
proxyFactory.getInvoker 的入参URL 为 registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())。这里将 url 添加到了 registryURL 中，所以proxyFactory.getInvoker 的入参 URL 如下：
```java
registry://localhost:2181/org.apache.dubbo.registry.RegistryService&registry=zookeeper
	&export=dubbo://localhost:9999/com.kingfish.service.DemoService
	&monitor=http://localhost:8080?interface=org.apache.dubbo.monitor.MonitorService
```
此时我们看一下 URL的结构：
```java
registry://... : 保存了注册中心的信息， registry=zookeeper 表明使用zk作为注册中心
export=dubbo://... : 保存了要导出服务的信息
monitor=http://... : 保存了监控中心的信息
```
在后面我们会介绍，由于 registry:// 所以 Dubbo会选择 RegistryProtocol 来处理本地服务暴露，而 RegistryProtocol 中会将 export 的参数取出识别出 dubbo:// 选择 DubboProtocol 来进行服务暴露。

proxyFactory 和 protocol 定义如下：
```java
private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();

private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();

```
可以看出 proxyFactory 和 protocol 都是 SPI 扩展接口的适配器类型。所以这里的 proxyFactory实际上是 ProxyFactory$Adaptive 类型，所以这里首先执行的是 ProxyFactory$Adaptive#getInvoker() 方法，而对于 ProxyFactory SPI 接口来说，默认的协议类型为 javassist，所以调用的是 JavassistProxyFactory#getInvoker 方法获取了代理类。而JavassistProxyFactory#getInvoker 代码如下 ：
```java
    @Override
    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
        // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
        // 将服务实现类转换成Wrapper 类，以减少反射的调用
        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
        // 创建匿名 Invoker 类对象，并实现 doInvoke 方法。
        return new AbstractProxyInvoker<T>(proxy, type, url) {
            @Override
            protected Object doInvoke(T proxy, String methodName,
                                      Class<?>[] parameterTypes,
                                      Object[] arguments) throws Throwable {
                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
            }
        };
    }
```
可以看到，在JavassistProxyFactory#getInvoker中将SPI 实现类动态转换成了 Wrapper，并封装成Invoker类型返回。

其中Wrapper 是在 JavassistProxyFactory#getInvoker 中动态生成的，如对于DemoService 接口来说，
```java
public interface DemoService {
    void sayMsg(String msg);

    String sayHello(String name);
}
```
其生成的Wrapper 类如下，可以看到这里的 invokeMethod 方法通过方法名称来匹配调用的方法，从而调用ref 对应的方法。：
```java

/*
 * Decompiled with CFR.
 * 
 * Could not load the following classes:
 *  com.kingfish.service.impl.DemoServiceImpl
 */
package org.apache.dubbo.common.bytecode;

import com.kingfish.service.impl.DemoServiceImpl;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;
import org.apache.dubbo.common.bytecode.ClassGenerator;
import org.apache.dubbo.common.bytecode.NoSuchMethodException;
import org.apache.dubbo.common.bytecode.NoSuchPropertyException;
import org.apache.dubbo.common.bytecode.Wrapper;

public class Wrapper1
extends Wrapper
implements ClassGenerator.DC {
    public static String[] pns;
    public static Map pts;
    public static String[] mns;
    public static String[] dmns;
    public static Class[] mts0;
    public static Class[] mts1;
    public static Class[] mts2;
    public static Class[] mts3;

    @Override
    public String[] getPropertyNames() {
        return pns;
    }

    @Override
    public boolean hasProperty(String string) {
        return pts.containsKey(string);
    }

    public Class getPropertyType(String string) {
        return (Class)pts.get(string);
    }

    @Override
    public String[] getMethodNames() {
        return mns;
    }

    @Override
    public String[] getDeclaredMethodNames() {
        return dmns;
    }

    @Override
    public void setPropertyValue(Object object, String string, Object object2) {
        try {
            DemoServiceImpl demoServiceImpl = (DemoServiceImpl)object;
        }
        catch (Throwable throwable) {
            throw new IllegalArgumentException(throwable);
        }
        throw new NoSuchPropertyException(new StringBuffer().append("Not found property \"").append(string).append("\" field or setter method in class com.kingfish.service.impl.DemoServiceImpl.").toString());
    }

    @Override
    public Object getPropertyValue(Object object, String string) {
        try {
            DemoServiceImpl demoServiceImpl = (DemoServiceImpl)object;
        }
        catch (Throwable throwable) {
            throw new IllegalArgumentException(throwable);
        }
        throw new NoSuchPropertyException(new StringBuffer().append("Not found property \"").append(string).append("\" field or setter method in class com.kingfish.service.impl.DemoServiceImpl.").toString());
    }
	// 这里会根据方法名匹配到对应实例到的具体方法
    public Object invokeMethod(Object object, String string, Class[] classArray, Object[] objectArray) throws InvocationTargetException {
        DemoServiceImpl demoServiceImpl;
        try {
            demoServiceImpl = (DemoServiceImpl)object;
        }
        catch (Throwable throwable) {
            throw new IllegalArgumentException(throwable);
        }
        try {
            if ("sayMsg".equals(string) && classArray.length == 1) {
                demoServiceImpl.sayMsg((String)objectArray[0]);
                return null;
            }
          
            if ("sayHello".equals(string) && classArray.length == 1) {
                return demoServiceImpl.sayHello((String)objectArray[0]);
            }
           
        }
        catch (Throwable throwable) {
            throw new InvocationTargetException(throwable);
        }
        throw new NoSuchMethodException(new StringBuffer().append("Not found method \"").append(string).append("\" in class com.kingfish.service.impl.DemoServiceImpl.").toString());
    }
}
```
这里就可以知道 ProxyFactory#getInvoker 返回的是由 JavassistProxyFactory#getInvoker 生成的匿名代理类 Invoker。

我们这里再来梳理一下：

当服务提供者暴露服务接口时，会调用 ProxyFactory#getInvoker 来生成一个 Invoker，此处由于 Dubbo SPI 的存在实际调用的是 JavassistProxyFactory#getInvoker。我们这里为了方便描述，把 JavassistProxyFactory#getInvoker 方法返回的 Invoker 称为 Javassist Invoker。

JavassistProxyFactory#getInvoker 方法中 第一步会生成一个 Wrapper 类来包装暴露的接口实例。如果需要调用实例的方法，则通过 Wrapper#invokeMethod 方法来调用，在 Wrapper#invokeMethod 中会根据调用的methodName 来直接调用实例的方法。如下代码：
```java
  final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type)
```
JavassistProxyFactory#getInvoker 方法中 第二步会创建一个AbstractProxyInvoker 的匿名实现类并返回，即我们上面提到的 Javassist Invoker。而 Javassist Invoker 的doInvoke 方法具体实现会委托给 Wrapper#invokeMethod 方法来处理。
```java
       @Override
       protected Object doInvoke(T proxy, String methodName,
                                 Class<?>[] parameterTypes,
                                 Object[] arguments) throws Throwable {
           return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
       }
```
当消费者调用提供者服务时，提供者会调用 Javassist Invoker 的 doInvoke 方法，该方法会委托给 Wrapper#invokeMethod 来处理，而 Wrapper#invokeMethod 中会根据 methodName 来调用实例的具体方法。即整个流程简化如下：
```java
Invoker#invoke -> AbstractProxyInvoker#doInvoke -> Wrapper#invokeMethod -> 调用 Ref 具体方法
```
注： Wrapper 的存在是为了减少调用 接口实例的反射。如果没有Wrapper，在 Javassist Invoker 的 doInvoke 方法中，则会根据 methodName 直接反射调用 proxy 对象。而 Wrapper 中动态生成了针对当前对象的方法，会根据方法名是否相同来直接调用实例方法，免去了反射调用 proxy 对象的过程。

## 服务暴露
经过了上面的过程， 暴露的接口对象的代理对象已经创建，这一步开始对该代理对象进行暴露。
该部分代码如下：
```java
 // 使用 DelegateProviderMetaDataInvoker  包装了一下 代理invoker。DelegateProviderMetaDataInvoker  中除了 Invoker 还保存了服务配置的数据
 DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
 // 进行服务暴露
 Exporter<?> exporter = protocol.export(wrapperInvoker);
```
当执行到 protocol.export(wrapperInvoker); 时，同样由于Dubbo SPI 机制，实际调用的是 Protocol$Adaptive#export() 方法。

并且由于Dubbo SPI 的扩展点使用了Wrapper自动增强，对于 Protocol 来说，存在三个Wrapper 增强。由于只有已知的这三个Wrapper，并且加载顺序不影响功能，为了方便描述，这里忽略这三个 Wrapper的排序问题。所以整个调用过程是 Protocol$Adaptive#export() => QosProtocolWrapper#export() => ProtocolListenerWrapper #export() => ProtocolFilterWrapper#export() => XxxProtocol#export() 。

对于 远程导出 的URL 来说：
- 存在注册中心：会使用 RegistryProtocol 来处理服务。这就导致 URL 变更为了 registry://localhost:2181/org.apache.dubbo.registry.RegistryService，但是这个URL中并没有包含暴露的接口的信息，所以URL 在暴露服务时会添加一个参数 export来记录需要暴露的服务信息。此时 URL 会变成 registry://localhost:2181/org.apache.dubbo.registry.RegistryService&export=URL.encode("dubbo://localhost:9999/com.kingfish.service.DemoService?version=1.0.0")。 而之后基于 Dubbo SPI的 自适应机制，根据 URL registry 协议会选择RegistryProtocol 来暴露服务，而 RegistryProtocol 只负责处理注册中心相关的内容，额外的暴露服务，会根据 export 参数指定的 URL 信息选择。这里URL 协议为 dubbo，则说明服务的暴露需要使用 Dubbo协议，则会使用 DubboProtocol 来进行服务暴露。
- 不存在注册中心 ：不存在注册中心时，最终暴露服务的URL 为 dubbo://localhost:9999/com.kingfish.service.DemoService?version=1.0.0，此时会根据 Dubbo SPI选择 DubboProtocol中的export方法进行暴露服务端口。这里 URL 也可能是别的协议，此时会寻找对应的Protocol 来处理，我们这里还是以 Dubbo 为例。

所以这里对于 XxxProtocol，存在三种情况：
- 本地服务导出：这种情况我们在上面说了，其内部根据URL 中Protocol类型为 injvm，会选择InjvmProtocol
- 远程服务导出 & 有注册中心：其内部根据URL 中 Protocol 类型为 registry，会选择RegistryProtocol
- 远程服务导出 & 没有注册中心：根据服务协议头类型判断，我们这里假设是 dubbo ，则会选择 DubboProtocol



























