---
layout: post
title: Git概述
categories: Git
description: none
keywords: Git,SVN
---

# Git

# 参考资料

Git-it(Git学习资料)：https://github.com/jlord/git-it

Git统计脚本：https://github.com/arzzen/git-quick-stats

Pro Git 2nd：https://git-scm.com/book/en/v2

# Git使用场景

**git**对于大家应该都不太陌生，熟练使用git已经成为程序员的一项基本技能，尽管在工作中有诸如 `Sourcetree`这样牛X的客户端工具，使得合并代码变的很方便。但找工作面试和一些需彰显个人实力的场景，仍然需要我们掌握足够多的git命令。

下边我们整理了日常用git合代码的经典操作场景，基本覆盖了工作中的需求。

### 我刚才提交了什么?

如果你用 `git commit -a` 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前`HEAD`上的最近一次的提交(commit):

```sh
(main)$ git show
```

或者

```sh
$ git log -n1 -p
```

### 我的提交信息(commit message)写错了

如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):

```sh
$ git commit --amend --only
```

这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:

```sh
$ git commit --amend --only -m 'xxxxxxx'
```

如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。

### 我提交(commit)里的用户名和邮箱不对

如果这只是单个提交(commit)，修改它：

```sh
$ git commit --amend --author "New Authorname <authoremail@mydomain.com>"
```

如果你需要修改所有历史, 参考 'git filter-branch'的指南页.

### 我想从一个提交(commit)里移除一个文件

通过下面的方法，从一个提交(commit)里移除一个文件:

```sh
$ git checkout HEAD^ myfile
$ git add -A
$ git commit --amend
```

这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。

### 我想删除我的的最后一次提交(commit)

如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。

```sh
$ git reset HEAD^ --hard
$ git push -f [remote] [branch]
```

如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):

```
(my-branch*)$ git reset --soft HEAD@{1}
```

这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 `git revert SHAofBadCommit`， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是rebase-safe的 (例如： 其它开发者不会从这个分支拉), 只需要使用 `git push -f`。

### 删除任意提交(commit)

同样的警告：不到万不得已的时候不要这么做.

```sh
$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT
$ git push -f [remote] [branch]
```

或者做一个 [交互式rebase](https://my.oschina.net/u/4455409/blog/5474550#interactive-rebase) 删除那些你想要删除的提交(commit)里所对应的行。

### 我尝试推一个修正后的提交(amended commit)到远程，但是报错：

```sh
To https://github.com/yourusername/repo.git
! [rejected]        mybranch -> mybranch (non-fast-forward)
error: failed to push some refs to 'https://github.com/tanay1337/webmaker.org.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

注意, rebasing(见下面)和修正(amending)会用一个**新的提交(commit)代替旧的**, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (`-f`)。 注意 – *总是* 确保你指明一个分支!

```sh
(my-branch)$ git push origin mybranch -f
```

一般来说, **要避免强推**. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。

### 我意外的做了一次硬重置(hard reset)，我想找回我的内容

如果你意外的做了 `git reset --hard`, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。

```sh
(main)$ git reflog
```

你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的SHA，再重置一次:

```sh
(main)$ git reset --hard SHA1234
```

这样就完成了。

## 暂存(Staging)

### 我需要把暂存的内容添加到上一次的提交(commit)

```sh
(my-branch*)$ git commit --amend
```

### 我想要暂存一个新文件的一部分，而不是这个文件的全部

一般来说, 如果你想暂存一个文件的一部分, 你可这样做:

```sh
$ git add --patch filename.x
```

`-p` 简写。这会打开交互模式， 你将能够用 `s` 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:

```sh
$ git add -N filename.x
```

然后, 你需要用 `e` 选项来手动选择需要添加的行，执行 `git diff --cached` 将会显示哪些行暂存了哪些行只是保存在本地了。

### 我想把在一个文件里的变化(changes)加到两个提交(commit)里

`git add` 会把整个文件加入到一个提交. `git add -p` 允许交互式的选择你想要提交的部分.

### 我想把暂存的内容变成未暂存，把未暂存的内容暂存起来

多数情况下，你应该将所有的内容变为未暂存，然后再选择你想要的内容进行commit。 但假定你就是想要这么做，这里你可以创建一个临时的commit来保存你已暂存的内容，然后暂存你的未暂存的内容并进行stash。然后reset最后一个commit将原本暂存的内容变为未暂存，最后stash pop回来。

```sh
$ git commit -m "WIP"
$ git add .
$ git stash
$ git reset HEAD^
$ git stash pop --index 0
```

注意1: 这里使用`pop`仅仅是因为想尽可能保持幂等。 注意2: 假如你不加上`--index`你会把暂存的文件标记为为存储。

## 未暂存(Unstaged)的内容

### 我想把未暂存的内容移动到一个新分支

```sh
$ git checkout -b my-branch
```

### 我想把未暂存的内容移动到另一个已存在的分支

```sh
$ git stash
$ git checkout my-branch
$ git stash pop
```

### 我想丢弃本地未提交的变化(uncommitted changes)

如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：

```sh
# one commit
(my-branch)$ git reset --hard HEAD^
# two commits
(my-branch)$ git reset --hard HEAD^^
# four commits
(my-branch)$ git reset --hard HEAD~4
# or
(main)$ git checkout -f
```

重置某个特殊的文件, 你可以用文件名做为参数:

```sh
$ git reset filename
```

### 我想丢弃某些未暂存的内容

如果你想丢弃工作拷贝中的一部分内容，而不是全部。

签出(checkout)不需要的内容，保留需要的。

```sh
$ git checkout -p
# Answer y to all of the snippets you want to drop
```

另外一个方法是使用 `stash`， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。

```sh
$ git stash -p
# Select all of the snippets you want to save
$ git reset --hard
$ git stash pop
```

或者, stash 你不需要的部分, 然后stash drop。

```sh
$ git stash -p
# Select all of the snippets you don't want to save
$ git stash drop
```

## 分支(Branches)

### 我从错误的分支拉取了内容，或把内容拉取到了错误的分支

这是另外一种使用 `git reflog` 情况，找到在这次错误拉(pull) 之前HEAD的指向。

```sh
(main)$ git reflog
ab7555f HEAD@{0}: pull origin wrong-branch: Fast-forward
c5bc55a HEAD@{1}: checkout: checkout message goes here
```

重置分支到你所需的提交(desired commit):

```sh
$ git reset --hard c5bc55a
```

完成。

### 我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致

先确认你没有推(push)你的内容到远程。

`git status` 会显示你领先(ahead)源(origin)多少个提交:

```sh
(my-branch)$ git status
# On branch my-branch
# Your branch is ahead of 'origin/my-branch' by 2 commits.
#   (use "git push" to publish your local commits)
#
```

一种方法是:

```sh
(main)$ git reset --hard origin/my-branch
```

### 我需要提交到一个新分支，但错误的提交到了main

在main下创建一个新分支，不切换到新分支,仍在main下:

```sh
(main)$ git branch my-branch
```

把main分支重置到前一个提交:

```sh
(main)$ git reset --hard HEAD^
```

`HEAD^` 是 `HEAD^1` 的简写，你可以通过指定要设置的`HEAD`来进一步重置。

或者, 如果你不想使用 `HEAD^`, 找到你想重置到的提交(commit)的hash(`git log` 能够完成)， 然后重置到这个hash。 使用`git push` 同步内容到远程。

例如, main分支想重置到的提交的hash为`a13b85e`:

```sh
(main)$ git reset --hard a13b85e
HEAD is now at a13b85e
```

签出(checkout)刚才新建的分支继续工作:

```sh
(main)$ git checkout my-branch
```

### 我想保留来自另外一个ref-ish的整个文件

假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:

```sh
(solution)$ git add -A && git commit -m "Adding all changes from this spike into one big commit."
```

当你想要把它放到一个分支里 (可能是`feature`, 或者 `develop`), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。

假设你有:

- 分支 `solution`, 拥有原型方案， 领先 `develop` 分支。
- 分支 `develop`, 在这里你应用原型方案的一些内容。

我去可以通过把内容拿到你的分支里，来解决这个问题:

```sh
(develop)$ git checkout solution -- file1.txt
```

这会把这个文件内容从分支 `solution` 拿到分支 `develop` 里来:

```sh
# On branch develop
# Your branch is up-to-date with 'origin/develop'.
# Changes to be committed:
#  (use "git reset HEAD <file>..." to unstage)
#
#        modified:   file1.txt
```

然后, 正常提交。

Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem.

### 我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里

假设你有一个`main`分支， 执行`git log`, 你看到你做过两次提交:

```sh
(main)$ git log

commit e3851e817c451cc36f2e6f3049db528415e3c114
Author: Alex Lee <alexlee@example.com>
Date:   Tue Jul 22 15:39:27 2014 -0400

    Bug #21 - Added CSRF protection

commit 5ea51731d150f7ddc4a365437931cd8be3bf3131
Author: Alex Lee <alexlee@example.com>
Date:   Tue Jul 22 15:39:12 2014 -0400

    Bug #14 - Fixed spacing on title

commit a13b85e984171c6e2a1729bb061994525f626d14
Author: Aki Rose <akirose@example.com>
Date:   Tue Jul 21 01:12:48 2014 -0400

    First commit
```

让我们用提交hash(commit hash)标记bug (`e3851e8` for #21, `5ea5173` for #14).

首先, 我们把`main`分支重置到正确的提交(`a13b85e`):

```sh
(main)$ git reset --hard a13b85e
HEAD is now at a13b85e
```

现在, 我们对 bug #21 创建一个新的分支:

```sh
(main)$ git checkout -b 21
(21)$
```

接着, 我们用 *cherry-pick* 把对bug #21的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。

```sh
(21)$ git cherry-pick e3851e8
```

这时候, 这里可能会产生冲突， 参见[交互式 rebasing 章](https://my.oschina.net/u/4455409/blog/5474550#interactive-rebase) [**冲突节**](https://my.oschina.net/u/4455409/blog/5474550#merge-conflict) 解决冲突.

再者， 我们为bug #14 创建一个新的分支, 也基于`main`分支

```sh
(21)$ git checkout main
(main)$ git checkout -b 14
(14)$
```

最后, 为 bug #14 执行 `cherry-pick`:

```sh
(14)$ git cherry-pick 5ea5173
```

### 我想删除上游(upstream)分支被删除了的本地分支

一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。

```sh
$ git fetch -p
```

### 我不小心删除了我的分支

如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:

```sh
(main)$ git checkout -b my-branch
(my-branch)$ git branch
(my-branch)$ touch foo.txt
(my-branch)$ ls
README.md foo.txt
```

添加文件并做一次提交

```sh
(my-branch)$ git add .
(my-branch)$ git commit -m 'foo.txt added'
(my-branch)$ foo.txt added
 1 files changed, 1 insertions(+)
 create mode 100644 foo.txt
(my-branch)$ git log

commit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012
Author: siemiatj <siemiatj@example.com>
Date:   Wed Jul 30 00:34:10 2014 +0200

    foo.txt added

commit 69204cdf0acbab201619d95ad8295928e7f411d5
Author: Kate Hudson <katehudson@example.com>
Date:   Tue Jul 29 13:14:46 2014 -0400

    Fixes #6: Force pushing after amending commits
```

现在我们切回到主(main)分支，‘不小心的’删除`my-branch`分支

```sh
(my-branch)$ git checkout main
Switched to branch 'main'
Your branch is up-to-date with 'origin/main'.
(main)$ git branch -D my-branch
Deleted branch my-branch (was 4e3cd85).
(main)$ echo oh noes, deleted my branch!
oh noes, deleted my branch!
```

在这时候你应该想起了`reflog`, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。

```
(main)$ git reflog
69204cd HEAD@{0}: checkout: moving from my-branch to main
4e3cd85 HEAD@{1}: commit: foo.txt added
69204cd HEAD@{2}: checkout: moving from main to my-branch
```

正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。

```sh
(main)$ git checkout -b my-branch-help
Switched to a new branch 'my-branch-help'
(my-branch-help)$ git reset --hard 4e3cd85
HEAD is now at 4e3cd85 foo.txt added
(my-branch-help)$ ls
README.md foo.txt
```

看! 我们把删除的文件找回来了。 Git的 `reflog` 在rebasing出错的时候也是同样有用的。

### 我想删除一个分支

删除一个远程分支:

```sh
(main)$ git push origin --delete my-branch
```

你也可以:

```sh
(main)$ git push origin :my-branch
```

删除一个本地分支:

```sh
(main)$ git branch -D my-branch
```

### 我想从别人正在工作的远程分支签出(checkout)一个分支

首先, 从远程拉取(fetch) 所有分支:

```sh
(main)$ git fetch --all
```

假设你想要从远程的`daves`分支签出到本地的`daves`

```sh
(main)$ git checkout --track origin/daves
Branch daves set up to track remote branch daves from origin.
Switched to a new branch 'daves'
```

(`--track` 是 `git checkout -b [branch] [remotename]/[branch]` 的简写)

这样就得到了一个`daves`分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.

## Rebasing 和合并(Merging)

### 我想撤销rebase/merge

你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。 Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。

```sh
(my-branch)$ git reset --hard ORIG_HEAD
```

### 我已经rebase过, 但是我不想强推(force push)

不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:

```sh
(main)$ git checkout my-branch
(my-branch)$ git rebase -i main
(my-branch)$ git checkout main
(main)$ git merge --ff-only my-branch
```

### 我需要组合(combine)几个提交(commit)

假设你的工作分支将会做对于 `main` 的pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 **所有** 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(main)分支是最新的和你的变化都已经提交了, 然后:

```sh
(my-branch)$ git reset --soft main
(my-branch)$ git commit -am "New awesome feature"
```

如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):

```sh
(my-branch)$ git rebase -i main
```

如果没有相对的其它分支， 你将不得不相对自己的`HEAD` 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于`HEAD~2` 进行rebase， 组合最近3次提交(commit), 相对于`HEAD~3`, 等等。

```sh
(main)$ git rebase -i HEAD~2
```

在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:

```vim
pick a9c8a1d Some refactoring
pick 01b2fd8 New awesome feature
pick b729ad5 fixup
pick e3851e8 another fix

# Rebase 8074d12..b729ad5 onto 8074d12
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
```

所有以 `#` 开头的行都是注释, 不会影响 rebase.

然后，你可以用任何上面命令列表的命令替换 `pick`, 你也可以通过删除对应的行来删除一个提交(commit)。

例如, 如果你想 **单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面**, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 `f`:

```vim
pick a9c8a1d Some refactoring
pick 01b2fd8 New awesome feature
f b729ad5 fixup
f e3851e8 another fix
```

如果你想组合这些提交(commit) **并重命名这个提交(commit)**, 你应该在第二个提交(commit)旁边添加一个`r`，或者更简单的用`s` 替代 `f`:

```vim
pick a9c8a1d Some refactoring
pick 01b2fd8 New awesome feature
s b729ad5 fixup
s e3851e8 another fix
```

你可以在接下来弹出的文本提示框里重命名提交(commit)。

```vim
Newer, awesomer features

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# rebase in progress; onto 8074d12
# You are currently editing a commit while rebasing branch 'main' on '8074d12'.
#
# Changes to be committed:
#	modified:   README.md
#
```

如果成功了, 你应该看到类似下面的内容:

```sh
(main)$ Successfully rebased and updated refs/heads/main.
```

#### 安全合并(merging)策略

`--no-commit` 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 `no-ff` 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。

```sh
(main)$ git merge --no-ff --no-commit my-branch
```

#### 我需要将一个分支合并成一个提交(commit)

```sh
(main)$ git merge --squash my-branch
```

#### 我只想组合(combine)未推的提交(unpushed commit)

有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。

```sh
(main)$ git rebase -i @{u}
```

这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。

### 检查是否分支上的所有提交(commit)都合并(merge)过了

检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:

```sh
(main)$ git log --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll
```

这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:

```sh
(main)$ git log main ^feature/120-on-scroll --no-merges
```

### 交互式rebase(interactive rebase)可能出现的问题

#### 这个rebase 编辑屏幕出现'noop'

如果你看到的是这样:

```
noop
```

这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 *领先(ahead)* 当前分支。 你可以尝试:

- 检查确保主(main)分支没有问题
- rebase `HEAD~2` 或者更早

#### 有冲突的情况

如果你不能成功的完成rebase, 你可能必须要解决冲突。

首先执行 `git status` 找出哪些文件有冲突:

```sh
(my-branch)$ git status
On branch my-branch
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   README.md
```

在这个例子里面, `README.md` 有冲突。 打开这个文件找到类似下面的内容:

```vim
   <<<<<<< HEAD
   some code
   =========
   some code
   >>>>>>> new-commit
```

你需要解决新提交的代码(示例里, 从中间`==`线到`new-commit`的地方)与`HEAD` 之间不一样的地方.

有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):

```sh
(main*)$ git mergetool -t opendiff
```

在你解决完所有冲突和测试过后, `git add` 变化了的(changed)文件, 然后用`git rebase --continue` 继续rebase。

```sh
(my-branch)$ git add README.md
(my-branch)$ git rebase --continue
```

如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行`git rebase --skip`。

任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:

```sh
(my-branch)$ git rebase --abort
```

## Stash

### 暂存所有改动

暂存你工作目录下的所有改动

```sh
$ git stash
```

你可以使用`-u`来排除一些文件

```sh
$ git stash -u
```

### 暂存指定文件

假设你只想暂存某一个文件

```sh
$ git stash push working-directory-path/filename.ext
```

假设你想暂存多个文件

```sh
$ git stash push working-directory-path/filename1.ext working-directory-path/filename2.ext
```

### 暂存时记录消息

这样你可以在`list`时看到它

```sh
$ git stash save <message>
```

或

```sh
$ git stash push -m <message>
```

### 使用某个指定暂存

首先你可以查看你的`stash`记录

```sh
$ git stash list
```

然后你可以`apply`某个`stash`

```sh
$ git stash apply "stash@{n}"
```

此处， 'n'是`stash`在栈中的位置，最上层的`stash`会是0

除此之外，也可以使用时间标记(假如你能记得的话)。

```sh
$ git stash apply "stash@{2.hours.ago}"
```

### 暂存时保留未暂存的内容

你需要手动create一个`stash commit`， 然后使用`git stash store`。

```sh
$ git stash create
$ git stash store -m "commit-message" CREATED_SHA1
```

## 杂项(Miscellaneous Objects)

### 克隆所有子模块

```sh
$ git clone --recursive git://github.com/foo/bar.git
```

如果已经克隆了:

```sh
$ git submodule update --init --recursive
```

### 删除标签(tag)

```sh
$ git tag -d <tag_name>
$ git push <remote> :refs/tags/<tag_name>
```

<a name="recover-tag"></a>

### 恢复已删除标签(tag)

如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):

```sh
$ git fsck --unreachable | grep tag
```

记下这个标签(tag)的hash，然后用Git的 update-ref

```sh
$ git update-ref refs/tags/<tag_name> <hash>
```

这时你的标签(tag)应该已经恢复了。

### 已删除补丁(patch)

如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 `git am`。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。

做完提交后, 再修改作者，参见[变更作者](https://my.oschina.net/u/4455409/blog/5474550#commit-wrong-author)。 然后, 应用变化, 再发起一个新的pull request。

## 跟踪文件(Tracking Files)

### 我只想改变一个文件名字的大小写，而不修改内容

```sh
(main)$ git mv --force myfile MyFile
```

### 我想从Git删除一个文件，但保留该文件

```sh
(main)$ git rm --cached log.txt
```

## 配置(Configuration)

### 我想给一些Git命令添加别名(alias)

在 OS X 和 Linux 下, 你的 Git的配置文件储存在 `~/.gitconfig`。我在`[alias]` 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:

```vim
[alias]
    a = add
    amend = commit --amend
    c = commit
    ca = commit --amend
    ci = commit -a
    co = checkout
    d = diff
    dc = diff --changed
    ds = diff --staged
    f = fetch
    loll = log --graph --decorate --pretty=oneline --abbrev-commit
    m = merge
    one = log --pretty=oneline
    outstanding = rebase -i @{u}
    s = status
    unpushed = log @{u}
    wc = whatchanged
    wip = rebase -i @{u}
    zap = fetch -p
```

### 我想缓存一个仓库(repository)的用户名和密码

你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。

```sh
$ git config --global credential.helper cache
# Set git to use the credential memory cache
$ git config --global credential.helper 'cache --timeout=3600'
# Set the cache to timeout after 1 hour (setting is in seconds)
```

### 我不知道我做错了些什么

你把事情搞砸了：你 `重置(reset)` 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。

这就是 `git reflog` 的目的， `reflog` 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到`reflog`。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。

```sh
(main)$ git reflog
0a2e358 HEAD@{0}: reset: moving to HEAD~2
0254ea7 HEAD@{1}: checkout: moving from 2.2 to main
c10f740 HEAD@{2}: checkout: moving from main to 2.2
```

上面的reflog展示了从main分支签出(checkout)到2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 `HEAD@{0}`标识.

如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前main上指向的提交(0254ea7)。

```sh
$ git reset --hard 0254ea7
```

然后使用git reset就可以把main改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。

# 将Git 项目迁移到另一个仓库

**将Git 项目迁移到另一个仓库**

**1、创建旧仓库的裸克隆**

```
git clone --bare https://github.com/exampleuser/old-repository.git
```

执行上述命令后，会在本地生成一个名叫 `old-repository.git`的文件夹。

**2、迁移到新仓库**

```
cd old-repository.git
git push --mirror https://github.com/exampleuser/new-repository.git
```

这样的话，项目就已经迁移到新仓库了。

注意，我们**不需要**手动新建一个空的新仓库，当我们执行上述命令之后，新仓库就已经自动创建好了。

讲 Git 的书有不少，我看过最好的一本书叫[Git Internals](https://github.com/pluralsight/git-internals-pdf)。里面第二章 Understand Git 讲了一部分 Git 的基础概念，但很快就陷入流俗，开始罗列命令。强记命令不但让学习毫无趣味，还可能在实际使用中误用命令导致各种麻烦。我一直在思考如何才能高效的掌握 Git。现在把这些思考整理成文供大家参考。

# Git原理

Git 一开始就引入了两个概念：**object database** 和 **current directory cache**。Git 所有的功能都是以这两个概念为基础。**打蛇打七寸**。我们就从这两个概念启程。

## object database

object database 是一组可以按照内容查询(content-addressable)的对象集合。说白了，就是对象的名字是根据对象的内容命名的，内容不一样，名字一定不一样；反过来，名字不一样，内容一定不一样。读到这里大家可能还是一头雾水，别急，我们继续剖析。如何实现这个所谓的按照内容查询呢？Linus 使用了 SHA1 摘要算法。对象的名字就是其内容的 SHA1 摘要值。摘要算法几乎可以保证内容不同，摘要值一定不一样。

确定了 object 的命名规则，接下来讨论 object 的结构。object 的结构非常简单，可以分为四部分：

- **tag**，也叫 type，表示 object 的类型，不能包含空格，最后接一个空格表示结束
- **size**，使用 ascii 字符数字表示的内容长度
- `\0`，也就是 ascii 中的 **nul** 字符
- **对象内容**，字节序列，长度为 size

拼在一起效果如下：

```
<ascii tag without space> + <space> + <ascii decimal size> + <byte\0> + <binary data>
```

以上内容经过 zlib 库的 `inflate()` 压缩后存入文件，就得到一个 object，对**压缩后**的内容计算 SHA1 摘要值，便得到了 object 的文件名。

第一个版本的 Git 只定义了三种 object，分别是 **blob**、**tree** 和 **changeset**。我们一一分解。

### blob

object 的 tag 取值为 `blob`，binary data 域存储文件的内容。这是最简单的 object。假设我们有一个叫 hello.txt 的文件，内容是 `hello world`。转换成 blob 之后的结构如下 `blob 11\0helloworld`，对应的文件名则是 `ede06c6ad21dd15a253f577717792731a320c404`。

大家要注意，blob 对象只存储了文件的内容和大小，并没有存文件的权限等信息，甚至连文件名都没有存。那这些信息存在哪里呢？答案就是 **tree**。

### tree

tree 对象的 tag 为 `tree`。tree 对象用来根踪目录。其 binary data 域存储一个列表，列表中每一项可能是一个 blob 对象（对应文件），也可能是一个 tree（对应子目录）。每一项的结构包含四部分：

- **mode**，权限和类型，接空格表示结束
- **file name**，对象路径
- `\0`，也就是 ascii 中的 **nul** 字符
- **sha1**，对象名

拼在一起结构如下：

```
<mode> + <space> + <file name> + <byte\0> + <sha1>
```

注意，tree 列表会根据 **file name** 排序。

举个列子说明一下。假设我们有如下目录结构：

```
.
├── foo
│   └── bar.txt
└── hello.txt
```

该目录对应的 tree 对象列表内ppw如下：

```
040000  tree    69ccc062670532506442789b4340dea98c73afd8        foo
100644  blob    ede06c6ad21dd15a253f577717792731a320c404        hello.txt
```

有两项内容，一项对应 foo 目录，这也是一个 tree 对象；另一项对应 hello.txt，这是一个 blob。而 foo 对应的 tree 对象的内容为：

```
100644  blob    0974d14c8dadb9ad9833dea721c63384b1448415        bar.txt
```

注意，tree 对象中的每一项是通过 `<mode>` 字段来区分是 tree 还是 blob 的；另一个需要注意的是 tree 对象中的每一项都是连在一起的，我们这里为了方便理解，做了分行处理。

好了，抽象的概念总是不易理解。让我们再回顾一下 tree 和 blob 两个对象。blob 只存储文件的**内容**，而文件名和权限信息需要存储到 tree 对象。tree 对象既可以引用 blob，也可以引用 tree。如此一来，使用 tree 和 blob 两类对象，我们就可以存储**一个目录下所有的文件内容和子目录结构**。

可以这么认为，tree 对象和 blob 对象记录了目录和文件的**当前状态**。

那如何使用 tree 和 blob 来跟踪项目呢？

首先，我们要找出所有**文件**，根据内容生成一组 blob 对象。然后，使用**深度优先遍历**所有子目录，生成对应的 tree 对象。显然，**层次最深**的子目录下肯定都是文件了，这样的子目录对应的 tree 对象只包含了 blob 对象；其他子目录和项目根目录对应的 tree 对象既可能包含 blob 对象，也可能包含 tree 对象。我们通过项目根目录的 tree 对象递归查找到所有的 tree 对象和 blob 对象。

假设我们存储了当前所有的 tree 和 blob 对象。这个时候，我们修改了某个文件。我们再脑补一下上段说的算法。遍历所有**文件**，根据内容生成 blob 对象。大家注意，blob 对象只存储内容，内容不变，就不会产生新的 blob 对象。我们只改了一个文件，所以，只会新增加一个 blob 对象。所以，这个文件所在的文件夹对应的 tree 对象肯定要引用刚才生成的新 blob 对象，所以是一个新 tree 对象。同样的，这个文件所在目录的每一级目录对应的 tree 都需要改变，所以会生成一组新的对象。那显然，项目录的 tree 对象也肯定是新的。

回到之前的例子，目录结构为：

```
.
├── foo
│   └── bar.txt
└── hello.txt
```

虚线左侧是最初的 tree 结构。如果我们 **./foo/bar.txt** 的内容改成 `baz`，则会产生一颗新的 tree 结构。变化的对象使用**双线矩形**标出。大家可以看到，hello.txt 的内容没有变化，所以被两个 tree 对象同时引用。

```
                     .
       +----------+  .  +==========+
       |tree:612ef|  .  |tree:87fd7|
       |    ./    |  .  |    ./    |
       +----------+  .  +==========+
       _____/ \_____  ______/ \____
      /             \/             \
 +----------+   +----------+   +==========+
 |tree:69ccc|   |blob:ede06|   |tree:8e4bb|
 |   foo/   |   |hello.txt |   |   foo/   |
 +----------+   +----------+   +==========+
      |              .              |
 +----------+        .         +==========+
 |blob:0974d|        .         |blob:46e91|
 |  bar.txt |        .         |  bar.txt |
 +----------+        .         +==========+
```

所以，我们可以通过项目**根目录**对应的 **tree 对象**来表示项目代码的**版本**。每一次内容改动都会产生一个**新 tree 对象**，也就是一个**新版本**。如果给定一个 **tree 对象** 以及它引用的所有 **tree 对象** 和 **blob 对象**，我们就能恢复对应的目录结构和文件内容。

可是，这次改动的时间、作者和动机该如何记录呢？为了解决这个问题，Git 引入了第三种对象 **changeset**。

###  commit

changeset 是早期的叫法，后来统一改成了 **commit** 了，而对应的 tag 为 **commit**。binary data 域就比较简单了，是纯文本：

```
tree 612ef8e50a094025e840ee951bce3036b030b888
parent 5cf777191a2da68ee90b0825162930e0f4a30032
author 涛叔 <hi@taoshu.in> Sat Jun 29 18:20:10 2019
committer 涛叔 <hi@taoshu.in> Sat Jun 29 18:20:10 2019

foo
```

这里的换行是真的换行，不似前文为了理解方便而进行的人为断行。

commit 对象首先通过 **tree 字段**指向一个 **tree 对象**，也就是前文说的一个**版本**。

然后会有零个或多个（一般是一个）所谓的 **parent**。如何理理这里的 parent 的数量呢？

还是从前面的例子说。最开始的版本对应 `tree:612ef`。因为这是第一个版本，我们可以创建一个没有 parent 的 commit，也叫 **root commit**。commit 的 SHA1 摘要值就是我们通常所说的 **Git 版本**。我们修改 `./foo/bar.txt` 之后得到 `tree:87fd7`，再创建 commit 的时候就可以使用 parent 字段引用上一个 commit。如此一来，我们就可以通过最新的 commit 追溯到所有历史的 commit。

commit 的其他部分都很简单，不再赘述。

到此，Git 的基础对象就讲完了。那基础对象讲完了，可以讲 Git 命令了吗？对不起，还不行。因为还有另外一个重要概念不得不讲，那就是所谓的**暂存区 (current directory cache)**。

## current directory cache

**暂存区**到底解决了什么问题呢？

前文讲到，一个 commit 对象对应一个 tree 对象，一个 tree 对象对应多个 tree 对象或者 blob 对象。这些 object 都是根据对象的**内容**命名的。我们修改了某个文件之后，需要对比改动的状态和内容。这就需要查看该文件被修改之前的版本。这需要找到当前 commit 对应的 tree，然后根据被修改文件的**路径**该 tree 做**深度优先搜索**才能找到对应的 blob。如果文件目录的层级很深，每一次 git diff 都会触发大量的磁盘操作，势必拖慢速度。

这个问题的根源是 tree 对象没有存储 blob 对象的**完整路径**，一个 blob 对象的路径信息被分散存储到了不同的 tree 对象中。例如前面提到的 `./foo/bar.txt`，路径 `foo` 被存储到了 `tree:612ef`，文件名 `bar.txt` 则被存储到了 `tree:69ccc` 中。解决的思路也很简单，就是**加缓存**。

暂存区是一个文件，路径为 `.git/index`。Git 使用了 mmap 将文件映射到内存，可以像内存一样操作文件内容。文件的内容是一组所谓的 entry，每个 entry 对应一个 blob 对象，并且存储了 blob 对象的**完整路径**和其他一些状态信息。所有的 entry 是按照 blob 对象的文件路径**升序排列**的。这样，对于给定路径，Git 可以使用**二分查找**快速找到对应的 blob 对象。

所以，暂存区是 working directory 和 object database 纽带。

## 实践篇

现在的 Git 命令确实比较复杂，这是多年迭代的结果。早在 2005 年 4 月 8 号 Linux 提交了 [Git 的第一个版本](https://github.com/git/git/commit/e83c5163316f89bfbde7d9ab23ca2e25604af290)。这个版本只有区区 **1036** 行 c 代码，却实现了【理论篇】全部的内容。因为第一个版本的 object database 目录还不是 `.git`，而且还缺少几个必要的工具，我们接下来使用[这个版本](https://github.com/git/git/commit/839a7a06f35bf8cd563a41d6db97f453ab108129)来演示。这是 2005 年 4 月 19 号提交的一个版本，主要引入了很简单的**同步**与**合并**的脚本。我个人认为具有**里程碑**式的意义。

### install

建议大家自己从源码编译。平台推荐使用 linux 或者 mac。

在 mac 下编译需要对源码做少许改动。一个是在 `cache.h` 中引入 `limits.h` 头文件。再一个是修改 `Makefile` 的 `LIBS` 变量，指定链接 libcrypto 库。如果你使用 homebrew 安装的 openssl，则需要给 `Makefile` 中的 CFLAGS 追加 `-L/usr/local/opt/openssl/lib -I/usr/local/opt/openssl/include` 参数。

如果是 mac 平台，首先会遇到如下错误：

```
./cache.h:13:10: fatal error: 'openssl/sha.h' file not found
#include <openssl/sha.h>
         ^~~~~~~~~~~~~~~
1 error generated.
make: *** [update-cache.o] Error 1
```

这是因为 Make 在构建的时候找不到 openssl 库。为此我们应该先安装 [openssl@1.1](mailto:openssl@1.1)

```
brew install openssl@1.1
```

然后在 Makefile 的 CFLAGS 中追加：

```
-L/usr/local/opt/openssl/lib -I/usr/local/opt/openssl/include
```

然后运行 make 会发现产生了更多的错误和警告

```
gcc -g -L/usr/local/opt/openssl/lib -I/usr/local/opt/openssl/include -I/usr/local/opt/sqlite/include  -c -o update-cache.o update-cache.c
clang: warning: argument unused during compilation: '-L/usr/local/opt/openssl/lib' [-Wunused-command-line-argument]
update-cache.c:8:8: error: implicitly declaring library function 'memcmp' with type 'int (const void *, const void *, unsigned long)' [-Werror,-Wimplicit-function-declaration]
        cmp = memcmp(name1, name2, len);
              ^
update-cache.c:8:8: note: include the header <string.h> or explicitly provide a declaration for 'memcmp'
update-cache.c:27:47: warning: passing 'unsigned char [0]' to parameter of type 'const char *' converts between pointers to integer types with different sign [-Wpointer-sign]
                int cmp = cache_name_compare(name, namelen, ce->name, ce->namelen);
                                                            ^~~~~~~~
update-cache.c:3:72: note: passing argument to parameter 'name2' here
static int cache_name_compare(const char *name1, int len1, const char *name2, int len2)
                                                                       ^
update-cache.c:41:33: error: implicitly declaring library function 'strlen' with type 'unsigned long (const char *)' [-Werror,-Wimplicit-function-declaration]
        int pos = cache_name_pos(path, strlen(path));
                                       ^
update-cache.c:41:33: note: include the header <string.h> or explicitly provide a declaration for 'strlen'
update-cache.c:46:4: error: implicitly declaring library function 'memmove' with type 'void *(void *, const void *, unsigned long)' [-Werror,-Wimplicit-function-declaration]
                        memmove(active_cache + pos, active_cache + pos + 1, (active_nr - pos - 1) * sizeof(struct cache_entry *));
                        ^
update-cache.c:46:4: note: include the header <string.h> or explicitly provide a declaration for 'memmove'
update-cache.c:48:1: warning: non-void function does not return a value [-Wreturn-type]
}
^
update-cache.c:54:23: warning: passing 'unsigned char [0]' to parameter of type 'const char *' converts between pointers to integer types with different sign [-Wpointer-sign]
        pos = cache_name_pos(ce->name, ce->namelen);
                             ^~~~~~~~
update-cache.c:18:39: note: passing argument to parameter 'name' here
static int cache_name_pos(const char *name, int namelen)
                                      ^
update-cache.c:89:2: error: implicitly declaring library function 'memset' with type 'void *(void *, int, unsigned long)' [-Werror,-Wimplicit-function-declaration]
        memset(&stream, 0, sizeof(stream));
        ^
update-cache.c:89:2: note: include the header <string.h> or explicitly provide a declaration for 'memset'
update-cache.c:140:2: error: implicitly declaring library function 'memcpy' with type 'void *(void *, const void *, unsigned long)' [-Werror,-Wimplicit-function-declaration]
        memcpy(ce->name, path, namelen);
        ^
update-cache.c:140:2: note: include the header <string.h> or explicitly provide a declaration for 'memcpy'
update-cache.c:142:22: error: no member named 'st_ctim' in 'struct stat'
        ce->ctime.nsec = st.st_ctim.tv_nsec;
                         ~~ ^
update-cache.c:144:22: error: no member named 'st_mtim' in 'struct stat'
        ce->mtime.nsec = st.st_mtim.tv_nsec;
                         ~~ ^
3 warnings and 7 errors generated.
make: *** [update-cache.o] Error 1
```

这是因为 clang 默认会输出很多警告信息。不要怕，这些警告不影响功能，可以在 CFLAGS 追加 -Wno-everything 隐藏。然后错误信息如下：

```
gcc -Wno-everything -g -L/usr/local/opt/openssl/lib -I/usr/local/opt/openssl/include -I/usr/local/opt/sqlite/include  -c -o update-cache.o update-cache.c
update-cache.c:142:22: error: no member named 'st_ctim' in 'struct stat'
        ce->ctime.nsec = st.st_ctim.tv_nsec;
                         ~~ ^
update-cache.c:144:22: error: no member named 'st_mtim' in 'struct stat'
        ce->mtime.nsec = st.st_mtim.tv_nsec;
                         ~~ ^
2 errors generated.
make: *** [update-cache.o] Error 1
```

这个错误是因为 mac 下没有定义 st_ctime 相关的结构体。通过 man 2 stat 发现，对应的是 st_ctimespec 结构体，全部改掉：

```
diff --git a/show-diff.c b/show-diff.c
index b8522886a1..6d00ba2a6f 100644
--- a/show-diff.c
+++ b/show-diff.c
@@ -11,11 +11,11 @@ static int match_stat(struct cache_entry *ce, struct stat *st)
 {
        unsigned int changed = 0;

-       if (ce->mtime.sec  != (unsigned int)st->st_mtim.tv_sec ||
-           ce->mtime.nsec != (unsigned int)st->st_mtim.tv_nsec)
+       if (ce->mtime.sec  != (unsigned int)st->st_mtimespec.tv_sec ||
+           ce->mtime.nsec != (unsigned int)st->st_mtimespec.tv_nsec)
                changed |= MTIME_CHANGED;
-       if (ce->ctime.sec  != (unsigned int)st->st_ctim.tv_sec ||
-           ce->ctime.nsec != (unsigned int)st->st_ctim.tv_nsec)
+       if (ce->ctime.sec  != (unsigned int)st->st_ctimespec.tv_sec ||
+           ce->ctime.nsec != (unsigned int)st->st_ctimespec.tv_nsec)
                changed |= CTIME_CHANGED;
        if (ce->st_uid != (unsigned int)st->st_uid ||
            ce->st_gid != (unsigned int)st->st_gid)
diff --git a/update-cache.c b/update-cache.c
index 5085a5cb53..b774c1c631 100644
--- a/update-cache.c
+++ b/update-cache.c
@@ -138,10 +138,10 @@ static int add_file_to_cache(char *path)
        ce = malloc(size);
        memset(ce, 0, size);
        memcpy(ce->name, path, namelen);
-       ce->ctime.sec = st.st_ctime;
-       ce->ctime.nsec = st.st_ctim.tv_nsec;
-       ce->mtime.sec = st.st_mtime;
-       ce->mtime.nsec = st.st_mtim.tv_nsec;
+       ce->ctime.sec = st.st_ctimespec.tv_sec;
+       ce->ctime.nsec = st.st_ctimespec.tv_nsec;
+       ce->mtime.sec = st.st_mtimespec.tv_sec;
+       ce->mtime.nsec = st.st_mtimespec.tv_nsec;
        ce->st_dev = st.st_dev;
        ce->st_ino = st.st_ino;
        ce->st_mode = st.st_mode;
```

然后就会发如下报错：

```
Undefined symbols for architecture x86_64:
  "_SHA1_Final", referenced from:
      _write_cache in update-cache.o
      _index_fd in update-cache.o
      _write_sha1_file in read-cache.o
      _verify_hdr in read-cache.o
  "_SHA1_Init", referenced from:
      _write_cache in update-cache.o
      _index_fd in update-cache.o
      _write_sha1_file in read-cache.o
      _verify_hdr in read-cache.o
  "_SHA1_Update", referenced from:
      _write_cache in update-cache.o
      _index_fd in update-cache.o
      _write_sha1_file in read-cache.o
      _verify_hdr in read-cache.o
  "_deflate", referenced from:
      _index_fd in update-cache.o
      _write_sha1_file in read-cache.o
  "_deflateBound", referenced from:
      _write_sha1_file in read-cache.o
  "_deflateEnd", referenced from:
      _index_fd in update-cache.o
      _write_sha1_file in read-cache.o
  "_deflateInit_", referenced from:
      _index_fd in update-cache.o
      _write_sha1_file in read-cache.o
  "_inflate", referenced from:
      _read_sha1_file in read-cache.o
  "_inflateEnd", referenced from:
      _read_sha1_file in read-cache.o
  "_inflateInit_", referenced from:
      _read_sha1_file in read-cache.o
ld: symbol(s) not found for architecture x86_64
```

这是因为没有指定链接 libcrypto 和 libz，给 Makefile 中的 LIBS 追加 -lcrypto -lz 即可！

改好后执行 `make && make install`，Git 的初代命令会安装到 `$HOME/bin` 中。`$HOME/bin` 需要自己创建，不然 `make install` 会报错。

初代的命令都很简陋。你甚至都找不到一个叫 git 的命令。但它们却又都很本质，实现了 Git 功能最核心的逻辑。命令列表如下：

```
cat-file        # 查看 object 内容
check-files     # ???
checkout-cache  # 从暂存区读取文件内容到工作区
commit-tree     # 提交 commit
diff-tree       # 比较两个 tree 对象的差异
fsck-cache      # ???
init-db         # 初始化 object database
ls-tree         # 查看 tree 对象内容
merge-base      # 查找两个 commit 的最新共公 commit
merge-cache     # 合并
read-tree       # 把 objce database 的一个 tree 对象加载到暂存区
rev-tree        # ???
show-diff       # 比较工作区和暂存区的差异
show-files      # 查看暂存区文件列表
update-cache    # 将工作区文件写入暂存区
write-tree      # 将暂存区的文件列表写入 object database，也就是生成 tree 对象
```

标问号的命令没有用到，也就没仔细看。大家有兴趣可以自行阅读源码。

### init

init-db 是 `git init` 的祖先。init-db 做的事情也很简单，创建 `.git/objects` 目录，然后在 `.git/objects` 下创建从 `00` 到 `ff` 共 256 子目录，效果如下：

```
.git/objects
├── 00
├── 01
├── ...
├── fe
└── ff
```

假设有一个对象的名字是 `00fd73eea32c97c962df8a84ea16c8ae34d4f3bc`，那么存储该对象的文件路径为 `.git/object/00/fd73eea32c97c962df8a84ea16c8ae34d4f3bc`。

### commit

然后大家就可以创建自己的文件。不妨 `echo -n "hello world" > hello.txt`。

为了使用 Git 管理这个 hello.txt，需要依次执行下列操作：

```
# 加入暂存区
➜  update-cache --add hello.text
# 生成 tree 对象并保存到 object database
# $tree 的值为 bf8e48a87fd9fb97b448e3e91a49607472f0c8de
➜  tree=$(write-tree)
# 首次提交
➜  echo init | commit-tree $tree
Committing initial tree bf8e48a87fd9fb97b448e3e91a49607472f0c8de
d7c0b275523e1222a63bb899d2f2cd4b616150ee
➜  echo d7c0b275523e1222a63bb899d2f2cd4b616150ee > .git/HEAD
```

为了引用方便，早期 Git 推荐把最新的 commit 写到 `.git/HEAD` 文件。这时的 Git 还没有 branch 的概念。

查看 commit 内容：

```
➜  cat-file commit $(cat .git/HEAD)
tree bf9e48a87fd9fb97b448e3e91a49607472f0c8de
author 涛叔 <hi@taoshu.in> 1561827318 +0800
committer 涛叔 <hi@taoshu.in> 1561827318 +0800

init
```

这个 cat-file 命可以解析各种 object 的对象，但因为 tree 包含二进制内容，有时还需要递归解析，所以有专门的 ls-tree 命令。

查看 tree 内容：

```
➜ ls-tree bf8e48a87fd9fb97b448e3e91a49607472f0c8de
100644  blob    ede06c6ad21dd15a253f577717792731a320c404        hello.txt
```

查看 blob 内容：

```
➜  cat-file blob ede06c6ad21dd15a253f577717792731a320c404
hello world
```

### reset

如果我们把 hello.txt 删除，我们就可以根据提交内容恢复，操作如下：

```
# 查询最新 commit 对应的 tree
➜  tree=$(cat-file commit $(cat .git/HEAD)|sed 's/tree //;q')
# 将 tree 加载到暂存区
➜  read-tree $tree
# 从暂存区恢复 hello.txt 文件
➜  checkout-cache hello.txt
```

### merge

分支合并是 Git 的灵魂。可 Git 引入合并功能的时候还没有分支这个概念。当时 Git 使用 `read-tree` 进行合并，是以 tree 为单位进行操作的。第一个版本无法处理合并冲突。我们演示的版本的是支持的。

首先，我们先生成两个不同的 tree。

```
# 记录当前 tree 方便合并
➜  cat-file commit $(cat .git/HEAD)|sed 's/tree //;q' > .git/a
# 添加一行，内容为 b
➜  echo -e "\nb" > hello.txt
# 更新暂存区
➜  update-cache --add hello.txt
# 生成 tree 对象并保存到 object database
➜  write-tree > .git/b
# 恢复暂存区到最初版本
➜  read-tree $(cat .git/a)
# 恢复 hello.text 内容
➜  checkout-cache -f hello.txt
# 添加一行，内容为 c
➜  echo -e "\nc" > hello.txt
# 更新暂存区
➜  update-cache --add hello.txt
# 生成 tree 对象并保存到 object database
➜  write-tree > .git/c
```

然后开始合并操作：

```
➜  read-tree -m $(cat .git/a) $(cat .git/b) $(cat .git/c)
➜  write-tree
hello.txt: unmerged (ede06c6ad21dd15a253f577717792731a320c404)
hello.txt: unmerged (b1882264fc8726c9876ca2baf2c82b60fd5eb27e)
hello.txt: unmerged (bc2bb8b9e7ad1a9d4d9260648cd474f21eda5b97)
fatal: write-tree: not able to write tree
```

显然，合并遇到冲突，我们需要手工解决。先查看冲突情况：

```
➜  show-files --unmerged
100644 ede06c6ad21dd15a253f577717792731a320c404 1 hello.txt
100644 b1882264fc8726c9876ca2baf2c82b60fd5eb27e 2 hello.txt
100644 bc2bb8b9e7ad1a9d4d9260648cd474f21eda5b97 3 hello.txt
```

这个时候的 Git 还没有处理冲突的功能。根据 Linux 的脚本，我发现他使了一个叫 [merge](https://www.computerhope.com/unix/merge.htm) 命令。merge 是 RCS 提供的三路合并工具。

冲突处理过程：

```
➜  cat-file blob ede06c6ad21dd15a253f577717792731a320c404 > .hello.txt.a
➜  cat-file blob b1882264fc8726c9876ca2baf2c82b60fd5eb27e > hello.txt
➜  cat-file blob bc2bb8b9e7ad1a9d4d9260648cd474f21eda5b97 > .hello.txt.c
➜  merge hello.txt .hello.txt.a .hello.txt.c
merge: warning: conflicts during merge
➜  cat hello.txt
<<<<<<< hello.txt

b
=======

c
>>>>>>> .hello.txt.c
```

大家注意 merge 工具输出的冲突是标记，这不是 Git 发明的。

手工处理好冲突，比如同时保留 bc。然后更新暂存区：

```
➜  update-cache --add hello.txt
write-tree
➜  write-tree
32af2679dfce5faaeff80db36840bb537d6478ad
```

## 总结

早期的 Git 跟现在相比非常简陋，但它们使用核心概念跟现在的 Git 却没有太大的差别。现在的 Git 比当年更加方便，但也隐藏了更多的细节。这给我们理解 Git 带来了不小的麻烦。所谓**万变不离其宗**。我们追根溯源，回到 Git 诞生不久的年代，理解了当时 Git 的特性，也就理解了 Git 的本质。