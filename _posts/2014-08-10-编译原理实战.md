---
layout: post
categories: OS
description: none
keywords: OS
---
# 编译原理实战

## JavaCC
Java Compiler Compiler(JAVACC) 基于Java应用实现的最受欢迎的语法解析器生成器。它是一个生成器，用于生成词法分析器（lexical analysers）和语法分析器（parsers）。它可以通过读取一个javacc编写的语法规则文件（包含了词法定义，语法定义的 jj,jjt结尾的文件），来生成一个java程序，这个java程序就包括了词法分析器和语法分析器。接着就可以用生成的词法分析器和语法分析器来对我们的输入进行判断，判断输入是否符合我们所要求的语法规则。

简单来说，javacc是一套词法、语法解析器。我们的java程序代码就是通过javacc进行前置的编译处理，对合法性进行校验，并生成对应的抽象语法树（AST），然后基于此做各种编译提示和编译优化的。

JavaCC 发布包是 JAR 格式，可以通过 Java 命令直接执行，读取 .jj 文件，并根据其生成可运行的 Java 代码，实现对符合语法规则的内容的解析。

## JAVACC版的Hello word
很多大神的编程书或（教程）都以一个Hello world小示例作为入门语言的开始。我也尊重传 统向大神致敬，下面编写简单的javacc版语法文件Hello.jj开始学习javacc。

在展示Hello.jj文件前，先讲一下Hello word的需求语义：解析 以 Hello 或 hello 或 HELLO 开头 跟着至少一个变量，多个变量时用“,”分割开，且以“!”结尾的字符串；解析完成后返回一个字符串Javacc Say :Hello 变量 当前时间，示例如下。
```

//输入
Hello world !
//输出
Javacc Say : Hello world ! 2022-01-01 21:15:08
 
//输入
hello 致敬javacc , everyone !
//输出
Javacc Say : Hello 致敬javacc , everyone  ! 2022-01-01 21:15:21
```

Hello.jj
```

//可选配置参数
options{
     STATIC = false; //关闭生成java方法是静态的，默认是true
     DEBUG_PARSER = true;//开启调试解析打印,默认是false
     JDK_VERSION = "1.8";//生产java时使用jdk版本,默认1.5
     UNICODE_INPUT=true;//接收unicode编码的输入，默认是false
}
//固定格式
PARSER_BEGIN(Hello)
//像java一样的包名定义,生成的java文件会带上此包名
package com.javacc.hello;
//导入需要引用java
import cn.hutool.core.date.DateUtil;
 
public class Hello {
    //可以再里面定义初始化信息，字符串接收方式，异常处理..
 
    //此处的main方法不是必须，只是为了方便此次调测，后面的示例将去除
    public static void main(String[] args){
        Hello helloParser = new Hello(System.in);
        try {
            String res = helloParser.sayHello();
            System.out.println(res);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
 
//固定格式
PARSER_END(Hello)
 
//词法定义
 
//SKIP是一种词法 要跳过忽略的字符串
SKIP : {" "}
 
//TOKEN也是一种词法，代表要识别的字符串
TOKEN : {
 /**定义一个Token名为HELLO,类似java语言中关键字“class”，会把符串中
 * 有 "Hello" ， "hello" ,"HELLO" 识别成此TOKEN。
 **/
 <HELLO : "Hello"
            | "hello"
            | "HELLO">
 |
 
 //定义一个Token名为IDENTITY,类似自定义变量，可以是英文，中文unicode（"\u4e00"-"\u9fa5"）
 // ["a" - "z"]表示的范围，小写a到z
 //(...)+ 表示括号中的内容至少出现一次
 <IDENTITY : (["a"-"z"
               ,"A"-"Z"
               ,"\u4e00"-"\u9fa5"])+>
}
 
//可以写多个TOKEN,此处主要定义特殊符号
TOKEN : {
  <EXCLAMATION : "!">
 | <COMMA : ",">
}
//为了调试方便将换行定义为一个特殊的token
TOKEN : { < EOL : "\n" | "\r" | "\r\n" > }
//定义语法
String sayHello():
{
  Token token;
  StringBuilder builder = new StringBuilder("Javacc Say : Hello ");
}
{
  <HELLO> token = <IDENTITY>
            //匹配到第一IDENTITY执行的动作
            {builder.append(token.image); }
 
            (
             <COMMA> token = <IDENTITY>
             //匹配到逗号后的IDENTITY时执行的动作
             {  builder.append(" , ");
                builder.append(token.image);
             }
            )*
            <EXCLAMATION>
 
   {
   builder.append(" ! ").append(DateUtil.now());
   return builder.toString();
   }
 
}
```
示例上注释基本上很全面了，jj语法文件大致结构可成分为：options可选配置、解析类的声明、词法定义、语法定义和动作执行。

## options
主要功能是javacc在读取*.jj语法文件生成java程序时，配置生成参数的。options的相关参数有很多，在javacc源码的Options类中大概有48个参数，都是有个默认值，它还可以通过javacc命令去配置，所有不去配置也是可以的， 但是还是要根据实际的情况合理的配置，后面对options写一篇专门的总结。

解析类的声明
```
PARSER_BEGIN(类名)
 
pakage 包名 //生成java文件采用此包名
 
import ....
public class 类 {
      ......
}
 
PARSER_END
```
按照固定格式去编写即可。这里的声明主要为了确定生成java语法解析器的类名、包名、import的java依赖类及构造函数，成员变量等。

## 词法定义   
```
TOKEN : {
  <定义词1 ：匹配规则1
          | 匹配规则n>
 | <定义词2 : 匹配规则>
.....
}
```
符号“|”是或者的含义，匹配规则类似正则表达式。javacc的词法类型有SKIP、TOKEN 、MORE、SPECIAL_TOKEN。词法定义是语法解析的基础，好的词法定义可以让语法解析时很容易处理到达事半功倍的效果。

## 语法定义和动作执行
```
返回类型 语法规则名(参数) 异常抛出声明 : 
{变量声明}
{
  //语法规则
   定义词的组合规则
  {匹配规则时的执行动作，即使java代码执行 ;}
}
```
语法定义的格式有点像java方法的定义：有返回类型，语法规则名，异常抛出声明 ，变量声明，语法主体及动作执行。

返回类型：无返则声明为 void，有返回类型 则要在动作执行中至少一次的 return 返回类型

语法规则名：类似java方法，可以无参数，格式遵守java方法的方式。

异常抛出声明 ：可以忽略不写，如果执行动作（java代码执行）中有抛出异常且未处理则要声明抛出的异常。

变量声明：无变量声明可以为空，但是这一对“{}”是不能省略。声明的变量为语法主体要使用的，其作用范围仅限在该语法规则中。

语法主体及动作执行：语法规则可以说是根据需要千变万化，其实质就是定义的词法的规则组合，其规则组合也类似正则表达式。要写好语法规则，除了要定义好词法外，重要就要理解清楚这个规则的语义，清楚了语义写规则就是信手捏来，那么动作执行就水到渠成。

## 生成语法（包括词法）解析程序   
```
javacc option-settings xx.jj文件路径
 
//例如
javacc Hello.jj
```
option-settings 就是上文介绍的options中的参数，此选项也是可以省略不写的。作用的优先级是命令设置>jj文件中定义的>默认值。

执行javacc命令，如果成功会有生成解析程序的反馈信息。 从反馈信息可以看到生成了几个java文件。其实目前的javacc版本会生成7个文件。
- Hello.java  主要的语法解析程序。
- HelloConstants.java 常量定义，jj文件定义的TOKEN在这里以常量形式定义
- HelloTokenManager.java  词法解析器
- ParseException.java  解析异常类
- SimpleCharStream 字符流，用于处理ASCII字符
- Token   Token token; 在jj文件语法定义变量时用的就是此类对象
- TokenMgrError 词法错误类

开启解析打印调试后（DEBUG_PARSER = true），对字符串的解析过程会输出打印，可以看到消费（匹配）的Token情况


## 词法TOKEN

### 词法类型
什么是词法。词法在javacc是这样定义的，词法有一个唯一的标识符，以及一个用于匹配的正则表达式列表。目前的javacc版本里明确可定义的词法类型有：SKIP、MORE、TOKEN、SPECIAL_TOKEN。在详细讲述上面词法类型前，先说下javacc默认的词法类型DEFAULT。

### DEFAULT
在语法中作为扩展单元出现的所有正则表达式都被视为处于 DEFAULT 词法状态，其出现顺序由它们在语法文件中的位置确定。也就说在语法中直接使用正则表达式，但是没有在词法中进行定义的正则表达式，就是DEFAULT 类型的词法，是属于javacc程序定义的默认词法。我的建议是尽量把词法定义全面，少用DEFAULT 。这样做的好处是便于词法的管理， 当正在使用的某个词法token的正则匹配表达式要发生变动的时候，就在词法定义的这一个地方改就可以了，不必去语法定义里去改很多使用的地方。

### SKIP
顾名思义，跳过，略过。用于那些不参与语法解析的字符。
```
SKIP : { " " | "\t" | "\n" }
```

### MORE
继续执行下一个词法，并沿用匹配的字符串。此字符串将是新匹配字符串的前缀。
```
MORE : { < ~[] > }
```

### TOKEN
使用匹配的字符串创建令牌（TOKEN），并将其发送到分析器（或任何调用方）。这个类型是最常用的词法。
```
TOKEN : {
    <NUMBER : <DIGITS>
      | <DIGITS> "." <DIGITS>
     >
  |
    //#开头则表示内部Token,只可以在词法中使用，不能在语法中引用
    <#DIGITS :(["0"-"9"])+>
}
```
字符串在匹配词法token的时候， 发现可以匹配到多个正则表达式时，则以最先出现的token定义的正则表达式规则为准。例如：
```
TOKEN : {
 
 <HELLO : "Hello"
            | "hello"
            | "HELLO">
 
}
 
TOKEN : {
 
  <IDENTITY : (["a"-"z"
               ,"A"-"Z"
               ,"\u4e00"-"\u9fa5"])+>
 
}
```
字符串"hello", 即可以匹配token 中 <HELLO>定义规则，也匹配token 中<IDENITIY>的定义规则。因为<HELLO>定义比<IDENITIY>早，则javacc会将"hello"识别成token<HELLO>。

### SPECIAL_TOKEN
特殊的token标记，这中特殊标记不参与解析。这里“解析”的含义不是说javacc不解析，而是不把这些匹配的字符串放入解析语法的上下文中。例如：单行注解定义
```
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}
```
这中特殊的token定义常被用于定义为注解，就像是在java里写了注解，但是注解不会被编译到class文件里，注解又不影响java代码的解析编译。

## 词法中的操作
```
TOKEN : {
  < TAB : "\t" >  { tabcount += 1; }
}
```
您希望在匹配token后立即执行某些 Java 代码。在正则表达式生产中，词法操作紧跟在正则表达式之后 。{ Java 语句; } 就是词法中的操作。

另外词法操作中有个image变量（与匹配token中的image字段不同）是一个 StringBuffer，其中包含自上次 SKIP、TOKEN 或 SPECIAL_TOKEN以来匹配的所有字符。只要您不将其分配给 null，您就可以自由地对其进行任何更改，因为生成的tokenManager也使用此变量。
```
<DEFAULT> MORE : { "a" : S1 }
 
<S1> MORE :
{
  "b"
    { int l = image.length()-1; image.setCharAt(l, image.charAt(l).toUpperCase()); }
    ^1                                                                             ^2
    : S2
}
 
<S2> TOKEN :
{
  "cd" { x = image; } : DEFAULT
       ^3
}

```

### 在词法操作中的类级声明
词法操作可以访问一组类级别声明。其格式如下
```
token_manager_decls ::=
  "TOKEN_MGR_DECLS" ":"
  "{" java_declarations_and_code "}"
```

例如在词法操作中进行打印字符串长度的操作
```
TOKEN_MGR_DECLS :
{
  int stringSize;
}
 
MORE :
{
  "\"" {stringSize = 0;} : WithinString
}
<WithinString> TOKEN :
{
  <STRLIT: "\""> {System.out.println("Size = " + stringSize);} : DEFAULT
}
 
<WithinString> MORE :
{
  <~["\n","\r"]> {stringSize++;}
}
```
这个词法中的动作我是在看javacc源码包中的样例中看到，实际中用的不多，关于这内置的image变量和词法操作中的类级声明则是在官网的教程中有提到（个人感觉它的教程写的很烂），在此也简单介绍一下，以后真的用到了会进行跟详细的总结。

## 词法建议
- 尽可能得多用字符串定义词法
```
//example1
SKIP : { " " | "\t" | "\n" }
//example2
SKIP : { < ([" ", "\t", "\n"])+ > }
```
上面的例子，都是跳过跳过空白/标签/新行，但是执行效率上来说，例子1的高于例子2的，对正则表达式的匹配处理会影响效率

- 尽量避免在同一个词法里用相同的字符定义
```
TOKEN :{
< NONE : "\"none\"" | "\'none\'" >
}
```

上面例子可以改下成两个词法定义如下：
```
TOKEN:{
< NONE1 : "\"none\"" >
|
< NONE2 : "\'none\'" >

}
```

- 少使用MORE
每个MORE最终应该最终以TOKEN（或SPECIAL_TOKEN）结束，因此如果可能的话，可以在TOKEN级别执行操作。
```
MORE : { < ~[] > }
```
上面的例子可以改下为
```
TOKEN : { < (~[])+ > }
```
- 定义到词法的要点
词法是语法解析的基本单元，语法定义中尽量使用明确的词法定义。

一般语法中用到的：变量、关键字（函数名、true/false、等）、符号（+，-，=，>>，[，]）等建议在词法中定义好。一方面可以方便语法解析使语法定义看起来更简洁明了，另一方面方便词法的管理。

## 语法分析
JavaCC 生成的是自上而下，不支持左递归，递归下降的解析器。这种解析器的优点是语法编写简单易懂，方便调试。在语法解析树上可以上下的传递属性，分支间可以也可调用。

四则运算的解析之路
```

//eg1:输入 
8+6*5-4
34//输出
 
 
//eg2
8+6*5-(59-3)/7
30
 
//eg3
-10 //输入
-10 //输出
 
//eg4
-10*7 //输入
-70 //输出
```
四则运算大家都比较熟悉，小学二年级就可以运算。在语法解析的处理的时候，重点解决运算的优先级问题：1、乘除优先 2、括号优先。

## 解析树
在开始编写语法分析前，可以先画一下语法分析树整理下思路。

先从简单的开始，7+8这个运算公式，可以这样简单解析为一颗树。但是我们是学习Java的， 面向对象的思想应该是必备的。我们可以将其抽象一下，把“+”、“-”、“*”、“\”抽象一个oper符号，符号左侧的抽象成一个left对象，右侧就抽象为right对象，那么四则运行算的基础表达应该是 left oper right。现在还处理不了 7+8-5....*6 运算公式，那就利用正则表达式完善一下，left （oper rignt）*表示可以处理很长的四则运算。

一级树处理加，减运算，运算的对象是二级树

二级树处理乘，除运算，运算的对象是三级树

三级树处理数字解析，以及括号里的四则运算。括号里的四则运算的解析可以调用根的解析。

到此四则运算的语法树的分析思路基本是大功告成了，可以根据思路去编写语法文件了。其实语法分析不是一次就能完成的，需要不断的改进思路，多尝试几次，才能最终定型。画语法树是帮助我们理清思路的重要方法。

Calculator.jj
```

//可选配置参数
options{
     STATIC = false; //关闭生成java方法是静态的，默认是true
     DEBUG_PARSER = true;//开启调试解析打印,默认是false
     JDK_VERSION = "1.8";//生产java时使用jdk版本,默认1.5
 
}
//固定格式
PARSER_BEGIN(Calculator)
//像java一样的包名定义,生成的java文件会带上此包名
package com.javacc.calculator;
//导入需要引用java
import cn.hutool.core.date.DateUtil;
import java.io.StringReader;
 
public class Calculator {
    //可以再里面定义初始化信息，字符串接收方式，异常处理..
    public Calculator(String expr){
         this(new StringReader(expr));
    }
 
}
 
//固定格式
PARSER_END(Calculator)
 
//词法定义
 
//SKIP是一种词法 要跳过忽略的字符串
SKIP : { " " | "\t" | "\n" }
 
TOKEN : {
    <NUMBER : <DIGITS>
      | <DIGITS> "." <DIGITS>
     >
  |
    //#开头则表示内部Token,只可以在词法中使用，不能在语法中引用
    <#DIGITS :(["0"-"9"])+>
}
 
TOKEN : {
     < LPAREN: "(" >
   | < RPAREN: ")" >
   | < ADD : "+" >
   | < SUBTRACT : "-" >
   | < MULTIPLY : "*" >
   | < DIVIDE : "/" >
}
//为了调试方便将换行定义为一个特殊的token
TOKEN : { < EOL : "\n" | "\r" | "\r\n" > }
//定义语法
 
//解析一级树处理加减
double calc():
{
 double left;
 double right;
 
}
{
  left = mutlOrDiv()
  (<ADD>   right = mutlOrDiv() {left += right;}
    | <SUBTRACT> right = mutlOrDiv() {left = left - right;}
     )*
 
  {
     return left;
   }
}
 
//解析二级树处理乘除
double mutlOrDiv():
{
 double left;
 double right;
 
}
{
  left = parseBase()
  (<MULTIPLY> right = parseBase() {left *= right ;}
    | <DIVIDE> right = parseBase() {left = left/right;}
     )*
  {
    return left;
   }
}
 
//解析三级树
double parseBase() :
{
 Token t = null;
 double num;
}
{
  t = <NUMBER> {return Double.parseDouble(t.image);}
//处理括号里的四则
 | <LPAREN> num = calc() <RPAREN> {return num;}
 //处理负数
 | <SUBTRACT> t = <NUMBER> {return 0-Double.parseDouble(t.image); }
}
```
实现的思路几乎跟上面的语法分析的是一致，就是对parseBase处理中增加了对负数的处理。

测试类CalculatorTest
```
public class CalculatorTest {
 
    public void testCalc() throws Exception {
 
        boolean isBeak = false;
        BufferedReader reader;
        String expr ="";
       com.javacc.calculator.Calculator calculator ;
        while (!isBeak){
            System.out.println("please input four arithmetic expressions , input quit exit");
            reader = new BufferedReader(new InputStreamReader(System.in));
            expr = reader.readLine();
            if(!"quit".equals(expr)){
                calculator = new Calculator(expr);
                double res = calculator.calc();
                System.out.println(res);
            }else {
                isBeak =true;
            }
 
        }
    }
 
    public static void main(String[] args) {
        CalculatorTest calculatorTest = new CalculatorTest();
        try {
            calculatorTest.testCalc();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
