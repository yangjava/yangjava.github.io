---
layout: post
categories: [Neo4j]
description: none
keywords: Neo4j
---
# Neo4j实战推荐
基于知识图谱的电影推荐系统

## 实战推荐

## 数据解下载与配置
选择TMDB电影数据集，Netflix Prize 数据集下载。
- TMDB电影数据集  https://www.kaggle.com/datasets/tmdb/tmdb-movie-metadata
- Netflix Prize 数据集  https://www.kaggle.com/datasets/netflix-inc/netflix-prize-data

执行preproc.py文件，进行数据预处理，生成5个处理后的文件：
```
import pandas as pd
import json
import re

def Netflix(MAX_USER = 1000):
    d_movie = dict()
    s_movie = set()
    
    out_movies = open("../out_movies.csv","w")
    out_movies.write("title\n")

    for line in open("../movie_titles.csv","r",encoding = 'ISO-8859-1'):
        line = line.strip().split(',')
        movie_id = int(line[0])
        title = line[2].replace("\"","")
        title = "\"" + title + "\""
        
        d_movie[movie_id] = title
        
        if title in s_movie:
           continue
        s_movie.add(title)
        
        out_movies.write(f"{title}\n")
        
    out_movies.close()
    
    out_grade = open("../out_grade.csv","w")
    out_grade.write("user_id,title,grade\n")

    files = ["../combined_data_1.txt"]
    for f in files:
        movie_id = -1
        for line in open(f,"r"):
            pos = line.find(":")
            if pos != -1: # is a new user
                movie_id = int(line[:pos])
                continue
            line = line.strip().split(",")
            user_id = int(line[0])
            rating = int(line[1])
            
            if user_id > MAX_USER:
                continue

            out_grade.write(f"{user_id},{d_movie[movie_id]},{rating}\n")
            
    out_grade.close()

def TMDB():
    pattern = re.compile("[A-Za-z0-9]+")
    # 提取电影类型
    out_genre = open("../out_genre.csv","w",encoding='utf-8')
    out_genre.write("title,genre\n")
    # 提取电影关键词
    out_keyword = open("../out_keyword.csv","w",encoding='utf-8')
    out_keyword.write("title,keyword\n")
    # 提取电影制片人
    out_productor = open("../out_productor.csv","w",encoding='utf-8')
    out_productor.write("title,productor\n")
    
    df = pd.read_csv("../tmdb_5000_movies.csv", sep=",")
    json_columns = ['genres', 'keywords', 'production_companies']
    for column in json_columns:
        df[column] = df[column].apply(json.loads)
    df = df[["genres", "keywords", "original_title","production_companies"]]
    for _, row in df.iterrows():
        title = row["original_title"]
        if not pattern.fullmatch(title):
            continue
        title = "\"" + title + "\""
        for g in row["genres"]:
            genre = g["name"]
            genre = "\"" + genre + "\""
            out_genre.write(f"{title},{genre}\n")
        for g in row["keywords"]:
            keyword = g["name"]
            keyword = "\"" + keyword + "\""
            out_keyword.write(f"{title},{keyword}\n")
        for g in row["production_companies"]:
            productor = g["name"]
            productor = "\"" + productor + "\""
            out_productor.write(f"{title},{productor}\n")

    
if __name__ == "__main__":
    Netflix()
    TMDB()


```

## 将处理好的数据导入数据库中
将上面数据预处理生成的5个文件，放入import文件夹中：

## 执行项目
修改main.py中的driver，输入自己数据库的用户名与密码。

执行main.py文件：
```
from neo4j import GraphDatabase
import pandas as pd

uri = "neo4j://localhost:7687"
driver = GraphDatabase.driver(uri, auth=("neo4j", "Liu881389."))

k = 10 # nearest neighbors (most similar users) to consider
movies_common = 3 # how many movies in common to be consider an user similar
users_common = 2 # minimum number of similar users that have seen the movie to consider it
threshold_sim = 0.9 # threshold to consider users similar

def load_data():
    with driver.session() as session:
        session.run("""MATCH ()-[r]->() DELETE r""")
        session.run("""MATCH (r) DELETE r""")
        
        print("Loading movies...")
        #加载数据，创建Movie标签,title属性的实体
        session.run("""
            LOAD CSV WITH HEADERS FROM "file:///out_movies.csv" AS csv
            CREATE (:Movie {title: csv.title})
            """)
            
        print("Loading gradings...")
        #加载评分数据，MERGE是搜索给定模式，如果存在，则返回结果如果它不存在于图中，则它创建新的节点/关系并返回结果。
        session.run("""
            LOAD CSV WITH HEADERS FROM "file:///out_grade.csv" AS csv
            MERGE (m:Movie {title: csv.title}) 
            MERGE (u:User {id: toInteger(csv.user_id)})
            CREATE (u)-[:RATED {grading : toInteger(csv.grade)}]->(m)
            """)
        #加载影片类型数据    
        print("Loading genres...")
            
        session.run("""
            LOAD CSV WITH HEADERS FROM "file:///out_genre.csv" AS csv
            MERGE (m:Movie {title: csv.title})
            MERGE (g:Genre {genre: csv.genre})
            CREATE (m)-[:HAS_GENRE]->(g)
            """)
            
        print("Loading keywords...")
        #加载关键词数据    
        session.run("""
            LOAD CSV WITH HEADERS FROM "file:///out_keyword.csv" AS csv
            MERGE (m:Movie {title: csv.title})
            MERGE (k:Keyword {keyword: csv.keyword})
            CREATE (m)-[:HAS_KEYWORD]->(k)
            """)
            
        print("Loading productors...")
        #制片人    
        session.run("""
            LOAD CSV WITH HEADERS FROM "file:///out_productor.csv" AS csv
            MERGE (m:Movie {title: csv.title})
            MERGE (p:Productor {name: csv.productor})
            CREATE (m)-[:HAS_PRODUCTOR]->(p)
            """)

def queries():
    while True:
        userid = int(input("请输入要为哪位用户推荐电影，输入其ID即可: "))
        m = int(input("为该用户推荐多少个电影呢？ "))
        
        genres = []
        if int(input("是否需要过滤掉不喜欢的类型?（输入0或1）")):#过滤掉不喜欢的类型
            with driver.session() as session:
                try:
                    q = session.run(f"""MATCH (g:Genre) RETURN g.genre AS genre""")
                    result = []
                    for i, r in enumerate(q):
                        result.append(r["genre"])#找到图谱中所有的电影类型
                    df = pd.DataFrame(result, columns=["genre"])
                    print()
                    print(df)
                    inp = input("输入不喜欢的类型索引即可，例如：1 2 3  ")
                    if len(inp) != 0:
                        inp = inp.split(" ")
                        genres = [df["genre"].iloc[int(x)] for x in inp]
                except:
                    print("Error")
                    
        with driver.session() as session:#找到当前ID评分的电影
            q = session.run(f"""
                    MATCH (u1:User {{id : {userid}}})-[r:RATED]-(m:Movie)
                    RETURN m.title AS title, r.grading AS grade
                    ORDER BY grade DESC
                    """)
            
            print()
            print("Your ratings are the following:")
            
            result = []
            for r in q:
                result.append([r["title"], r["grade"]])
                
            if len(result) == 0:
                print("No ratings found")
            else:
                df = pd.DataFrame(result, columns=["title", "grade"])
                print()
                print(df.to_string(index=False))
            print()
            
            session.run(f"""
                MATCH (u1:User)-[s:SIMILARITY]-(u2:User)
                DELETE s
                """)
            #找到当前用户评分的电影以及这些电影被其他用户评分的用户，with是把查询集合当做结果以便后面用where 余弦相似度计算
            session.run(f"""
                MATCH (u1:User {{id : {userid}}})-[r1:RATED]-(m:Movie)-[r2:RATED]-(u2:User)
                WITH
                    u1, u2,
                    COUNT(m) AS movies_common,
                    SUM(r1.grading * r2.grading)/(SQRT(SUM(r1.grading^2)) * SQRT(SUM(r2.grading^2))) AS sim
                WHERE movies_common >= {movies_common} AND sim > {threshold_sim}
                MERGE (u1)-[s:SIMILARITY]-(u2)
                SET s.sim = sim
                """)
                
            Q_GENRE = ""
            if (len(genres) > 0):
                Q_GENRE = "AND ((SIZE(gen) > 0) AND "
                Q_GENRE += "(ANY(x IN " + str(genres) + " WHERE x IN gen))"
                Q_GENRE += ")"
            #找到相似的用户，然后看他们喜欢什么电影 Collect：将所有值收集到一个集合list中
            q = session.run(f"""
                    MATCH (u1:User {{id : {userid}}})-[s:SIMILARITY]-(u2:User)
                    WITH u1, u2, s
                    ORDER BY s.sim DESC LIMIT {k}
                    MATCH (m:Movie)-[r:RATED]-(u2)
                    OPTIONAL MATCH (g:Genre)--(m)
                    WITH u1, u2, s, m, r, COLLECT(DISTINCT g.genre) AS gen
                    WHERE NOT((m)-[:RATED]-(u1)) {Q_GENRE}
                    WITH
                        m.title AS title,
                        SUM(r.grading * s.sim)/SUM(s.sim) AS grade,
                        COUNT(u2) AS num,
                        gen
                    WHERE num >= {users_common}
                    RETURN title, grade, num, gen
                    ORDER BY grade DESC, num DESC
                    LIMIT {m}
                    """)

            print("Recommended movies:")

            result = []
            for r in q:
                result.append([r["title"], r["grade"], r["num"], r["gen"]])
            if len(result) == 0:
                print("No recommendations found")
                print()
                continue
            df = pd.DataFrame(result, columns=["title", "avg grade", "num recommenders", "genres"])
            print()
            print(df.to_string(index=False))
            print()

if __name__ == "__main__":
    if int(input("是否需要重新加载并创建知识图谱？（请选择输入0或1）")):
        load_data()
    queries()


```
## 基于内容的过滤(Content-based filtering)
该技术通过比较商品之间的相似性或者相关性进行推荐。这种方式忽略用户的购买行为，只考虑商品之间的相似关系。
```
MATCH p=(m:Movie {title: "Net, The"})-[:ACTED_IN|:IN_GENRE|:DIRECTED*2]-()
RETURN p LIMIT 25
```
Cypher 语句的意思是：找出25条记录，该记录满足以下条件之一：
- 该记录中的电影是电影m 有相同的流派（IN_GENRE）
- 出演过电影m的演员，出演过该电影（ACTED_IN）
- 执导过电影m的导演，执导过该电影（DIRECTED）

注意：此语句返回的记录P，是一条关系链，并不仅仅是某一部电影。 另外，关系的运算，用到了 | 或。:DIRECTED*2 中的 *2 表示关系长度为2的关系。

从上面可以看出，:DIRECTED 表示一层关系， :DIRECTED*2表示2层关系，:DIRECTED*表示任意多层关系。

## 协同过滤
协同过滤简单来说是利用某兴趣相投、拥有共同经验之群体的喜好来推荐用户感兴趣的信息
```
MATCH (m:Movie {title: "Crimson Tide"})<-[:RATED]-(u:User)-[:RATED]->(rec:Movie)
RETURN rec.title AS recommendation, COUNT(*) AS usersWhoAlsoWatched
ORDER BY usersWhoAlsoWatched DESC LIMIT 25
```
此Cypher 语句的意思是：找出对电影《Crimson Tide》 进行过评分的用户，还对哪些电影进行过评分？并对这些被评分的电影，进行评分次数的累加并排名。

这就是通过简单的协同过滤，来看拥有相同兴趣的用户，他们还有哪些共同的喜好。

## 基于内容的过滤
首先，基于共同类型的相似性，如果用户看过《Inception》，我们就可以给用户推荐和该电影具有相同分类（流派）的电影。
```
// Find similar movies by common genres
MATCH (m:Movie)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
WHERE m.title = "Inception"
WITH rec, COLLECT(g.name) AS genres, COUNT(*) AS commonGenres
RETURN rec.title, genres, commonGenres
ORDER BY commonGenres DESC LIMIT 10;
```
通过上面的Cypher语句，可以很清晰地看到，筛选出 m 的条件是title 属性为“Inception”，然后通过关系（:IN_GENRE)找出流派（g:Genre)，此处注意关系的方向是 -> 。找出 (g:GENRE) 之后，反向查询 <- 有该流派的所有电影。

在结果返回中，COLLECT 首先把流派名放入一个集合中，然后计算所属流派的数量（此数量是电影m 和电影rec 具有相同流派的数量）。返回结果再排个序，取最多的前10条。

## 基于类型的个性化建议
如果我们知道用户看过了哪些电影，我们可以使用此信息来推荐类似的电影：
```
// Content recommendation by overlapping genres
MATCH (u:User {name: "Angelica Rodriguez"})-[r:RATED]->(m:Movie),
  (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
WHERE NOT EXISTS( (u)-[:RATED]->(rec) )
WITH rec, [g.name, COUNT(*)] AS scores
RETURN rec.title AS recommendation, rec.year AS year,
COLLECT(scores) AS scoreComponents,
REDUCE (s=0,x in COLLECT(scores) | s+x[1]) AS score
ORDER BY score DESC LIMIT 10
```
分析：
- 确定用户Angelica
- 找出用户评过分的电影m
- 把被评分的电影的流派找出来（g:Genre)
- 通过流派g再返回去搜索属于该流派的电影 （rec:Movie)，并且是Angelica 没有评过分的那部分电影
- 返回电影，根据流派名称数量来打分 —— [g.name, COUNT(*)] AS scores
- 把Scores 列表中的数据列出来 —— COLLECT(scores) AS scoreComponents,
- 从Scores 列表中，把名称数量提取出来相加，作为得分 —— REDUCE (s=0,x in COLLECT(scores) | s+x[1]) AS score
- 按得分高低排序

这里运用到了几个函数和表达式：
- ['a', 'b', 'c'] AS list  Literal lists are declared in square brackets.
- collect(n.property) List from the values, ignores null.
- reduce(s = "", x IN list | s + x.prop) Evaluate expression for each element in the list, accumulate the results.

备注：
[g.name, COUNT(*)] AS scores 这句话想了很久什么意思

因为最终是要返回rec 记录，假设我们已经找到了rec，那么rec 记录中的每一条，它的流派是清晰的。那么它的流派，在 m 中出现过多少次，就是 [g.name, count(*)] 的结果。

## 加权内容算法
除了考虑计算相似性的类型之外，还有更多的特征，如演员和导演。让我们使用加权总和根据他们共同的演员、流派和导演的数量对建议进行评分，以提高分数。根据重叠特征的数量和类型计算加权和：
```
// Find similar movies by common genres
MATCH (m:Movie) WHERE m.title = "Wizard of Oz, The"
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
 
WITH m, rec, COUNT(*) AS gs
 
OPTIONAL MATCH (m)<-[:ACTED_IN]-(a:Actor)-[:ACTED_IN]->(rec)
WITH m, rec, gs, COUNT(a) AS as
 
OPTIONAL MATCH (m)<-[:DIRECTED]-(d:Director)-[:DIRECTED]->(rec)
WITH m, rec, gs, as, COUNT(d) AS ds
 
RETURN rec.title AS recommendation, (5*gs)+(3*as)+(4*ds) AS score ORDER BY score DESC LIMIT 100
```
分析：
-  首先把movie选择出来
- 把相同流派的电影找出来，并计算流派的总和
- 同理计算出演员和导演
- 根据流派占比5，演员占比3，导演占比4来计算总分值

由此得出与电影 m 具有相似特征的其他电影的排名。

















