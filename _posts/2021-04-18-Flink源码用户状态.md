---
layout: post
categories: [Flink]
description: none
keywords: Flink
---
# Flink源码用户状态
状态数据是flink中非常重要的一部分，在flink实时计算中，涉及到聚合操作的计算，不管是窗口计算还是非窗口计算，都离不开状态数据，在窗口计算中，状态数据由flink自己进行维护，用户不需关心。但是还有一些算子，用户可以自己操作状态数据，比如在map算子中定义状态数据，可能是ValueState或者ListState。本文就来分析一下这些状态数据到底是如何实现和管理的。

首先，flink的状态数据分为两种，一种是KeyedState，这是针对kv键值对的状态数据，每个key都有自己的状态值，一般用在keyBy算子之后。另一种是OperatorState，跟key无关，每个operator的实例只有一个state。

我们先来看看KeyedState，代码示例如下：
```
    def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setParallelism(1)
    val stream = env.socketTextStream("10.18.34.198", 9999)

    stream
      .filter(!StringUtils.isBlank(_))
      .map((_, random.nextInt(100)))
      .keyBy(0)
      .map(new MyMapFunction)
      .addSink(new BufferSink(5))

    env.execute("Stateful Stream Test")
    }

//Keyed State：针对keyedStream的状态值操作
class MyMapFunction extends RichMapFunction[(String, Int), (String, Int, Int)] {
  //每个key的sum状态值
  var sumValueState: ValueState[Int] = _
  //通过stateDescriptor获取状态值，第一次获取不到就会创建一个默认的状态值并返回
  val stateDescriptor = new ValueStateDescriptor[Int]("sumValueState", classOf[Int])
  //设置state的过期时间，当读或写这个key的state时都会更新（重置）ttl时间
  val stateTtlConfig: StateTtlConfig = StateTtlConfig
    .newBuilder(Time.seconds(60))
    .setUpdateType(StateTtlConfig.UpdateType.OnReadAndWrite)
    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)
    .build()
//  stateDescriptor.enableTimeToLive(stateTtlConfig)

  override def map(value: (String, Int)): (String, Int, Int) = {
    val currentSum = sumValueState.value()
    println(s"previous sum value: $currentSum")
    //更新state状态值
    sumValueState.update(value._2 + currentSum)
    (value._1, value._2, value._2 + currentSum)
  }

  override def open(parameters: Configuration): Unit = {
    sumValueState = getRuntimeContext.getState(stateDescriptor)
  }

}
```
在上述代码中，sumValueState就是一个KeyedState，它的结构是ValueState，在map方法中可以访问key对应的value值，也可以对value值进行更新。注意这里的value值都是针对当前进入map方法的数据对应的key。

## 创建状态管理后台
在StreamTask进行初始化的时候，会对StreamTask中operatorChain上的每个operator调用initializeState()方法
```
//StreamTask类
public final void invoke() throws Exception {
    ...
synchronized (lock) {

   // both the following operations are protected by the lock
   // so that we avoid race conditions in the case that initializeState()
   // registers a timer, that fires before the open() is called.

   initializeState();
   openAllOperators();
}
...
}


//AbstractStreamOperator类
private void initializeState() throws Exception {

   StreamOperator<?>[] allOperators = operatorChain.getAllOperators();

   for (StreamOperator<?> operator : allOperators) {
      if (null != operator) {
         operator.initializeState();
      }
   }
}
```

operator.initializeState()方法就是来创建状态管理后台，包括KeyedState和operatorState的管理后台。
```
public final void initializeState() throws Exception {

    //从配置config中获取keySerializer，keySerializer决定了当前operator是否拥有keyedStateBackend，如果没有keySerializer，那么也没有keyedStateBackend
   final TypeSerializer<?> keySerializer = config.getStateKeySerializer(getUserCodeClassloader());

   final StreamTask<?, ?> containingTask =
      Preconditions.checkNotNull(getContainingTask());
   final CloseableRegistry streamTaskCloseableRegistry =
      Preconditions.checkNotNull(containingTask.getCancelables());
   final StreamTaskStateInitializer streamTaskStateManager =
      Preconditions.checkNotNull(containingTask.createStreamTaskStateInitializer());

   final StreamOperatorStateContext context =
      streamTaskStateManager.streamOperatorStateContext(
         getOperatorID(),
         getClass().getSimpleName(),
         this,
         keySerializer,
         streamTaskCloseableRegistry,
         metrics);

   this.operatorStateBackend = context.operatorStateBackend();
   this.keyedStateBackend = context.keyedStateBackend();

   if (keyedStateBackend != null) {
      this.keyedStateStore = new DefaultKeyedStateStore(keyedStateBackend, getExecutionConfig());
   }

   timeServiceManager = context.internalTimerServiceManager();

   CloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = context.rawKeyedStateInputs();
   CloseableIterable<StatePartitionStreamProvider> operatorStateInputs = context.rawOperatorStateInputs();

   try {
      StateInitializationContext initializationContext = new StateInitializationContextImpl(
         context.isRestored(), // information whether we restore or start for the first time
         operatorStateBackend, // access to operator state backend
         keyedStateStore, // access to keyed state backend
         keyedStateInputs, // access to keyed state stream
         operatorStateInputs); // access to operator state stream

      initializeState(initializationContext);
   } finally {
      closeFromRegistry(operatorStateInputs, streamTaskCloseableRegistry);
      closeFromRegistry(keyedStateInputs, streamTaskCloseableRegistry);
   }
}
```
initializeState()主要的实现就是创建了KeyedState和管理后台keyedStateBackend和operatorState的管理后台operatorStateBackend。

## 创建KeyedState的管理后台keyedStateBackend
首先就来看看keyedStateBackend的创建：
```
//StreamTaskStateInitializerImpl类
public StreamOperatorStateContext streamOperatorStateContext(
   @Nonnull OperatorID operatorID,
   @Nonnull String operatorClassName,
   @Nonnull KeyContext keyContext,
   @Nullable TypeSerializer<?> keySerializer,
   @Nonnull CloseableRegistry streamTaskCloseableRegistry,
   @Nonnull MetricGroup metricGroup) throws Exception {

    ...

   try {

      // -------------- Keyed State Backend --------------
      keyedStatedBackend = keyedStatedBackend(
         keySerializer,
         operatorIdentifierText,
         prioritizedOperatorSubtaskStates,
         streamTaskCloseableRegistry,
         metricGroup);

      // -------------- Operator State Backend --------------
      operatorStateBackend = operatorStateBackend(
         operatorIdentifierText,
         prioritizedOperatorSubtaskStates,
         streamTaskCloseableRegistry);

      // -------------- Raw State Streams --------------
      rawKeyedStateInputs = rawKeyedStateInputs(
         prioritizedOperatorSubtaskStates.getPrioritizedRawKeyedState().iterator());
      streamTaskCloseableRegistry.registerCloseable(rawKeyedStateInputs);

      rawOperatorStateInputs = rawOperatorStateInputs(
         prioritizedOperatorSubtaskStates.getPrioritizedRawOperatorState().iterator());
      streamTaskCloseableRegistry.registerCloseable(rawOperatorStateInputs);

      // -------------- Internal Timer Service Manager --------------
      timeServiceManager = internalTimeServiceManager(keyedStatedBackend, keyContext, rawKeyedStateInputs);

      // -------------- Preparing return value --------------

      return new StreamOperatorStateContextImpl(
         prioritizedOperatorSubtaskStates.isRestored(),
         operatorStateBackend,
         keyedStatedBackend,
         timeServiceManager,
         rawOperatorStateInputs,
         rawKeyedStateInputs);
   } catch (Exception ex) {
       ...
   }
}


protected <K> AbstractKeyedStateBackend<K> keyedStatedBackend(
   TypeSerializer<K> keySerializer,
   String operatorIdentifierText,
   PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates,
   CloseableRegistry backendCloseableRegistry,
   MetricGroup metricGroup) throws Exception {
    //如果keySerializer == null，就返回null，即keyedStatedBackend就是null
   if (keySerializer == null) {
      return null;
   }

   String logDescription = "keyed state backend for " + operatorIdentifierText;

   TaskInfo taskInfo = environment.getTaskInfo();

    //为当前的operator实例分配KeyGroupRange，例如[0, 10]代表着hash(key)%maxParallelism在[0, 10]这个区间的key属于当前这个operator实例管理
   final KeyGroupRange keyGroupRange = KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(
      taskInfo.getMaxNumberOfParallelSubtasks(),
      taskInfo.getNumberOfParallelSubtasks(),
      taskInfo.getIndexOfThisSubtask());

   // Now restore processing is included in backend building/constructing process, so we need to make sure
   // each stream constructed in restore could also be closed in case of task cancel, for example the data
   // input stream opened for serDe during restore.
   CloseableRegistry cancelStreamRegistryForRestore = new CloseableRegistry();
   backendCloseableRegistry.registerCloseable(cancelStreamRegistryForRestore);
   BackendRestorerProcedure<AbstractKeyedStateBackend<K>, KeyedStateHandle> backendRestorer =
      new BackendRestorerProcedure<>(
         (stateHandles) -> stateBackend.createKeyedStateBackend(
            environment,
            environment.getJobID(),
            operatorIdentifierText,
            keySerializer,
            taskInfo.getMaxNumberOfParallelSubtasks(),
            keyGroupRange,
            environment.getTaskKvStateRegistry(),
            TtlTimeProvider.DEFAULT,
            metricGroup,
            stateHandles,
            cancelStreamRegistryForRestore),
         backendCloseableRegistry,
         logDescription);

   try {
       //返回的是HeapKeyedStateBackend实例
      return backendRestorer.createAndRestore(
         prioritizedOperatorSubtaskStates.getPrioritizedManagedKeyedState());
   } finally {
      if (backendCloseableRegistry.unregisterCloseable(cancelStreamRegistryForRestore)) {
         IOUtils.closeQuietly(cancelStreamRegistryForRestore);
      }
   }
}
```
由上可以看到keyedStatedBackend是由StreamTaskStateInitializerImpl.keyedStatedBackend()方法创建出来的，实现如下：

- 如果keySerializer == null，就返回null，即keyedStatedBackend就是null

- 为当前的operator实例分配KeyGroupRange，例如[0, 10]代表着hash(key)%maxParallelism在[0, 10]这个区间的key属于当前operator实例管理

- 返回的keyedStatedBackend是HeapKeyedStateBackend实例

可以看到一个operator是否具有keyedStatedBackend跟它是否拥有keySerializer相关，那么operator的keySerializer又是怎么来的呢？这还要从map算子来说起。步骤大致如下：

1、map算子是在KeyedStream上调用的，map经调用后会生成一个新的DataStream，新的DataStream拥有一个StreamTransformation，在KeyedStream上调用的transform会给新生成的DataStream的StreamTransformation设置keySelector和keyType,同时这个StreamTransformation会被放入到后台列表

2、在生成StreamGraph的时候会对这个StreamTransformation创建一个StreamNode，同时给这个StreamNode设置keySelector和keySerializer。StreamNode中持有operator的引用，StreamNode和operator一一对应。

3、在构建JobGraph时，会给operatorChain上的每个operator设置config，StreamNode中的keySelector和keySerializer就会被写入到operator的config中。

4、在StreamTask初始化过程中，operator调用setup()方法是会从config中获取keySelector，作为operator的stateKeySelector1；调用initializeState()从config中获取keySerializer，根据这个keySerializer来创建keyedStatedBackend。

以下是上述实现的简单源码：

1、给KeyedStream给新生成的DataStream的StreamTransformation设置keySelector和keyType
```
//KeyedStream类
public <R> SingleOutputStreamOperator<R> transform(String operatorName,
      TypeInformation<R> outTypeInfo, OneInputStreamOperator<T, R> operator) {

   SingleOutputStreamOperator<R> returnStream = super.transform(operatorName, outTypeInfo, operator);

   // inject the key selector and key type
   OneInputTransformation<T, R> transform = (OneInputTransformation<T, R>) returnStream.getTransformation();
   transform.setStateKeySelector(keySelector);
   transform.setStateKeyType(keyType);

   return returnStream;
}
```
2、给StreamNode设置keySelector和keySerializer
```
private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {
   ...
   if (transform.getStateKeySelector() != null) {
      TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig());
      streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer);
   }
    ...
}

public void setOneInputStateKey(Integer vertexID, KeySelector<?, ?> keySelector, TypeSerializer<?> keySerializer) {
   StreamNode node = getStreamNode(vertexID);
   node.setStatePartitioner1(keySelector);
   node.setStateKeySerializer(keySerializer);
   }

```
3、构建JobGraph时给operator设置config，config中会设置keySelector和KeySerializer

```
//StreamingJobGraphGenerator类
private List<StreamEdge> createChain(
      Integer startNodeId,
      Integer currentNodeId,
      Map<Integer, byte[]> hashes,
      List<Map<Integer, byte[]>> legacyHashes,
      int chainIndex,
      Map<Integer, List<Tuple2<byte[], byte[]>>> chainedOperatorHashes) {

       ...
      StreamConfig config = currentNodeId.equals(startNodeId)
            ? createJobVertex(startNodeId, hashes, legacyHashes, chainedOperatorHashes)
            : new StreamConfig(new Configuration());

      setVertexConfig(currentNodeId, config, chainableOutputs, nonChainableOutputs);
      ...
}

private void setVertexConfig(Integer vertexID, StreamConfig config,
      List<StreamEdge> chainableOutputs, List<StreamEdge> nonChainableOutputs) {
    StreamNode vertex = streamGraph.getStreamNode(vertexID);
   ...
   config.setStatePartitioner(0, vertex.getStatePartitioner1());
   config.setStatePartitioner(1, vertex.getStatePartitioner2());
   config.setStateKeySerializer(vertex.getStateKeySerializer());
    ...
}
```

4、operator初始化时从config中获取keySelector和keySerializer

```
//AbstractStreamOperator类
public void setup(StreamTask<?, ?> containingTask, StreamConfig config, Output<StreamRecord<OUT>> output) {
    ...
   this.runtimeContext = new StreamingRuntimeContext(this, environment, container.getAccumulatorMap());

   stateKeySelector1 = config.getStatePartitioner(0, getUserCodeClassloader());
   stateKeySelector2 = config.getStatePartitioner(1, getUserCodeClassloader());
}

public final void initializeState() throws Exception {

   final TypeSerializer<?> keySerializer = config.getStateKeySerializer(getUserCodeClassloader());
   ...
   }
```
到此，operator的KeyedState的管理后台keyedStatedBackend的创建就梳理完了。接下来要看的就是状态数据的创建和管理。

## KeyedState状态数据的创建
获取状态的代码如下：
```
sumValueState = getRuntimeContext.getState(stateDescriptor)

```
getRuntimeContext()返回的是StreamingRuntimeContext，keyedStateStore是跟keyedStatedBackend一起创建的，它持有keyedStatedBackend的引用。最终的state的获取是调用的keyedStateBackend.getPartitionedState()方法。

```
public <T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties) {
   KeyedStateStore keyedStateStore = checkPreconditionsAndGetKeyedStateStore(stateProperties);
   stateProperties.initializeSerializerUnlessSet(getExecutionConfig());
   return keyedStateStore.getState(stateProperties);
}

public <T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties) {
   requireNonNull(stateProperties, "The state properties must not be null");
   try {
      stateProperties.initializeSerializerUnlessSet(executionConfig);
      return getPartitionedState(stateProperties);
   } catch (Exception e) {
      throw new RuntimeException("Error while getting state", e);
   }
}

protected  <S extends State> S getPartitionedState(StateDescriptor<S, ?> stateDescriptor) throws Exception {
   return keyedStateBackend.getPartitionedState(
         VoidNamespace.INSTANCE,
         VoidNamespaceSerializer.INSTANCE,
         stateDescriptor);
}
```
最终会调用getOrCreateKeyedState来创建state，而且这个state是InternalKvState的实例

```
//AbstractKeyedStateBackend类
public <N, S extends State> S getPartitionedState(
      final N namespace,
      final TypeSerializer<N> namespaceSerializer,
      final StateDescriptor<S, ?> stateDescriptor) throws Exception {
    ...

   final S state = getOrCreateKeyedState(namespaceSerializer, stateDescriptor);
   final InternalKvState<K, N, ?> kvState = (InternalKvState<K, N, ?>) state;
   
   ...

   return state;
}
```

```
public <N, S extends State, V> S getOrCreateKeyedState(
      final TypeSerializer<N> namespaceSerializer,
      StateDescriptor<S, V> stateDescriptor) throws Exception {
   checkNotNull(namespaceSerializer, "Namespace serializer");
   checkNotNull(keySerializerProvider, "State key serializer has not been configured in the config. " +
         "This operation cannot use partitioned state.");

   InternalKvState<K, ?, ?> kvState = keyValueStatesByName.get(stateDescriptor.getName());
   if (kvState == null) {
      if (!stateDescriptor.isSerializerInitialized()) {
         stateDescriptor.initializeSerializerUnlessSet(executionConfig);
      }
      kvState = TtlStateFactory.createStateAndWrapWithTtlIfEnabled(
         namespaceSerializer, stateDescriptor, this, ttlTimeProvider);
      keyValueStatesByName.put(stateDescriptor.getName(), kvState);
      publishQueryableStateIfEnabled(stateDescriptor, kvState);
   }
   return (S) kvState;
}
```

最终会调用HeapKeyedStateBackend.createInternalState()方法来创建State

```
//HeapKeyedStateBackend类
public <N, SV, SEV, S extends State, IS extends S> IS createInternalState(
   @Nonnull TypeSerializer<N> namespaceSerializer,
   @Nonnull StateDescriptor<S, SV> stateDesc,
   @Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception {
   StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass());
   if (stateFactory == null) {
      String message = String.format("State %s is not supported by %s",
         stateDesc.getClass(), this.getClass());
      throw new FlinkRuntimeException(message);
   }
   StateTable<K, N, SV> stateTable = tryRegisterStateTable(
      namespaceSerializer, stateDesc, getStateSnapshotTransformFactory(stateDesc, snapshotTransformFactory));
   return stateFactory.createState(stateDesc, stateTable, getKeySerializer());
}

//STATE_FACTORIES是一个Map，保存了State的构建函数
private static final Map<Class<? extends StateDescriptor>, StateFactory> STATE_FACTORIES =
   Stream.of(
      Tuple2.of(ValueStateDescriptor.class, (StateFactory) HeapValueState::create),
      Tuple2.of(ListStateDescriptor.class, (StateFactory) HeapListState::create),
      Tuple2.of(MapStateDescriptor.class, (StateFactory) HeapMapState::create),
      Tuple2.of(AggregatingStateDescriptor.class, (StateFactory) HeapAggregatingState::create),
      Tuple2.of(ReducingStateDescriptor.class, (StateFactory) HeapReducingState::create),
      Tuple2.of(FoldingStateDescriptor.class, (StateFactory) HeapFoldingState::create)
   ).collect(Collectors.toMap(t -> t.f0, t -> t.f1));

//HeapValueState类
static <K, N, SV, S extends State, IS extends S> IS create(
   StateDescriptor<S, SV> stateDesc,
   StateTable<K, N, SV> stateTable,
   TypeSerializer<K> keySerializer) {
   return (IS) new HeapValueState<>(
      stateTable,
      keySerializer,
      stateTable.getStateSerializer(),
      stateTable.getNamespaceSerializer(),
      stateDesc.getDefaultValue());
}
```
State中最重要的一个成员就是StateTable，一般情况下，程序里生成的都是CopyOnWriteStateTable，StateTable的结构就像一个HashMap，里面存着每个key和key的状态。StateTable里有个成员叫keyContext，这个keyContext就是KeyedStateBackend
```
public abstract class StateTable<K, N, S> implements StateSnapshotRestore {

   /**
    * The key context view on the backend. This provides information, such as the currently active key.
    */
   protected final InternalKeyContext<K> keyContext;

   /**
    * Combined meta information such as name and serializers for this state.
    */
   protected RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo;

   /**
    *
    * @param keyContext the key context provides the key scope for all put/get/delete operations.
    * @param metaInfo the meta information, including the type serializer for state copy-on-write.
    */
   public StateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {
      this.keyContext = Preconditions.checkNotNull(keyContext);
      this.metaInfo = Preconditions.checkNotNull(metaInfo);
   }
```

## KeyedState状态数据的使用
接下来就是state的应用了，代码如下
```
override def map(value: (String, Int)): (String, Int, Int) = {
  val currentSum = sumValueState.value()
  sumValueState.update(value._2 + currentSum)
  (value._1, value._2, value._2 + currentSum)
}
```
看看如何从state获取key的状态数据
```
//HeapValueState类
public V value() {
   final V result = stateTable.get(currentNamespace);

   if (result == null) {
      return getDefaultValue();
   }

   return result;
}

//CopyOnWriteStateTable类，keyContext就是KeyedStateBackend，namespace就是VoidNamespace
public S get(N namespace) {
   return get(keyContext.getCurrentKey(), namespace);
}

//类似于HashMap的查找方式
public S get(K key, N namespace) {

   final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace);
   final int requiredVersion = highestRequiredSnapshotVersion;
   final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash);
   int index = hash & (tab.length - 1);

   for (StateTableEntry<K, N, S> e = tab[index]; e != null; e = e.next) {
      final K eKey = e.key;
      final N eNamespace = e.namespace;
      if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {

         // copy-on-write check for state
         if (e.stateVersion < requiredVersion) {
            // copy-on-write check for entry
            if (e.entryVersion < requiredVersion) {
               e = handleChainedEntryCopyOnWrite(tab, hash & (tab.length - 1), e);
            }
            e.stateVersion = stateTableVersion;
            e.state = getStateSerializer().copy(e.state);
         }

         return e.state;
      }
   }

   return null;
}
```
从state中获取key的状态值类似于HashMap中的查找方式，而且key的值都是程序后台来获取的，用户不需要管，只需要调用state.value就能获取到当前key的状态值。这里得说说获取当前key的方法keyContext.getCurrentKey()，既然有getCurrentKey()，那么key肯定已经被设置了，就应该有setCurrentKey()方法。

原来，当map operator在接受到一条数据时，就会给KeyedStateBackend设置当前的key值，然后调用map()方法进行处理时，getCurrentKey()返回的就是这个已经设置了的key值。代码如下：
```
//StreamInputProcessor类
public boolean processInput() throws Exception {
    ...
StreamRecord<IN> record = recordOrMark.asRecord();
synchronized (lock) {
   numRecordsIn.inc();
   streamOperator.setKeyContextElement1(record);
   streamOperator.processElement(record);
}
...
}

public void setKeyContextElement1(StreamRecord record) throws Exception {
   setKeyContextElement(record, stateKeySelector1);
}

private <T> void setKeyContextElement(StreamRecord<T> record, KeySelector<T, ?> selector) throws Exception {
   if (selector != null) {
      Object key = selector.getKey(record.getValue());
      setCurrentKey(key);
   }
}

public void setCurrentKey(Object key) {
   if (keyedStateBackend != null) {
      try {
         // need to work around type restrictions
         @SuppressWarnings("unchecked,rawtypes")
         AbstractKeyedStateBackend rawBackend = (AbstractKeyedStateBackend) keyedStateBackend;
        //给keyedStateBackend设置当前的key值
         rawBackend.setCurrentKey(key);
      } catch (Exception e) {
         throw new RuntimeException("Exception occurred while setting the current key context.", e);
      }
   }
}
```
再来看看state的状态更新实现，就是更新stateTable中key的状态值

```
//HeapValueState类
public void update(V value) {

   if (value == null) {
      clear();
      return;
   }

   stateTable.put(currentNamespace, value);
}

public void put(N namespace, S state) {
   put(keyContext.getCurrentKey(), namespace, state);
}

void put(K key, N namespace, S value) {
   final StateTableEntry<K, N, S> e = putEntry(key, namespace);

   e.state = value;
   e.stateVersion = stateTableVersion;
}
```
到此，KeyedState的后台管理KeyedStateBackend的创建，KeyedState的创建，key值对应value的获取、更新就都分析完毕了。

## 创建operatorStateBackend
接下来就分析一下operator state的实现。

operator的操作示例代码如下
```
//Operator state，需要实现CheckpointedFunction
class BufferSink(limit: Int) extends RichSinkFunction[(String, Int, Int)] with CheckpointedFunction{

  //operator state常用ListState
  private var checkpointState: ListState[(String, Int, Int)] = _
  private val buffer = ListBuffer[(String, Int, Int)]()
  //通过ListStateDescriptor获取ListState
  private val stateDescriptor = new ListStateDescriptor[(String, Int, Int)]("BufferSink", createTypeInformation[(String, Int, Int)])

  override def invoke(value: (String, Int, Int)): Unit = {
    buffer += value
    if(buffer.size >= limit){
      buffer.foreach(println)
      buffer.clear()
    }
  }

  //执行checkpoint时调用
  override def snapshotState(context: FunctionSnapshotContext): Unit = {
    checkpointState.clear()
    checkpointState.addAll(buffer.asJava)
  }

  //初始化或者数据恢复时调用
  override def initializeState(context: FunctionInitializationContext): Unit = {
    checkpointState = context.getOperatorStateStore.getListState(stateDescriptor)
    if(context.isRestored){
      checkpointState.get().asScala.foreach(buffer += _)
      println(s"restore buffer size: ${buffer.size}")
    }
  }
```
operator state也有管理后台operatorStateBackend，跟keyedStateBackend一同创建的，在operator的initializeState()方法中，最终返回的是DefaultOperatorStateBackend实例。不同于keyedStateBackend的是，keyedStateBackend是针对有keySerializer的operator才会创建，而operatorStateBackend每个operator都会创建。创建代码如下
```
//StreamTaskStateInitializerImpl
public StreamOperatorStateContext streamOperatorStateContext(
   @Nonnull OperatorID operatorID,
   @Nonnull String operatorClassName,
   @Nonnull KeyContext keyContext,
   @Nullable TypeSerializer<?> keySerializer,
   @Nonnull CloseableRegistry streamTaskCloseableRegistry,
   @Nonnull MetricGroup metricGroup) throws Exception {
       ...
operatorStateBackend = operatorStateBackend(
   operatorIdentifierText,
   prioritizedOperatorSubtaskStates,
   streamTaskCloseableRegistry);
   ...
}


protected OperatorStateBackend operatorStateBackend(
   String operatorIdentifierText,
   PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates,
   CloseableRegistry backendCloseableRegistry) throws Exception {

   String logDescription = "operator state backend for " + operatorIdentifierText;

   // Now restore processing is included in backend building/constructing process, so we need to make sure
   // each stream constructed in restore could also be closed in case of task cancel, for example the data
   // input stream opened for serDe during restore.
   CloseableRegistry cancelStreamRegistryForRestore = new CloseableRegistry();
   backendCloseableRegistry.registerCloseable(cancelStreamRegistryForRestore);
   BackendRestorerProcedure<OperatorStateBackend, OperatorStateHandle> backendRestorer =
      new BackendRestorerProcedure<>(
         (stateHandles) -> stateBackend.createOperatorStateBackend(
            environment,
            operatorIdentifierText,
            stateHandles,
            cancelStreamRegistryForRestore),
         backendCloseableRegistry,
         logDescription);

   try {
      return backendRestorer.createAndRestore(
         prioritizedOperatorSubtaskStates.getPrioritizedManagedOperatorState());
   } finally {
      if (backendCloseableRegistry.unregisterCloseable(cancelStreamRegistryForRestore)) {
         IOUtils.closeQuietly(cancelStreamRegistryForRestore);
      }
   }
}
```

## operator state的创建和使用
下面是operator state的使用，用户操作operator state需要实现CheckpointedFunction,其中的两个方法分别是initializeState()，snapshotState()。

operator state的结构一般是ListState，获取代码如下
```
context.getOperatorStateStore.getListState(stateDescriptor)
```
这个方法最终会调用到DefaultOperatorStateBackend.getListState()
```
//DefaultOperatorStateBackend类
private <S> ListState<S> getListState(
      ListStateDescriptor<S> stateDescriptor,
      OperatorStateHandle.Mode mode) throws StateMigrationException {

     ...
   @SuppressWarnings("unchecked")
   PartitionableListState<S> partitionableListState = (PartitionableListState<S>) registeredOperatorStates.get(name);

   if (null == partitionableListState) {
      // no restored state for the state name; simply create new state holder

      partitionableListState = new PartitionableListState<>(
         new RegisteredOperatorStateBackendMetaInfo<>(
            name,
            partitionStateSerializer,
            mode));

      registeredOperatorStates.put(name, partitionableListState);
   } else {
      ... 
   }

   accessedStatesByName.put(name, partitionableListState);
   return partitionableListState;
}

//PartitionableListState的构造方法
PartitionableListState(RegisteredOperatorStateBackendMetaInfo<S> stateMetaInfo) {
   this(stateMetaInfo, new ArrayList<S>());
}

private PartitionableListState(
      RegisteredOperatorStateBackendMetaInfo<S> stateMetaInfo,
      ArrayList<S> internalList) {

   this.stateMetaInfo = Preconditions.checkNotNull(stateMetaInfo);
   this.internalList = Preconditions.checkNotNull(internalList);
   this.internalListCopySerializer = new ArrayListSerializer<>(stateMetaInfo.getPartitionStateSerializer());
}
```
可以看到，operator state获取的ListState是PartitionableListState，PartitionableListState中有一个内部的List，用于存储数据。

接下来就是ListState的使用了。本例中就是在进行checkpoint时将buffer中的数据添加到PartitionableListState中，进行checkpoint。
```
override def snapshotState(context: FunctionSnapshotContext): Unit = {
  checkpointState.clear()
  checkpointState.addAll(buffer.asJava)
}
```
可以看到，对PartitionableListState的操作都是对PartitionableListState内部的List进行的操作。

```
//PartitionableListState类
public void clear() {
   internalList.clear();
}

public void add(S value) {
   Preconditions.checkNotNull(value, "You cannot add null to a ListState.");
   internalList.add(value);
}

public void update(List<S> values) {
   internalList.clear();

   addAll(values);
}

public void addAll(List<S> values) {
   if (values != null && !values.isEmpty()) {
      internalList.addAll(values);
   }
}
```
到此，operator state也分析完毕了。

## 总结
flink状态数据实现大致如下：

1、flink的状态数据分为keyedState和operatorState，keyedState针对每个key都有其状态数值，类似于HashMap，operatorState不针对key，每个operator实例只有一个state，一般的结构都是ListState。他们都有对应的管理后台keyedStatedBackend和OperatorStateBackend。

2、在KeyedStream上调用的算子所生成的DataStream中的StreamTransformation中会设置keySelector和keyType，有了keyType就能根据keyType创建出keySerializer。同时这个StreamTransformation中也包含stream operator，例如map、flatMap等。

3、在构建StreamGraph的时候会对这个StreamTransformation创建一个StreamNode，同时给这个StreamNode设置keySelector和keySerializer。StreamNode中持有operator的引用，StreamNode和operator一一对应。

4、在构建JobGraph时，会给operatorChain上的每个operator设置config，StreamNode中的keySelector和keySerializer就会被写入到operator的config中。

5、在StreamTask初始化过程中，operator调用setup()方法是会从config中获取keySelector，作为operator的stateKeySelector1；调用initializeState()从config中获取keySerializer，根据这个keySerializer来创建keyedStatedBackend。如果没有keySerializer，那么keyedStatedBackend就是null，否则一般的创建出的都是HeapKeyedStateBackend的实例。也就是说只有在KeyedStream上创建出来的DataStream中的operator才拥有keyedStatedBackend。在创建keyedStatedBackend的同时也会创建operatorStateBackend，每个operator都会有operatorStateBackend，类型是DefaultOperatorStateBackend

5、state的创建由对应的管理后台负责，在KeyedState中，例如ValueState，他们都是InternalKvState的实例，其创建过程是由keyedStatedBackend完成的，KeyedState中最重要的一个结构就是StateTable，StateTable中存储了key，namespace（这里都是VoidNamespace），对应的状态值。StateTable的结构类似于HashMap,横向是一个数组，纵向是链表。获取或者更新key的状态值都在StateTable中操作。

6、StateTable持有keyedStatedBackend的引用当做keyContext，在operator接收到新数据时，会给keyedStatedBackend设置当前的key，然后用户在function操作状态数据时不需要指定key，只需要.value()就可以获取到当前key的状态值。

7、operator state需要用户定义的function实现CheckpointedFunction接口，实现snapshotState()和initializeState()，snapshotState()在checkpoint时调用，用于将状态值进行checkpoint，initializeState()在operator初始化或者任务恢复的时候调用。operator state一般的结构是ListState，state的创建也是由DefaultOperatorStateBackend负责，返回的是PartitionableListState，PartitionableListState中有一个ArrayList作为内部数据存储。PartitionableListState的更新获取都是针对这个ArrayList的操作。