---
layout: post
categories: Java
description: none
keywords: Java
---
# Java接口开发

## 接口
接口是Java中的重要组成部分，是由常量和公共的抽象方法组成的。也可以理解为是更纯粹的抽象类，即接口是抽象方法和常量值的定义集合，只包含常量和方法的定义，没有变量和方法的实现。

### 接口定义
Java中接口的定义形式如下：
```
[修饰词] interface 接口名
{
     常量声明
     方法声明
}

```
接口是另一种引用类型。接口的修饰词只有public和默认两个，含义与类修饰符相同。接口名的命名规则也与类名相同。因为接口中变量的修饰词只能是public、final、static，所以不用显式地使用修饰词。又因为接口中变量的修饰词是public、final、static，所以在接口中声明的都是常量。接口中的方法都没有方法体，除了定义的常量以外也没有变量。接口中方法的修饰词只能是public，默认也是public。

另外，接口也有继承机制并支持多继承，可以使用extends关键字继承其他接口。

### 实现接口
接口只是声明了提供的功能和服务，而功能和服务具体的实现还是要在接口的类中定义。一个类可以通过implements关键字实现接口，接口在使用时也必须有子类，子类要实现（覆写）接口的所有抽象方法。一个子类可以同时实现多个接口，实现接口的类称为实现类。类之间实现继承，接口之间也可以实现继承，类和接口之间可以实现多接口的继承。

抽象类和接口实际上是一套规范，规定子类（实现类）必须定义的方法，除非子类（实现类）严格执行了这套规范，否则将不能实例化和使用。

下面的示例演示了计算机主板在工作时接口的实现。
```java
interface VideoCard{               // 显卡接口
     void display();               // 显卡工作的抽象方法
     String getName();               // 获取显卡厂商名字的抽象方法
}
class Dmeng implements VideoCard{      // 具体厂商的显卡
     private String name;
     Dmeng(){
          name = "Dmeng's videoCard";
     }
     public void setName(String name) {
          this.name = name;
     }
     public String getName() {
          return this.name;
     }

     public void display() {
          System.out.println("Dmeng's videoCard working!!!");
     }
}
class Mainboard{
     private String CPU;
     VideoCard vc;
     public String getCPU() {
          return CPU;
     }
     public void setCPU(String cpu) {
          CPU = cpu;
     }
     public VideoCard getVc() {
          return vc;
     }
     public void setVc(VideoCard vc) {
          this.vc = vc;
     }
     public void run(){
          System.out.println(CPU);
          System.out.println(vc.getName());
          vc.display();
          System.out.println("Mainboard's running!!!");
     }
}
public class Computer {
     public static void main(String[] args) {
          Dmeng dm = new Dmeng();
          Mainboard mb = new Mainboard();
          mb.setCPU("Intel's CPU");
          mb.setVc(dm);
          mb.run();
     }
}
```

## 匿名内部类
匿名内部类就是没有名字的内部类，经常被应用于Swing程序设计中的事件监听处理。例如创建一个匿名的内部类ButtonAction：
```
public class ClassDemo {
     public static void main(String[] args) {
          new ButtonAction(){
               public void click(){
                    System.out.println("这是匿名类，但谁也无法使用它！");
               }
          }
     }
}

```
匿名类通常用于创建接口的唯一实现类，或者创建某个类的唯一子类。

## 包及访问控制权限
包是Java中的文件组织形式，对应系统的文件夹。一个文件夹下可以存在文件也可以包含另一个文件夹，包也是如此。正因为有了包的存在，Java工程中允许存在同名不同包的Java文件，所以指定一个类时除了类名还要有类所在的包路径。

### 包的操作
Java中包的声明形式如下：
```
package 包名
```
例如：
```
package example.code.demo;
```
包名一般都为小写。包像文件夹一样可以嵌套，上面的例子表示demo包在code包下，而code包又存在于example包中。

一个类如果要引用其他包下的类，就需要使用import关键字。而指定一个类，就需要指定这个类所在包的完全路径。例如：
```java
import java.util.ArrayList;
```
虽然可以使用*代表包下所有的类，但不建议使用，建议完整指定要引入的类的路径。

## 访问权限修饰符
访问权限修饰符，下面详细讲解4种权限的不同。按照权限大小排序：
```
public > protected > default > private
```
### 权限修饰符public
最大的权限，完全开放，没有任何限制。任何类都可以调用public权限的方法，都可以访问public权限的属性。构造方法和类的权限通常为public。

### 权限修饰符private
最小的权限，限制类外的访问，它修饰的成员对类来说是私有的。一般情况下，把属性设置为private，让其他类不能直接访问属性，达到保护属性的目的。

### 默认权限修饰符
该权限修饰的成员在类内可以访问，同一个包内的其他类也可以访问，其他包中的类不能访问。

### 权限修饰符protected
该权限修饰的成员能够被子类和同一个包中的类访问。

以上4个权限修饰符可以修饰类的成员，不能修饰局部变量。







