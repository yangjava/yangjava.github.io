---
layout: post
categories: [JVM]
description: none
keywords: JVM
---
# 代码缓存源码
研究负责管理生成的汇编代码缓存的CodeCache的相关实现类

## CodeCache
CodeCache就是用于缓存不同类型的生成的汇编代码，如热点方法编译后的代码，各种运行时的调用入口Stub等，所有的汇编代码在CodeCache中都是以CodeBlob及其子类的形式存在的。

通常CodeBlob会对应一个CodeBuffer，负责生成汇编代码的生成器会通过CodeBuffer将汇编代码写入到CodeBlob中，参考MacroAssembler类的说明。

CodeCache的定义位于hotspot src/share/vm/code/codeCache.hpp中，包含的属性和方法都是静态的，属性不多
```
class CodeCache : AllStatic {
  friend class VMStructs;
 private:
  // CodeHeap is malloc()'ed at startup and never deleted during shutdown,
  // so that the generated assembly code is always there when it's needed.
  // This may cause memory leak, but is necessary, for now. See 4423824,
  // 4422213 or 4436291 for details.
  static CodeHeap * _heap;
  static int _number_of_blobs;
  static int _number_of_adapters;
  static int _number_of_nmethods;
  static int _number_of_nmethods_with_dependencies;
  static bool _needs_cache_clean;
  static nmethod* _scavenge_root_nmethods;  // linked via nm->scavenge_root_link()
```
其中_heap属性是实际负责内存管理的， _number_of开头的几个属性是统计计数的，_scavenge_root_nmethods是为了GC时遍历nmethod使用。

CodeCache定义的关键方法主要有以下几种：
- 内存分配和释放的，如allocate，commit，free等
- 查找或者遍历已经存在的Blob和nmethod，如find_blob，find_nmethod，blobs_do，nmethods_do，first，next等
- GC支持的，如gc_epilogue，gc_prologue，do_unloading，scavenge_root_nmethods_do等
- 获取CodeCache对应内存块属性的，如low_bound，high_bound，capacity等
- 逆优化相关的，如mark_for_deoptimization，mark_all_nmethods_for_deoptimization，make_marked_nmethods_not_entrant等 

我们重点关注其初始化和内存分配相关方法的实现。
initialize

initialize方法用来初始化CodeCache的，在JVM进程启动时执行，初始化结束后整个运行期通过_heap属性管理的内存都不会被释放，从而保证已生成的被频繁访问的汇编代码一直常驻内存。

initialize方法实现的源码说明如下：
```
void CodeCache::initialize() {
//校验参数配置是否正确，CodeCacheSegmentSize表示CodeCache对应内存的最小值，CodeEntryAlignment表示分配给一段汇编代码的最小内存空间
  assert(CodeCacheSegmentSize >= (uintx)CodeEntryAlignment, "CodeCacheSegmentSize must be large enough to align entry points");
#ifdef COMPILER2
//OptoLoopAlignment表示给内部循环代码分配的最低内存大小
  assert(CodeCacheSegmentSize >= (uintx)OptoLoopAlignment,  "CodeCacheSegmentSize must be large enough to align inner loops");
#endif
  assert(CodeCacheSegmentSize >= sizeof(jdouble),    "CodeCacheSegmentSize must be large enough to align constants");
  
  //按照系统的内存页大小对CodeCache的参数取整
  //CodeCacheExpansionSize表示CodeCache扩展一次内存空间对应的内存大小，x86下默认值是2304k
  CodeCacheExpansionSize = round_to(CodeCacheExpansionSize, os::vm_page_size());
  //InitialCodeCacheSize表示CodeCache的初始大小，x86 启用C2编译下，默认值是2304k
  InitialCodeCacheSize = round_to(InitialCodeCacheSize, os::vm_page_size());
  //ReservedCodeCacheSize表示CodeCache的最大内存大小，x86 启用C2编译下，默认值是48M
  ReservedCodeCacheSize = round_to(ReservedCodeCacheSize, os::vm_page_size());
  //完成heap属性的初始化
  if (!_heap->reserve(ReservedCodeCacheSize, InitialCodeCacheSize, CodeCacheSegmentSize)) {
    vm_exit_during_initialization("Could not reserve enough space for code cache");
  }
  //将CodeHeap放入一个MemoryPool中管理起来
  MemoryService::add_code_heap_memory_pool(_heap);
 
  //初始化用于刷新CPU指令缓存的Icache，即生成一段用于刷新指令缓存的汇编代码，此时因为heap属性已初始化完成，所以可以从CodeCache中分配Blob了
  icache_init();
 
  //通知操作系统我们的CodeCache的内存区域，主要是win64使用
  os::register_code_area(_heap->low_boundary(), _heap->high_boundary());
}
```

## allocate / commit / free
allocate方法用于分配CodeBlob的，当CodeBlob分配成功并且初始化完成时调用commit方法来增加CodeCache的相关统计计数；free方法用于释放一个已分配的CodeBlob并减少CodeCache的统计计数。

其中BufferBlob，nmethod，RuntimeStub和SingletonBlob就是CodeBlob的四个直接子类。

这三个方法的源码说明如下：
```
CodeBlob* CodeCache::allocate(int size, bool is_critical) {
  guarantee(size >= 0, "allocation request must be reasonable");
  //校验已经获取锁了，由此方法的调用方负责获取锁
  assert_locked_or_safepoint(CodeCache_lock);
  CodeBlob* cb = NULL;
  //增加计数器
  _number_of_blobs++;
  //不断循环
  while (true) {
    //分配CodeBlob
    cb = (CodeBlob*)_heap->allocate(size, is_critical);
    //分配成功
    if (cb != NULL) break;
    //分配失败，尝试扩展CodeCache，如果失败返回NULL
    if (!_heap->expand_by(CodeCacheExpansionSize)) {
      // Expansion failed
      return NULL;
    }
    //扩展CodeCache成功后继续尝试分配一个Blob
    //打印CodeCache扩展日志
    if (PrintCodeCacheExtension) {
      ResourceMark rm;
      tty->print_cr("code cache extended to [" INTPTR_FORMAT ", " INTPTR_FORMAT "] (" SSIZE_FORMAT " bytes)",
                    (intptr_t)_heap->low_boundary(), (intptr_t)_heap->high(),
                    (address)_heap->high() - (address)_heap->low_boundary());
    }
  }
  //更新已使用的CodeCache内存大小，maxCodeCacheUsed是一个静态变量
  maxCodeCacheUsed = MAX2(maxCodeCacheUsed, ((address)_heap->high_boundary() -
                          (address)_heap->low_boundary()) - unallocated_capacity());
  //校验CodeHeap
  verify_if_often();
  print_trace("allocation", cb, size);
  return cb;
}
 
void CodeCache::verify_if_often() {
  if (VerifyCodeCacheOften) {
    _heap->verify();
  }
}
 
 
void CodeCache::free(CodeBlob* cb) {
  assert_locked_or_safepoint(CodeCache_lock);
  verify_if_often();
 
  print_trace("free", cb);
  //根据CodeBlob的类型减少对应的计数器
  if (cb->is_nmethod()) {
    _number_of_nmethods--;
    if (((nmethod *)cb)->has_dependencies()) {
      _number_of_nmethods_with_dependencies--;
    }
  }
  if (cb->is_adapter_blob()) {
    _number_of_adapters--;
  }
  _number_of_blobs--;
  //释放CodeBlob
  _heap->deallocate(cb);
 
  verify_if_often();
  assert(_number_of_blobs >= 0, "sanity check");
}
 
 
void CodeCache::commit(CodeBlob* cb) {
  //校验已获取锁CodeCache_lock
  assert_locked_or_safepoint(CodeCache_lock);
  //根据CodeBlob的类型增加计数器
  if (cb->is_nmethod()) {
    _number_of_nmethods++;
    if (((nmethod *)cb)->has_dependencies()) {
      _number_of_nmethods_with_dependencies++;
    }
  }
  if (cb->is_adapter_blob()) {
    _number_of_adapters++;
  }
 
  //刷新CPU的汇编指令缓存
  ICache::invalidate_range(cb->content_begin(), cb->content_size());
}
```

## blobs_do / nmethods_do
blobs_do用于遍历所有的CodeBlob执行指定的函数，nmethods_do用于遍历所有的nmethod执行指定的函数，这两个方法实现的源码说明如下：
```
void CodeCache::blobs_do(void f(CodeBlob* nm)) {
  assert_locked_or_safepoint(CodeCache_lock);
  //FOR_ALL_BLOBS是一个遍历所有Blob的宏
  FOR_ALL_BLOBS(p) {
    f(p);
  }
}
 
void CodeCache::nmethods_do(void f(nmethod* nm)) {
  assert_locked_or_safepoint(CodeCache_lock);
  FOR_ALL_BLOBS(nm) {
    //判断Blob是否是nmethod
    if (nm->is_nmethod()) f((nmethod*)nm);
  }
}
 
//最终通过heap属性的方法完成遍历
#define FOR_ALL_BLOBS(var)       for (CodeBlob *var =       first() ; var != NULL; var =       next(var) )
 
CodeBlob* CodeCache::first() {
  assert_locked_or_safepoint(CodeCache_lock);
  return (CodeBlob*)_heap->first();
}
 
 
CodeBlob* CodeCache::next(CodeBlob* cb) {
  assert_locked_or_safepoint(CodeCache_lock);
  return (CodeBlob*)_heap->next(cb);
}
```
综合上述源码分析可知，CodeCache只是CodeHeap的一层包装而已，核心实现都在CodeHeap中。

## CodeHeap
CodeHeap就是实际管理汇编代码内存分配的实现，其定义在hotspot src/share/vm/memory/heap.hpp中。CodeHeap定义的属性如下：
- _memory：VirtualSpace，用于描述CodeHeap对应的一段连续的内存空间
- _segmap：VirtualSpace，用于保存所有的segment的起始地址，记录这些segment的使用情况，通过mark_segmap_as_free方法标记为未分配给Block，通过mark_segmap_as_used方法标记为已分配给Block
- _number_of_committed_segments：size_t，已分配内存的segments的数量
- _number_of_reserved_segments：size_t，剩余的未分配内存的保留的segments的数量
- _segment_size：size_t，一个segment的大小
- _log2_segment_size：int，segment的大小取log2，用于计算根据内存地址计算所属的segment的序号
- _next_segment：size_t，下一待分配给Block的segment的序号
- _freelist：FreeBlock*，可用的HeapBlock 链表，所有的Block按照地址依次增加的顺序排序，即_freelist是内存地址最小的一个Block
- _freelist_segments：size_t，可用的segments的个数
- 一个segment可以理解为一个内存页，是操作系统分配内存的最小粒度，为了避免内存碎片，任意一个Block的大小都必须是segment的整数倍，即任意一个Block会对应N个segment。

CodeHeap定义的public方法主要有以下几类：
- 内存初始化，扩展，缩小和释放的，如reserve，release，expand_by，shrink_by等
- CodeBlob内存分配和销毁的，如allocate，deallocate
- 获取CodeHeap的内存使用情况的，如low_boundary，high，capacity，allocated_capacity等
- CodeBlob遍历相关的，如first，next
重点关注内存管理和遍历相关的方法实现，可以通过方法的实现反过来理解定义的属性的具体含义和用途。
