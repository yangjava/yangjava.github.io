---
layout: post
categories: [Dubbo]
description: none
keywords: Dubbo
---
# Dubbo服务自省

## 概念
注册中心数据结构格式改变（service：接口服务，application：同个应用实例组成的集合，instance：单个应用实例），带来的是“服务自省”

以 Dubbo 当前的地址发现数据格式为例，它是“RPC 服务粒度”的，它是以 RPC 服务作为 key，以实例列表作为 value 来组织数据的：

而我们新引入的“应用粒度的服务发现”，它以应用名（Application）作为 key，以这个应用部署的一组实例（Instance）列表作为 value。

这带来两点不同：
- 数据映射关系变了，从 RPC Service -> Instance 变为 Application -> Instance；数据变少了，注册中心没有了 RPC Service 及其相关配置信息。
- 应用粒度服务发现的数据模型有几个以下明显变化：数据中心的数据量少了，RPC 服务相关的数据在注册中心没有了，现在只有 application - instance 这两个层级的数据。

为了保证这部分缺少的 RPC 服务数据仍然能被 Consumer 端正确的感知，我们在 Consumer 和 Provider 间建立了一条单独的通信通道：Consumer 和 Provider 两两之间通过特定端口交换信息，我们把这种 Provider 自己主动暴露自身信息的行为认为是一种内省机制，因此从这个角度出发，我们把整个机制命名为：服务自省。

## 个人理解
在服务自省之前，Dubbo中的提供者是通过注册中心来完成数据更新，即当提供者信息有变化时，会重新发布到注册中心，而消费者通过监听注册中心的提供者节点，当提供者信息更新时，消费者可以感知。

而服务自省则是抹去了 “注册中心” 这个中间商，提供者在启动时会主动暴露 一个 MetadateSevice（这个 Service并不需要我们手动暴露, 而是 Dubbo 主动会为每个应用暴露该服务），MetadateSevice 作为一个 dubbo 服务对外提供了获取应用信息的能力。消费者通过 MetadateSevice 可以获取到提供者的最新信息。

## 如何支持以应用为粒度的服务注册与发现
尽管 Dubbo 也存在应用（Application）的概念，不过传统的使用场景并非核心要素，仅在 Dubbo Monitor 或 Dubbo Admin 场景下做辨识之用。随着微服务架构和云原生技术的兴起，以应用为粒度的注册模型已是大势所趋，如 Spring Cloud 和 Kubernetes 服务注册与发现模型。注册中心所管理的对象通常与业务无关，甚至不具备 RPC 的语义。在术语上，微服务架构中的“服务”（Services）与云原生中“应用”（Applications）是相同的概念，属于逻辑名称，而它们的成员则以服务实例（Service Instances）体现，服务和服务实例的数量关系为 1:N。

单个服务实例代表一个服务进程，而多个 Dubbo 服务 URL 可隶属一个 Dubbo Provider 进程，因此，Dubbo URL 与服务实例的数量关系是 N : 1。假设一个 Dubbo Provider 进程仅提供一个 Dubbo 服务（接口）的话，即 N = 1 的情况，虽然以应用为粒度的服务注册与发现能够基于 Dubbo 传统的 Registry SPI 实现，不过对于现有 Dubbo 应用而言，将存在巨大的应用微服务化工作。

## 服务注册与发现架构
Dubbo 服务自省首要需求是减轻注册中心的承载的压力，同时，以应用为粒度的服务注册与发现模型不但能够最大化的减少 Dubbo 服务元信息注册数量，而且还能支持 Spring Cloud 和 Kubernetes 环境，可谓是一举两得

## 注册实体
从 Provider 和 Consumer 向注册中心注册的实体不再是 Dubbo URL，而是服务实例（Service Instance），一个服务实例代表一个 Provider 或 Consumer Dubbo 应用进程。服务实例属性包括：

- 服务名（Service Name）：该名称必须在注册中心全局唯一 注：名称规则架构上不做约束，不过不同注册中心的规则存在差异
- 主机地址（Host/IP）：能够被解析的主机名或者 TCP IP 地址
- 服务端口（Port）：应用进程所暴露的 Dubbo 协议端口，如 Dubbo 默认端口 20880

注：如果应用进程暴露多个 Dubbo 协议端口，如 dubbo 和 rest，那么，服务端口随机挑选其一，架构上不强制检验端口是否可用

- 元数据（Metadata）：服务实例的附加信息，用于存储 Dubbo 元信息，类似于通讯协议头或附件
- 激活状态（Enabled）：用于标记当前实例是否对外提供服务
上述服务实例模型的支持依赖于注册中心的实现。换言之，并非所有注册中心实现满足服务自省架构的要求。

## 注册中心
除了满足服务实例模型的要求之外，注册中心还得具备以下能力：

- 服务实例变化通知（Notification）：当 Consumer 订阅的 Provider 的服务实例发生变化时，注册中心能够实时地通知 Consumer
- 心跳检测（Heartbeats）：注册中心能够检测失效的服务实例，并且合理地移除它们

Dubbo 服务 ID 字符表达模式为： ${protocol}:${interface}:${version}:${group} , 其中，版本（version）或分组（group）是可选的。当 Dubbo Consumer 订阅 Dubbo 服务时，构建对应 ID，通过这个 ID 来查询 Dubbo Provider 的 Service 名称列表。

## 中心化映射配置
Dubbo 2.7.5 动态配置 API（DynamicConfiguration ）支持二级结构，即：group 和 key，其中，group 存储 Dubbo 服务 ID，而 key 则关联对应的 Dubbo Service 名称

## 服务自省
我们以下面的配置为例来介绍几个配置属性。
```
dubbo:
  application:
    name: simple-provider
#    metadata-type: local # 是否使用远程的元数据中心，如果使用，则会将元数据信息注册到指定的元数据中心，否则使用本地元数据中心
    logger: slf4j
#    register-consumer: true # 待研究，已明了调用场景，待研究
  registry:
    address: zookeeper://localhost:2181
#    simplified: true # 简化 url，服务自省情况下不能简化，否则无法注册到注册中心
    parameters:
      registry-type: service # 开启服务自省
  protocol:
    name: dubbo
    port: 9999
  scan:
    base-packages: com.kingfish.service
  metadata-report:
    address: zookeeper://localhost:2181

```




