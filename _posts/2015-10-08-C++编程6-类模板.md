---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++编程指南-类模板

## 类模板
函数模板代表了一类函数，它可以以一致的算法流程来处理各种不同类型的数据。但是，函数模板只是一个算法处理过程，它并不能维护算法过程中的数据。例如，一个算法不可能知道它上一次调用时的数据，也不可能将中间数据留给下一次调用时使用。为了解决这个问题，可以将算法组织到一个算法类中，利用类的成员变量来维护算法过程中的数据，利用类的成员函数来代表算法。跟函数模板相同，在C++中也可以将类模板化，通过为类提供类型参数来实现对不同类型数据的统一处理。

类模板的定义形式跟函数模板类似，其语法格式如下：
```
template <typename 标识符>

class 类名

{

    // 类的定义

}
```
其中，template关键字表示接下来的语句将定义一个模板。typename所定义的标识符实际上就是类模板的类型参数，可以是一个，也可以是多个。typename关键字也可以使用class关键字代替。因为类模板所定义的只是一个模板，所以类型参数只是代表一种抽象的数据类型，我们可以把它当作数据类型在类的定义中使用，比如可以用它定义成员变量，也可以用作函数返回值或者参数的数据类型。例如，我们可以这样定义一个比较两个数据大小的类模板：
```
// 定义一个用于比较两个数据大小的类模板
template <typename T>  // T是类模板的类型参数

class compare
{
public:
    // 构造函数，使用T做参数类型，实际上它相当于一个函数模板
    compare(T a, T b)
        :m_a(a),m_b(b)
    {}

	// 比较类的接口函数
public:
    // 返回两个数中的较小值，使用T作返回值类型
    T min()
    {
        return m_a > m_b ? m_b : m_a;
    }

    // 返回两个数中的较大值
    T max()
    {
        return m_a > m_b ? m_a : m_b;
    }
    // 类模板的成员变量，使用T作为其数据类型
private:
    T m_a;
    T m_b;
};
```
在这段代码中，定义了一个用于比较两个数据大小的类模板compare<T>。这个类模板拥有一个类型参数T，这就表示我们在使用这个类模板时，需要根据所比较数据的类型在类名之后的“<>”之内指定具体的数据类型，这样类模板才能根据这个实际的类型参数实例化，生成相应版本的模板类以适应各种类型数据的比较。例如：
```
// 要比较两个整型数的大小，
// 所以使用int作为类模板的实际类型参数
compare<int> cmpint(2,3); // 定义用于比较两个int数据的compare对象
// 使用compare<T>的成员函数进行比较
cout<<cmpint.max()<<"大于"<<cmpint.min()<<endl;

// 要比较两个字符串的大小，
// 所以使用string作为类模板的实际类型参数   
compare<string> cmpstr("good","afternoon");
out<<cmpstr.max()<<"大于"<<cmpstr.min()<<endl;
```
在这段代码中，我们想要比较两个整型数，所以首先使用int数据类型作为类模板compare<T>的实际类型参数，将其实例化后得到一个新的模板类compare<int>，这个模板类就可以完成两个int类型数据的比较。这里所谓的实例化，也就是用类模板的实际类型参数替换掉类模板中的类型参数，得到一个针对特定类型的模板类。比如，使用int对compare<T>类模板实例化后得到的模板类就是：
```
// 使用实际类型参数int替换形式类型参数T，得到实例化后的compare<int>类
class compare
{
public:
    compare(int a, int b)
        :m_a(a),m_b(b)
    {}

// 比较类的接口函数
public:
    int min()
    {
        return m_a > m_b ? m_b : m_a;
    }

    // …

private:
    int m_a;
    int m_b;
};
```
有了实例化之后的compare<int>类，我们就可以将它当作一个普通的类来使用，可以用它定义对象，进而可以调用这个对象的成员函数来完成对两个整型数的比较。同样，使用string数据类型实例化compare<T>类模板可以得到模板类compare<string>，这个类可以用于比较两个字符串的大小。以此类推，compare<T>类模板还可以根据其他更多数据类型实例化，用于比较相应类型数据的大小，以此实现算法的通用性。

无论是函数模板还是类模板，它们的意义都是将算法和具体的数据类型相分离，在定义的时候使用类型参数代表数据类型，而在使用的时候用实际的数据类型取代类型参数，以此使得算法适用于不同的数据类型，实现算法的通用性。这使得程序员可以用一个模板通吃各种数据类型，再也不用为了处理多种数据类型而去创建同一个函数或者类的多个版本，一劳永逸地解决了算法适应不同数据类型的问题。而STL也正是基于C++的模板机制构建起来的，名字当中就含有一个T（template），其通用性自然是不言自明。

知道更多：什么是泛型编程？

泛型编程（generic programming）就是一种大量应用模板来实现更好的代码重用性的编程方式。一般而言，我们编写的算法都是针对某个特定数据类型的，一个算法无法同时应用于多种数据类型，而泛型编程通过使用模板，可以使算法具有更好的代码重用性，一个算法可以适应于多种数据类型，从而避免重复劳动提高开发效率。

跟面向对象编程不同，泛型编程并不要求我们通过额外的间接层来调用函数，它可以编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。所谓泛型（genericity），是指具有在多种数据类型上皆可操作的含义。它允许程序员在编写代码时定义一些可变的数据类型参数，而在使用时指定这个类型参数就可以得到针对特定的数据类型的算法，以此实现代码的大量复用。程序员在设计算法的时候，不再是针对特定的数据类型来设计算法，而是直接针对最核心的“操作”来设计算法。

泛型编程的一个典型应用就是STL，它提供了许多与具体数据类型无关的容器，同一种容器就可以用于保存多种不同类型的数据。同时其中的算法通过迭代器间接地操作容器中的数据，从而也使得算法与具体的数据类型不相关。这样，整个STL都与具体的数据类型无关，而这也就正是“泛型”的意义。