---
layout: post
categories: JVM
description: none
keywords: JVM
---
## HotSpot 启动流程
学习启动过程可以帮助我们了解程序的入口，并对虚拟机的运行有个整体的把握，方便日后深入学习具体的一些模块。

## Launcher简介
Launcher是一种用于启动JVM进程的启动器，并且可以根据类别划分为两种不同的Launcher， 一种是正式版的启动器，也就是大家在Windows平台下经常用到的java.exe和javaw.exe程序。 前者在运行时会保留控制台，以及显示程序的输出信息。而后者主要是用于执行Java的GUI程序，也就是说，使用javaw.exe执行Java程序时将不会显示任何的程序的输出信息。关于Launcher的具体使用方式和标准选项配置，大家可以在控制台中输入命令“java-help”，如下所示。

具体用法：
```
  java [-options] class [args...](执行类)
```
或
```
    java [-options] -jar jarfile [args...](执行jar文件)
```
其中选项包括：
```
    -d32                                  使用32 位数据模型(如果可用)
    -d64                                  使用64 位数据模型(如果可用)
    -client                               选择"client"VM
    -server                               选择"server"VM
    -hotspot                              是"client"VM 的同义词[已过时], 默认VM 是client
    -cp                                   目录和zip/jar 文件的类搜索路径
    -classpath                            目录和zip/jar 文件的类搜索路径用“;”分隔的
                                          目录,JAR 档案和ZIP 档案列表, 用于搜索类文件
    -D<name>=<value>                      设置系统属性
    -verbose[:class|gc|jni]               启用详细输出
    -version                              输出产品版本并退出
    -version:<value>                      需要指定的版本才能运行
    -showversion                          输出产品版本并继续
    -jre-restrict-search|-no-jre-res      在版本搜索中包括/排除用户专用JRE
    trict-search                          
    -? –help                              输出此帮助消息
    -X                                    输出非标准选项的帮助
    -ea[:<packagename>...|:<classname>]
    -enableassertions[:<packagename>      按指定的粒度启用断言
    ...|:<classname>]                     
    -disableassertions[:<packagename      禁用具有指定粒度的断言
    >...|:<classname>]
    -esa | -enablesystemassertions        启用系统断言
    -dsa | -disablesystemassertions       禁用系统断言
    -agentlib:<libname>[=<options>]       加载本机代理库<libname>,例如-agentlib:
                                          hprof, 另请参阅-agentlib:jdwp=help 和
                                          -agentlib:hprof=help
    -agentpath:<pathname>[=<options>]     按完整路径名加载本机代理库
    -javaagent:<jarpath>[=<options>]      加载Java 编程语言代理, 请参阅java.lang.
                                          instrument
    -splash:<imagepath>                   使用指定的图像显示启动屏幕
```
大家千万不要认为Launcher就是虚拟机实现，其实从严格意义上来说，Launcher只是一个封装了虚拟机的执行外壳，由它负责装载JRE环境和Windows平台下的jvm.dll动态链接库（Linux平台下则是装载libjvm.so）。在一个JVM的进程内部，只能执行一个指定的Java程序，也就是说，当执行多个Java程序时，也就意味着同时启动了多个JVM进程。

所以为了调试跟踪方面，大家可以使用Java的另一种启动器gamma。在HotSpot中Launcher是使用C语言编写的，对比gamma和java后不难发现两者的源码几乎是一模一样的，仅存在少量差异，也就是说，在OpenJDK中gamma和java是共用的同一套Launcher源码实现。

gamma的源码在HotSpot的源码目录下，大家可以在/hotspot/src/share/tools/launcher/java.c中找到。而java却并非包含在HotSpot的源码目录下，而是包含在/jdk/src/share/bin/main.c中。

尽管Launcher并非是HotSpot的核心，甚至应该算是HotSpot中比较“外围”的功能模块，但既然是这样，笔者为什么还需要大费周章地对Launcher的源码进行剖析？其实了解Launcher的执行原理是非常有意义的。既然Launcher是JVM的启动器，那么必然会由它负责调用HotSpot的核心代码对JVM执行初始化，以及由它负责维护JVM的整个生命周期，所以理解Launcher的执行原理，是迈进HotSpot的第一步。

### 整体感知启动过程

整体的感知启动过程可以在启动时添加`_JAVA_LAUNCHER_DEBUG=1`的环境变量。这样JVM会输出详细的打印。
通过这些打印，我们大致能了解到启动过程发生了什么。

```
----_JAVA_LAUNCHER_DEBUG----
Launcher state:
	debug:on
	javargs:off
	program name:java
	launcher name:openjdk
	javaw:off
	fullversion:1.8.0-internal-debug-xieshang_2020_12_18_09_49-b00
	dotversion:1.8
	ergo_policy:DEFAULT_ERGONOMICS_POLICY
Command line args:
argv[0] = /home/xieshang/learn-jvm/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java
argv[1] = com.insanexs/HelloHotspot
JRE path is /home/xieshang/learn-jvm/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk
jvm.cfg[0] = ->-server<-
jvm.cfg[1] = ->-client<-
1 micro seconds to parse jvm.cfg
Default VM: server
Does `/home/xieshang/learn-jvm/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/server/libjvm.so' exist ... yes.
mustsetenv: FALSE
JVM path is /home/xieshang/learn-jvm/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/server/libjvm.so
1 micro seconds to LoadJavaVM
JavaVM args:
    version 0x00010002, ignoreUnrecognized is JNI_FALSE, nOptions is 5
    option[ 0] = '-Dsun.java.launcher.diag=true'
    option[ 1] = '-Djava.class.path=/home/xieshang/learn-open-jdk'
    option[ 2] = '-Dsun.java.command=com.insanexs/HelloHotspot'
    option[ 3] = '-Dsun.java.launcher=SUN_STANDARD'
    option[ 4] = '-Dsun.java.launcher.pid=4485'
1 micro seconds to InitializeJVM
Main class is 'com.insanexs/HelloHotspot'
App's argc is 0
1 micro seconds to load main class
----_JAVA_LAUNCHER_DEBUG----
```

从上面的打印大致可以看出有这么几步：

1. 打印了启动器的状态，包括版本号、程序名等
2. 打印了传给程序命令行参数，第一个是java命令的相信路径，第二个虚拟机将要执行的java代码
3. 解析JRE路径，解析jvm.cfg
4. 加载libjvm库
5. 解析虚拟机参数
6. 初始化虚拟机
7. 虚拟机加载要执行的Java主类，解析参数并执行

### 启动过程说明

我们就以上面划分的阶段为整体脉络，再深入的看看各阶段的具体逻辑。

#### 1 启动入口

虚拟机程序运行的入口是在main.c/main方法中。之后会调用java.c/JLI_Launch方法。

```cpp
int
JLI_Launch(int argc, char ** argv,              /* main argc, argc */
        int jargc, const char** jargv,          /* java args */
        int appclassc, const char** appclassv,  /* app classpath */
        const char* fullversion,                /* full version defined */
        const char* dotversion,                 /* dot version defined */
        const char* pname,                      /* program name */
        const char* lname,                      /* launcher name */
        jboolean javaargs,                      /* JAVA_ARGS */
        jboolean cpwildcard,                    /* classpath wildcard*/
        jboolean javaw,                         /* windows-only javaw */
        jint ergo                               /* ergonomics class policy */
)
{   
    /************************** 前期初始化工作和状态打印 ********************/
    int mode = LM_UNKNOWN;
    char *what = NULL;
    char *cpath = 0;
    char *main_class = NULL;
    int ret;
    InvocationFunctions ifn; //和创建虚拟机相关的结构体 指向三个关键的函数
    jlong start, end;
    char jvmpath[MAXPATHLEN];
    char jrepath[MAXPATHLEN];
    char jvmcfg[MAXPATHLEN];

    _fVersion = fullversion;
    _dVersion = dotversion;
    _launcher_name = lname;
    _program_name = pname;
    _is_java_args = javaargs;
    _wc_enabled = cpwildcard;
    _ergo_policy = ergo;

    InitLauncher(javaw);
    DumpState(); //打印相关状态
    
    //打印参数
    if (JLI_IsTraceLauncher()) {
        int i;
        printf("Command line args:\n");
        for (i = 0; i < argc ; i++) {
            printf("argv[%d] = %s\n", i, argv[i]);
        }
        AddOption("-Dsun.java.launcher.diag=true", NULL);
    }
    
    /************************** 检验版本 ********************/
    /*
     * Make sure the specified version of the JRE is running.
     *
     * There are three things to note about the SelectVersion() routine:
     *  1) If the version running isn't correct, this routine doesn't
     *     return (either the correct version has been exec'd or an error
     *     was issued).
     *  2) Argc and Argv in this scope are *not* altered by this routine.
     *     It is the responsibility of subsequent code to ignore the
     *     arguments handled by this routine.
     *  3) As a side-effect, the variable "main_class" is guaranteed to
     *     be set (if it should ever be set).  This isn't exactly the
     *     poster child for structured programming, but it is a small
     *     price to pay for not processing a jar file operand twice.
     *     (Note: This side effect has been disabled.  See comment on
     *     bugid 5030265 below.)
     */
    SelectVersion(argc, argv, &main_class); //版本检测
    
    /************************** 创建执行环境 ********************/
    CreateExecutionEnvironment(&argc, &argv,
                               jrepath, sizeof(jrepath),
                               jvmpath, sizeof(jvmpath),
                               jvmcfg,  sizeof(jvmcfg));//解析相关环境 获取jre路径、jvmlib库和jvm.cfg
    
    /************************** 设置虚拟机环境 ********************/
    if (!IsJavaArgs()) {
        SetJvmEnvironment(argc,argv);
    }

    ifn.CreateJavaVM = 0;
    ifn.GetDefaultJavaVMInitArgs = 0;

    if (JLI_IsTraceLauncher()) {
        start = CounterGet();
    }
    
    /************************** 加载虚拟机 ********************/
    if (!LoadJavaVM(jvmpath, &ifn)) { //加载 主要是从jvmlib库中解析函数地址 赋值给ifn
        return(6);
    }

    if (JLI_IsTraceLauncher()) {
        end   = CounterGet();
    }

    JLI_TraceLauncher("%ld micro seconds to LoadJavaVM\n",
             (long)(jint)Counter2Micros(end-start));

    ++argv;
    --argc;

    if (IsJavaArgs()) {
        /* Preprocess wrapper arguments */
        TranslateApplicationArgs(jargc, jargv, &argc, &argv);
        if (!AddApplicationOptions(appclassc, appclassv)) {
            return(1);
        }
    } else {
        /* Set default CLASSPATH */
        cpath = getenv("CLASSPATH"); //添加CLASSPATH
        if (cpath == NULL) {
            cpath = ".";
        }
        SetClassPath(cpath);
    }
    
    /************************** 解析参数 ********************/
    /* Parse command line options; if the return value of
     * ParseArguments is false, the program should exit.
     */
    if (!ParseArguments(&argc, &argv, &mode, &what, &ret, jrepath))
    {
        return(ret);
    }

    /* Override class path if -jar flag was specified */
    if (mode == LM_JAR) { //如果是java -jar 则覆盖classpath
        SetClassPath(what);     /* Override class path */
    }

    /* set the -Dsun.java.command pseudo property */ //解析特殊属性
    SetJavaCommandLineProp(what, argc, argv);

    /* Set the -Dsun.java.launcher pseudo property */
    SetJavaLauncherProp();

    /* set the -Dsun.java.launcher.* platform properties */
    SetJavaLauncherPlatformProps();
    
    /************************** 初始化虚拟机 ********************/
    return JVMInit(&ifn, threadStackSize, argc, argv, mode, what, ret);
}
```

这个方法比较长，但是可以划分为几个部分去分析：

##### 1 前期初始化工作和状态打印

这里的初始化部分包括一些参数值的声明，特殊结构体`InvocationFuntions`的声明，启动器的初始化。
其中声明的参数会在后续的启动过程用来存储相关信息，例如保存JVM、JRE相关路径等。
`InvocationFuntions`是个重要的结构体，其中包含了创建JVM会被调用的三个函数指针。

```cpp
typedef struct {
    CreateJavaVM_t CreateJavaVM; //指向负责创建JavaVM和JNIEnv结构的函数指针
    GetDefaultJavaVMInitArgs_t GetDefaultJavaVMInitArgs; //指向获取默认JVM初始参数的函数指针
    GetCreatedJavaVMs_t GetCreatedJavaVMs; //指向获取JVM的函数指针
} InvocationFunctions;
```

`InitLaucher`方法主要就是根据`_JAVA_LAUNCHER_DEBUG`这个环境变量会决定后续是否输出DEBUG的打印。
在开启了launcher_debug后，`DumpState()`方法会打印出启动状态，并且之后打印出命令行参数。

##### 2 检验版本

`SelectVersion`会验证用户指定的java版本和实际执行的java版本是否兼容，如果不兼容会退出进程。用户可以通过`_JAVA_VERSION_SET`的环境变量或是jar包中manifest文件等方式指定运行的java版本。

##### 3 创建执行环境

`CreateExecutionEnvironment`会为后续的启动创建执行环境，这一步骤中主要是确定jdk所在的路径，解析jvmcfg和确认libjvm是否存在等。

1. 主要是根据处理器类型和主路径确定出JRE的路径
2. 以同样的方式确定jvm.cfg的文件位置，并解析jvm.cfg（jvm.cfg里面是一些虚拟机的默认配置，如常见的指定以客户端或服务端模式运行）
3. 检查虚拟机类型(-server/-client)，可以是jvm.cfg指定或是由启动参数指定
4. 确定libjvm库的位置，校验库是否存在，这个库核心的函数库

##### 4 设置虚拟机环境

`SetJvmEnviroment`主要解析NativeMemoryTracking参数，可以用来追踪本地内存的使用情况

##### 5 加载虚拟机

前期环境准备好之后，`LoadJavaVM()`会从之前确定的路径，加载libjvm库，并将其中的库中`JNI_CreateJavaVM`,`JNI_GetDefaultJavaVMInitArgs`和`JNI_GetCreatedJavaVMs`三个函数赋值给ifn。
这三个函数会在之后创建虚拟机时被使用。

##### 6 解析参数

这里有两个部分，一是解析命令行传入的参数，看是否有特定的JVM配置选项。这些参数会被用于后续虚拟机的创建上。这一过程主要发生在`ParseArguments()`中。另一个部分就是添加一些特定的虚拟机参数，发生在`SetJavaCommandLineProp`、`SetJavaLaucherProp`和`SetJavaLaucherPlatformProps`中。

##### 7 虚拟机初始化

在环境都准备好之后，会由`JVMInit()`执行虚拟机初始化工作，首先会通过`ShowSplashScreen()`方法加载启动动画，之后会进入`CountinueInNewThread()`方法，由新的线程负责创建虚拟机的工作。

#### 2 在新线程中继续虚拟机的创建

通过上文的介绍，我们找到了`java.c/ConutinueInNewThread()`的方法。这个方法分为两个部分，第一部分就是确定线程栈的深度，第二部分就是由`ContinueInNewThread0()`这个方法实现真正的虚拟机创建过程。

```cpp
int
ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
    int rslt;
#ifndef __solaris__
    pthread_t tid;
    //声明线程属性
    pthread_attr_t attr;
    //初始化线程属性并设置相关属性值
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

    //设置线程栈深度
    if (stack_size > 0) {
      pthread_attr_setstacksize(&attr, stack_size);
    }

    //创建线程并执行方法
    if (pthread_create(&tid, &attr, (void *(*)(void*))continuation, (void*)args) == 0) { //创建线程 并将运行函数的起始地址和运行参数传入
      void * tmp;
      pthread_join(tid, &tmp);//阻塞当前线程 等待新线程运行结束返回
      rslt = (int)tmp;
    } else {
     /*
      * Continue execution in current thread if for some reason (e.g. out of
      * memory/LWP)  a new thread can't be created. This will likely fail
      * later in continuation as JNI_CreateJavaVM needs to create quite a
      * few new threads, anyway, just give it a try..
      */
      rslt = continuation(args);
    }

    pthread_attr_destroy(&attr);
#else /* __solaris__ */
    thread_t tid;
    long flags = 0;
    if (thr_create(NULL, stack_size, (void *(*)(void *))continuation, args, flags, &tid) == 0) {
      void * tmp;
      thr_join(tid, NULL, &tmp);
      rslt = (int)tmp;
    } else {
      /* See above. Continue in current thread if thr_create() failed */
      rslt = continuation(args);
    }
#endif /* !__solaris__ */
    return rslt;
}
```

在这个方法中，首先调用了`pthread_create()`函数创建了一个新线程，同时旧线程被jion等待新线程运行完成后返回。
`pthread_create()`是unix操作系统创建线程的函数，它的第一个参数表示线程标识，第二参数表示线程属性，第三个参数表示创建线程所要执行函数的地址，第四个参数则是将要执行的函数的参数。
等到新线程运行完成后，旧的线程也会返回。此时说明运行结束，进程将会退出。

需要注意的是此时传入的函数地址，它是指向`java.c/JavaMain()`函数。也就是说新创建的线程将会开始执行该函数。

#### 3 虚拟机创建、Java程序运行的主过程——JavaMain

新创建的线程会去执行`JavaMain()`函数，正式进入了创建虚拟机、运行Java代码的过程。

```cpp
int JNICALL
JavaMain(void * _args)
{   
    /*********************获取相关参数****************************/
    JavaMainArgs *args = (JavaMainArgs *)_args;
    int argc = args->argc;
    char **argv = args->argv;
    int mode = args->mode;
    char *what = args->what;
    InvocationFunctions ifn = args->ifn;

    JavaVM *vm = 0;
    JNIEnv *env = 0;
    jclass mainClass = NULL;
    jclass appClass = NULL; // actual application class being launched
    jmethodID mainID;
    jobjectArray mainArgs;
    int ret = 0;
    jlong start, end;

    RegisterThread();

    /*******************初始化JVM、打印相关信息********************************/
    start = CounterGet();
    if (!InitializeJVM(&vm, &env, &ifn)) {
        JLI_ReportErrorMessage(JVM_ERROR1);
        exit(1);
    }

    if (showSettings != NULL) {
        ShowSettings(env, showSettings);
        CHECK_EXCEPTION_LEAVE(1);
    }

    if (printVersion || showVersion) {
        PrintJavaVersion(env, showVersion);
        CHECK_EXCEPTION_LEAVE(0);
        if (printVersion) {
            LEAVE();
        }
    }

    /* If the user specified neither a class name nor a JAR file */
    if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) {
        PrintUsage(env, printXUsage);
        CHECK_EXCEPTION_LEAVE(1);
        LEAVE();
    }

    FreeKnownVMs();  /* after last possible PrintUsage() */

    if (JLI_IsTraceLauncher()) {
        end = CounterGet();
        JLI_TraceLauncher("%ld micro seconds to InitializeJVM\n",
               (long)(jint)Counter2Micros(end-start));
    }

    /* At this stage, argc/argv have the application's arguments */
    //打印Java程序的参数
    if (JLI_IsTraceLauncher()){
        int i;
        printf("%s is '%s'\n", launchModeNames[mode], what);
        printf("App's argc is %d\n", argc);
        for (i=0; i < argc; i++) {
            printf("    argv[%2d] = '%s'\n", i, argv[i]);
        }
    }
    
    /******************获取Java程序的主类***************************/
    ret = 1;

    /*
     * Get the application's main class.
     *
     * See bugid 5030265.  The Main-Class name has already been parsed
     * from the manifest, but not parsed properly for UTF-8 support.
     * Hence the code here ignores the value previously extracted and
     * uses the pre-existing code to reextract the value.  This is
     * possibly an end of release cycle expedient.  However, it has
     * also been discovered that passing some character sets through
     * the environment has "strange" behavior on some variants of
     * Windows.  Hence, maybe the manifest parsing code local to the
     * launcher should never be enhanced.
     *
     * Hence, future work should either:
     *     1)   Correct the local parsing code and verify that the
     *          Main-Class attribute gets properly passed through
     *          all environments,
     *     2)   Remove the vestages of maintaining main_class through
     *          the environment (and remove these comments).
     *
     * This method also correctly handles launching existing JavaFX
     * applications that may or may not have a Main-Class manifest entry.
     */
    mainClass = LoadMainClass(env, mode, what);//加载mainClass
    CHECK_EXCEPTION_NULL_LEAVE(mainClass);
    /*
     * In some cases when launching an application that needs a helper, e.g., a
     * JavaFX application with no main method, the mainClass will not be the
     * applications own main class but rather a helper class. To keep things
     * consistent in the UI we need to track and report the application main class.
     */
    appClass = GetApplicationClass(env); //获取application class
    NULL_CHECK_RETURN_VALUE(appClass, -1);
    /*
     * PostJVMInit uses the class name as the application name for GUI purposes,
     * for example, on OSX this sets the application name in the menu bar for
     * both SWT and JavaFX. So we'll pass the actual application class here
     * instead of mainClass as that may be a launcher or helper class instead
     * of the application class.
     */
    PostJVMInit(env, appClass, vm); // JVM 初始化后置处理
    /*
     * The LoadMainClass not only loads the main class, it will also ensure
     * that the main method's signature is correct, therefore further checking
     * is not required. The main method is invoked here so that extraneous java
     * stacks are not in the application stack trace.
     */
     
    /******************找主类的main方法************************/
    mainID = (*env)->GetStaticMethodID(env, mainClass, "main",
                                       "([Ljava/lang/String;)V"); //获取main class的 main(String[] args)方法
    CHECK_EXCEPTION_NULL_LEAVE(mainID);
    
    /*******************封装参数，调用main方法*****************/
    /* Build platform specific argument array */
    mainArgs = CreateApplicationArgs(env, argv, argc); //封装 main(String[] args) 方法的参数args
    CHECK_EXCEPTION_NULL_LEAVE(mainArgs);

    /* Invoke main method. */
    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs); //调用main(String args)方法

    /*
     * The launcher's exit code (in the absence of calls to
     * System.exit) will be non-zero if main threw an exception.
     */
    /*******************获取执行结果 并退出虚拟机**************/
    ret = (*env)->ExceptionOccurred(env) == NULL ? 0 : 1; //根据是否有异常 确定退出码
    LEAVE(); //线程解绑 销毁JVM
}
```

##### 1 参数解析

之前上文解析得到的命令行参数等都被封装在`JavaMainArgs`结构体中，传给了`JavaMain`方法。因此需要从这个结构体中取回参数。
另外，还创建了一些变量用于之后的过程中存储值，譬如jclass，jmethodID等。

##### 2 初始化虚拟机，打印相关信息

上述代码中的`InitializeJVM()`方法会负责虚拟机的初始化过程。其代码如下：

```cpp
static jboolean
InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
{
    JavaVMInitArgs args;
    jint r;

    memset(&args, 0, sizeof(args));
    args.version  = JNI_VERSION_1_2;
    args.nOptions = numOptions;
    args.options  = options;
    args.ignoreUnrecognized = JNI_FALSE;

    if (JLI_IsTraceLauncher()) {
        int i = 0;
        printf("JavaVM args:\n    ");
        printf("version 0x%08lx, ", (long)args.version);
        printf("ignoreUnrecognized is %s, ",
               args.ignoreUnrecognized ? "JNI_TRUE" : "JNI_FALSE");
        printf("nOptions is %ld\n", (long)args.nOptions);
        for (i = 0; i < numOptions; i++)
            printf("    option[%2d] = '%s'\n",
                   i, args.options[i].optionString);
    }

    r = ifn->CreateJavaVM(pvm, (void **)penv, &args); //通过ifn的函数指针 调用CreateJavaVM函数初始化JavaVM 和 JNIEnv
    JLI_MemFree(options);
    return r == JNI_OK;
}
```

先获取虚拟机参数，在通过ifn结构体中CreateJavaVM指针，调用正式创建Java虚拟机的函数`JNI_CreateJavaVM`。
`JNI_CreateJavaVM`代码的主要流程如下：

1. 先由`Threads::create_vm()`方法创建虚拟机
2. 给两个重要的指针赋值，分别是JavaVM * 和 JNIEnv
3. 一些后置处理，例如通过JVMTI（可以说是虚拟机的工具接口，提供了对虚拟机调试、监测等等的功能）、事件提交等

针对第一点，`Threads::create_vm()`是负责创建虚拟机，整个过程相对复杂，需要初始化很多模块，创建虚拟机的后台线程，加载必要的类等等，这里不做深入分析。之后有时间可以单独分析这一过程。
针对第二点中提到的两个数据结构，非常重要。我们可以看看它们的具体的内容。

###### JavaVM

JavaVM结构内部包的是`JNIInvokeInterface_`结构，因此我们直接看一下`JNIInvokeInterface_`的结构

```scss
struct JNIInvokeInterface_ {
    //预留字段
    void *reserved0;
    void *reserved1;
    void *reserved2;

    jint (JNICALL *DestroyJavaVM)(JavaVM *vm); //销毁虚拟机的函数指针

    jint (JNICALL *AttachCurrentThread)(JavaVM *vm, void **penv, void *args); //绑定线程的函数指针

    jint (JNICALL *DetachCurrentThread)(JavaVM *vm); //解绑线程的函数指针

    jint (JNICALL *GetEnv)(JavaVM *vm, void **penv, jint version); //获取JNIEnv结构的函数指针

    jint (JNICALL *AttachCurrentThreadAsDaemon)(JavaVM *vm, void **penv, void *args);//将线程转为后台线程
};
```

可以看到主要是一些和虚拟机操作的相关函数。

###### JNIEnv

`JNIEnv`结构内部包的是JNINativeInterface结构，这个结构同样定义了很多函数指针，代码太长，这里就不直接贴出了。有兴趣的可以在`jni.h`中自行查看。如果对结构中的方法分类的话，可以分成以下几类：

- 获取虚拟机信息
- 获取相关类和方法，方法执行
- 获取/设置对象字段
- 静态方法、静态变量的获取与设置
- 常见类型的对象的创建和释放
- 创建直接内存、访问锁等

总之，提供了通过C++代码访问Java程序的能力（这对于从事JNI开发的人来说十分重要）。

##### 3 确定Java程序的主类

了解完成虚拟机的初始化过程后，再回到JavaMain()方法中，之后是通过`LoadMainClass()`或`GetApplicationClass()`方法确定Java代码的主类。
如果我们在运行指定了Java类，那么这个类就是主类。这里还会调用`LauncherHelper.checkAndLoadMain()`检验主类是否合法。`LauncherHelper`的Java代码，这里就是上面介绍的JNIEnv的能力在C++的代码中执行Java代码。
对于一些没有主类的程序，需要通过`LaucherHelper.getApplicationClass()`确定程序类。

##### 4 从主类中获取main方法的methodID，并调用方法

再确定了mainClass之后，还需要找到该类定义的`main()`，获取main()方法，然后将程序参数封装，传递给`main()`执行，线程会以此为入口，开始执行Java程序。
这里的找方法和执行方法同样是依赖了JNIEnv中`GetStaticMethodID`和`CallStaticVoidMethod`。
所以我们的main()方法总是`static void`的。

##### 5 获取执行结果，退出虚拟机

当线程从Main()方法中返回，说明Java程序已经执行完成(或是异常退出)，这时候虚拟机会检查运行结果，并解绑线程销毁虚拟机，最终退出。