---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++多线程Linux 线程创建

## 线程创建 pthread_creat
```
#include <pthread.h>
int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict attr,void *(start_rtn)(void*),void *restrict arg)
返回值:成功返回 0 否则返回错误编号
//void* 标识通用类型
```
参数
tidp：线程标识符指针
attr：线程属性指针
start_rtn：线程运行函数的起始地址
arg：传递给线程运行函数的参数


新创建线程从start_rtn函数的地址开始运行
默认情况下不能保存新线程和调用线程的执行顺序，但是可以人工干预。

## 此时代码pthread_create中的参数arg为 50单个参数
```
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<math.h>
//定义线程运行函数
void* th_fn(void* arg) {
    //void* arg 传过来的int类型的数值 要用需要强制转换成int
    int distance = (int)arg;
    for (int i = 1; i < distance; i++) {
        printf("&lx run %d\n", pthread_self, i);
        //int time = (int)(drand48() * 10000);//产生随机数 drand48只有在Linux下才有
        Sleep(5);//阻塞5毫秒 
    }
    return (void*)0;
}
int main(void) {
    
    //用于接收线程是否创建成功的返回值
    int err;
    //定义线程标识符rabbit turtle
    pthread_t rabbit, turtle;
​
    //创建rabbit线程
    if ((err = pthread_create(&rabbit, NULL, th_fn, (void*)50)) != 0) {
        perror("pthread_create error");
    }
​
    //创建turtle线程
    if ((err = pthread_create(&turtle, NULL, th_fn, (void*)50)) != 0) {
        perror("pthread_create error");
    }
​
    //阻塞10秒  如果不阻塞，因为三个线程不知道谁先进行，可能会有主线程做完整个进程就结束了，剩余两个进程不会再走
    //Sleep(10);
​
    //后面会详细介绍
    //pthread_join是主控线程调用的，表示自己会阻塞
    //直到rabbit线程结束  主控线程方可运行
    pthread_join(rabbit, NULL);
    pthread_join(turtle, NULL);
    //输出的是主控线程的ID
    printf("control thread id:%lx\n", pthread_self());
    printf("finished!\n");
    return 0;
}
```
此时代码pthread_create中的参数arg为 一个结构体RaceArg
```
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<math.h>
//定义结构体
typedef struct{
    char name[20];//姓名
    int time;//休眠时间
    int start;//开始地点
    int end;//结束地点
}RaceArg;
//定义线程运行函数
void* th_fn(void* arg) {
    //void* arg 传过来具体参数是结构体指针 要用需要强制转换成结构体
    RaceArg *r = (RaceArg*)arg;
    //取值
    int i = r->start;
    for (; i <= r->end; i++) {
        printf("%s(%lx) running %d\n", r->name,pthread_self, i);
        //int time = (int)(drand48() * 10000);//产生随机数 drand48只有在Linux下才有
        Sleep(r->time);//阻塞5毫秒 
    }
    return (void*)0;
}
int main(void){
    
    //用于接收线程是否创建成功的返回值
    int err;
    
    //定义线程标识符rabbit turtle
    pthread_t rabbit, turtle;
    
    //结构体赋值
    RaceArg r_a = {"rabbit",(int)(drand48() * 10000),20,50};
    RaceArg t_a = {"turtle",(int)(drand48() * 10000),10,60};
    
    //创建rabbit线程,并给与赋值
    if ((err = pthread_create(&rabbit, NULL, th_fn, (void*)&r_a)) != 0) {
        perror("pthread_create error");
    }
​
    //创建turtle线程，并给与赋值
    if ((err = pthread_create(&turtle, NULL, th_fn, (void*)&r_t)) != 0) {
        perror("pthread_create error");
    }
    
    //阻塞主线程,等待rabbit和turtle线程结束
    pthread_join(rabbit, NULL);
    pthread_join(turtle, NULL);
    //输出的是主控线程的ID
    printf("control thread id:%lx\n", pthread_self());
    printf("finished!\n");
    return 0;
}
```
注意：以上面代码为例，每个线程之间的局部变量是互不影响如：int i或者指针 r都是每个线程自己数据不会相互影响，但是如果是全局变量，就是共享数据。

## 线程终止

### 线程终止基础
主动终止
线程的执行函数中调用return语句
调用pthread_exit()
被动终止
线程可以被同一进程的其他线程取消，其他线程调用pthread_cancel(pthid)

线程终止
```
#include<pthread.h>
int pthread_cancel(pthread_ tid);
void pthread_exit(void *retval);
int pthread_join(pthread_ th,void **thread_return);
返回：成功为0 否则为非零 
```

pthread_cancel 函数
int pthread_cancel(pthread_ tid);
线程可以被同一进程的其他线程取消，tid为要终止的线程标识符

pthread_exit 函数
void pthread_exit(void *retval);
retval：线程创建时，需要运行函数，pthread_exit 的参数就为这个函数的返回值，可由其他函数和pthread_join来检测获取
线程退出时使用函数pthread_exit，是线程的主动行为
由于一个进程中的多个线程共享数据段，因此通常在线程退出后，退出线程所占用的资源并不会随线程结束而释放。如果想要立即释放就必须在主控线程中使用pthread_join函数来等待线程结束，这样线程才会释放干净。

pthread_join函数
int pthread_join(pthread_ th,void * *thread_return);
th:要等待线程的标识符
thread_return(是一个二阶指针)：用户定义指针，用来存储要等待线程的返回值。
作用：谁调用谁阻塞，直到第一个参数的线程执行完毕
举例：pthread_join(rabbit, NULL); pthread_join是主控线程调用的，表示自己会阻塞，直到rabbit线程结束 主控线程方可运行

以上函数在代码实例：
```
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<math.h>
//定义结构体
typedef struct{
    int d1;
    int d2;
}Arg;
//定义线程运行函数
void* th_fn(void* arg) {
    //void* arg 传过来具体参数是结构体指针 要用需要强制转换成结构体
    RaceArg *r = (RaceArg*)arg;
    
    //返回值值是一个数据类型
    //return (r->d1+r->d2); 可以用pthread_exit()函数代替,参数为函数的返回值
    pthread_exit((void*)(r->d1+r->d2));
    
    //可以返回结构体指针
    return (void*)r;
}
int main(void){
    
    //用于接收线程是否创建成功的返回值
    int err;
    
    //定义线程标识符rabbit turtle
    pthread_t th;
    
    //结构体赋值
    Arg r = {10,60};
    
    //创建rabbit线程,并给与赋值
    if ((err = pthread_create(&r, NULL, th_fn, (void*)&r)) != 0) {
        perror("pthread_create error");
    }
    
    //返回值值是一个数据类型
    //用来存放r线程调用函数的返回值
    int *result;
    //阻塞主线程，等待r结束 第二个参数是用于存放函数的返回值
    pthread_join(r,(void**)&result);
    //输出的是主控线程的ID
    printf("result is %d\n", (int)result);
    
    //另一种方式
    int result;
    pthread_join(r,(void*)&result);
    printf("result is %d\n", result);
    
    
    //当返回值值是一个结构体指针
    int *result;
    pthread_join(r,(void**)&result);
    printf("result is %d\n", (Arg*)result->d1+(Arg*)result->d2);
    
     //另一种方式
    int result;
    pthread_join(r,(void**)&result);
    printf("result is %d\n", (Arg*)result->d1+(Arg*)result->d2);
    
    return 0;
}
```