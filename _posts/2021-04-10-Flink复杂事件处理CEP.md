---
layout: post
categories: [Flink]
description: none
keywords: Flink
---
# ## Flink复杂事件处理
复杂事件处理（CEP）是一种基于流处理的技术，将系统数据看作不同类型的事件，通过分析事件之间的关系，建立不同的事件关系序列库，并利用过滤、关联、聚合等技术，最终由简单事件产生高级事件，并通过模式规则的方式对重要信息进行跟踪和分析，从实时数据中发掘有价值的信息。

复杂事件处理主要应用于防范网络欺诈、设备故障检测、风险规避和智能营销等领域。目前主流的CEP工具有Esper、Jboss Drools和商业版的MicroSoft StreamInsight等，Flink基于DataStrem API提供了FlinkCEP组件栈，专门用于对复杂事件的处理，帮助用户从流式数据中发掘有价值的信息。

## 基础概念

### 环境准备
在使用FlinkCEP组件之前，需要将FlinkCEP的依赖库引入项目工程中。与FlinkCEP对应的Maven Dependence如下（将如下配置添加到本地Maven项目工程的Pom.xml文件中即可）
```xml
<dependency>
  <groupId>org.apache.flink</groupId>
  <artifactId>flink-cep-scala_2.11</artifactId>
  <version>1.7.2</version>
</dependency>
```

### 基本概念
### 事件定义
- 简单事件
  简单事件存在于现实场景中，主要的特点为处理单一事件，事件的定义可以直接观察出来，处理过程中无须关注多个事件之间的关系，能够通过简单的数据处理手段将结果计算出来。例如通过对当天的订单总额按照用户维度进行汇总统计，超过一定数量之后进行报告。这种情况只需要计算每个用户每天的订单金额累加值，达到条件进行输出即可。
- 复杂事件
  相对于简单事件，复杂事件处理的不仅是单一的事件，也处理由多个事件组成的复合事件。复杂事件处理监测分析事件流(Event Streaming)，当特定事件发生时来触发某些动作。

### 事件关系
复杂事件中事件与事件之间包含多种类型关系，常见的有时序关系、聚合关系、层次关系、依赖关系及因果关系等。
- 时序关系
  动作事件和动作事件之间，动作事件和状态变化事件之间，都存在时间顺序。事件和事件的时序关系决定了大部分的时序规则，例如A事件状态持续为1的同时B事件状态变为0等。
- 聚合关系
  动作事件和动作事件之间，状态事件和状态事件之间都存在聚合关系，即个体聚合形成整体集合。例如A事件状态为1的次数为10触发预警。
- 层次关系
  动作事件和动作事件之间，状态事件和状态事件之间都存在层次关系，即父类事件和子类事件的层次关系，从父类到子类是具体化的，从子类到父类是泛化的。
- 依赖关系
  事物的状态属性之间彼此的依赖关系和约束关系。例如A事件状态触发的条件前提是B事件触发，则A与B事件之间就形成了依赖关系。
- 因果关系
  对于完整的动作过程，结果状态为果，初始状态和动作都可以视为原因。例如A事件状态的改变导致了B事件的触发，则A事件就是因，而B事件就是果。

### 事件处理
复杂事件处理的目的是通过相应的规则对实时数据执行相应的处理策略，这些策略包括了推断、查因、决策、预测等方面的应用。
- 事件推断
  主要利用事物状态之间的约束关系，从一部分状态属性值可以推断出另一部分的状态属性值。例如由三角形一个角为90度及另一个角为45度，可以推断出第三个角为45度。
- 事件查因
  当出现结果状态，并且知道初始状态，可以查明某个动作是原因；同样当出现结果状态，并且知道之前发生了什么动作，可以查明初始状态是原因。当然反向的推断要求原因对结果来说必须是必要条件。
- 事件决策
  想得到某个结果状态，知道初始状态，决定执行什么动作。该过程和规则引擎相似，例如某个规则符合条件后触发行动，然后执行报警等操作。
- 事件预测
  该种情况知道事件初始状态，以及将要做的动作，预测未发生的结果状态。例如气象局根据气象相关的数据预测未来的天气情况等。

## Pattern API
FlinkCEP中提供了Pattern API用于对输入流数据的复杂事件规则定义，并从事件流中抽取事件结果。通过使用Pattern API构建CEP应用程序，其中包括输入事件流的创建，以及Pattern接口的定义，然后通过CEP.pattern方法将定义的Pattern应用在输入的Stream上，最后使用PatternStream.select方法获取触发事件结果。

以下实例是将温度大于35度的信号事件抽取出来，并产生事件报警，最后将结果输出到外部数据集中。
```java
//创建输入事件流
val inputStream: DataStream[Event] = ...
//定义Pattern接口
val pattern = Pattern
  .begin[Event]("start") 
  .where(_.getType == "temperature")
  .next("middle")
  .subtype(classOf[TempEvent])
  .where(_.getTemp >= 35.0)
  .followedBy("end")
  .where(_.getName == "end")
//将创建好的Pattern应用在输入事件流上
val patternStream = CEP.pattern(inputStream, pattern)
//获取触发事件结果
val result: DataStream[Result] = patternStream.select(getResult(_))
```

## 模式定义
个体Pattern可以是单次执行模式，也可以是循环执行模式。单词执行模式一次只接受一个事件，循环执行模式可以接收一个或者多个事件。通常情况下，可以通过指定循环次数将单次执行模式变为循环执行模式。每种模式能够将多个条件组合应用到同一事件之上，条件组合可以通过where方法进行叠加。

个体Pattern都是通过begin方法定义的，例如以下通过Pattern.begin方法定义基于Event事件类型的Pattern，其中<start_pattern>是指定的PatternName象。
```java
val start = Pattern.begin[Event]("start_pattern")
```
下一步通过Pattern.where()方法在Pattern上指定Condition，只有当Condition满足之后，当前的Pattern才会接受事件。
```java
start.where(event => event.getType == "temperature")
```

### 指定循环次数
对于已经创建好的Pattern，可以指定循环次数，形成循环执行的Pattern，且有3种方式来指定循环方式。
- times：可以通过times指定固定的循环执行次数。
```java
//指定循环触发4次
start.times(4);
//可以执行触发次数范围,让循环执行次数在该范围之内
start.times(2, 4);
```
- optional：也可以通过optional关键字指定要么不触发要么触发指定的次数。
```java
start.times(4).optional();
start.times(2, 4).optional();
```
- greedy：可以通过greedy将Pattern标记为贪婪模式，在Pattern匹配成功的前提下，会尽可能多地触发。
```java
//触发2、3、4次,尽可能重复执行
start.times(2, 4).greedy();
//触发0、2、3、4次,尽可能重复执行
start.times(2, 4).optional().greedy();
```
- oneOrMore：可以通过oneOrMore方法指定触发一次或多次。
```java
// 触发一次或者多次
start.oneOrMore();
//触发一次或者多次,尽可能重复执行
start.oneOrMore().greedy();
// 触发0次或者多次
start.oneOrMore().optional();
// 触发0次或者多次,尽可能重复执行
start.oneOrMore().optional().greedy();
```
- timesOrMor：通过timesOrMore方法可以指定触发固定次数以上，例如执行两次以上。
```java
// 触发两次或者多次
start.timesOrMore(2);
// 触发两次或者多次,尽可能重复执行
start.timesOrMore(2).greedy();
// 不触发或者触发两次以上,尽可能重复执行
start.timesOrMore(2).optional().greedy();
```

## 定义模式条件
每个模式都需要指定触发条件，作为事件进入到该模式是否接受的判断依据，当事件中的数值满足了条件时，便进行下一步操作。在FlinkCFP中通过pattern.where()、pattern.or()及pattern.until()方法来为Pattern指定条件，且Pattern条件有Iterative Conditions、Simple Conditions及Combining Conditions三种类型。

- 迭代条件：Iterative Conditions能够对前面模式所有接收的事件进行处理，根据接收的事件集合统计出计算指标，并作为本次模式匹配中的条件输入参数。如代码清单8-2所示，通过subtype将Event事件转换为TempEvent，然后在where条件中通过使用ctx.getEventsForPattern(...)方法获取“middle”模式所有接收的Event记录，并基于这些Event数据之上对温度求取平均值，然后判断当前事件的温度是否小于平均值。
```java
middle.oneOrMore()
  .subtype(classOf[TempEvent])
  .where(
    (value, ctx) => {
      lazy val avg = ctx.getEventsForPattern("middle").map(_.getValue).avg
      value.getName.startsWith("condition") && value.getPrice < avg
        }
    )
```

- 简单条件：Simple Condition继承于Iterative Condition类，其主要根据事件中的字段信息进行判断，决定是否接受该事件。如以下代码将Sensor事件中Type为temperature的事件筛选出来。
```java
start.where(event => event.getType == "temperature"))
```

可以通过subtype对事件进行子类类型转换，然后在where方法中针对子类定义模式条件。
```java
start.subtype(classOf[TempEvent]).where(tempEvent => event.getValue > 10)
```

- 组合条件：组合条件是将简单条件进行合并，通常情况下也可以使用where方法进行条件的组合，默认每个条件通过AND逻辑相连。如果需要使用OR逻辑，如以下代码直接使用or方法连接条件即可。
```java
pattern.where(event => event.getName.startWith("foo").or(event => 
event.getType == "temperature")
```

- 终止条件
  如果程序中使用了oneOrMore或者oneOrMore().optional()方法，则必须指定终止条件，否则模式中的规则会一直循环下去，如下终止条件通过until()方法指定。
```java
pattern.oneOrMore().until(event => event.getName == "end")
```
需要注意的是，在上述迭代条件中通过调用ctx.getEventsForPattern("middle")的过程中，成本相对较高，会产生比较大的性能开销，因此建议用户尽可能少地使用该方式。

## 模式序列












