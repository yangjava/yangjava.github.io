---
layout: post
categories: [JVM]
description: none
keywords: JVM
---
# 方法调用源码
Java对象是如何创建的，其本质就是按照对象的大小分配一块内存，然后完成属性的初始化。对象创建完了，接着干啥了？调用Java方法完成特定功能。这就是我们接下来探讨的主题，Java方法调用是怎么实现的。

## Main方法
本篇我们从方法调用的入口着手，然后再顺藤摸瓜理顺整个方法调用的实现逻辑。

main方法是Java应用启动执行的入口方法，这个方法是怎么执行的了？可以从JVM的启动入手分析，关键代码在OpenJDK jdk/src/share/bin/java.c中的int JNICALL JavaMain(void * _args)方法，
```
// 虚拟机的入口函数
int JNICALL
JavaMain(void * _args)
{
    JavaMainArgs *args = (JavaMainArgs *)_args;       //获取参数
    int argc = args->argc;
    char **argv = args->argv;
    int mode = args->mode;
    char *what = args->what;
    InvocationFunctions ifn = args->ifn;            //当前虚拟机导致的函数指针
                                                    //该机制可以保证同一环境配置多个jdk版本
    JavaVM *vm = 0;
    JNIEnv *env = 0;
    jclass mainClass = NULL;                        //main函数class
    jclass appClass = NULL; // actual application class being launched // 正在启动的实际应用程序类
    jmethodID mainID;
    jobjectArray mainArgs;
    int ret = 0;
    jlong start, end;

    RegisterThread();                            //window/类unix为空实现，macos特别处理

    /* Initialize the virtual machine */
    // 初始化虚拟机
    start = CounterGet();
    //通过CreateJavaVM导出jvm到&vm, &env
    //&vm主要提供虚拟整体的操作
    //&env主要提供虚拟启动的环境的操作
    if (!InitializeJVM(&vm, &env, &ifn)) {
        JLI_ReportErrorMessage(JVM_ERROR1);
        exit(1);
    }

    if (showSettings != NULL) {
        ShowSettings(env, showSettings);
        CHECK_EXCEPTION_LEAVE(1);
    }

    if (printVersion || showVersion) {
        PrintJavaVersion(env, showVersion);
        CHECK_EXCEPTION_LEAVE(0);
        if (printVersion) {
            LEAVE();
        }
    }

    /* If the user specified neither a class name nor a JAR file */
    // 如果没有指定class或者jar，则直接退出
    if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) {
        PrintUsage(env, printXUsage);
        CHECK_EXCEPTION_LEAVE(1);
        LEAVE();
    }

    FreeKnownVMs();  /* after last possible PrintUsage() */
    // 记录初始化jvm时间
    if (JLI_IsTraceLauncher()) {
        end = CounterGet();
        JLI_TraceLauncher("%ld micro seconds to InitializeJVM\n",
               (long)(jint)Counter2Micros(end-start));
    }

    /* At this stage, argc/argv have the application's arguments */
    // 从argv获取应用的参数，打印参数
    if (JLI_IsTraceLauncher()){
        int i;
        printf("%s is '%s'\n", launchModeNames[mode], what);
        printf("App's argc is %d\n", argc);
        for (i=0; i < argc; i++) {
            printf("    argv[%2d] = '%s'\n", i, argv[i]);
        }
    }

    ret = 1;

    /*
     * Get the application's main class.
     *
     * See bugid 5030265.  The Main-Class name has already been parsed
     * from the manifest, but not parsed properly for UTF-8 support.
     * Hence the code here ignores the value previously extracted and
     * uses the pre-existing code to reextract the value.  This is
     * possibly an end of release cycle expedient.  However, it has
     * also been discovered that passing some character sets through
     * the environment has "strange" behavior on some variants of
     * Windows.  Hence, maybe the manifest parsing code local to the
     * launcher should never be enhanced.
     *
     * Hence, future work should either:
     *     1)   Correct the local parsing code and verify that the
     *          Main-Class attribute gets properly passed through
     *          all environments,
     *     2)   Remove the vestages of maintaining main_class through
     *          the environment (and remove these comments).
     *
     * This method also correctly handles launching existing JavaFX
     * applications that may or may not have a Main-Class manifest entry.
     */
    // 加载Main class
    // 从环境中取出java主类
    mainClass = LoadMainClass(env, mode, what);
    // 检查是否指定main class， 不存在则退出虚拟机
    CHECK_EXCEPTION_NULL_LEAVE(mainClass);
    /*
     * In some cases when launching an application that needs a helper, e.g., a
     * JavaFX application with no main method, the mainClass will not be the
     * applications own main class but rather a helper class. To keep things
     * consistent in the UI we need to track and report the application main class.
     */
    // 获取应用的class文件
    // JavaFX gui应用相关可忽略
    appClass = GetApplicationClass(env);
    // 检查是否指定app class， 不存在返回-1
    NULL_CHECK_RETURN_VALUE(appClass, -1);
    /*
     * PostJVMInit uses the class name as the application name for GUI purposes,
     * for example, on OSX this sets the application name in the menu bar for
     * both SWT and JavaFX. So we'll pass the actual application class here
     * instead of mainClass as that may be a launcher or helper class instead
     * of the application class.
     */
    // window和类unix为空实现，在macos下设定gui程序的程序名称
    // JavaFX gui应用相关可忽略
    PostJVMInit(env, appClass, vm);
    /*
     * The LoadMainClass not only loads the main class, it will also ensure
     * that the main method's signature is correct, therefore further checking
     * is not required. The main method is invoked here so that extraneous java
     * stacks are not in the application stack trace.
     */
    // 从mainclass中加载静态main方法
    mainID = (*env)->GetStaticMethodID(env, mainClass, "main",
                                       "([Ljava/lang/String;)V");
    CHECK_EXCEPTION_NULL_LEAVE(mainID);

    /* Build platform specific argument array */
    // 组装main函数参数
    mainArgs = CreateApplicationArgs(env, argv, argc);
    CHECK_EXCEPTION_NULL_LEAVE(mainArgs);

    /* Invoke main method. */
    // 调用main方法，并把参数传递过去
    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);

    /*
     * The launcher's exit code (in the absence of calls to
     * System.exit) will be non-zero if main threw an exception.
     */
    ret = (*env)->ExceptionOccurred(env) == NULL ? 0 : 1;
    //main方法执行完毕，JVM退出，包含两步：
    //(*vm)->DetachCurrentThread，让当前Main线程同启动线程断联
    //创建一个新的名为DestroyJavaVM的线程，让该线程等待所有的非后台进程退出，并在最后执行(*vm)->DestroyJavaVM方法。
    LEAVE();
}

```
即main方法是通过JNI的CallStaticVoidMethod方法执行的。

## JNI 方法调用
API定义

JNI的方法调用的API，分为三种，总结如下：

- NativeType Call<type>Method：执行非静态方法调用，如果子类覆写父类方法，则调用子类覆写后的方法。
- NativeType CallNonvirtual<type>Method：Call<type>Method的扩展版，如果子类覆写父类方法，可以根据jmethedId调用子类覆写后的方法或者调用父类原来的方法，前者jmethodId从子类jclass中获取，后者jmethodId从父类jclass中获取。
- NativeType CallStatic<type>Method：执行静态方法调用。

三者根据传递参数的方式的不同，又有三个“重载”方法，以Call<type>Method为例：
- Call<type>Method：按照Java方法中定义的参数类型和顺序依次传递参数即可，注意JNI中不支持基本类型的自动装箱拆箱，如果方法参数是包装类，则需要调用包装类的构造方法构造基本包装类实例。
- Call<type>MethodA：按照Java方法中定义的参数类型和顺序将所有参数放入一个jvalue数组中，然后传入该数组的指针即可，jvalue是一个union类型，可以支持所有的参数类型。
- Call<type>MethodV：按照Java方法中定义的参数类型和顺序将所有参数放入一个va_list类中，该类表示一个参数列表。

通过宏的方式实现不同NativeType和type下的方法定义，以Call<type>Method为例，如下图：
