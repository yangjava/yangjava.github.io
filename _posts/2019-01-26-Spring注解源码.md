---
layout: post
categories: Spring
description: none
keywords: Spring
---
# Spring注解源码


## Spring注解启动
使用AnnotationConfigApplicationContext可以实现基于Java的配置类加载Spring的应用上下文。避免使用application.xml进行配置。相比XML配置，更加便捷。

```java
@Configuration
public class config {
    @Bean
    public User user(){
        return new User();
    }
}
```
@Configuration可理解为用spring的时候xml里面的<beans>标签
@Bean可理解为用spring的时候xml里面的<bean>标签

通过AnnotationConfigApplicationContext获取Bean
```java
public class Main {
    public static void main(String[] args) {
      /*  ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring.xml");*/
 
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(config.class);
 
        System.out.println(applicationContext.getBean("user"));
    }
}
```

## AnnotationConfigApplicationContext源码
```
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
		/**
		 * 先调用父类 GenericApplicationContext() 构造方法创建出工厂类 DefaultListableBeanFactory
		 * DefaultListableBeanFactory 中 又调用父类 AbstractAutowireCapableBeanFactory() 构造方法
		 * 设置 三个 ignoredDependencyInterfaces 忽略依赖检查和自动装配
		 * 	BeanNameAware
		 * 	BeanFactoryAware
		 * 	BeanClassLoaderAware
		 */
		this();
		/**
		 * 将传进来的配置类 转换成BeanDefinition 并且put到map中  this.aliasMap.put(alias, name);
		 * 使用 register() 进行注册的bean定义是使用的 AnnotatedGenericBeanDefinition 类
		 * 使用 scan() 方法进行扫描的bean定义是使用的 ScannedGenericBeanDefinition 类进行包装
		 * 默认spring自身的bean定义是使用的 RootBeanDefinition 类进行包装
		 */
		register(componentClasses);
		/**
		 * 最重要的方法，执行Bean注入以及处理
		 */
		refresh();
	}
```
- 首先调用该类的继承类GenericApplicationContext的无参构造方法，该构造方法创建了一个DefaultListableBeanFactory，该类继承了BeanDefinitionRegistry接口
- 调用this()，即AnnotationConfigApplicationContext的无参构造方法，目的是为了创建reader和scanner，即AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner。
- AnnotatedBeanDefinitionReader的作用是为了让context支持类的注册，context.register(Class<?>... componentClasses)，该方法便是用的reader.register()方法，对类进行注册后，会将类名作为key和类的BeanDefinition作为value放入DefaultListableBeanFactory的Map<String, BeanDefinition> beanDefinitionMap中，通过调用registerBeanDefinition(beanName, definition)实现
- AnnotationBeanDefinitionReader的构造方法public AnnotationBeanDefinitionReader(BeanDefinitionRegistry registry, Environment em)其中的BeanDefinitionRegistry可以理解成就是DefaultListableBeanFactory，因为DefaultLisableBeanFactory实现了BeanDefinitionRegistry接口。该构造方法在解析完@Conditional注解后，进行注册，调用方法registryAnnotationConfigProcessors

### register()
```
public void register(Class<?>... componentClasses) {
		Assert.notEmpty(componentClasses, "At least one component class must be specified");
		StartupStep registerComponentClass = this.getApplicationStartup().start("spring.context.component-classes.register")
				.tag("classes", () -> Arrays.toString(componentClasses));
       //调用 AnnotatedBeanDefinitionReader 中的 register() 方法，将传入的Class，包装成BeanDefinition对象注册到容器当中
		this.reader.register(componentClasses);
		registerComponentClass.end();
	}
```

### refresh()
refresh方法是直接调用的 AbstractApplicationContext 对象中的方法，调用12个方法
```
public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            //准备加载上下文，包括初始化配置资源（由子类实现），创建早期事件监听器，环境配置文件的校验
			prepareRefresh();
            //获取到bean工厂，其中会调用 refreshBeanFactory 方法也是由子类实现
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
            //初始化bean工厂，注入一些需要忽略的依赖接口，直接将环境创建为对象存入单例池当中
			prepareBeanFactory(beanFactory);
			try {
                //可以对bean工厂进行一些后置处理（子类实现）
				postProcessBeanFactory(beanFactory);
                //执行实现了 BeanFactoryPostProcessor接口的类，可手动添加
				invokeBeanFactoryPostProcessors(beanFactory);
                //执行Bean的扫描类，从bean工厂中查询出 BeanPostProcessor 接口的实现；
                //其中在构造方法中的 reader对象创建时就注入了 ConfigurationClassPostProcessor类
				registerBeanPostProcessors(beanFactory);
                //
				initMessageSource();
                //初始化事件广播器
				initApplicationEventMulticaster();
                //初始化其它特殊的bean对象，springboot中 tomcat的创建就在这里
				onRefresh();
                //注册监听器
				registerListeners();
                //执行bean对象的创建，将所有bean定义创建成对象存入到容器当中
				finishBeanFactoryInitialization(beanFactory);
                //最后发布完成创建的事件
				finishRefresh();
			}
			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}
				destroyBeans();
				cancelRefresh(ex);
				throw ex;
			}
			finally {
				resetCommonCaches();
				contextRefresh.end();
			}
		}
	}
```

## prepareRefresh()
```
protected void prepareRefresh() {
		this.startupDate = System.currentTimeMillis();
    	//切换容器的状态
		this.closed.set(false);
		this.active.set(true);
		//初始化配置资源，通过子类来实现
		initPropertySources();
    	//主要是获取所有被标记为required的配置类都是可以解析的
		getEnvironment().validateRequiredProperties();
		//创建早期事件监听器
		if (this.earlyApplicationListeners == null) {
			this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
		}
		else {
			this.applicationListeners.clear();
			this.applicationListeners.addAll(this.earlyApplicationListeners);
		}
		this.earlyApplicationEvents = new LinkedHashSet<>();
	}
```

## ConfigurationClassPostProcessor
ConfigurationClassPostProcessor 是非常重要的一个 后处理器。 ConfigurationClassPostProcessor 完成了 配置类的解析和保存以及@Component 注解、@Import 等注解的解析工作 。将所有需要注入的bean解析成 BeanDefinition保存到 BeanFactory 中。
```java
public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {
    public static final AnnotationBeanNameGenerator IMPORT_BEAN_NAME_GENERATOR = new FullyQualifiedAnnotationBeanNameGenerator();
    private static final String IMPORT_REGISTRY_BEAN_NAME = ConfigurationClassPostProcessor.class.getName() + ".importRegistry";
    private final Log logger = LogFactory.getLog(this.getClass());
    // ......
}
```
可见ConfigurationClassPostProcessor 接口实现了BeanDefinitionRegistryPostProcessor(BeanFactory 的后处理器)
PriorityOrdered(设置自己的优先级为最高) 和各种 Aware 接口。

在 Springboot启动后，会通过 SpringApplication#createApplicationContext 来创建应用上下文，默认请情况下我们一般创建 AnnotationConfigServletWebServerApplicationContext 作为应用上下文。而在AnnotationConfigServletWebServerApplicationContext 构造函数中会创建 AnnotatedBeanDefinitionReader。而在 AnnotatedBeanDefinitionReader 构造函数中会调用 AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);，该方法将一些必要Bean(如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor 等)注入到了容器中。
```java
public class AnnotatedBeanDefinitionReader {
    private final BeanDefinitionRegistry registry;
    private BeanNameGenerator beanNameGenerator;
    private ScopeMetadataResolver scopeMetadataResolver;
    private ConditionEvaluator conditionEvaluator;

    public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
        this(registry, getOrCreateEnvironment(registry));
    }

    public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
        this.beanNameGenerator = AnnotationBeanNameGenerator.INSTANCE;
        this.scopeMetadataResolver = new AnnotationScopeMetadataResolver();
        Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
        Assert.notNull(environment, "Environment must not be null");
        this.registry = registry;
        this.conditionEvaluator = new ConditionEvaluator(registry, environment, (ResourceLoader) null);
        AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
    }
    // .......
}
```

## ConfigurationClassPostProcessor
主要关注 ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry 方法的解析。所以我们下面来看看 postProcessBeanDefinitionRegistry 方法
```java
public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
    void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry var1) throws BeansException;
}
```
可以看到 postProcessBeanDefinitionRegistry 方法中并没有处理什么逻辑，真正逻辑在其调用的 processConfigBeanDefinitions 方法中

### processConfigBeanDefinitions
processConfigBeanDefinitions 方法完成了关于配置类的所有解析。
```
	public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
		List<BeanDefinitionHolder> configCandidates = new ArrayList<>();
		// 获取已经解析的BeanName。这里需要注意的是，Springboot的话，启动类已经被注册。具体的注册时机是在  Springboot启动时候的 SpringApplication#prepareContext方法中。
		String[] candidateNames = registry.getBeanDefinitionNames();
		// 遍历BeanName
		for (String beanName : candidateNames) {
			// 获取BeanDefinition 
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			// 如果bean被解析过(Bean 被解析后会在beanDef 中设置属性 CONFIGURATION_CLASS_ATTRIBUTE )，if 属性成立，这里是为了防止重复解析
			if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
				if (logger.isDebugEnabled()) {
					logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
				}
			}
			// 1. ConfigurationClassUtils.checkConfigurationClassCandidate 解析了当前bean是否是配置类，关于其详细内容，后面解析 需要注意的是，本文所说的配置类即使满足 full 或 lite 条件的类，而不仅仅是被 @Configuration 修饰的类。
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
				// 添加到配置类集合中
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
			}
		}

		// Return immediately if no @Configuration classes were found
		// 如果没有找到配置类，则直接返回，不需要下面的解析
		if (configCandidates.isEmpty()) {
			return;
		}

		// Sort by previously determined @Order value, if applicable
		// 按照@Order 注解进行排序(如果使用了 @Order 注解的话)
		configCandidates.sort((bd1, bd2) -> {
			int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
			int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
			return Integer.compare(i1, i2);
		});

		.// Detect any custom bean name generation strategy supplied through the enclosing application context
		// 判断如果是 registry  是 SingletonBeanRegistry 类型，则从中获取 beanName 生成器(BeanNameGenerator )。实际上这里是 register 类型是 DefaultListableBeanFactory。是 SingletonBeanRegistry  的子类
		SingletonBeanRegistry sbr = null;
		if (registry instanceof SingletonBeanRegistry) {
			sbr = (SingletonBeanRegistry) registry;
			if (!this.localBeanNameGeneratorSet) {
				BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(
						AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);
				if (generator != null) {
					this.componentScanBeanNameGenerator = generator;
					this.importBeanNameGenerator = generator;
				}
			}
		}
		// 如果环境变量为空则指定一个标准环境，这里是 StandardServletEnvironment 类型，在前面的启动篇我们可以知道。
		if (this.environment == null) {
			this.environment = new StandardEnvironment();
		}
	
		// Parse each @Configuration class
		// 下面开始解析每一个配置类
		// 准备配置类的解析类ConfigurationClassParser 
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
		// 用来保存尚未解析的配置类
		Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
		// 用来保存已经解析的配置类
		Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
		// do..while 循环解析。因为一个配置类可能引入另一个配置类，需要循环解析，直至没有其他需要解析的类。
		do {
			// 2. 开始解析。后面详细分析
			parser.parse(candidates);
			// 3. 这里的校验规则是如果是被 @Configuration修饰且proxyBeanMethods属性为true,则类不能为final。如果@Bean修饰的方法，则必须是可覆盖的.
			// 因为@Configuration(proxyBeanMethods = true) 是需要cglib代理的，所以不能为终态， @Bean所修饰的方法也有一套约束规则，下面详细讲
			// 是否需要代理是根据 类或方法上的 @Scope 注解指定的，默认都是不代理
			parser.validate();
			// configClasses  保存这次解析出的配置类。此时这些ConfigurationClass 中保存了解析出来的各种属性值，等待最后构建 BeanDefinition
			Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
			// 去除已经解析过的配置类
			configClasses.removeAll(alreadyParsed);

			// Read the model and create bean definitions based on its content
			if (this.reader == null) {
				this.reader = new ConfigurationClassBeanDefinitionReader(
						registry, this.sourceExtractor, this.resourceLoader, this.environment,
						this.importBeanNameGenerator, parser.getImportRegistry());
			}
			// 4. 注册bean
			this.reader.loadBeanDefinitions(configClasses);
			alreadyParsed.addAll(configClasses);

			candidates.clear();
			// if 如果成立，说明有新的bean注册了，则需要解析新的bean
			if (registry.getBeanDefinitionCount() > candidateNames.length) {
				// 获取新的beanName
				String[] newCandidateNames = registry.getBeanDefinitionNames();
				Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));
				Set<String> alreadyParsedClasses = new HashSet<>();
				for (ConfigurationClass configurationClass : alreadyParsed) {
					alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
				}
				for (String candidateName : newCandidateNames) {
					if (!oldCandidateNames.contains(candidateName)) {
						// 过滤出未解析的bean检测是否是未解析过的配置类
						BeanDefinition bd = registry.getBeanDefinition(candidateName);
						if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
								!alreadyParsedClasses.contains(bd.getBeanClassName())) {
							// 如果是未解析的配置类，则保存到candidates中
							candidates.add(new BeanDefinitionHolder(bd, candidateName));
						}
					}
				}
				candidateNames = newCandidateNames;
			}
		}
		// 如果 candidates 不为空，则说明有未被解析的配置类，循环解析。
		while (!candidates.isEmpty());

		// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
			// 到这里已经把配置类解析完毕了。
			// 将ImportRegistry  注册为 bean，以支持ImportAware @Configuration 类
		if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
			sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
		}
		// 清除缓存
		if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
			// Clear cache in externally provided MetadataReaderFactory; this is a no-op
			// for a shared cache since it'll be cleared by the ApplicationContext.
			((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
		}
	}
```
这里简单总结一下流程;
- 获取已经注册的Bean, 并筛选出配置类，按照@Order 进行排序，得到配置类集合 configCandidates
- 调用 parser.parse(candidates); 对配置类进行解析
- 调用 this.reader.loadBeanDefinitions(configClasses); 进行配置类的注册
- 检验 registry.getBeanDefinitionCount() > candidateNames.length 是否成立。这里由于第三步会将新解析出来的bean进行注册，如果这里成立，则说明有新的配置类完成了注册，获取到新注册的配置类candidateNames。循环从第二步重新解析，直到没有新注入的配置类。

### checkConfigurationClassCandidate
在 processConfigBeanDefinitions 方法中。判断一个类是否是配置类就是通过 checkConfigurationClassCandidate 方法来判断的，那么我们需要看看这个方法中是怎么实现的。

在这个方法里，关键的部分是 给 BeanDefinition 设置了CONFIGURATION_CLASS_ATTRIBUTE 为 full 或者 lite 设置这两个属性标识，如果一个类满足full或 lite的条件，则会被认为是配置类。需要注意的是，本文所说的配置类即使满足 full 或 lite 条件的类，而不仅仅是被 @Configuration 修饰的类。
首先需要注意的是，在 checkConfigurationClassCandidate 中，配置类的类型分为两种，Full 和 Lite，即完整的配置类和精简的配置类。

full 和 lite 设置的规则如下：
- Full
Full 配置类就是我们常规使用的配置类。即类被 @Configuration 注解修饰 && proxyBeanMethods属性为true (默认为 true)
- Lite
Lite 配置类就是一些需要其他操作引入一些bean 的类。被 @Component、@ComponentScan、@Import、@ImportResource 修饰的类 或者 类中有被@Bean修饰的方法。

下面我们来看具体代码：
```
	public static boolean checkConfigurationClassCandidate(
			BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
		// 获取className
		String className = beanDef.getBeanClassName();
		if (className == null || beanDef.getFactoryMethodName() != null) {
			return false;
		}

		// 解析关于当前被解析类的 注解元数据
		AnnotationMetadata metadata;
		// 如果当前BeanDefinition  是 AnnotatedBeanDefinition(相较于一般的 BeanDefinition，他多了一些注解信息的解析) 类型。直接获取注解元数据即可
		if (beanDef instanceof AnnotatedBeanDefinition &&
				className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
			// Can reuse the pre-parsed metadata from the given BeanDefinition...
			metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
		}
		
		else if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
			// Check already loaded Class if present...
			// since we possibly can't even load the class file for this Class.
			
			Class<?> beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
			// 如果当前类是 BeanFactoryPostProcessor、BeanPostProcessor、AopInfrastructureBean、EventListenerFactory 类型不当做配置类处理，返回false
			if (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) ||
					BeanPostProcessor.class.isAssignableFrom(beanClass) ||
					AopInfrastructureBean.class.isAssignableFrom(beanClass) ||
					EventListenerFactory.class.isAssignableFrom(beanClass)) {
				return false;
			}
			// 获取数据
			metadata = AnnotationMetadata.introspect(beanClass);
		}
		else {
		// 按照默认规则解析
			try {
				MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
				metadata = metadataReader.getAnnotationMetadata();
			}
			catch (IOException ex) {
				if (logger.isDebugEnabled()) {
					logger.debug("Could not find class file for introspecting configuration annotations: " +
							className, ex);
				}
				return false;
			}
		}

		
		// 获取bean上的Configuration 注解的属性。如果没有被 @Configuration 修饰 config 则为null
		Map<String, Object> config = metadata.getAnnotationAttributes(Configuration.class.getName());
		// 如果被 @Configuration 修饰 &&  proxyBeanMethods 属性为 true。 @Configuration 的 proxyBeanMethods  属性默认值即为 true。
		if (config != null && !Boolean.FALSE.equals(config.get("proxyBeanMethods"))) {
			// 设置 CONFIGURATION_CLASS_ATTRIBUTE 为 full
			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
		}
		// 如果被 @Configuration 修饰 &&  isConfigurationCandidate(metadata) = true
		// 关于  isConfigurationCandidate(metadata) 的解析在下面
		else if (config != null || isConfigurationCandidate(metadata)) {
			// 设置 CONFIGURATION_CLASS_ATTRIBUTE 为 lite
			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
		}
		else {
			return false;
		}

		// It's a full or lite configuration candidate... Let's determine the order value, if any.
		// 按照@Order 注解排序
		Integer order = getOrder(metadata);
		if (order != null) {
			beanDef.setAttribute(ORDER_ATTRIBUTE, order);
		}

		return true;
	}
```
#### isConfigurationCandidate
在上面的代码中，我们看到 判断是否是 Lite 的关键方法是 isConfigurationCandidate。其代码如下：
```
	// candidateIndicators  的定义
	private static final Set<String> candidateIndicators = new HashSet<>(8);

	static {
		candidateIndicators.add(Component.class.getName());
		candidateIndicators.add(ComponentScan.class.getName());
		candidateIndicators.add(Import.class.getName());
		candidateIndicators.add(ImportResource.class.getName());
	}	

	public static boolean isConfigurationCandidate(AnnotationMetadata metadata) {
		// Do not consider an interface or an annotation...
		// 不能是接口
		if (metadata.isInterface()) {
			return false;
		}

		// Any of the typical annotations found?
		// 被 candidateIndicators 中的注解修饰。其中 candidateIndicators  注解在静态代码块中加载了
		for (String indicator : candidateIndicators) {
			if (metadata.isAnnotated(indicator)) {
				return true;
			}
		}

		// Finally, let's look for @Bean methods...
		try {
			// 类中包含被 @Bean 注解修饰的方法
			return metadata.hasAnnotatedMethods(Bean.class.getName());
		}
		catch (Throwable ex) {
			if (logger.isDebugEnabled()) {
				logger.debug("Failed to introspect @Bean methods on class [" + metadata.getClassName() + "]: " + ex);
			}
			return false;
		}
	}
```

#### parser.parse(candidates);
上面解析了如何判断一个类是否是配置类。也完成了配置类的筛选。那么开始进行配置类的解析，在 processConfigBeanDefinitions 方法中，对配置类的解析也只是一句话完成:
```
parser.parse(candidates);
```

parser.parse(candidates); 的作用是：

- 将所有的配置类保存到 ConfigurationClassParser#configurationClasses 集合中
```
private final Map<ConfigurationClass, ConfigurationClass> configurationClasses = new LinkedHashMap<>();
```

- 解析注解并赋值给每个 ConfigurationClass 对应的属性。如解析 @Import 注解，并通过如下语句将结果保存到 ConfigurationClass.importBeanDefinitionRegistrars 集合中。
```
configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
```
同样的还有 将@ ImportResource 注解保存到ConfigurationClass.importedResources中，将@Bean 修饰的方法 和接口静态方法保存到ConfigurationClass.beanMethods 中。
而在之后的 this.reader.loadBeanDefinitions(configClasses); 中才进行了这些属性的进一步处理

下面我们来具体看代码，其代码如下：
```
	public void parse(Set<BeanDefinitionHolder> configCandidates) {
		for (BeanDefinitionHolder holder : configCandidates) {
			BeanDefinition bd = holder.getBeanDefinition();
			try {
				// 针对不同类型的 BeanDefinition 做一些处理
				if (bd instanceof AnnotatedBeanDefinition) {
					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
				}
				else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
					parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
				}
				else {
					parse(bd.getBeanClassName(), holder.getBeanName());
				}
			}
			catch (BeanDefinitionStoreException ex) {
				throw ex;
			}
			catch (Throwable ex) {
				throw new BeanDefinitionStoreException(
						"Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
			}
		}
		// 在这里调用了 AutoConfigurationImportSelector 完成了Springboot的自动化装配
		this.deferredImportSelectorHandler.process();
	}
```
里面的 parse 方法殊途同归，最终都会调用 processConfigurationClass 方法，所以我们直接进入 processConfigurationClass 方法：
```
	protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
		// 判断是否应该跳过当前类的解析。这里面解析了 @Conditional 注解
		if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
			return;
		}
		// 判断是否已经解析过。configurationClasses 中保存着已经解析过的配置类。在下面解析过的类都会被保存到 configurationClasses 中
		// 这里应该是 注入的配置类优先级高于引入的配置类
		// 如果配置类被多次引入则合并属性
		ConfigurationClass existingClass = this.configurationClasses.get(configClass);
		if (existingClass != null) {
			// 一个类被重复解析，那么可能被重复引入了，可能是通过 @Import 注解或者嵌套在其他配置类中被引入。如果这两者都是通过这种方式被引入，那么则进行引入合并
			// 如果当前配置类和之前解析过的配置类都是引入的，则直接合并
			if (configClass.isImported()) {
				if (existingClass.isImported()) {
					existingClass.mergeImportedBy(configClass);
				}
				// Otherwise ignore new imported config class; existing non-imported class overrides it.
				// 否则，忽略新导入的配置类；现有的非导入类将覆盖它
				return;
			}
			else {
				// Explicit bean definition found, probably replacing an import.
				// Let's remove the old one and go with the new one.
				// 如果当前的配置类不是引入的，则移除之前的配置类，重新解析
				this.configurationClasses.remove(configClass);
				this.knownSuperclasses.values().removeIf(configClass::equals);
			}
		}

		// Recursively process the configuration class and its superclass hierarchy.
		SourceClass sourceClass = asSourceClass(configClass, filter);
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
		}
		while (sourceClass != null);
		// 保存解析过的 配置类
		this.configurationClasses.put(configClass, configClass);
	}
```
this.conditionEvaluator.shouldSkip 中对 @Conditional 注解 注解进行了处理，由于篇幅所限(写太长了)，这里不再展开叙述。

this.deferredImportSelectorHandler.process(); 通过对AutoConfigurationImportSelector 的处理，完成了Springboot 的自动化装配。

这里需要注意的是配置类的重复引入优先级的问题 ：
一般来说，Spring有一个自己的规则 ：自身注入方式 优先于 引入方式。这里的引入方式指的被 @Import 或者其他配置类引入。当一个类被多次引入时，会使用自身注入的方式的bean 替代 被引入方式的bean。如果二者都是引入方式，则进行合并(在 ConfigurationClass 类中有一个importedBy 集合，将新引入的来源保存到 importedBy 中)

看了这么久的源码，也知道了Spring的套路，方法名以do开头的才是真正做事的方法, 所以我们来看 doProcessConfigurationClass 方法。
```
	@Nullable
	protected final SourceClass doProcessConfigurationClass(
			ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
			throws IOException {
		// 1. 处理 @Component 注解
		if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
			// Recursively process any member (nested) classes first
			processMemberClasses(configClass, sourceClass, filter);
		}

		// Process any @PropertySource annotations
		// 2. 处理 @PropertySource 注解
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class,
				org.springframework.context.annotation.PropertySource.class)) {
			if (this.environment instanceof ConfigurableEnvironment) {
				processPropertySource(propertySource);
			}
			else {
				logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
						"]. Reason: Environment must implement ConfigurableEnvironment");
			}
		}

		// Process any @ComponentScan annotations
		// 3. 处理 @ComponentScan注解
		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
		if (!componentScans.isEmpty() &&
				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			for (AnnotationAttributes componentScan : componentScans) {
				// The config class is annotated with @ComponentScan -> perform the scan immediately
				Set<BeanDefinitionHolder> scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
				// Check the set of scanned definitions for any further config classes and parse recursively if needed
				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
					if (bdCand == null) {
						bdCand = holder.getBeanDefinition();
					}
					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
						parse(bdCand.getBeanClassName(), holder.getBeanName());
					}
				}
			}
		}

		// Process any @Import annotations
		// 4. 处理 @Import 注解
		processImports(configClass, sourceClass, getImports(sourceClass), filter, true);

		// Process any @ImportResource annotations
		// 5. 处理 @ImportResource 注解
		AnnotationAttributes importResource =
				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
		if (importResource != null) {
			String[] resources = importResource.getStringArray("locations");
			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
			for (String resource : resources) {
				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
				configClass.addImportedResource(resolvedResource, readerClass);
			}
		}

		// Process individual @Bean methods
		// 6. 处理 @Bean修饰的方法
		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
		for (MethodMetadata methodMetadata : beanMethods) {
			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
		}

		// Process default methods on interfaces
		// 7. 处理其他默认接口方法
		processInterfaces(configClass, sourceClass);

		// Process superclass, if any
		// 处理父类，如果存在
		if (sourceClass.getMetadata().hasSuperClass()) {
			String superclass = sourceClass.getMetadata().getSuperClassName();
			if (superclass != null && !superclass.startsWith("java") &&
					!this.knownSuperclasses.containsKey(superclass)) {
				this.knownSuperclasses.put(superclass, configClass);
				// Superclass found, return its annotation metadata and recurse
				return sourceClass.getSuperClass();
			}
		}

		// No superclass -> processing is complete
		return null;
	}
```

doProcessConfigurationClass 方法中的逻辑很清楚，因为他把大部分的逻辑直接封装成了方法。下面我们就来一个一个分析。

### 处理 @Component 注解
这里对 @Component 的处理其实是处理配置类的内部类，即如果当前类是被 @Component 修饰，则需要判断其内部类是否需要解析。
```
		// 首先判断如果配置类被@Component 修饰，则调用processMemberClasses 方法处理
		if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
			// Recursively process any member (nested) classes first
			processMemberClasses(configClass, sourceClass, filter);
		}
```
processMemberClasses 方法的代码如下：
代码逻辑也很简单。即如果配置类中有内部类，则判断其内部类是否是配置类，如果是则递归去解析新发现的内部配置类。
```
	private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass,
			Predicate<String> filter) throws IOException {
		// 获取内部类
		Collection<SourceClass> memberClasses = sourceClass.getMemberClasses();
		if (!memberClasses.isEmpty()) {
			// 如果有内部类，则遍历内部类，判断内部类是否是配置类，如果是，则添加到 candidates 集合中。
			List<SourceClass> candidates = new ArrayList<>(memberClasses.size());
			for (SourceClass memberClass : memberClasses) {
				// 这里判断的是是否是lite 类型的配置类
				if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&
						!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {
					candidates.add(memberClass);
				}
			}
			// 进行排序
			OrderComparator.sort(candidates);
			for (SourceClass candidate : candidates) {
				// importStack 用来缓存已经解析过的内部类，这里处理循环引入问题。
				if (this.importStack.contains(configClass)) {
					// 打印循环引用异常
					this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
				}
				else {
					// 解析前入栈，防止循环引入
					this.importStack.push(configClass);
					try {
						// 递归去解析新发现的配置类
						processConfigurationClass(candidate.asConfigClass(configClass), filter);
					}
					finally {
						// 解析完毕出栈
						this.importStack.pop();
					}
				}
			}
		}
	}
```
- 判断内部类是否是配置类，使用的方法是 ConfigurationClassUtils.isConfigurationCandidate，这里是检测内部类是否满足lite 的配置类规则，并未校验 full的规则。
- 代码中使用了this.importStack 来防止递归引入。避免了A引入B，B又引入A这种无限循环的情况。

### 处理 @PropertySource 注解
@PropertySource 注解可以引入配置文件使用。在这里进行 @PropertySource 注解的解析，将引入的配置文件加载到环境变量中
```
	// 去重后遍历 PropertySource 注解所指向的属性。注意这里有两个注解@PropertySources 和 @PropertySource。
	for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
			sourceClass.getMetadata(), PropertySources.class,
			org.springframework.context.annotation.PropertySource.class)) {
		if (this.environment instanceof ConfigurableEnvironment) {
			// 解析PropertySource  注解
			processPropertySource(propertySource);
		}
		else {
			logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
					"]. Reason: Environment must implement ConfigurableEnvironment");
		}
	}
```
processPropertySource 代码如下，在这里解析每一个@PropertySource 注解属性 :
```
	private void processPropertySource(AnnotationAttributes propertySource) throws IOException {
		// 获取 @PropertySource 注解的各个属性
		String name = propertySource.getString("name");
		if (!StringUtils.hasLength(name)) {
			name = null;
		}
		String encoding = propertySource.getString("encoding");
		if (!StringUtils.hasLength(encoding)) {
			encoding = null;
		}
		// 获取指向的文件路径
		String[] locations = propertySource.getStringArray("value");
		Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required");
		boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound");

		Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory");
		PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?
				DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));
		// 遍历文件路径
		for (String location : locations) {
			try {
				//  根据路径获取到资源文件并保存到environment 中
				// 解决占位符，获取真正路径
				String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);
				Resource resource = this.resourceLoader.getResource(resolvedLocation);
				//保存 PropertySource 到 environment 中
				addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));
			}
			catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {
				// Placeholders not resolvable or resource not found when trying to open it
				if (ignoreResourceNotFound) {
					if (logger.isInfoEnabled()) {
						logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage());
					}
				}
				else {
					throw ex;
				}
			}
		}
	}
```

### 处理 @ComponentScan、@ComponentScans 注解
@componentScans 指定自动扫描的路径。
```
		// 这里会将 @ComponentScans 中的多个 @ComponentScan 也解析出来封装成一个个AnnotationAttributes对象
		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
		// 如果当前配置类被 @componentScans 或 @componentScan 注解修饰 && 不应跳过
		if (!componentScans.isEmpty() &&
				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
				// 遍历 @ComponentScans、 @ComponentScan
			for (AnnotationAttributes componentScan : componentScans) {
				// The config class is annotated with @ComponentScan -> perform the scan immediately
				// 直接执行扫描，根据指定路径扫描出来bean。
				Set<BeanDefinitionHolder> scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
				// Check the set of scanned definitions for any further config classes and parse recursively if needed
				// 遍历扫描出来的bean
				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				// 获取原始的bean的定义
					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
					if (bdCand == null) {
						bdCand = holder.getBeanDefinition();
					}
					// 检测如果是配置类，则递归调用 parse 解析。
					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
						parse(bdCand.getBeanClassName(), holder.getBeanName());
					}
				}
			}
		}
```
这里需要注意 :
- this.componentScanParser.parse 方法完成了指定路径下的bean的扫描，这里不再具体分析。详参：Spring 源码分析补充篇二 ：ClassPathBeanDefinitionScanner#doScan
- 这里校验是否是配置类调用的是 checkConfigurationClassCandidate 方法，即校验了 full或lite的规则，和 处理 @Component 中的内部类的规则并不相同。 没错，又是递归，如果扫描到的bean中发现了新的配置类，则递归去解析。
- 之前的我们提过，Springboot 在启动过程中将 启动类注册到了容器中，那么在这里进行递归遍历的时候就会通过启动类指定的默认路径来进行遍历， 完成了Springboot的启动注册。

### 处理 @Import、ImportSelector、ImportBeanDefinitionRegistrar
processImports(configClass, sourceClass, getImports(sourceClass), filter, true); 该方法处理的包括 @Import、ImportSelector、 ImportBeanDefinitionRegistrar。这三个注解或接口都可以完成Bean的引入功能。

@Import ： 可以通过 @Import(XXX.class) 的方式，将指定的类注册到容器中
ImportSelector : Spring会将 ImportSelector#selectImports 方法返回的内容通过反射加载到容器中
ImportBeanDefinitionRegistrar ： 可以通过 registerBeanDefinitions 方法声明BeanDefinition 并自己注册到Spring容器中 比如 ： MyBatis 中的 AutoConfiguredMapperScannerRegistrar 对@Mapper 修饰类的注册过程

需要注意的是，这里解析的ImportSelector、ImportBeanDefinitionRegistrar 都是通过 @Import 注解引入的。如果不是通过 @Import 引入(比如直接通过@Component 将ImportSelector、ImportBeanDefinitionRegistrar 注入)的类则不会被解析。

注意 getImports(sourceClass) 方法的作用是解析 @Import 注解

我们直接来看 processImports 方法，注释都比较清楚 :
```
	private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
			Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter,
			boolean checkForCircularImports) {
		// importCandidates 是通过getImports() 方法解析 @Import 注解而来， 如果为空则说明没有需要引入的直接返回
		if (importCandidates.isEmpty()) {
			return;
		}
		// 检测是否是循环引用。
		if (checkForCircularImports && isChainedImportOnStack(configClass)) {
			this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
		}
		else {
			// 解析前先入栈，防止循环引用
			this.importStack.push(configClass);
			try {
				for (SourceClass candidate : importCandidates) {
					// 判断是否是ImportSelector类型。ImportSelector 则需要调用selectImports 方法来获取需要注入的类。
					if (candidate.isAssignable(ImportSelector.class)) {
						// Candidate class is an ImportSelector -> delegate to it to determine imports
						Class<?> candidateClass = candidate.loadClass();
						ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,
								this.environment, this.resourceLoader, this.registry);
						Predicate<String> selectorFilter = selector.getExclusionFilter();
						if (selectorFilter != null) {
							exclusionFilter = exclusionFilter.or(selectorFilter);
						}
						if (selector instanceof DeferredImportSelector) {
							this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);
						}
						else {
						// 调用 selectImports 方法获取需要引入的类，并递归再次处理。
							String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
							Collection<SourceClass> importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);
							// 递归解析
							processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false);
						}
					}
					// 如果是 ImportBeanDefinitionRegistrar 类型，则委托它注册其他bean定义
					else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
						// Candidate class is an ImportBeanDefinitionRegistrar ->
						// delegate to it to register additional bean definitions
						Class<?> candidateClass = candidate.loadClass();
						ImportBeanDefinitionRegistrar registrar =
								ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
										this.environment, this.resourceLoader, this.registry);
						configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
					}
					else {
						// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar ->
						// process it as an @Configuration class
						this.importStack.registerImport(
								currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
						// 否则递归处理需要引入的类。
						processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);
					}
				}
			}
			catch (BeanDefinitionStoreException ex) {
				throw ex;
			}
			catch (Throwable ex) {
				throw new BeanDefinitionStoreException(
						"Failed to process import candidates for configuration class [" +
						configClass.getMetadata().getClassName() + "]", ex);
			}
			finally {
				this.importStack.pop();
			}
		}
	}
```























