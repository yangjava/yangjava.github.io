---
layout: post
categories: [Quartz]
description: none
keywords: Quartz
---
# Quartz详解
Quartz 是 OpenSymphony 开源组织在任务调度领域的一个开源项目，完全基于 Java 实现。该项目于 2009 年被 Terracotta 收购，目前是 Terracotta 旗下的一个项目。

Quartz 其实就是通过一个调度线程不断的扫描数据库中的数据来获取到那些已经到点要触发的任务，然后调度执行它的。这个线程就是 QuartzSchedulerThread类。其run方法中就是quartz的调度逻辑。
## Quartz特点

作为一个优秀的开源调度框架，Quartz 具有以下特点：
1. 强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求；
2. 灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式；
3. 分布式和集群能力，Terracotta 收购后在原来功能基础上作了进一步提升。

另外，作为 Spring 默认的调度框架，Quartz 很容易与 Spring 集成实现灵活可配置的调度功能。

## quartz调度核心元素

### Scheduler
Scheduler:任务调度器，是实际执行任务调度的控制器。在spring中通过SchedulerFactoryBean封装起来。

### Trigger
Trigger：触发器，用于定义任务调度的时间规则，有SimpleTrigger,CronTrigger,DateIntervalTrigger和NthIncludedDayTrigger，其中CronTrigger用的比较多。CronTrigger在spring中封装在CronTriggerFactoryBean中。

### Calendar
Calendar:它是一些日历特定时间点的集合。一个trigger可以包含多个Calendar，以便排除或包含某些时间点。

### JobDetail
JobDetail:用来描述Job实现类及其它相关的静态信息，如Job名字、关联监听器等信息。在spring中有JobDetailFactoryBean和 MethodInvokingJobDetailFactoryBean两种实现，如果任务调度只需要执行某个类的某个方法，就可以通过MethodInvokingJobDetailFactoryBean来调用。

### Job
Job：是一个接口，只有一个方法void execute(JobExecutionContext context),开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中。实现Job接口的任务，默认是无状态的，若要将Job设置成有状态的，在quartz中是给实现的Job添加@DisallowConcurrentExecution注解（以前是实现StatefulJob接口，现在已被Deprecated）,在与spring结合中可以在spring配置文件的job detail中配置concurrent参数。

### Quartz 集群配置
quartz集群是通过数据库表来感知其他的应用的，各个节点之间并没有直接的通信。只有使用持久的JobStore才能完成Quartz集群。
数据库表：以前有12张表，现在只有11张表，现在没有存储listener相关的表，多了QRTZ_SIMPROP_TRIGGERS表：

|  Table name   |  Description   |
|-----|-----|
|  QRTZ_CALENDARS   |  存储Quartz的Calendar信息   |
|  QRTZ_CRON_TRIGGERS   | 存储CronTrigger，包括Cron表达式和时区信息    |
| QRTZ_FIRED_TRIGGERS    | 存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息    |
|  QRTZ_PAUSED_TRIGGER_GRPS   |  存储已暂停的Trigger组的信息   |
|  QRTZ_SCHEDULER_STATE   | 存储少量的有关Scheduler的状态信息，和别的Scheduler实例    |
|  QRTZ_LOCKS   | 存储程序的悲观锁的信息    |
|  QRTZ_JOB_DETAILS   | 存储每一个已配置的Job的详细信息    |
|  QRTZ_SIMPLE_TRIGGERS   | 存储简单的Trigger，包括重复次数、间隔、以及已触的次数    |
|  QRTZ_BLOG_TRIGGERS   |  Trigger作为Blob类型存储   |
|  QRTZ_TRIGGERS   |  存储已配置的Trigger的信息   |
|  QRTZ_SIMPROP_TRIGGERS   |     |

QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表,包括以下几个锁：CALENDAR_ACCESS 、JOB_ACCESS、MISFIRE_ACCESS 、STATE_ACCESS 、TRIGGER_ACCESS。


## quartz基本原理

Quartz 任务调度的核心元素是 scheduler, trigger 和 job，其中 trigger 和 job 是任务调度的元数据， scheduler 是实际执行调度的控制器。

在 Quartz 中，trigger 是用于定义调度时间的元素，即按照什么时间规则去执行任务。Quartz 中主要提供了四种类型的 trigger：SimpleTrigger，CronTirgger，DateIntervalTrigger，和 NthIncludedDayTrigger。这四种 trigger 可以满足企业应用中的绝大部分需求。我们将在企业应用一节中进一步讨论四种 trigger 的功能。

在 Quartz 中，job 用于表示被调度的任务。主要有两种类型的 job：无状态的（stateless）和有状态的（stateful）。对于同一个 trigger 来说，有状态的 job 不能被并行执行，只有上一次触发的任务被执行完之后，才能触发下一次执行。Job 主要有两种属性：volatility 和 durability，其中 volatility 表示任务是否被持久化到数据库存储，而 durability 表示在没有 trigger 关联的时候任务是否被保留。两者都是在值为 true 的时候任务被持久化或保留。一个 job 可以被多个 trigger 关联，但是一个 trigger 只能关联一个 job。

在 Quartz 中， scheduler 由 scheduler 工厂创建：DirectSchedulerFactory 或者 StdSchedulerFactory。 第二种工厂 StdSchedulerFactory 使用较多，因为 DirectSchedulerFactory 使用起来不够方便，需要作许多详细的手工编码设置。 Scheduler 主要有三种：RemoteMBeanScheduler， RemoteScheduler 和 StdScheduler。本文以最常用的 StdScheduler 为例讲解。

### 线程

在 Quartz 中，有两类线程，Scheduler 调度线程和任务执行线程，其中任务执行线程通常使用一个线程池维护一组线程。
Scheduler 调度线程主要有两个： 执行常规调度的线程，和执行 misfired trigger 的线程。常规调度线程轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务。Misfire 线程是扫描所有的 trigger，查看是否有 misfired trigger，如果有的话根据 misfire 的策略分别处理。

### 数据存储
Quartz 中的 trigger 和 job 需要存储下来才能被使用。Quartz 中有两种存储方式：RAMJobStore, JobStoreSupport，其中 RAMJobStore 是将 trigger 和 job 存储在内存中，而 JobStoreSupport 是基于 jdbc 将 trigger 和 job 存储到数据库中。RAMJobStore 的存取速度非常快，但是由于其在系统被停止后所有的数据都会丢失，所以在通常应用中，都是使用 JobStoreSupport。

在 Quartz 中，JobStoreSupport 使用一个驱动代理来操作 trigger 和 job 的数据存储：StdJDBCDelegate。StdJDBCDelegate 实现了大部分基于标准 JDBC 的功能接口，但是对于各种数据库来说，需要根据其具体实现的特点做某些特殊处理，因此各种数据库需要扩展 StdJDBCDelegate 以实现这些特殊处理。Quartz 已经自带了一些数据库的扩展实现，可以直接使用。

## quartz启动流程

若quartz是配置在spring中，当服务器启动时，就会装载相关的bean。SchedulerFactoryBean实现了InitializingBean接口，因此在初始化bean的时候，会执行afterPropertiesSet方法，该方法将会调用SchedulerFactory(DirectSchedulerFactory 或者 StdSchedulerFactory，通常用StdSchedulerFactory)创建Scheduler。SchedulerFactory在创建quartzScheduler的过程中，将会读取配置参数，初始化各个组件，关键组件如下：
- ThreadPool
一般是使用SimpleThreadPool,SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。在SimpleThreadPool中有三个list：workers-存放池中所有的线程引用，availWorkers-存放所有空闲的线程，busyWorkers-存放所有工作中的线程；
线程池的配置参数如下所示：
```properties
org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount=3
org.quartz.threadPool.threadPriority=5
```
- JobStore
分为存储在内存的RAMJobStore和存储在数据库的JobStoreSupport(包括JobStoreTX和JobStoreCMT两种实现，JobStoreCMT是依赖于容器来进行事务的管理，而JobStoreTX是自己管理事务），若要使用集群要使用JobStoreSupport的方式
- QuartzSchedulerThread
用来进行任务调度的线程，在初始化的时候paused=true,halted=false,虽然线程开始运行了，但是paused=true，线程会一直等待，直到start方法将paused置为false
另外，SchedulerFactoryBean还实现了SmartLifeCycle接口，因此初始化完成后，会执行start()方法，该方法将主要会执行以下的几个动作：
- 创建ClusterManager线程并启动线程:该线程用来进行集群故障检测和处理，将在下文详细讨论；
- 创建MisfireHandler线程并启动线程:该线程用来进行misfire任务的处理，将在下文详细讨论；
- 置QuartzSchedulerThread的paused=false，调度线程才真正开始调度；

## SpringBoot + Quartz

### Maven依赖
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
</dependency>
```
### 数据库脚本
```text

```
在Quartz包下docs/dbTables，选择对应的数据库脚本，创建相应的数据库表即可，我用的是mysql5.6，这里有一个需要注意的地方，mysql5.5之前用的表存储引擎是MyISAM，使用的是表级锁，锁发生冲突的概率比较高，并发度低；5.6之后默认的存储引擎为InnoDB,InnoDB采用的锁机制是行级锁，并发度也较高。而quartz集群使用数据库锁的机制来来实现同一个任务在同一个时刻只被实例执行，所以为了防止冲突，我们建表的时候要选取InnoDB作为表的存储引擎。

### 创建一个 job 并继承 QuartzJobBean
```java
package com.quartz;

import lombok.extern.slf4j.Slf4j;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.JobKey;
import org.springframework.scheduling.quartz.QuartzJobBean;


@Slf4j
public class HelloWorldJob extends QuartzJobBean {
    @Override
    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        JobKey key = jobExecutionContext.getJobDetail().getKey();
        log.info("[JobKey] name:{},group:{}",key.getName(),key.getGroup());
        JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap();
        log.info("[jobDataMap] arg1:{},arg2:{}",jobDataMap.get("arg1"),jobDataMap.get("arg2"));


    }
}
```

### 创建 JobDetail 和 Trigger
```java
package com.quartz.config;

import com.quartz.HelloWorldJob;
import org.quartz.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class QuartzConfig {

    @Bean
    public JobDetail myJobDetail() {
        return JobBuilder.newJob(HelloWorldJob.class)
                .withIdentity("HelloWorldJob", "HelloWorldJob")
                //JobDataMap可以给任务execute传递参数
                .usingJobData("arg1", "Hello")
                .usingJobData("arg2", "World")
                .storeDurably()
                .build();
    }

    @Bean
    public Trigger myTrigger() {
        return TriggerBuilder.newTrigger()
                .forJob(myJobDetail())
                .withIdentity("Hello World Job TRIGGER", "TRIGGER GROUP1")
                .usingJobData("arg11","TRIGGER-arg11")
                .usingJobData("arg1","TRIGGER-arg1")
                .startNow()
                //.withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(5).repeatForever())
                .withSchedule(CronScheduleBuilder.cronSchedule("0/10 * * * * ?"))
                .build();
    }

}
```

## 配置 application.yml
```yaml
spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/yang?useSSL=false&useUnicode=true&characterEncoding=utf-8
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
  quartz:
    jdbc:
#      这里有 三个选项 always（每次都帮你创建表） never(自己手动建表) embedded 初始化表结构时,使用 embedded(内嵌的) 会去 看看db的类型是不是内嵌型的数据库或者说是内存型的 如常见的: h2
      initialize-schema: always
    #持久化到数据库方式
    job-store-type: jdbc
    properties:
      org:
        quartz:
          scheduler:
            instanceName: MysqlScheduler
            instanceId: AUTO
            startupDelay: 10
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: QRTZ_
            isClustered: true
            clusterCheckinInterval: 10000
            useProperties: false
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            #线程数 一个任务使用一个线程
            threadCount: 10
            threadPriority: 5
            threadsInheritContextClassLoaderOfInitializingThread: true
```









