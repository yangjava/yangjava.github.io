---
layout: post
categories: [JUC]
description: none
keywords: JUC
---
# 临时










## 线程的start方法剖析
分析Thread的start方法，在调用了start方法之后到底进行了什么操作?
先来看一下Thread start方法的源码，如下所示：
```
public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        }
    }
}
```
start方法的源码足够简单，其实最核心的部分是start0这个本地方法，也就是JNI方法：
```
private native void start0();
```
也就是说在start方法中会调用start0方法，那么重写的那个run方法何时被调用了呢？单从上面是看不出来任何端倪的，但是打开JDK的官方文档，在start方法中有如下的注释说明：
```
Causes this thread to begin execution; the Java Virtual Machine calls the <code>run</code> method of this thread.
```
上面这句话的意思是：在开始执行这个线程时，JVM将会调用该线程的run方法，换言之，run方法是被JNI方法start0（）调用的，仔细阅读start的源码将会总结出如下几个知识要点。
- Thread被构造后的NEW状态，事实上threadStatus这个内部属性为0。
- 不能两次启动Thread，否则就会出现IllegalThreadStateException异常。
- 线程启动后将会被加入到一个ThreadGroup中，后文中我们将详细介绍ThreadGroup。
- 一个线程生命周期结束，也就是到了TERMINATED状态，再次调用start方法是不允许的，也就是说TERMINATED状态是没有办法回到RUNNABLE/RUNNING状态的。
```java
Thread thread = new Thread()
{
    @Override
    public void run()
    {
        try
        {
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
};
thread.start();//启动线程

thread.start();//再次启动
```
执行上面的代码将会抛出IllegalThreadStateException异常，而我们将代码稍作改动，模拟一个线程生命周期的结束，再次启动看看会发生什么：
```java
Thread thread = new Thread()
{
    @Override
    public void run()
    {
        try
        {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
};
thread.start();
TimeUnit.SECONDS.sleep(2);//休眠主要是确保thread结束生命周期
thread.start();//企图重新激活该线程
```
程序同样会抛出IllegalThreadStateException异常，但是这两个异常的抛出却有本质上的区别，第一个是重复启动，只是第二次启动是不允许的，但是此时该线程是处于运行状态的，而第二次企图重新激活也抛出了非法状态的异常，但是此时没有线程，因为该线程的生命周期已经被终结。

## 模板设计模式在Thread中的应用
线程的真正的执行逻辑是在run方法中，通常我们会把run方法称为线程的执行单元，这也就回答了我们最开始提出的疑问，重写run方法，用start方法启动线程。Thread中run方法的代码如下，如果我们没有使用Runnable接口对其进行构造，则可以认为Thread的run方法本身就是一个空的实现：
```java
@Override
public void run() {
    if (target != null) {//我们并没有使用runnable构造Thread
        target.run();
    }
}
```
其实Thread的run和start就是一个比较典型的模板设计模式，父类编写算法结构代码，子类实现逻辑细节。

## 深入理解Thread构造函数
Java中的Thread为我们提供了比较丰富的构造函数。

### 线程的命名
在构造线程的时候可以为线程起一个有特殊意义的名字，这也是比较好的一种做法，尤其在一个线程比较多的程序中，为线程赋予一个包含特殊意义的名字有助于问题的排查和线程的跟踪。

### 线程的默认命名
下面的几个构造函数中，并没有提供为线程命名的参数，那么此时线程会有一个怎样的命名呢？
- Thread（）
- Thread（Runnable target）
- Thread（ThreadGroup group，Runnable target）
  打开JDK的源码会看到下面的代码：
```java
public Thread(Runnable target) {
    init(null, target, "Thread-" + nextThreadNum(), 0);
}
/* For autonumbering anonymous threads. */
private static int threadInitNumber;
private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}
```
如果没有为线程显式地指定一个名字，那么线程将会以“Thread-”作为前缀与一个自增数字进行组合，这个自增数字在整个JVM进程中将会不断自增：
```java
public static void main(String[] args)
{
    IntStream.range(0, 5).boxed().map(i -> new Thread(
    () -> System.out.println(Thread.currentThread().getName()))
     ).forEach(Thread::start);
 }
```
执行上面的代码，这里使用无参的构造函数创建了5个线程，并且分别输出了各自的名字，会发现输出结果与我们对源码的分析是一致的，输出如下：
```java
Thread-0
Thread-2
Thread-1
Thread-4
Thread-3
```

### 命名线程
在构造Thread的时候，为线程赋予一个特殊的名字是一种比较好的实战方式，Thread同样也提供了这样的构造函数，具体如下。
- Thread（Runnable target，String name）
- Thread（String name）
- Thread（ThreadGroup group，Runnable target，String name）
- Thread（ThreadGroup group，Runnable target，String name，long stackSize）
- Thread（ThreadGroup group，String name）
  示例代码如下：
```java
private final static String PREFIX = "ALEX-";
public static void main(String[] args)
{
IntStream.range(0,5).mapToObj(ThreadConstruction::createThread)
            .forEach(Thread::start);
}
private static Thread createThread(final int intName)
{
    return new Thread(
        () -> System.out.println(Thread.currentThread().getName())
            , PREFIX + intName);
}
```
在上面的代码中，我们定义了一个新的前缀“ALEX-”，然后用0～4之间的数字作为后缀对线程进行了命名，代码执行输出的结果如下所示：
```java
ALEX-0
ALEX-1
ALEX-2
ALEX-3
ALEX-4
```

### 修改线程的名字
不论你使用的是默认的函数命名规则，还是指定了一个特殊的名字，在线程启动之前还有一个机会可以对其进行修改，一旦线程启动，名字将不再被修改，下面是Thread的setName源码：
```java
public final synchronized void setName(String name) {
    checkAccess();
    this.name = name.toCharArray();
    if (threadStatus != 0) { //线程不是NEW状态，对其的修改将不会生效
        setNativeName(name);
    }
}
```

### 线程的父子关系
Thread的所有构造函数，最终都会去调用一个静态方法init，我们截取片段代码对其进行分析，不难发现新创建的任何一个线程都会有一个父线程：
```java
private void init(ThreadGroup g, Runnable target, String name,
                long stackSize, AccessControlContext acc) {
    if (name == null) {
        throw new NullPointerException("name cannot be null");
    }
    this.name = name.toCharArray();
    Thread parent = currentThread(); //获取当前线程作为父线程
    SecurityManager security = System.getSecurityManager();
```
上面代码中的currentThread（）是获取当前线程，在线程生命周期中，我们说过线程的最初状态为NEW，没有执行start方法之前，它只能算是一个Thread的实例，并不意味着一个新的线程被创建，因此currentThread（）代表的将会是创建它的那个线程，因此我们可以得出以下结论。
- 一个线程的创建肯定是由另一个线程完成的。
- 被创建线程的父线程是创建它的线程。
  我们都知道main函数所在的线程是由JVM创建的，也就是main线程，那就意味着我们前面创建的所有线程，其父线程都是main线程。

### Thread与ThreadGroup
在Thread的构造函数中，可以显式地指定线程的Group，也就是ThreadGroup
接着往下阅读Thread init方法的源码：
```java
SecurityManager security = System.getSecurityManager();
if (g == null) {
    /* Determine if it's an applet or not */
    /* If there is a security manager, ask the security manager
        what to do. */
    if (security != null) {
        g = security.getThreadGroup();
    }
    /* If the security doesn't have a strong opinion of the matter
        use the parent thread group. */
    if (g == null) {
        g = parent.getThreadGroup();
    }
}
```
通过对源码进行分析，我们可以看出，如果在构造Thread的时候没有显示地指定一个ThreadGroup，那么子线程将会被加入父线程所在的线程组，下面写一个简单的代码来测试一下
```java
public class ThreadConstruction
{
    public static void main(String[] args)
    {
        //①
        Thread t1 = new Thread("t1");

        //②
        ThreadGroup group = new ThreadGroup("TestGroup");
        //③
        Thread t2 = new Thread(group, "t2");
        ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();
        System.out.println("Main thread belong group:" + mainThreadGroup.getName());
        System.out.println("t1 and main belong the same group:" + (mainThreadGroup == t1.getThreadGroup()));
        System.out.println("t2 thread group not belong main group:" + (mainThreadGroup == t2.getThreadGroup()));
        System.out.println("t2 thread group belong main TestGroup:" + (group == t2.getThreadGroup()));

    }
}
```
注释①创建了一个Thread t1，注释②创建了一个ThreadGroup，注释③创建了一个Thread t2，并且将它加入到了group中，我们并没有给t1指定任何Group，执行上面的代码，输出结果为：
```java
Main thread belong group:main
t1 and main belong the same group:true
t2 thread group not belong main group:false
t2 thread group belong main TestGroup:true
```
通过对Thread源码的分析和我们自己的测试可以得出以下结论。
- main线程所在的ThreadGroup称为main。
- 构造一个线程的时候如果没有显式地指定ThreadGroup，那么它将会和父线程同属于一个ThreadGroup。

在默认设置中，当然除了子线程会和父线程同属于一个Group之外，它还会和父线程拥有同样的优先级，同样的daemon。

### Thread与JVM虚拟机栈
在Thread的构造函数中，可发现有一个特殊的参数stackSize，这个参数的作用是什么呢？它的值对线程有什么影响呢？下面我们就来一起探讨这个问题。

打开JDK官方文档，将会发现Thread中对stacksize构造函数的文字说明，具体如下：
```
※The stack size is the approximate number of bytes of address space that the virtual machine is to allocate for this thread’s stack.The effect of the stackSize parameter，if any，is highly platform dependent.

On some platforms，specifying a higher value for the stackSize parameter may allow a thread to achieve greater recursion depth before throwing a StackOverflowError.Similarly，specifying a lower value may allow a greater number of threads to exist concurrently without throwing an OutOfMemoryError（or other internal error）.The details of the relationship between the value of the stackSize parameter and the maximum recursion depth and concurrency level are platform-dependent.On some platforms，the value of the stackSize parameter may have no effect whatsoever.
```
一般情况下，创建线程的时候不会手动指定栈内存的地址空间字节数组，统一通过xss参数进行设置即可，通过上面这段官网文档的描述，我们不难发现stacksize越大则代表着正在线程内方法调用递归的深度就越深，stacksize越小则代表着创建的线程数量越多，当然了这个参数对平台的依赖性比较高，比如不同的操作系统、不同的硬件。

在有些平台下，越高的stack设定，可以允许的递归深度越多；反之，越少的stack设定，则递归深度越浅。当然在某些平台下，该参数压根不会起到任何作用，如果将该参数设置为0，也不会起到任何的作用。

## 守护线程
守护线程是一类比较特殊的线程，一般用于处理一些后台的工作，比如JDK的垃圾回收线程，什么是守护线程？为什么要有守护线程，以及何时需要守护线程？

要回答关于守护线程的问题，就必须先搞清楚另外一个特别重要的问题：JVM程序在什么情况下会退出？
```
※The Java Virtual Machine exits when the only threads running are all daemon threads.
```
上面这句话来自于JDK的官方文档，当然这句话指的是正常退出的情况，而不是调用了System.exit（）方法，通过这句话的描述，我们不难发现，在正常情况下，若JVM中没有一个非守护线程，则JVM的进程会退出。

### 什么是守护线程
我们先通过一个简单的程序，来认识一下守护线程和守护线程的特点：
```java
public class DaemonThread
{
    public static void main(String[] args) throws InterruptedException
    {
    //① main线程开始
        Thread thread = new Thread(() ->
        {
            while (true)
            {
                try
                {
                    Thread.sleep(1);
                } catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
        });
        //thread.setDaemon(true); //②将thread设置为守护线程

        thread.start();  //③ 启动thread线程
        Thread.sleep(2_000L);
        System.out.println("Main thread finished lifecycle.");
        //④ main线程结束
    }
}
```
上面的代码中存在两个线程，一个是由JVM启动的main线程，另外一个则是我们自己创建的线程thread，运行上面的这段代码，你会发现JVM进程永远不会退出，即使main线程正常地结束了自己的生命周期（main线程的生命周期是从注释①到注释④之间的那段代码），原因就是因为在JVM进程中还存在一个非守护线程在运行。

如果打开注释②，也就是通过setDaemon方法将thread设置为了守护线程，那么main进程结束生命周期后，JVM也会随之退出运行，当然thread线程也会结束。

设置守护线程的方法很简单，调用setDaemon方法即可，true代表守护线程，false代表正常线程。

线程是否为守护线程和它的父线程有很大的关系，如果父线程是正常线程，则子线程也是正常线程，反之亦然，如果你想要修改它的特性则可以借助setDaemon方法。

isDaemon方法可以判断该线程是不是守护线程。

另外需要注意的就是，setDaemon方法只在线程启动之前才能生效，如果一个线程已经死亡，那么再设置setDaemon则会抛出IllegalThreadStateException异常。

## 守护线程的作用
在了解了什么是守护线程，以及如何创建守护线程之后，我们来讨论一下为什么要有守护线程以及何时使用守护线程。

通过上面的分析，如果一个JVM进程中没有一个非守护线程，那么JVM会退出，也就是说守护线程具备自动结束生命周期的特性，而非守护线程则不具备这个特点，试想一下如果JVM进程的垃圾回收线程是非守护线程，如果main线程完成了工作，则JVM无法退出，因为垃圾回收线程还在正常的工作。再比如有一个简单的游戏程序，其中有一个线程正在与服务器不断地交互以获取玩家最新的金币、武器信息，若希望在退出游戏客户端的时候，这些数据同步的工作也能够立即结束，等等。

守护线程经常用作与执行一些后台任务，因此有时它也被称为后台线程，当你希望关闭某些线程的时候，或者退出JVM进程的时候，一些线程能够自动关闭，此时就可以考虑用守护线程为你完成这样的工作。








## 线程的状态


在 Thread 类中，有一个枚举内部类：

```
    /**
     * A thread state.  A thread can be in one of the following states:
     * <ul>
     * <li>{@link #NEW}<br>
     *     A thread that has not yet started is in this state.
     *     </li>
     * <li>{@link #RUNNABLE}<br>
     *     A thread executing in the Java virtual machine is in this state.
     *     </li>
     * <li>{@link #BLOCKED}<br>
     *     A thread that is blocked waiting for a monitor lock
     *     is in this state.
     *     </li>
     * <li>{@link #WAITING}<br>
     *     A thread that is waiting indefinitely for another thread to
     *     perform a particular action is in this state.
     *     </li>
     * <li>{@link #TIMED_WAITING}<br>
     *     A thread that is waiting for another thread to perform an action
     *     for up to a specified waiting time is in this state.
     *     </li>
     * <li>{@link #TERMINATED}<br>
     *     A thread that has exited is in this state.
     *     </li>
     * </ul>
     *
     * <p>
     * A thread can be in only one state at a given point in time.
     * These states are virtual machine states which do not reflect
     * any operating system thread states.
     *
     * @since   1.5
     * @see #getState
     */
    public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```

### 新建状态（**NEW**）

**使用 new 创建一个线程，仅仅只是在堆中分配了内存空间**

新建状态下，线程还没有调用 start()方法启动，只是存在一个线程对象而已

Thread t = new Thread();//这就是t线程的新建状态

### **可运行状态（Runnable）**

**新建状态调用 start() 方法，进入可运行状态。而这个又分成两种状态，ready 和 running，分别表示就绪状态和运行状态**

- 就绪状态（Ready）
  线程对象调用了 start() 方法，等待 JVM 的调度，（此时该线程并没有运行）
- 运行状态（Running）
  线程对象获得 JVM 调度，如果存在多个 CPU，那么运行多个线程并行运行

**注意：线程对象只能调用一次 start() 方法，否则报错：illegaThreadStateExecptiong**


### **阻塞状态（Blocked）**
**正在运行的线程因为某种原因放弃 CPU，暂时停止运行，就会进入阻塞状态。此时 JVM 不会给线程分配 CPU，知道线程重新进入就绪状态，才有机会转到 运行状态。**
　　注意：阻塞状态只能先进入就绪状态，不能直接进入运行状态

阻塞状态分为两种情况：

①、当线程 A 处于可运行状态中，试图获取同步锁时，却被 B 线程获取，此时 JVM 把当前 A 线程放入锁池中，A线程进入阻塞状态

②、当线程处于运行状态时，发出了 IO 请求，此时进入阻塞状态

1）等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。

2）同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态。

3）其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。


### ****无限期等待**（Waiting）**

**等待状态只能被其他线程唤醒，此时使用的是无参数的 wait() 方法**

①、当线程处于运行状态时，调用了 wait() 方法，此时 JVM 把该线程放入等待池中

等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。

| 进入方法                                   | 退出方法                             |
| ------------------------------------------ | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
| LockSupport.park() 方法                    | -                                    |

### ****限期等待**（Timed waiting）**

**调用了带参数的 wait（long time）或 sleep(long time) 方法**

无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

①、当线程处于运行状态时，调用 Object.wait(long time) 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述，此时 JVM 把该线程放入等待池中。

②、当前线程调用了 sleep(long time) 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。



睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。

| 进入方法                                       | 退出方法                                             |
|--------------------------------------------|--------------------------------------------------|
| Thread.sleep() 方法                          | 时间结束                                             |
| 设置了 Timeout 参数的 Object.wait() 方法        | 时间结束 / Object.notify() / Object.notifyAll()      |
| 设置了 Timeout 参数的 Thread.join() 方法        | 时间结束 / 被调用的线程执行完毕                          |
| LockSupport.parkNanos() 方法                 | -                                                |
| LockSupport.parkUntil() 方法                 | -                                                |

#### **终止状态（**Terminated**）**

**通常称为死亡状态，表示线程终止**

①、正常终止，执行完 run() 方法，正常结束

②、强制终止，如调用 stop() 方法或 destory() 方法

③、异常终止，执行过程中发生异常


## 线程组
从名字上来看，线程组就是给不同的线程设计不同的分组，并且在命名上也做区分，在 JDK 中，它的具体表现是 ThreadGroup 这个类，如下边的这段案例：
```java
public class ThreadGroupDemo {

    public static List<Thread> DbConnThread() {
        ThreadGroup dbConnThreadGroup = new ThreadGroup("数据库连接线程组");
        List<Thread> dbConnThreadList = new ArrayList<>();
        for (int i = 0; i < 2; i++) {
            Thread t = new Thread(dbConnThreadGroup, new Runnable() {
                @Override
                public void run() {
                    System.out.println("线程名: " + Thread.currentThread().getName()
                            + ", 所在线程组: " + Thread.currentThread().getThreadGroup().getName());
                }
            }, "db-conn-thread-" + i);
            dbConnThreadList.add(t);
        }
        return dbConnThreadList;
    }

    public static List<Thread> httpReqThread() {
        ThreadGroup httpReqThreadGroup = new ThreadGroup("第三方http请求线程组");
        List<Thread> httpReqThreadList = new ArrayList<>();
        for (int i = 0; i < 2; i++) {
            Thread t = new Thread(httpReqThreadGroup, new Runnable() {
                @Override
                public void run() {
                    System.out.println("线程名: " + Thread.currentThread().getName()
                            + ", 所在线程组: " + Thread.currentThread().getThreadGroup().getName());
                }
            }, "http-req-thread-" + i);
            httpReqThreadList.add(t);
        }
        return httpReqThreadList;
    }

    public static void startThread(List<Thread> threadList) {
        for (Thread thread : threadList) {
            thread.start();
        }
    }

    public static void main(String[] args) {
        List<Thread> dbConnThreadList = DbConnThread();
        List<Thread> httpReqThreadList = httpReqThread();
        startThread(dbConnThreadList);
        startThread(httpReqThreadList);
    }
}
```
运行这段程序，我们可以在控制台中看到每个线程都会有自己专属的名字和分组，这样可以方便我们后期对于线程的分类管理。
采用了线程组技术之后，对于多线程的管理方面会降低一定的复杂度。
例如：我们可以通过线程组快速定位到具体是哪个业务模块的线程出现了异常，然后进行快速修复。

又或者是针对不同的线程组进行线程监控，了解各个业务模块对于CPU的使用率。

可能有些细心的同学会发现，使用 ThreadGroup 的时候，需要将它注入到 Thread 类中，这类硬编码的操作比较繁琐，是否有什么合理的方式可以简化相关代码呢？

其实是有的，JDK的开发者在设计的时候还留下了一个叫做 ThreadFacotry 的类。下边让我们一同来了解下这个类的作用。

## 线程工厂

了解过设计模式中工厂模式的朋友，应该对 ThreadFacotry 不会太陌生，ThreadFactory 是 一个JDK 包中提供的线程工厂类，它的职责就是专门用于生产 Thread 对象。使用了 ThreadFactory 之后，可以帮助我们缩减一些生产线程的代码量，例如下边这个 SimpleThreadFactory 类：

```java
public class SimpleThreadFactory implements ThreadFactory {

    private final int maxThread;
    private final String threadGroupName;
    private final String threadNamePrefix;

    private final AtomicInteger count = new AtomicInteger(0);
    private final AtomicInteger threadSeq = new AtomicInteger(0);

    private final ThreadGroup threadGroup;


    public SimpleThreadFactory(int maxThread, String threadGroupName, String threadNamePrefix) {
        this.maxThread = maxThread;
        this.threadNamePrefix = threadNamePrefix;
        this.threadGroupName = threadGroupName;
        this.threadGroup = new ThreadGroup(threadGroupName);
    }


    @Override
    public Thread newThread(Runnable r) {
        int c = count.incrementAndGet();
        if (c > maxThread) {
            return null;
        }
        Thread t = new Thread(threadGroup, r, threadNamePrefix + threadSeq.getAndIncrement());
        t.setDaemon(false);
        //默认线程优先级
        t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        ThreadFactory threadFactory = new SimpleThreadFactory(10, "test-thread-group", "test-thread-");
        Thread t = threadFactory.newThread(new Runnable() {
            @Override
            public void run() {
                System.out.println("this is task");
                try {
                    countDownLatch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t.start();
        countDownLatch.await();
    }
}
```
可以看到 ThreadFactory 内部提供了 newThread 方法，这个方法的具体实现中封装了关于线程产生的具体细节，例如线程的分组、命名、优先级，以及是否是守护线程类型。

如果你细心阅读过线程池底层的源代码，那么你应该会发现，线程池在生产线程的时候，其实也是使用了ThreadFactory这个工厂类。 在 Jdk1.8 中的线程池中，定义了两套工厂类，分别是 DefaultThreadFactory 和 PrivilegedThreadFactory，它们其实本质功能都差不多，只不过 PrivilegedThreadFactory 具备了 AccessControlContext 和上下文的类加载器权限。

```java
/**
 * The default thread factory
 */
static class DefaultThreadFactory implements ThreadFactory {
    private static final AtomicInteger poolNumber = new AtomicInteger(1);
    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null) ? s.getThreadGroup() :
                              Thread.currentThread().getThreadGroup();
        namePrefix = "pool-" +
                      poolNumber.getAndIncrement() +
                     "-thread-";
    }

    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}

/**
 * Thread factory capturing access control context and class loader
 */
static class PrivilegedThreadFactory extends DefaultThreadFactory {
    private final AccessControlContext acc;
    private final ClassLoader ccl;

    PrivilegedThreadFactory() {
        super();
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            // Calls to getContextClassLoader from this class
            // never trigger a security check, but we check
            // whether our callers have this permission anyways.
            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);

            // Fail fast
            sm.checkPermission(new RuntimePermission("setContextClassLoader"));
        }
        this.acc = AccessController.getContext();
        this.ccl = Thread.currentThread().getContextClassLoader();
    }

    public Thread newThread(final Runnable r) {
        return super.newThread(new Runnable() {
            public void run() {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        Thread.currentThread().setContextClassLoader(ccl);
                        r.run();
                        return null;
                    }
                }, acc);
            }
        });
    }
}
```

好了，现在我们大概已经了解了该怎么去优雅地构建一个线程对象，以及如何去较好地管理多个线程，但是在实际工作中，线程还会有许多不同的应用场景，例如后台监控就是一类非常适合使用线程技术去完成的场景。

而 JDK 的开发者似乎也很早就预料到了这一点，所以他在设计 Thread 类的时候，还专门留下了一个叫做 daemon 的属性，这个属性主要是用于定义当前线程是否属于守护线程。

## 守护线程
守护线程其实是 JVM 中特殊定义的一类线程，这类线程通常都是以在后台单独运作的方式存在，常见的代表，例如 JVM 中的 Gc 回收线程，可以通过 Arthas 的 Thread 指令区查询这类线程
那么， 为什么需要守护线程呢 ？ 常规的线程也可以实现在后台执行的效果啊，下边我们来看一组实战代码案例：
```java
public class DaemonThreadDemo {

    public static void main(String[] args) throws InterruptedException {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> System.out.println("jvm exit success!! ")));

        Thread testThread = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(2000);
                    System.out.println("thread still running ....");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        testThread.start();
    }
}
```

在上边的守护线程代码案例中，我使用了一个 ShutdownHook的钩子函数，用于监听当前JVM是否退出。
可以看到，main 线程中构建了一个非守护线程 testThread，testThread 的内部一直在执行 while 循环，导致 main 线程迟迟都无法结束执行。而如果我们尝试将 testThread 设置为守护线程类型的话，结果就会发生变化：
```java
public class DaemonThreadDemo {

    public static void main(String[] args) throws InterruptedException {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> System.out.println("jvm exit success!! ")));

        Thread testThread = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(2000);
                    System.out.println("thread still running ....");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        testThread.setDaemon(true);
        testThread.start();
    }
}
```
通过上边的这个实验可以发现，守护线程具有在JVM退出的时候也自我销毁的特点，而非守护线程不具备这个特点，这也是为什么GC回收线程被设置为守护线程类型的主要原因。

守护线程通常会在一些后台任务中所使用，例如分布式锁中在即将出现超时前，需要进行续命操作的时候，就可以采用守护线程去实现。 Thread 类其实还具有很多其他的特点，例如异常捕获器就是其中之一。

## 线程的异常捕获器
在线程的内部，有一个叫做异常捕获器的概念，当线程在执行过程中产生了异常，就会回调到该接口，来看看下边的这个案例代码：
```java

public class ThreadExceptionCatchDemo {

    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("this is test");
                int i = 10/0;
            }
        });
        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            //这里是对Throwable对象进行监控，所以无论是error或者exception都能识别到
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                System.err.println("thread is "+t.getName());
                e.printStackTrace();
            }
        });
        thread.start();
    }
}
```
可以看到，当线程出现异常的时候，会回调到 UncaughtExceptionHandler 中，而异常回调器其实本身也是一个函数接口，当线程出现异常的时候，JVM 会默认携带线程信息和异常内容回调到这个接口中:
```java

@FunctionalInterface
public interface UncaughtExceptionHandler {
    /**
     * Method invoked when the given thread terminates due to the
     * given uncaught exception.
     * <p>Any exception thrown by this method will be ignored by the
     * Java Virtual Machine.
     * @param t the thread
     * @param e the exception
     */
    void uncaughtException(Thread t, Throwable e);
}
```
在 ThreadGroup 类中，其实就是对 UncaughtExceptionHandler 进行了单独的实现，所以每次当线程报错的时候才会有异常信息展示，这部分可以通过阅读 ThreadGroup 内部的源代码进行深入了解，下边我将这部分源代码粘出来给大家了解下：
```java
//Jdk1.8中对于线程异常堆栈打印逻辑的源代码
public void uncaughtException(Thread t, Throwable e) {
    if (parent != null) {
        parent.uncaughtException(t, e);
    } else {
        Thread.UncaughtExceptionHandler ueh =
            Thread.getDefaultUncaughtExceptionHandler();
        if (ueh != null) {
            ueh.uncaughtException(t, e);
        } else if (!(e instanceof ThreadDeath)) {
            System.err.print("Exception in thread \""
                             + t.getName() + "\" ");
            e.printStackTrace(System.err);
        }
    }
}
```
如果我们希望当线程运行过程中出现异常后做些上报功能，可以通过采用异常捕获器的思路来实现。

上边我们所学习的各种属性，都是 Thread 类内部比较有用的属性，但是除开这些属性之外，Thread 中还有一个很容易误导开发者的属性，它就是 priority。

## 线程优先级
在 Thread 的内部还有一个叫做优先级的参数，具体设置可以通过 setPriority 方法去修改。例如下边这段代码：
```java
public class ThreadPriorityDemo {

    static class InnerTask implements Runnable {

        private int i;

        public InnerTask(int i) {
            this.i = i;
        }

        public void run() {
            for(int j=0;j<10;j++){
                System.out.println("ThreadName is " + Thread.currentThread().getName()+" "+j);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new InnerTask(10),"task-1");
        t1.setPriority(1);
        Thread t2 = new Thread(new InnerTask(2),"task-2");
        //优先级只能作为一个参考数值，而且具体的线程优先级还和操作系统有关
        t2.setPriority(2);
        Thread t3 = new Thread(new InnerTask(3),"task-3");
        t3.setPriority(3);

        t1.start();
        t2.start();
        t3.start();
        Thread.sleep(2000);
    }
}
```
不过“优先级”这个参数通常并不是那么地“靠谱”，理论上说线程的优先级越高，分配到时间片的几率也就越高，但是在实际运行过程中却并非如此，优先级只能作为一个参考数值，而且具体的线程优先级还和操作系统有关， 所以大家在编码中如果使用到了“优先级”的设置，请不要强依赖于它。




