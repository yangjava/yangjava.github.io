---
layout: post
categories: [Spark]
description: none
keywords: Spark
---
# SparkSQL编译器
Hive、Presto和Spark SQL等大数据引擎的SQL编译模块也都是基于ANTLR构建的。

## SparkSqlParser之AstBuilder
回到SparkSQL，Catalyst中提供了直接面向用户的ParseInterface接口，该接口中包含了对SQL语句、Expression表达式和TableIdentifier数据表标识符的解析方法。AbstractSqlParser是实现了ParseInterface的虚类，其中定义了返回AstBuilder的函数。

整个SQL解析相关的实现，其中CatalystSqlParser仅用于Catalyst内部，而SparkSqlParser用于外部调用。其中，比较核心的是AstBuilder，它继承了ANTLR4生成的默认SqlBaseBaseVisitor，用于生成SQL对应的抽象语法树AST（UnresolvedLogicalPlan）；SparkSqlAst-Builder继承AstBuilder，并在其基础上定义了一些DDL语句的访问操作，主要在SparkSqlParser中调用。

当面临开发新的语法支持时，首先需要改动的是ANTLR4文件（在SqlBase.g4中添加文法），重新生成词法分析器（SqlBaseLexer）、语法分析器（SqlBaseParser）和访问者类（SqlBaseVisitor接口与SqlBaseBaseVisitor类），然后在AstBuilder等类中添加相应的访问逻辑，最后添加执行逻辑。

为加深理解Spark SQL生成的语法树结构，读者可以将Spark SQL编译器部分剥离出来，构造一个类似AstBuilder的访问者类MyVisitor，在实现的访问方法中输出visitor访问操作。

类似于下面的代码逻辑，实现SqlBaseBaseVisitor中的所有方法。
```
```
需要注意的是，上述代码中的访问操作顺序统一为先序遍历。而AstBuilder中的操作则遵循后序遍历方式（首先会生成子节点的LogicalPlan，然后生成当前节点的LogicalPlan）。AstBuilder左右子节点的访问顺序也不固定，读者可以对上述代码中的节点访问顺序进行相应调整。

MyVisitor中访问方法的类型为String（AstBuilder中的SqlBaseBaseVisitor为AnyRef类型，返回LogicalPlan类型），但不会返回字符串，仅用于输出访问的路径和对AST的理解。构造上述访问者类之后，接下来还需要构造一个Driver程序来驱动上述访问过程。

ParserDriver的代码如下。
```java

```

## 常见SQL生成的抽象语法树概览
本节将常用的一些查询语句可视化，帮助读者对SQL编译器进行理解。在Catalyst中，SQL语句经过解析，生成的抽象语法树节点都以Context结尾来命名。

从语法树可以看到，SingleStatementContext是根节点，但是在访问该节点时一般什么都不做，只递归访问子节点。整个遍历访问操作中比较重要的是包含多个子节点的节点。例如QuerySpecificationContext节点，一般将数据表和具体的查询表达式整合在一起。左边的一系列节点对应select表达式中选择的列，中间的From ClauseContext为根节点的系列节点对应数据表，右边的一系列节点则对应where条件中的表达式。




























