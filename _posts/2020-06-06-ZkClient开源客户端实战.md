---
layout: post
categories: Zookeeper
description: none
keywords: Zookeeper
---
# Zkclient开源客户端实战
ZkClient是Github上一个开源的zookeeper客户端，在Zookeeper原生API接口之上进行了包装，是一个更易用的Zookeeper客户端，同时，zkClient在内部还实现了诸如Session超时重连、Watcher反复注册等功能

### Maven依赖

```
        <dependency>
            <groupId>com.101tec</groupId>
            <artifactId>zkclient</artifactId>
            <version>0.2</version>
            <exclusions>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-log4j12</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-api</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
```

### zclient使用案例

```
package com.zookeeper;

import lombok.extern.slf4j.Slf4j;
import org.I0Itec.zkclient.ZkClient;
import org.I0Itec.zkclient.ZkConnection;

/**
 * ZkClient是在Zookeeper原声API接口之上进行了包装，
 * 是一个更易用的Zookeeper客户端，其
 * 内部还实现了诸如Session超时重连、
 * Watcher反复注册等功能。
 */
@Slf4j
public class ZkClientDemo {

    private static String connectString = "127.0.0.1:2181";
    private static int sessionTimeout = 50 * 1000;

    public static void main(String[] args) {
        ZkClientDemo zkClientDemo = new ZkClientDemo();
        ZkClient zkClient = zkClientDemo.connectionZooKeeper();
//        zclietDemo.createZnode(zkClient,"/user1","lisi");
        String znodeData = zkClientDemo.getZnodeData(zkClient, "/user1");
        log.info("znodeData:{}", znodeData);
    }

    /**
     * 使用ZkClient可以轻松的创建会话，连接到服务端。
     *
     * @param zkServers
     * @param connectionTimeout
     * @return
     */
    public ZkClient getZkClient(String zkServers, int connectionTimeout) {
        return new ZkClient(zkServers, connectionTimeout);
    }

    /**
     * ZkClient提供了递归创建节点的接口，
     * 即其帮助开发者完成父节点的创建，再创建子节点。
     * 结果表明已经成功创建了节点，
     * <p>
     * 值得注意的是，在原生态接口中是无法创建成功的（父节点不存在），
     * 但是通过ZkClient可以递归的先创建父节点，再创建子节点。
     *
     * @param zkClient
     * @param path
     */
    public void createPersistent(ZkClient zkClient, String path) {
        zkClient.createPersistent(path);
    }

    /**
     * ZkClient提供了递归删除节点的接口，
     * 即其帮助开发者先删除所有子节点（存在），再删除父节点。
     *
     * @param zkClient
     * @param path
     */
    public void deleteRecursive(ZkClient zkClient, String path) {
        zkClient.deleteRecursive(path);
    }


    public ZkClient connectionZooKeeper() {
        ZkClient zkClient = new ZkClient(new ZkConnection(connectString), sessionTimeout);
//        //对父节点添加监听子节点变化。
//        zkClient.subscribeChildChanges("", new IZkChildListener() {
//            @Override
//            public void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {
//               // 操作
//            }
//        });
        return zkClient;
    }

    public void createZnode(ZkClient zkClient, String path, Object data) {
        zkClient.createPersistent(path, data);
    }


    public String getZnodeData(ZkClient zkClient, String path) {
        return zkClient.readData(path);
    }


    public boolean isExitZKPath(ZkClient zkClient, String path) {
        return zkClient.exists(path);
    }
}
```