---
layout: post
categories: Assembly
description: none
keywords: Assembly
---
# 汇编语言存储器管理
Intel公司的80X86系列的CPU基本上采用内存分段的管理模式。它把内存和程序分成若干个段，每个段的起点用一个段寄存器来记忆，所以，学习微机汇编语言，必须要清楚地理解存储器的分段含义、存储单元的逻辑地址和其物理地址之间的转换关系。

## 16位微机的内存管理模式
### 存储器的分段
我们知道：计算机的内存单元是以“字节”为最小单位进行线性编址的。为了标识每个存储单元，就给每个存储单元规定一个编号，此编号就是该存储单元的物理地址。

存储单元的物理地址是一个无符号的二进制数。但为了书写的简化，物理地址通常用十六进制来表示。

16位CPU内部有20根地址线，其编码区间为：00000H~0FFFFFH，所以，它可直接访问的物理空间为1M(220)字节。而16位CPU内部存放存储单元偏移量的寄存器（如：IP、SP、BP、SI、DI和BX等）都是16位，它们的编码范围仅为：00000H~0FFFFH。这样，如果用16位寄存器来访问内存的话，则只能访问内存的最低端的64K，其它的内存将无法访问。为了能用16位寄存器来有效地访问1M的存储空间，16位CPU采用了内存分段的管理模式，并引用段寄存器的概念。

16位微机把内存空间划分成若干个逻辑段，每个逻辑段的要求如下：
- 逻辑段的起始地址(通常简称为：段地址)必须是16的倍数，即最低4位二进制必须全为0；
- 逻辑段的最大容量为64K，这由16位寄存器的寻址空间所决定。

按上述规定，1M内存最多可分成64K个段，即65536个段(段之间相互重叠)，至少可分成16个相互不重叠的段。

这种存储器分段的内存管理方法不仅实现了用两个16位寄存器来访问1M的内存空间，而且对程序的重定位、浮动地址的编码和提高内存的利用率等方面都具有重要的实用价值。 

### 物理地址的形成方式
由于规定段地址必须是16的倍数，所以，其值的一般形式为：XXXX0H，即：前16位二进制位是变化的，后四位是固定为0。鉴于段地址的这种特性，我们可以仅保存其前16位二进制来达到保存整个段地址，其后四位可通过“左移补0”来获得。

在确定了某个存储单元所属的内存段后，我们也只知道其所处内存位置的范围，还不能确定其具体位置。要想确定内存单元的具体位置，还必须知道该单元离该段地址有多远。我们通常把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也可称为有效地址(EA—Effective Address)或偏移量(Offset)等。有了段地址和偏移量，就能唯一地确定某一内存单元在存储器内的具体位置。

由此可见，存储单元的逻辑地址分为两部分：段地址和偏移量。由逻辑地址得到其物理地址(PA—Physical Address)的计算方法如下：
```text
物理地址PA=段地址×16 + 偏移量
```
对物理地址来说，当段地址变化时，只要对其偏移量进行相应的调整就可对应同一个物理地址，所以，同一个物理地址可有多个逻辑地址。

在汇编语言程序中，存储单元通常不是用其物理地址标识的，而是用其逻辑地址标识的。逻辑地址的段地址由段寄存器给出，偏移量可由寄存器(SI、DI、BP和BX等)给出，也可用符号地址或具体的数值给出。

### 段寄存器的引用
段寄存器是因为对内存的分段管理而设置的。16位CPU有四个段寄存器，所以，其程序可同时访问四个不同含义的段。

段寄存器CS指向存放程序的内存段，IP是用来存放下条待执行的指令在该段的偏移量，把它们合在一起可在该内存段内取到下次要执行的指令。

段寄存器SS指向用于堆栈的内存段，SP是用来指向该堆栈的栈顶，把它们合在一起可访问栈顶单元。另外，当偏移量用到了指针寄存器BP，则其缺省的段寄存器也是SS，并且用BP可访问整个堆栈，不仅仅是只访问栈顶。

段寄存器DS指向数据段，ES指向附加段，在存取操作数时，二者之一和一个偏移量合并就可得到存储单元的物理地址。该偏移量可以是具体数值、符号地址和指针寄存器的值等之一，具体情况将由指令的寻址方式来决定。

通常，缺省的数据段寄存器是DS，只有一个例外，即：在进行串操作时，其目的地址的段寄存器规定为ES。

16位CPU在段寄存器的引用方面有如下规定：
- 取指令所用的段寄存器和偏移量一定是用CS和IP；
- 堆栈操作所用的段寄存器和偏移量一定是SS和SP；
- 串操作的目标操作数所用的段寄存器和偏移量一定是ES和DI；
- 其它情况，段寄存器除了其默认引用的寄存器外，还可以强行改变为其它段寄存器。
 
### 存储单元的内容
存储单元中所存放的二进制信息通常称为该存储单元的内容或值，并且规定：
- 一个字节的内容是该字节单元内存放的二进制信息；
- 一个字的内容是该字地址所指向的单元及其后继一个单元的内容拼接而成；
- 一个双字的内容是该字地址所指向的单元及其后继三个单元的内容拼接而成。
在拼接“字内容”时，我们按“高高低低”的原则来处理，即：高存储单元(地址大的存储单元)的值是“字内容”的高8位，低存储单元(地址小的存储单元)的值是“字内容”的低8位。在拼接“双字内容”时也是如此。

## 32位微机的内存管理模式 

32位微机的内存存管理仍然采用“分段”的管理模式，存储器的逻辑地址同样由段地址和偏移量两部分组成。32位微机的内存管理与16位微机的有相同之处，也有不同之处，因为它提供了两种不同工作方式：实方式和保护方式。
### 物理地址的计算方式
- 实方式：段地址仍然是16的倍数，每个段的最大容量仍为64K。段寄存器的值是段的起始地址，存储单元的物理地址仍为段寄存器的值乘16，再加上段内偏移量。在此方式下，32位微机的内存管理与16位微机是相一致的。
- 保护方式：段地址可以长达32位，其值可以不是16的倍数，每个段的最大容量可达4G。段寄存器的值是表示段地址的“选择器”(Selector)，用该“选择器”可从内存中得到一个32位的段地址，存储单元的物理地址就是该段地址加上段内偏移量，这与16位微机的物理地址计算完全不同。

### 段寄存器的引用
32位CPU内有6个段寄存器，程序在某一时刻可访问6个不同的段。其段寄存器的值在不同的方式下具有不同的含义：
- 在实方式下，段寄存器的值就是段地址；
- 在保护方式下，段寄存器的值不是段地址，是段地址的“选择器”。它间接指出一个32位的段地址。

下面分别说明各段寄存器的用法和作用。
- 代码段寄存器：32位微机在取指令时，系统自动引用CS和EIP来取出下条指令。在实方式下，由于段的最大容量不超过64K，所以，EIP的高16位全为0，其效果相当于16位CPU中的IP。
- 堆栈段寄存器：32位微机在访问堆栈段时，总是引用堆栈段寄存器SS。但在不同的方式下其堆栈指针有所不同：
- 在实方式下，32位微机把ESP的低16位SP作为指向堆栈的指针，所以，我们可以认为栈顶单元是由SS和SP来指定的。这就与16位微机访问栈顶单元的方法相一致；
- 在保护方式下，堆栈指针可用32位的ESP和16位的SP。

数据段寄存器：DS是主要的数据段寄存器。通常情况下，它是除访问堆栈以外数据时的默认段寄存器。在某些串操作中，其目的操作数的段寄存器被指定为ES是另一个例外。

另外，段寄存器CS、SS、ES、FS和GS也都可以作为访问数据时的段寄存器，但它们必须用段超越前缀的方式在指令中直接写出。用这种方式会增加指令的长度，指令的执行时间也有所延长。

一般来说，程序频繁访问的数据段用DS来指向，不太经常访问的数据段可用ES、FS和GS等来指向。

### 存储单元的内容

32位微机存储单元内容的存储格式与16位微机的完全一致，也都采用“高高低低”的原则来存放数据。





