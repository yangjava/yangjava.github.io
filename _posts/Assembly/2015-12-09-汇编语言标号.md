---
layout: post
categories: Assembly
description: none
keywords: Assembly
---
# 汇编语言标号

## 标号
标号是一种特殊的标识符，它代表代码段中的某个具体位置，它主要用于表明转移的目标位置。其说明形式如下：

标号:　　汇编语言指令　　　;注释

解释：标号必须是一个合法的标识符，在其后面紧跟一个冒号":"，冒号与汇编语言指令之间要有分隔符。通常用若干个空格、TAB来作分隔符，一般用分隔符使有关内容对齐为宜。

## 内存变量和标号的属性
变量是一个符号地质，其值会根据其数据类型来对应从该地址以后的若干个存储单元中所存的数值。标号也是一个符号地址，它所对应的存储单元中存放的是指令代码。虽然它们在某些性质上有所不同，但它们都是一个符号地址，代表一个存储单元的地址，所以，它们都具有存储单元的属性。除此之外，它们还有各自特殊的属性。

下面介绍内存变量和标号的属性及其有关操作符。

### 段属性操作符

段属性操作符(SEG)返回该标识符所在段的段地址。我们一般只会取内存变量所在段的段地址，而很少取标号所在段的段地址。

假设有下面变量定义：

…
SCORE　DW　?
NAME　 DB　10 DUP(10)  ;数据段的变量定义
…
MOV　AX, SEG SCORE ;代码段的指令
MOV　BX, SEG NAME

由于SCORE和NAME在同一段中定义，所以，寄存器AX和BX的值是相等的。

### 偏移量属性操作符

偏移量属性操作符(OFFSET)返回该标识符离它所在段的段地址有多少字节。一般情况，程序员只会取内存变量的偏移量，而不太关心标号的偏移量。

假设有下面变量定义：

FIRST　 DD　12345678H, 0  ;数据段的变量定义
SCORE　DW　?, 12H
NAME　 DB　10 DUP(10)
…
MOV　AX, OFFSET SCORE ;代码段的指令
MOV　BX, OFFSET NAME
…

假设FIRST是数据段的第一个被定义的变量名，它的偏移量为0，SCORE的偏移量为8，因为它要跳过二个双字，其它如此类推。

由于NAME在SCORE之后，且SCORE之后有二个字，占四个字节，所以，BX的值要比AX的值大4。

### 类型属性操作符

类型属性操作符(TYPE)是返回该变量所占字节数，或标号的“远”(FAR)、“近”(NEAR)类型。

例如：  PEASON STRUC
NO DD ?
NAME DB  10 dup (?)
DW  1
PEASOM ENDS
…
B1 DB 1, 2, 3
W1 DW 200 DUP(1,2,30 DUP(10,20)), 101H, -1
PEOPLE PEASON <>


按属性TYPE的含义，TYPE B1、TYPE W1和TYPE PEOPLE的值分别为：1，2和16。

### 长度属性操作符
长度属性操作符(LENGTH)是针对内存变量的操作符，它返回重复操作符DUP中的重复数。如果有嵌套的DUP，则只返回最外层的重复数；如果没有操作符DUP，则返回1。

如上例所示，根据属性LENGTH的含义，LENGTH B1、LENGTH W1和LENGTH PEOPLE的值分别为：1，200和1。

### 容量属性操作符
容量属性操作符(SIZE)也是针对内存变量的操作符。它的返回值按下列公式计算：

SIZE 变量 ＝ (LENGTH 变量) × (TYPE 变量)

如上例所示，SIZE B1、SIZE W1和SIZE PEOPLE的值分别为：1，400和16。

### 强制属性操作符
在程序中，我们有时需要对同一个存储单元以不同的属性来访问，或对一些不确定的存储属性需要显式指定等，这时，我们就需要强制属性操作符PTR。该操作符的作用有点象C语言中的类型强制方法。

对于指令：MOV [BX], 1H，其目标操作数[BX]是寄存器间接寻址方式，它指向一个存储单元。在作传送操作时，是把“1H”扩展成8位作字节传送，还是扩展成16位作字传送呢？这就使该指令具有二义性，因为[BX]指向的存储单元可以字节或字的首地址。含有该指令的程序在汇编时，可能会产生警告或出错信息。

为了使指令中存储单元操作数具有明确的属性，我们可以使用强制属性操作符PTR。其一般格式为：

数据类型　PTR　地址表达式

其中：数据类型是前面所学的各种数据类型，常用的数据类型有：BYTE、WORD、DWORD、NEAR和FAR等。

为了明确指令中存储单元的属性，可把指令“MOV [BX], 1H”可改写成：

MOV  byte ptr [BX], 1H 　　或　　MOV  word ptr [BX], 1H

在指令中用操作符PTR强制后，不管其后的地址表达式原数据类型是什么，在本指令中就以PTR前面的类型为准。该强制属性只在本指令有效，是一种临时性的属性，它不会改变原内存单元的定义属性。

例如：

W1 DW　1234H, 5678H
B1 DB　2
DB　5
D1 DD　23456789H
…
MOV AX, word ptr b1 ;把B1开始的二个字节拼接成一个字，执行后，(AX)=0502H
MOV BH, byte ptr w1  ;把字W1的低字节传送给BH，执行后，(BH)=34H
MOV CH, byte ptr w1+1 ;把字W1的高字节传送给CH，执行后，(CH)=12H
MOV word ptr d1, 12H  ;把双字D1的低字修改成0012H，执行后，(D1)=23450012H

上面指令中的强制属性是临时属性，它不能改变这些变量在定义时的永久属性。

### 存储单元别名操作符
由上一节的内容，我们知道：在程序中，如果需要以另一种数据类型来访问某一存储单元时，可用强制属性操作符PTR来实现。但如果在程序中要经常以某种其它的数据类型来访问该存储单元的话，那么，就必须在每次访问时都要加上强制属性操作符PTR。这样做虽然可行，但在编写程序时就显得比较麻烦。

为了克服上述不便，汇编语言提供了另一种操作符THIS，它为同一存储单元取另一别名，该别名可具有其自身的数据属性，但其段地址和偏移量是不变的。

操作符THIS的一般格式为：

THIS 数据类型

其中：数据类型是前面所学的各种数据类型，常用的数据类型有：BYTE、WORD、DWORD、NEAR和FAR等。

例如：

WBUFFER EQU THIS WORD ;EQU是一个等价符号定义语句，在后面有介绍
BUFFER DB 20 DUP(?)

这样就给同一片存储单元，取了二个具有不同数据类型的变量名。于是，在指令中，引用不同的变量名，就使用其不同的数据属性：

、如果引用变量名WBUFFER，则是按“字”属性来访问；
、如果引用变量名BUFFER，则是按“字节”属性来访问。

如此一来，指令“MOV　AX, word ptr BUFFER”和“MOV　AX, WBUFFER”是等效的，所不同的是：当以“字”属性访问BUFFER存储区时，不必使用强制属性符PTR，而改用“字”属性变量WBUFFER即可。




