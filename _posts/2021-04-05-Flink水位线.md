---
layout: post
categories: [Flink]
description: none
keywords: Flink
---
# Flink水位线

## Watermark（水位线）
Flink的三种时间语义中，只有Event Time需要设置Watermark 。流式数据从产生到处理中间经过了很多过程，中间因为网络等原因可能会出现乱序，导致Flink接收到的事件的先后顺序不是严格按照Event Time的先后顺序排了的。一旦出现乱序，如果只根据EventTime决定window的运行，不能明确数据是否全部到位，但又不能无限期的等下去，此时必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了，这个特别的机制，就是 Watermark。 Watermark本质上是Flink插入到数据流中的一种特殊的数据结构，它包含一个时间戳，并假设后续不会有小于该时间戳的数据 。

通常情况下，由于网络或系统等外部因素影响，事件数据往往不能及时传输至Flink系统中，导致数据乱序到达或者延迟到达等问题，因此，需要有一种机制能够控制数据处理的过程和进度，比如基于事件时间的Window创建后，具体该如何确定属于该Window的数据元素已经全部到达。如果确定全部到达，就可以对Window的所有数据做窗口计算操作（如汇总、分组等），如果数据没有全部到达，则继续等待该窗口中的数据全部到达才开始处理。这种情况下就需要用到水位线（WaterMarks）机制，它能够衡量数据处理进度（表达数据到达的完整性），保证事件数据（全部）到达Flink系统，或者在乱序及延迟到达时，也能够像预期一样计算出正确并且连续的结果。Flink会将用读取进入系统的最新事件时间减去固定的时间间隔作为Watermark，该时间间隔为用户外部配置的支持最大延迟到达的时间长度，也就是说理论上认为不会有事件超过该间隔到达，否则就认为是迟到事件或异常事件。

## 水位线的定义
在事件时间的语义下，不依赖系统时间，而是基于数据自带的时间戳去定义一个时钟，用来表示当前时间的进展。

在数据流中加入一个时钟标记，记录当前的事件时间，这个标记可以直接广播到下游，当下游任务收到这个标记，就可以更新自己的时钟了，这种类似于水流中用来做标志的记号，在Flink中被称为水位线

## watermark基本概念
在使用Event time时,我们需要思考一个问题，对于一个无限的数据流，窗口大小的情况下，如何确定窗口内的数据都已经全部都到了？例如，现在的窗口大小是1小时。对于有序的数据流而言，我们只需要判断数据的时间即可。08:01的数据一定是在08：02之前进入应用，当09:00的数据到达时，Flink就知道可以操作08:00~09:00的数据了。

但是在我们实际的应用环境中，大部分的数据流都是无序的，而且影响因素可能有很多。在这种情况下，8:58的数据可能是在9点之后才到的，这种情况下，我们的窗口操作又该在何时执行呢？

上面的问题总结一下就是：1. Flink如何确定窗口内的数据全部都到齐了？ 2. Flink如何对待数据流中迟到的数据？

为了解决上面的问题，需要用到Flink中的Watermark(时间水印)机制。Watermark能够衡量数据进度，确保数据在乱序情况下也能被正常处理，得出连续的结果。Watermark作为数据流中一部分随数据流入下游，当一个watermark(t)到达下游时就表示后面的数据时间都是迟于t。

在Flink中用户可以配置大延迟的时间间隔，Flink会用新的数据时间减去这个间隔来更新watermark。当watermark时间大于窗口结束时间，且窗口中有数据时，就会立刻触发窗口计算。例如，我们以30分钟做为大延迟间隔，窗口大小为1个小时，那么窗口时间就应该为(00:00-01:00),(02:00-03:00)...(23:00-00:00)。假设现在有一条03:31的数据进入应用,它减去半个小时就是03:01大于(02:00-03:00)的结束时间，那么就认为没有数据时间迟于03:00了，此时如果窗口内有数据就会立马触发窗口计算。这个计算需要通过延迟间隔和新的数据计算，判断是否已经超过了窗口允许的延迟时间。设置半个小时就意味着每个窗口的数据可以迟到半个小时。如果真的有数据超过了这个延迟时间，那我们就需要指定这类迟到数据的处理策略了。

### 顺序数据流中的watermark
在数据有序的情况下，10:00的数据到达时，我们就知道09:00~10:00的窗口可以操作了，因为不会有比10点还早的数据了，所有09:00~10:00窗口内的时间都已经到了。但是因为我们甚至了30分钟的watermark，10点减去半个小时为09:30小于窗口的结束时间，所以它会等，一直等到10：31数据来了之后，10:31减半个小时大于10:00。原本早就可以执行的计算现在多等了半个小时，所以在数据流有序的情况，并不能很好的发挥watermark的作用，反而会增加应用的延迟。

### 乱序数据流中的watermark
在实际环境中使用event time，我们也会遇到因为网络阻塞或者其他原因导致的无序数据流。在这种情况下watermark便可以保证窗口内的数据按照指定的窗口大小和延迟时间进行计算。值得注意的是，Flink的延迟时间是相对于event time而言的，不是根据系统时间来匹配的。就是说，如果我们设置的窗口大小为1个小时，延迟时间是10分钟。对于(09:00~10:00)的窗口而言，它不一定是会在系统时间超过10:10后计算，因为此刻不一定有时间戳大于10:10的数据到来。只有当watermark大于窗口结束时间时才会进行窗口操作，watermark一般都是根据event time计算的。

```
                                     09:00   ------  10:00 
[09:00] [10:09] [09:38] [10:01] |    [09:50]  [09:40] [09:01]    |
```
假设窗口大小为1小时，延迟时间设为10分钟。明显，数据09:38已经迟到，但它依然会被正确计算，只有当有数据时间大于10:10的数据到达之后（即对应的watermark大于10:10-10min) 09:00~10:00的窗口才会执行计算。

### 并行数据流中的watermark
对应并行度大于1的source task，它每个独立的subtask都会生成各自的watermark。这些watermark会随着流数据一起分发到下游算子，并覆盖掉之前的watermark。当有多个watermark同时到达下游算子的时候，flink会选择较小的watermark进行更新。当一个task的watermark大于窗口结束时间时，就会立马触发窗口操作。

## 水位线的生成
计算处理更快、实时性更强、计算准确性尽可能得到保障，我们就需要设置合理的水位线。

### 水位线生成策略
在Flink的DataStream API中，有一个单独用于生成水位线的方法：assignTimestampsAndWatermarks()，它主要用来为流中的数据分配时间戳，并生成水位线来指示事件时间：
```
public SingleOutputStreamOperator<T> assignTimestampsAndWatermarks(
         WatermarkStrategy<T> watermarkStrategy)
```
上述方法需要传入一个watermarkStrategy参数，这就是所谓的水位线生成策略
```java
public interface WatermarkStrategy<T> extends TimestampAssignerSupplier<T>,
	WatermarkGeneratorSupplier<T>{
 		@Override
 		TimestampAssigner<T> createTimestampAssigner(TimestampAssignerSupplier.Context context);
 		@Override
 		WatermarkGenerator<T> createWatermarkGenerator(WatermarkGeneratorSupplier.Context context);
}
```
- TimestampAssigner：主要负责从流中数据元素的某个字段中提取时间戳，并分配给元素。时间戳的分配是生成水位线的基础
- WatermarkGenerator：主要负责按照既定方式，基于时间戳生成水位线。在WatermarkGenerator接口中有两个方法：onEvent，onPeriodicEmit
- onEvent：每个事件（数据）到来都会调用的方法，它的参数有当前事件、时间戳，以及允许发出水位线的一个WatermarkOutput，可以基于事件做出各种操作
- onPeriodicEmit：周期性调用的方法，可以由WatermarkOutput发出水位线。周期时间为处理时间，可以调用环境配置的…setAutoWatermarkInterval()方法来设置，默认为200ms

```java
public interface WatermarkGenerator<T> {
    void onEvent(T event, long eventTimestamp, WatermarkOutput output);
    void onPeriodicEmit(WatermarkOutput output);
}
```

### Flink内置水位线生成器
WatermarkStrategy这个接口是一个生成水位线策略的抽象，让我们可以灵活地实现自己的需求，如果想要自己实现还是比较麻烦的。

Flink提供了内置的水位线生成器WatermarkGenerator，不仅开箱即用简化了编程，而且也为我们自定义水位线策略提供了模板。
- 固定延迟生成水印 forBoundedOutOfOrderness
- 单调递增生成水印 forMonotonousTimestamps

#### 固定延迟生成水印
通过静态方法forBoundedOutOfOrderness提供,入参接收一个Duration类型的时间间隔，也就是我们可以接受的最大的延迟时间.使用这种延迟策略的时候需要我们对数据的延迟时间有一个大概的预估判断。
```
WatermarkStrategy#forBoundedOutOfOrderness(Duration maxOutOfOrderness)
```
我们实现一个延迟3秒的固定延迟水印，可以这样做：
```
DataStream dataStream = ...... ;
dataStream.assignTimestampsAndWatermarks(WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(3)));
```
他的底层使用的WatermarkGenerator接口的一个实现类BoundedOutOfOrdernessWatermarks。
```
 @Override
 public void onEvent(T event, long eventTimestamp, WatermarkOutput output) {
  maxTimestamp = Math.max(maxTimestamp, eventTimestamp);
 }

 @Override
 public void onPeriodicEmit(WatermarkOutput output) {
  output.emitWatermark(new Watermark(maxTimestamp - outOfOrdernessMillis - 1));
 }
```

#### 单调递增生成水印
通过静态方法forMonotonousTimestamps来提供.
```
WatermarkStrategy.forMonotonousTimestamps()
```
这个也就是相当于上述的延迟策略去掉了延迟时间，以event中的时间戳充当了水印。

在程序中可以这样使用：
```
DataStream dataStream = ...... ;
dataStream.assignTimestampsAndWatermarks(WatermarkStrategy.forMonotonousTimestamps());
```
它的底层实现是AscendingTimestampsWatermarks，其实它就是BoundedOutOfOrdernessWatermarks类的一个子类，没有了延迟时间，我们来看看具体源码的实现.
```
@Public
public class AscendingTimestampsWatermarks<T> extends BoundedOutOfOrdernessWatermarks<T> {

 /**
  * Creates a new watermark generator with for ascending timestamps.
  */
 public AscendingTimestampsWatermarks() {
  super(Duration.ofMillis(0));
 }
}
```

这两个生成器可以通过调用WatermarkStrategy 的静态辅助方法来创建。它们都是周期性 生成水位线的，分别对应着处理有序流和乱序流的场景
```java
import com.demo.Source.Event;
import org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

import java.time.Duration;

public class WatermarkTest {

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.getConfig().setAutoWatermarkInterval(100);

        //从元素中读取数据
        SingleOutputStreamOperator<Event> stream = env.fromElements(
                new Event("Mary", "./home", 1000L),
                new Event("Bob", "./cart", 2000L),
                new Event("Alice", "./prod?id=100", 3000L),
                new Event("Bob", "./prod?id=1", 3300L),
                new Event("Bob", "./home", 3500L),
                new Event("Alice", "./prod?id=200", 3200L),
                new Event("Bob", "./prod?id=2", 3800L),
                new Event("Bob", "./prod?id=3", 4200L))
                //有序流的watermark生成
//                .assignTimestampsAndWatermarks(WatermarkStrategy
//                        .<Event>forMonotonousTimestamps()
//                        .withTimestampAssigner(new SerializableTimestampAssigner<Event>() {
//                            @Override
//                            public long extractTimestamp(Event element, long recordTimestamp) {
//                                return element.timestamp;
//                            }
//                        }))
                //乱序流的watermark生成
                .assignTimestampsAndWatermarks(WatermarkStrategy.<Event>forBoundedOutOfOrderness(Duration.ofSeconds(2))
                        .withTimestampAssigner(new SerializableTimestampAssigner<Event>() {
                            @Override
                            public long extractTimestamp(Event element, long recordTimestamp) {
                                return element.timestamp;
                            }
                        }));

        env.execute();
    }
}
```
事实上，有序流的水位线生成器本质上和乱序流式一样的，相当于延迟设为0的乱序流水位线生成器，两者完全相同：
```
WatermarkStrategy.forMonotonousTimestamps()
WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(0))
```
注意：乱序流中生成的水位线真正的时间戳，其实是当前最大时间戳 - 延迟时间 - 1，这里单位是毫秒。
```
public void onPeriodicEmit(WatermarkOutput output) {
 	output.emitWatermark(new Watermark(maxTimestamp - outOfOrdernessMillis - 1));
}
```

## 自定义水位线策略
一般来说，Flink内置的水位线生成器就可以满足应用需求了。不过有时我们得业务逻辑可能非常复杂，这就必须自定义实现水位线策略WatermarkStrategy。WatermarkGenerator接口中有两个方法：onEvent()、onPeriodicEmit()，前者是在每个时间到来时调用，后者由框架周期性调用。周期性调用的方法中发出水位线，自然就是周期性生成水位线；而在事件触发的方法中发出水位线，自然就是断点式生成了。两种方式的不同就集中体现在这两个方法的实现上

### 周期性水位线生成器
周期性生成器一般是通过onEvent()观察判断输入的事件，而在onPeriodicEmit()里发出水位线
```java
import com.yingzi.chapter05.Source.ClickSource;
import com.yingzi.chapter05.Source.Event;
import org.apache.flink.api.common.eventtime.*;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

public class CustomWatermarkTest {

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        env.addSource(new ClickSource())
                .assignTimestampsAndWatermarks(new CustomWatermarkStrategy()).print();

        env.execute();
    }

    public static class CustomWatermarkStrategy implements WatermarkStrategy<Event> {
        @Override
        public TimestampAssigner<Event> createTimestampAssigner(TimestampAssignerSupplier.Context context) {
            return new SerializableTimestampAssigner<Event>() {
                @Override
                public long extractTimestamp(Event element, long recordTimestamp) {
                    return element.timestamp; // 告诉程序数据源里的时间戳是哪一个字段
                }
            };
        }

        @Override
        public WatermarkGenerator<Event>
        createWatermarkGenerator(WatermarkGeneratorSupplier.Context context) {
            return new CustomPeriodicGenerator();
        }
    }

    public static class CustomPeriodicGenerator implements WatermarkGenerator<Event> {
        private Long delayTime = 5000L; // 延迟时间
        private Long maxTs = Long.MIN_VALUE + delayTime + 1L; // 观察到的最大时间戳

        @Override
        public void onEvent(Event event, long eventTimestamp, WatermarkOutput
                output) {
            // 每来一条数据就调用一次
            maxTs = Math.max(event.timestamp, maxTs); // 更新最大时间戳
        }

        @Override
        public void onPeriodicEmit(WatermarkOutput output) {
            // 发射水位线，默认 200ms 调用一次
            output.emitWatermark(new Watermark(maxTs - delayTime - 1L));
        }
    }
}
```

### 断点式水位线生成器
断点式生成器会不停地检测onEvent()中的事件，当发现带有水位线信息的特殊事件时，立即发出水位线。一般来说，断点式生成器不会通过onPeriodicEmit()发出水位线

```java
public class CustomPunctuatedGenerator implements WatermarkGenerator<Event> {
	@Override
 	public void onEvent(Event r, long eventTimestamp, WatermarkOutput output) {
	// 只有在遇到特定的 itemId 时，才发出水位线
 		if (r.user.equals("Mary")) {
 			output.emitWatermark(new Watermark(r.timestamp - 1));
 		}
 	}
     @Override
     public void onPeriodicEmit(WatermarkOutput output) {
     	// 不需要做任何事情，因为我们在 onEvent 方法中发射了水位线
     }
}
```
我们在 onEvent()中判断当前事件的 user 字段，只有遇到“Mary”这个特殊的值时，才调用 output.emitWatermark()发出水位线。这个过程是完全依靠事件来触发的，所以水位线的生成一 定在某个数据到来之后

## 在自定义数据源中发送水位线
我们也可以在自定义的数据源中抽取事件时间，然后发送水位线。这里要注意的是，在自 定义数据源中发送了水位线以后，就不能再在程序中使用 assignTimestampsAndWatermarks 方 法 来 生 成 水 位 线 了 。 在 自 定 义 数 据 源 中 生 成 水 位 线 和 在 程 序 中 使 用 assignTimestampsAndWatermarks 方法生成水位线二者只能取其一。

在自定义水位线中生成水位线相比 assignTimestampsAndWatermarks 方法更加灵活，可以 任意的产生周期性的、非周期性的水位线，以及水位线的大小也完全由我们自定义。所以非常 适合用来编写 Flink 的测试程序，测试 Flink 的各种各样的特性
```java
import com.demo.Source.Event;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.streaming.api.watermark.Watermark;

import java.util.Calendar;
import java.util.Random;

public class EmitWatermarkInSourceFunction {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        env.addSource(new ClickSourceWithWatermark()).print();
        env.execute();
    }

    // 泛型是数据源中的类型
    public static class ClickSourceWithWatermark implements SourceFunction<Event> {
        private boolean running = true;

        @Override
        public void run(SourceContext<Event> sourceContext) throws Exception {
            Random random = new Random();
            String[] userArr = {"Mary", "Bob", "Alice"};
            String[] urlArr = {"./home", "./cart", "./prod?id=1"};
            while (running) {
                long currTs = Calendar.getInstance().getTimeInMillis(); // 毫秒时间戳
                String username = userArr[random.nextInt(userArr.length)];
                String url = urlArr[random.nextInt(urlArr.length)];
                Event event = new Event(username, url, currTs);
                // 使用 collectWithTimestamp 方法将数据发送出去，并指明数据中的时间戳的字段
                sourceContext.collectWithTimestamp(event, event.timestamp);
                // 发送水位线
                sourceContext.emitWatermark(new Watermark(event.timestamp - 1L));
                Thread.sleep(1000L);
            }
        }

        @Override
        public void cancel() {
            running = false;
        }
    }
}
```
在实际应用中往往上下游都有多个并行子任务，为了统一推进事件时间的进展，我们要求上游任务处理完水位线、时钟改变之后，要把当前的水位线广播给所有的下游任务。这样，后续任务就不需要依赖原始数据中的时间戳，也可以知道当前事件时间了。

上游并行子任务发来不同的水位线，当前任务会为每一个分区设置一个“分区水位线” （Partition Watermark），这是一个分区时钟；而当前任务自己的时钟，就是所有分区时钟里最小的那个。

## event时间的获取
上述我们讲了flink自带的两种水印生成策略，但是对于我们使用eventtime语义的时候，我们想从我们的自己的数据中抽取eventtime，这个就需要TimestampAssigner了
```
@Public
@FunctionalInterface
public interface TimestampAssigner<T> {

    ............
    
 long extractTimestamp(T element, long recordTimestamp);
}
```
使用的时候我们主要就是从我们自己的元素element中提取我们想要的eventtime。

使用flink自带的水印策略和eventtime抽取类，可以这样用：
```
DataStream dataStream = ...... ;
dataStream.assignTimestampsAndWatermarks(
    WatermarkStrategy
      .<Tuple2<String,Long>>forBoundedOutOfOrderness(Duration.ofSeconds(5))
      .withTimestampAssigner((event, timestamp)->event.f1));
```

## 水位线的总结
水位线在事件时间的世界里面，承担了时钟的角色，是唯一的时间尺度。

水位线的默认计算公式：水位线 = 观察到的最大事件时间 – 最大延迟时间 – 1 毫秒

在数据流开始之前，Flink 会插入一个大小是负无穷大的水位线，而在数据流结束时，Flink 会插入一个正无穷大)的水位线，保证所有的窗口闭合以及所有的定时器都被触发。

对于离线数据集，Flink 也会将其作为流读入，也就是一条数据一条数据的读取。在这种 情况下，Flink 对于离线数据集，只会插入两次水位线，也就是在最开始处插入负无穷大的水 位线，在结束位置插入一个正无穷大的水位线。因为只需要插入两次水位线，就可以保证计算的正确，无需在数据流的中间插入水位线了



