---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL数据目录源码

## MySQL数据目录
MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储到这个目录下的某些文件中，这个目录就称为`数据目录`，我们下面就要详细唠唠这个目录下具体都有哪些重要的东西。

## 如何确定MySQL中的数据目录
那说了半天，到底`MySQL`把数据都存到哪个路径下呢？其实`数据目录`对应着一个系统变量`datadir`，我们在使用客户端与服务器建立连接之后查看这个系统变量的值就可以了：
```
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------------+
| Variable_name | Value                 |
+---------------+-----------------------+
| datadir       | /usr/local/var/mysql/ |
+---------------+-----------------------+
1 row in set (0.00 sec)
```
从结果中可以看出，在我的计算机上`MySQL`的数据目录就是`/usr/local/var/mysql/`，你用你的计算机试试呗～

## 数据库和文件系统的关系
查看默认数据库
查看一下在我的计算机上当前有哪些数据库：
```
mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| charset_demo_db    |
| dahaizi            |
| mysql              |
| performance_schema |
| sys                |
| xiaohaizi          |
+--------------------+
7 rows in set (0.00 sec)
```
可以看到有4个数据库是属于MySQL自带的系统数据库。
- mysql
MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。
- information_schema
MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为 元数据 。在系统数据库 information_schema 中提供了一些以innodb_sys 开头的表，用于表示内部系统表。
```
mysql> USE information_schema; 
Database changed 
mysql> SHOW TABLES LIKE 'innodb_sys%'; 
+--------------------------------------------+
| Tables_in_information_schema (innodb_sys%) |
+--------------------------------------------+
| INNODB_SYS_DATAFILES | 
| INNODB_SYS_VIRTUAL | 
| INNODB_SYS_INDEXES | 
| INNODB_SYS_TABLES |
| INNODB_SYS_FIELDS | 
| INNODB_SYS_TABLESPACES | 
| INNODB_SYS_FOREIGN_COLS |
| INNODB_SYS_COLUMNS |
| INNODB_SYS_FOREIGN | 
| INNODB_SYS_TABLESTATS |
+--------------------------------------------+
10 rows in set (0.00 sec)
```
- performance_schema
MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。
- sys
MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。

数据库在文件系统中的表示
看一下我的计算机上的数据目录下的内容：
```
.
├── auto.cnf
├── ca-key.pem
├── ca.pem
├── charset_demo_db
├── client-cert.pem
├── client-key.pem
├── dahaizi
├── ib_buffer_pool
├── ib_logfile0
├── ib_logfile1
├── ibdata1
├── ibtmp1
├── mysql
├── performance_schema
├── private_key.pem
├── public_key.pem
├── server-cert.pem
├── server-key.pem
├── sys
├── xiaohaizideMacBook-Pro.local.err
├── xiaohaizideMacBook-Pro.local.pid
└── xiaohaizi

6 directories, 16 files
```
这个数据目录下的文件和子目录比较多，除了 information_schema 这个系统数据库外，其他的数据库在 数据目录 下都有对应的子目录。

## 表在文件系统中的表示

### InnoDB存储引擎模式
- 表结构
为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 描述表结构的文 件 ，文件名是这样：表名.frm

比方说我们在 test1db数据库下创建一个名为 test 的表

那在数据库 test1db对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。.frm文件的格式在不同的平台上都是相同的。这个后缀名为.frm是以 二进制格式 存储的，我们直接打开是乱码的。

- 表中数据和索引

### 系统表空间（system tablespace）
默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自己增加文件大小。当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置文件：
```
[server] 
innodb_data_file_path=data1:512M;data2:512M:autoextend
```
### 独立表空间(file-per-table tablespace)
在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为 每 一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：表名.ibd

系统表空间与独立表空间的设置

我们可以自己指定使用 系统表空间 还是 独立表空间 来存储数据，这个功能由启动参数innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动MySQL服务器的时候这样配置：
```
[server] 
innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间
```
默认情况：
```
mysql> show variables like 'innodb_file_per_table'; 
+-----------------------+-------+
| Variable_name | Value | 
+-----------------------+-------+
| innodb_file_per_table | ON | 
+-----------------------+-------+
1 row in set (0.01 sec)

```
其他类型的表空间

随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。

## MyISAM存储引擎模式
表结构

在存储表结构方面， MyISAM 和 InnoDB 一样，也是在 数据目录 下对应的数据库子目录下创建了一个专门用于描述表结构的文件：表名.frm

表中数据和索引

在MyISAM中的索引全部都是 二级索引 ，该存储引擎的 数据和索引是分开存放 的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 test表使用MyISAM存储引擎的话，那么在它所在数据库对应的 test1db目录下会为 test 表创建这三个文件：
```
test.frm 存储表结构 
test.MYD 存储数据 (MYData) 
test.MYI 存储索引 (MYIndex)
```

## 表空间（Tablespaces）
Innodb 存储引擎其数据根据表空间进行管理。

表空间用于存储表结构和数据。表空间可分为系统表空间、独立表空间、通用表空间、临时表空间、撤消表空间和其他类型。

## 系统表空间（The System Tablespace）
系统表空间，包含InnoDB数据字典、Doublewrite Buffers、Change Buffers和Undo Logs的存储区域。

默认情况下，系统表空间还包含任何用户在系统表空间中创建的表数据和索引数据。系统表空间是一个共享表空间，因为它由多个表共享。系统表空间可以有一个或多个数据文件。默认情况下，将在数据目录中创建ibdata1文件，默认大小为12M 。
```
-- 通过 innodb_data_file_path 配置文件的大小和数量。
-- innodb_data_file_path 用来指定innodb tablespace文件
-- 如果我们不在My.cnf文件中指定innodb_data_home_dir和innodb_data_file_path
-- 那么默认会在datadir目录下创建ibdata1 作为innodb tablespace。
 
-- 默认值:
-- 文件名为ibdata1，autoextend自动扩展
innodb_data_file_path = ibdata1:12M:autoextend
```
### 独立表空间（File-Per-Table Tablespaces）
独占表空间文件存储在 /data/database1/table1.ibd 文件中，其中仅存储表的相应数据和索引，其余的撤消日志（undo log）、更改缓冲区（change buffer）和双写缓冲区（doublewrite buffer）仍存储在系统表空间中。

如果希望每个表都有一个单独的表空间文件，可以使用innodb_file_per_table。默认情况下从MySQL 5.6开始，启用的（独立的表空间是单个表空间，表是在其自己的数据文件中创建的，而不是在系统表空间中创建的）。如果禁用配置，则将在系统表空间中创建表。
```
-- 开启独立表空间参数为：innodb_file_per_table
 
-- 独立表空间：tablename.ibd
-- 新建表被创建于【表空间】中,每一个表建立ibd的扩展文件
-- 文件名为：表名.ibd，该文件默认被创建于数据库目录中,表空间的表文件支持动态和压缩行格式。
innodb_file_per_table = ON
-- 系统表空间：ibdataX，innodb将被创建于【系统表空间】中，即ibdataX中
-- X代表从1开始的一个数字
innodb_file_per_table = OFF
 
-- 查看表的存储表空间的存储方式值
show variables like 'innodb_file_per_table';
 
-- 修改存储表空间的存储方式值为OFF
set global innodb_file_per_table=off;
```
独立表空间和系统表空间的优缺点：

优点： 1、重建或删除表后，独占表空间的磁盘空间可以被回收，而系统表空间优化的磁盘空间只能被后续数据表重用，不能被操作系统回收。2、每个表之间的文件隔离使表文件维度的备份、恢复和压缩更加灵活，而不会影响其他表。

缺点：1、fsync系统调用不友好。如果使用表空间文件，一次系统调用可以完成数据存储，但如果将表空间文件拆分为多个文件。原始的fsync可以对所有涉及的表空间文件执行一次，从而增加fsyncs的数量。2、多个文件将占用更多空间和文件描述符。如果管理不当，很容易浪费空间。例如删除后，系统表空间中的所有表都可以重用标记的空间。如果它是独占表，则只能由同一个表重用。

### 通用表空间（General Tablespaces）
公共表空间是通过 create tablespace 创建表空间语法创建的共享表空间，可以在mysql数据目录之外的其他表空间中创建公共表空间，其作用是可以保存多个表并支持所有行格式。

系统表空间中的所有表共享一个文件，独立表空间中每个表都有一个文件。

优点和缺点都很明显。公共表空间是系统表空间和独立表空间之间的折衷方案。您可以选择指定一些表并将它们存储在公共表空间中。
```
-- 在/data 目录下创建表空间
CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB; 
-- 在指定目录创建表空间
CREATE TABLESPACE `ts1` ADD DATAFILE '/my/tablespace/directory/ts1.ibd' Engine=InnoDB;
 
-- 将表添加到通用表空间
CREATE TABLE sub_order_info (c1 INT PRIMARY KEY) TABLESPACE ts1; 
```
### 撤销表空间（Undo Tablespaces）
撤消表空间（Undo Tablespaces）由一个或多个撤消日志文件组成。在MySQL 5.7之前，Undo占用了系统表空间（System Tablespace）共享。从5.7开始，Undo与系统表空间分离。

默认情况下，undo日志存储在系统表空间中，可以配置为存储在一个或多个重做表空间文件，配置 innodb_undo_directory 的 undo 表空间文件的位置。默认值为/data/undo001，

innodb_undo_tablespaces=0：默认值，表示系统表空间ibdata1的使用；大于0表示使用undo表空间undo_001、undo_002等，如果使用的是 SSD 存储，推荐配置 undo 表空间。

### 临时表空间（Temporary Tablespaces）
当MySQL服务器正常关闭或异常终止时，临时表空间将在每次启动时删除并重新创建。

默认情况下，临时表空间数据文件将自动展开，并根据需要自动展开。删除临时表后，可以重用释放的空间，但文件大小保持不变。ibtmp1将在数据库重新启动后重新初始化。您还可以配置以指定最大文件大小。
```
innodb_temp_data_file_path=ibtmp1:12M:autoextend:max:500M
```
有两种类型的临时表空间：会话临时表空间（session temporary tablespaces），存储用户创建的临时表和磁盘内的临时表；全局临时表空间（global temporary tablespace）存储用户临时表的回滚段（rollback segments）。

## 源码
首先来看tablespace的定义：
```
A data file that can hold data for one or more InnoDB tables and associated indexes.
```
这里system tablespace是一个特殊的tablespace,他包含了很多数据文件(ibdata files).而且如果没有设置 file-per-table的话，所有的新创建的表的数据以及索引信息都会保存在它里面.

下面就是ibdata可能包含的内容
```
A set of files with names such as ibdata1, ibdata2, and so on, that make up the InnoDB system tablespace. These files contain metadata about InnoDB tables, (the InnoDB data dictionary), and the storage areas for one or more undo logs, the change buffer, and the doublewrite buffer.
```
假设设置了file-per-table(默认打开),那么每一个表都会有自己的tablespace文件(.ibd).
```
The .ibd file extension does not apply to the system tablespace, which consists of one or more ibdata files.
```
还有一种就是temporary tablespace，也就是临时表的tablespace.
```
InnoDB uses two types of temporary tablespace. Session temporary tablespaces store user-created temporary tables and internal temporary tables created by the optimizer.
```

### 源码分析
通过上面我们可以简单的认为tablespace就是对于数据库中table的内部抽象.

既然我们已经知道tablespace是和table相关的，那么我们就按照这个逻辑来分析源码.
```
	/* The default dir for data files is the datadir of MySQL */

	srv_data_home = innobase_data_home_dir
		? innobase_data_home_dir : default_path;

	/*--------------- Shared tablespaces -------------------------*/

	/* Check that the value of system variable innodb_page_size was
	set correctly.  Its value was put into srv_page_size. If valid,
	return the associated srv_page_size_shift. */
	srv_page_size_shift = innodb_page_size_validate(srv_page_size);
	if (!srv_page_size_shift) {
		sql_print_error("InnoDB: Invalid page size=%lu.\n",
				srv_page_size);
		DBUG_RETURN(innobase_init_abort());
	}

	/* Set default InnoDB temp data file size to 12 MB and let it be
	auto-extending. */
	if (!innobase_data_file_path) {
		innobase_data_file_path = (char*) "ibdata1:12M:autoextend";
	}

	/* This is the first time univ_page_size is used.
	It was initialized to 16k pages before srv_page_size was set */
	univ_page_size.copy_from(
		page_size_t(srv_page_size, srv_page_size, false));

	srv_sys_space.set_space_id(TRX_SYS_SPACE);

	/* Create the filespace flags. */
	ulint	fsp_flags = fsp_flags_init(
		univ_page_size, false, false, false, false);
	srv_sys_space.set_flags(fsp_flags);

	srv_sys_space.set_name(reserved_system_space_name);
	srv_sys_space.set_path(srv_data_home);

	/* Supports raw devices */
	if (!srv_sys_space.parse_params(innobase_data_file_path, true)) {
		ib::error() << "Unable to parse innodb_data_file_path="
			    << innobase_data_file_path;
		DBUG_RETURN(innobase_init_abort());
	}

	/* Set default InnoDB temp data file size to 12 MB and let it be
	auto-extending. */

	if (!innobase_temp_data_file_path) {
		innobase_temp_data_file_path = (char*) "ibtmp1:12M:autoextend";
	}

	/* We set the temporary tablspace id later, after recovery.
	The temp tablespace doesn't support raw devices.
	Set the name and path. */
	srv_tmp_space.set_name(reserved_temporary_space_name);
	srv_tmp_space.set_path(srv_data_home);

	/* Create the filespace flags with the temp flag set. */
	fsp_flags = fsp_flags_init(
		univ_page_size, false, false, false, true);
	srv_tmp_space.set_flags(fsp_flags);

	if (!srv_tmp_space.parse_params(innobase_temp_data_file_path, false)) {
		ib::error() << "Unable to parse innodb_temp_data_file_path="
			    << innobase_temp_data_file_path;
		DBUG_RETURN(innobase_init_abort());
	}

	/* Perform all sanity check before we take action of deleting files*/
	if (srv_sys_space.intersection(&srv_tmp_space)) {
		sql_print_error("%s and %s file names seem to be the same.",
			srv_tmp_space.name(), srv_sys_space.name());
		DBUG_RETURN(innobase_init_abort());
	}

	/* ------------ UNDO tablespaces files ---------------------*/
	if (!srv_undo_dir) {
		srv_undo_dir = default_path;
	}

	os_normalize_path(srv_undo_dir);

	if (strchr(srv_undo_dir, ';')) {
		sql_print_error("syntax error in innodb_undo_directory");
		DBUG_RETURN(innobase_init_abort());
	}
```

### shared tablespace
首先来看system tablespace的创建，在InnoDB中每一个tablespace都会有一个uint32类型的id,每一个唯一的id用来表示对应的tablespace,而system tablespace的space id就是0.
```
static const space_id_t TRX_SYS_SPACE = 0;
```
而由于只有system tablespace和temporary tablespace是共享的，因此他们在InnoDB中有专门的数据结构来表示他们(Tablespace表示所有的shared tablespace的基类).

源码地址fsp0sysspace.h
```
class SysTablespace : public Tablespace {
 public:
  SysTablespace()
      : m_auto_extend_last_file(),
        m_last_file_size_max(),
        m_created_new_raw(),
        m_is_tablespace_full(false),
        m_sanity_checks_done(false) {
    /* No op */
  }
```
而对应的变量则是
```
/** The control info of the system tablespace. */
SysTablespace srv_sys_space;

/** The control info of a temporary table shared tablespace. */
SysTablespace srv_tmp_space;
```
tablespace数据文件的创建则是在SysTablespace::open_or_create中，因此我们来看这个函数.这个函数主要功能是遍历当前system tablespace的所有文件(m_files),然后存在就打开，不存在就创建对应的文件.
```
files_t::iterator begin = m_files.begin();
  files_t::iterator end = m_files.end();

  ut_ad(begin->order() == 0);

  for (files_t::iterator it = begin; it != end; ++it) {
    if (it->m_exists) {
      err = open_file(*it);

    } else {
      err = create_file(*it);
    }
```
当打开文件之后，将会把打开的文件进行缓存(InnoDB会将所有的tablespace缓存在fil_system中).
```
/* Close the curent handles, add space and file info to the
  fil_system cache and the Data Dictionary, and re-open them
  in file_system cache so that they stay open until shutdown. */
  ulint node_counter = 0;
  for (files_t::iterator it = begin; it != end; ++it) {
    it->close();
    it->m_exists = true;
..............................
    page_no_t max_size =
        (++node_counter == m_files.size()
             ? (m_last_file_size_max == 0 ? PAGE_NO_MAX : m_last_file_size_max)
             : it->m_size);

    /* Add the datafile to the fil_system cache. */
    if (!fil_node_create(it->m_filepath, it->m_size, space,
                         it->m_type != SRV_NOT_RAW, it->m_atomic_write,
                         max_size)) {
      err = DB_ERROR;
      break;
    }
  }
```
fil_node_create就是将当前的文件加入到文件cache中，这是因为在InnoDB中所有的文件都会统一管理，包括redo/undo，所有的tablespace都会根据他们的spaceid进行缓存.
```
char *fil_node_create(const char *name, page_no_t size, fil_space_t *space,
                      bool is_raw, bool atomic_write, page_no_t max_pages) {
  auto shard = fil_system->shard_by_id(space->id);

  fil_node_t *file;

  file = shard->create_node(name, size, space, is_raw,
                            IORequest::is_punch_hole_supported(), atomic_write,
                            max_pages);

  return (file == nullptr ? nullptr : file->name);
}
```
此时的疑问就是m_files是何时被初始化的，也就是system tablespace文件名的初始化，这里system tablespace的文件名初始化是在数据库init的时候被初始化的，因此我们来看相关代码.

InnoDB中有一个变量叫做innobase_data_file_path，这个变量是一个字符串，这个字符串包含了所有的system tablespace需要创建 的文件以及一些属性，这个字符串默认值是在InnoDB引擎初始化的时候初始化的.
```
/* Set default InnoDB temp data file size to 12 MB and let it be
  auto-extending. */
  if (!innobase_data_file_path) {
    innobase_data_file_path = (char *)"ibdata1:12M:autoextend";
  }
```
可以看到默认只创建ibdata1文件，并且大小为12m,自动扩展，而innobase_data_file_path的格式如下
```
innodb_data_file_path=datafile_spec1[;datafile_spec2]..
file_name:file_size[:autoextend[:max:max_file_size]]
```
因此system tablespace创建文件也会根据这个配置来创建，也就是当InnoDB参数解析完毕之后进入system tablespace的文件创建.
```
if (int error = innodb_init_params()) {
    DBUG_RETURN(error);
  }

  /* After this point, error handling has to use
  innodb_init_abort(). */

  if (!srv_sys_space.parse_params(innobase_data_file_path, true)) {
    ib::error(ER_IB_MSG_545)
        << "Unable to parse innodb_data_file_path=" << innobase_data_file_path;
    DBUG_RETURN(innodb_init_abort());
  }
```
parse_params这个函数将会解析innobase_data_file_path,然后根据不同的属性创建对应的文件，先来看参数解析.
```
/*---------------------- PASS 1 ---------------------------*/
  /* First calculate the number of data files and check syntax. */
  while (*ptr != '\0') {
    filepath = ptr;

    ptr = parse_file_name(ptr);

    if (ptr == filepath) {
...........................
      return (false);
    }

    if (*ptr == '\0') {
.................................

      return (false);
    }

    ptr++;

    size = parse_units(ptr);

    if (size == 0) {
.........................
      return (false);
    }

    if (0 == strncmp(ptr, ":autoextend", (sizeof ":autoextend") - 1)) {
      ptr += (sizeof ":autoextend") - 1;

      if (0 == strncmp(ptr, ":max:", (sizeof ":max:") - 1)) {
        ptr += (sizeof ":max:") - 1;

        page_no_t max = parse_units(ptr);

        if (max < size) {
          goto invalid_size;
        }
      }

      if (*ptr == ';') {
..................................
        return (false);
      }
    }

    if (0 == strncmp(ptr, "new", (sizeof "new") - 1)) {
      ptr += (sizeof "new") - 1;
    }

    if (0 == strncmp(ptr, "raw", (sizeof "raw") - 1)) {
...............................
        return (false);
      }

      ptr += (sizeof "raw") - 1;
    }

    ++n_files;

    if (*ptr == ';') {
      ptr++;
    } else if (*ptr != '\0') {
.......................
      return (false);
    }
  }

  if (n_files == 0) {
......................
    return (false);
  }
```
然后第二步就是存储对应的文件名以及属性到m_files中，这里有一个重要的数据结构就是Datafile,每一个数据文件在InnoDB中的抽象就是Datafile.
```
while (*ptr != '\0') {
    filepath = ptr;

    ptr = parse_file_name(ptr);

    if (*ptr == ':') {
      /* Make filepath a null-terminated string */
      *ptr = '\0';
      ptr++;
    }

    size = parse_units(ptr);
    ut_ad(size > 0);

    if (0 == strncmp(ptr, ":autoextend", (sizeof ":autoextend") - 1)) {
      m_auto_extend_last_file = true;

      ptr += (sizeof ":autoextend") - 1;

      if (0 == strncmp(ptr, ":max:", (sizeof ":max:") - 1)) {
        ptr += (sizeof ":max:") - 1;

        m_last_file_size_max = parse_units(ptr);
      }
    }

    m_files.push_back(Datafile(filepath, flags(), size, order));
    Datafile *datafile = &m_files.back();
    datafile->make_filepath(path(), filepath, NO_EXT);

    if (0 == strncmp(ptr, "new", (sizeof "new") - 1)) {
      ptr += (sizeof "new") - 1;
    }

    if (0 == strncmp(ptr, "raw", (sizeof "raw") - 1)) {
      ut_a(supports_raw);

      ptr += (sizeof "raw") - 1;

      /* Initialize new raw device only during initialize */
      m_files.back().m_type =
#ifndef UNIV_HOTBACKUP
          opt_initialize ? SRV_NEW_RAW : SRV_OLD_RAW;
#else  /* !UNIV_HOTBACKUP */
          SRV_OLD_RAW;
#endif /* !UNIV_HOTBACKUP */
    }

    if (*ptr == ';') {
      ++ptr;
    }
    order++;
  }
```

### 非共享的tablespace
然后我们来看非共享的tablespace的创建,一般来说每创建一个表都会创建一个新的ibd文件，也就是tablespace. 而这种tablespace以及Redolog/undolog都是属于fil_space_t这个结构体.通过上面的代码我们知道system tablespace最终也是创建一个fil_space_t然后再接入整个系统的tablespace的管理的.

这里先来看两个特殊的tablespace,也就是REDO log和UNDO log，由于这两个log也都是磁盘上的文件，因此在InnoDB中会讲这两个log文件作为一种特殊的tablespace，来看他们的初始化.
```
static dberr_t create_log_files(char *logfilename, size_t dirnamelen, lsn_t lsn,
                                char *&logfile0, lsn_t &checkpoint_lsn) {
........................
    /* Disable the doublewrite buffer for log files. */
    fil_space_t *log_space = fil_space_create(
        "innodb_redo_log", dict_sys_t::s_log_space_first_id,
        fsp_flags_set_page_size(0, univ_page_size), FIL_TYPE_LOG);
.......................
}
```
下面的undo log.
```
static dberr_t srv_undo_tablespace_open(space_id_t space_id) {
....................................
    space = fil_space_create(undo_name, space_id, flags, FIL_TYPE_TABLESPACE);
..............
}
```
以后我们详细分析undolog/redolog的时候会再来分析这个地方

接下来我们就来看当一般表的创建的时候会发生什么(设置了file-per-table)，对于一般的表，创建tablespace是跟随着ibd文件一起创建的(上面的都是在初始化的时候创建)。
```
static bool dd_create_hardcoded(space_id_t space_id, const char *filename) {
  page_no_t pages = FIL_IBD_FILE_INITIAL_SIZE;

  dberr_t err = fil_ibd_create(space_id, dict_sys_t::s_dd_space_name, filename,
                               predefined_flags, pages);

  if (err == DB_SUCCESS) {
    mtr_t mtr;
    mtr.start();

    bool ret = fsp_header_init(space_id, pages, &mtr, true);

    mtr.commit();

    if (ret) {
      btr_sdi_create_index(space_id, false);
      return (false);
    }
  }

  return (true);
}
```






