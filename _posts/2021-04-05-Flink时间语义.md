---
layout: post
categories: [Flink]
description: none
keywords: Flink
---
# Flink时间
在流处理中，时间是一个核心的概念，是整个系统的基石。

## 时间概念类型
对于流式数据处理，最大的特点是数据上具有时间的属性特征，Flink根据时间产生的位置不同，将时间区分为三种时间概念，分别为

- 事件生成时间（Event Time）
数据从终端产生，或者从系统中产生的过程中生成的时间为事件生成时间。是事件创建的时间。它通常由事件中的时间戳描述， 例如采集的日志数据中，每一条日志都会记录自己的生成时间，Flink通过时间戳分配器访问事件时间戳。

使用Event Time，在理想情况下可以一直等待所有事件到达后再进行时间窗口的处理，最终结果是正确且一致的，并且不用担心乱序的问题。但是实际应用中，在涉及到按时间窗口进行统计时，会将窗口内的事件缓存下来，直到接收到一个watermark。Watermark意味着在一个时间窗口下，Flink会等待一个有限的时间，这在一定程度上降低了计算结果的绝对准确性，而且增加了系统的延迟。

- 事件接入时间（Ingestion Time）
当数据经过消息中间件传入到Flink系统中，在DataSource中接入的时候会生成事件接入时间。是数据进入Flink的时间。从源端到下游各个算子中间可能有很多计算环节，任何一个算子处理速度的快慢都可能影响到下游算子的Processing Time。而Ingestion Time是数据流最早进入Flink的时间，因此不会被算子的处理效率影响。

Ingestion Time在概念上是位于Event Time和Processing Time之间，比Processing Time稍早，不需要指定Watermark

- 事件处理时间（Processing Time）
当数据在Flink系统中通过各个算子实例执行转换操作的过程中，算子实例所在系统的时间为数据处理时间。是每一个执行基于时间操作的算子的本地系统时间，与机器相关，默认的时间属性就是Processing Time。在Processing Time时间窗口下，无论事件什么时候发生，只要该事件在某个时间段到达了某个算子，就会被归结为该窗口。

Processing Time只依赖当前节点的操作系统时间，无需缓存，实现起来更简单，延迟更小。

在Flink的流式处理中，绝大部分的业务都会使用EventTime，一般只在EventTime无法使用时，才会被迫使用ProcessingTime 或者IngestionTime。

### 事件时间（Event Time）
事件时间（Event Time）是每个独立事件在产生它的设备上发生的时间，这个时间通常在事件进入Flink之前就已经嵌入到事件中，时间顺序取决于事件产生的地方，和下游数据处理系统的时间无关。事件数据具有不变的事件时间属性，该时间自事件元素产生就不会改变。通常情况下可以在Flink系统中指定事件时间属性或者设定时间提取器来提取事件时间。

所有进入到Flink流式系统处理的事件，其时间都是在外部系统中产生，经过网络进入到Flink系统内处理的，在理论情况下（所有系统都具有相同系统时钟），事件时间对应的时间戳一定会早于在Flink系统中处理的时间戳，但在实际情况中往往会出现数据记录乱序、延迟到达等问题。基于EventTime的时间概念，数据处理过程依赖于数据本身产生的时间，而不是Flink系统中Operator所在主机节点的系统时间，这样能够借助于事件产生时的时间信息来还原事件的先后关系。

### 接入时间（Ingestion Time）
接入时间（Ingestion Time）是数据进入Flink系统的时间，Ingestion Time依赖于Source Operator所在主机的系统时钟。Ingestion Time介于Event Time和Process Time之间，相对于Process Time，Ingestion Time生成的代价相对较高，Ingestion Time具有一定的可预见性，主要因为Ingestion Time在数据接入过程生成后，时间戳就不再发生变化，和后续数据处理Operator所在机器的时钟没有关系，从而不会因为某台机器时钟不同步或网络时延而导致计算结果不准确的问题。但是需要注意的是相比于Event Time，Ingestion Time不能处理乱序事件，所以也就不用生成对应的Watermarks。

### 处理时间（Processing Time）
处理时间（Processing Time）是指数据在操作算子计算过程中获取到的所在主机时间。当用户选择使用Processing Time时，所有和时间相关的计算算子，例如Windows计算，在当前的任务中所有的算子将直接使用其所在主机的系统时间。Processing Time是Flink系统中最简单的一种时间概念，基于Processing Time时间概念，Flink的程序性能相对较高，延时也相对较低，对接入到系统中的数据时间相关的计算完全交给算子内部决定，时间窗口计算依赖的时间都是在具体算子运行的过程中产生，不需要做任何时间上的对比和协调。但Processing Time时间概念虽然在性能和易用性的角度上具有优势，但考虑到对数据乱序处理的情况，Processing Time就不是最优的选择。同时在分布式系统中，数据本身不乱序，但每台机器的时间如果不同步，也可能导致数据处理过程中数据乱序的问题，从而影响计算结果。总之，Processing Time概念适用于时间计算精度要求不是特别高的计算场景，例如统计某些延时非常高的日志数据等。

## 时间概念指定
1.12版本默认是根据EventTime,之前版本默认是采用ProcessingTime。渐渐的，摄入时间（IngestionTime）越来越不推荐使用了，实际上就生产而言，我们更多选择是根据业务采用不同的窗口分配器，选择根据事件时间还是处理时间进行计算。

用户需要在创建的StreamExecutionEnvironment中调用setStream-TimeCharacteristic()方法设定系统的时间概念

如下代码使用TimeCharacteristic.EventTime作为系统的时间概念，这样对当前的StreamExecutionEnvironment会全局生效。对应的。
```java
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

public class SteamWordCount {

    public static void main(String[] args) throws Exception {
        // 创建流处理执行环境
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);
        // 设置时间
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        DataStreamSource<Tuple2<String, Integer>> resultStream = env.fromElements(Tuple2.of("Hello", 1683797649), Tuple2.of("World", 1683797649));
        // 指定计算结果输出位置
        resultStream.print();
        // 指定名称并触发流式任务
        env.execute("Stream");
    }

}
```















