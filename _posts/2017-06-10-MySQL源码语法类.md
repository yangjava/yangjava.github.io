---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL源码语法类

## SELECT_LEX类
此类表示查询块，又名查询规范，该查询块由SELECT关键字，表列表，可选的WHERE子句，GROUP BY等组成。

在#include <sql_lex.h>中。
此类表示查询块，又名查询规范，该查询块由SELECT关键字，表列表，可选的WHERE子句，GROUP BY等组成。

在#include <sql_lex.h>中。

公共函数
```
 	//构造并初始化SELECT_LEX对象
	SELECT_LEX (MEM_ROOT *mem_root, Item *where, Item *having)
Item * 	where_cond () const
Item ** 	where_cond_ref () 
void 	set_where_cond (Item *cond)
Item * 	having_cond () const
Item ** 	having_cond_ref ()
void 	set_having_cond (Item *cond)
void 	set_query_result (Query_result *result)
Query_result * 	query_result () const
//是否更改查询块的Query_result对象
bool 	change_query_result (THD *thd, Query_result_interceptor *new_result, Query_result_interceptor *old_result)
//设置查询块的基本选项（以及活动选项）
void 	set_base_options (ulonglong options_arg)
//将基本选项添加到查询块，还更新活动选项。
void 	add_base_options (ulonglong options)
//从查询块中删除基本选项。
void 	remove_base_options (ulonglong options)
//从基本选项，提供的选项和环境中选择激活选项：
void 	make_active_options (ulonglong added_options, ulonglong removed_options)
//调整激活选项集
void 	add_active_options (ulonglong options)
ulonglong 	active_options () const
//将关联的表设置为read_only
void 	set_tables_readonly ()
table_map 	all_tables_map () const
//删除我们之前作为transform_scalar_subqueries_to_join_with_derived的一部分添加的派生表
void 	remove_derived (THD *thd, TABLE_LIST *tl)
bool 	remove_aggregates (THD *thd, SELECT_LEX *select)
SELECT_LEX_UNIT * 	master_unit () const
SELECT_LEX_UNIT * 	first_inner_unit () const
SELECT_LEX * 	outer_select () const
SELECT_LEX * 	next_select () const
//在from子句中按名称查找（可能是未解析的）表引用 
TABLE_LIST * 	find_table_by_name (const Table_ident *ident)
bool 	is_straight_join ()
SELECT_LEX * 	last_select ()
SELECT_LEX * 	next_select_in_list () const
//将所有查询块从此标记为“最后”作为从属
void 	mark_as_dependent (SELECT_LEX *last, bool aggregate) 
bool 	is_explicitly_grouped () const
bool 	is_implicitly_grouped () const
//如果此查询块被隐式分组，则为true。
bool 	is_single_grouped () const
bool 	is_grouped () const
bool 	is_distinct () const
bool 	is_ordered () const
//根据解析时查询的结构，可以得出DISTINCT没用并将其删除的结论。
bool 	can_skip_distinct () const
bool 	has_limit () const 
bool 	has_ft_funcs () const
bool 	is_recursive () const
bool 	is_in_select_list (Item *i)
//查找与给定项目匹配的组表达式，如果没有，则返回nullptr。
ORDER * 	find_in_group_list (Item *item, int *rollup_level) const
int 	group_list_size () const
bool 	has_windows () const
//通过使指向其他SELECT_LEX_UNIT和SELECT_LEXes的指针无效来使之失效。
void 	invalidate ()
uint 	get_in_sum_expr () const
bool 	add_item_to_list (Item *item)
bool 	add_ftfunc_to_list (Item_func_match *func)
void 	add_order_to_list (ORDER *order)
//将表添加到已用表列表
TABLE_LIST * 	add_table_to_list (THD *thd, Table_ident *table, const char *alias, ulong table_options, thr_lock_type flags=TL_UNLOCK, enum_mdl_type mdl_type=MDL_SHARED_READ, List< Index_hint > *hints=nullptr, List< String > *partition_names=nullptr, LEX_STRING *option=nullptr, Parse_context *pc=nullptr)
//将项目添加到选择列表的隐藏部分
Item ** 	add_hidden_item (Item *item)
//从选择列表中删除隐藏的项目
void 	remove_hidden_items ()
TABLE_LIST * 	get_table_list () const
//初始化嵌套联接的新表列表
bool 	init_nested_join (THD *thd)
//结束嵌套的联接表列表。
TABLE_LIST * 	end_nested_join ()
//嵌套最后加入操作
TABLE_LIST * 	nest_last_join (THD *thd, size_t table_cnt=2)
//将表添加到当前联接列表
bool 	add_joined_table (TABLE_LIST *table)
mem_root_deque< Item * > * 	get_fields_list ()
//在字段/ get_fields_list（）上包装，可在item-> hidden的地方隐藏项目，这意味着基于范围的for循环。
auto 	visible_fields ()
auto 	visible_fields () const
//是否检查特权以合并到查询块中的视图。
bool 	check_view_privileges (THD *thd, ulong want_privilege_first, ulong want_privilege_next)
//是否检查从查询块引用的所有列的特权
bool 	check_column_privileges (THD *thd)
//是否检查查询块的子查询中列引用的特权
bool 	check_privileges_for_subqueries (THD *thd)
//是否解决并准备有关一个查询块的表的信息
bool 	setup_tables (THD *thd, TABLE_LIST *tables, bool select_insert)
//解决OFFSET和LIMIT子句。
bool 	resolve_limits (THD *thd)
//解决查询块的派生表，视图，表函数信息
bool 	resolve_placeholder_tables (THD *thd, bool apply_semijoin)
//将排除从表唯一性测试传播到子查询
void 	propagate_unique_test_exclusion ()
//将子查询的名称解析上下文对象合并到其父级中
void 	merge_contexts (SELECT_LEX *inner)
//是否将派生表合并到查询块中。
bool 	merge_derived (THD *thd, TABLE_LIST *derived_table)
//将半联接子查询谓词转换为半联接联接嵌套
bool 	flatten_subqueries (THD *thd)
//更新半连接嵌套的可用半连接策略。
void 	update_semijoin_strategies (THD *thd)
//返回可用于此查询块的子查询执行策略
Subquery_strategy 	subquery_strategy (const THD *thd) const
//返回是否为此查询块启用半联接
bool 	semijoin_enabled (const THD *thd) const
void 	set_sj_candidates (Mem_root_array< Item_exists_subselect *> *sj_cand)
bool 	has_sj_candidates () const
//从sj_candidates数组中删除指向子查询的指针
void 	remove_semijoin_candidate (Item_exists_subselect *sub_query)
//将列表中的全文功能元素添加到此查询块中
bool 	add_ftfunc_list (List< Item_func_match > *ftfuncs)
void 	set_lock_for_table (const Lock_descriptor &descriptor, TABLE_LIST *table)
//为当前查询块中的所有表设置锁定。
void 	set_lock_for_tables (thr_lock_type lock_type)
void 	init_order ()
void 	cut_subtree ()
bool 	test_limit ()
//获得LIMIT的偏移量
ha_rows 	get_offset (THD *thd)
//获得limit
ha_rows 	get_limit (THD *thd)
//为该查询块分配默认名称解析对象
bool 	set_context (Name_resolution_context *outer_context)
//设置包含对基础项目的引用的数组。
bool 	setup_base_ref_items (THD *thd)
void 	print (const THD *thd, String *str, enum_query_type query_type)
//打印SELECT_LEX对象的详细信息
void 	print_select (const THD *thd, String *str, enum_query_type query_type)
//打印UPDATE语句的详细信息
void 	print_update (const THD *thd, String *str, enum_query_type query_type)
//打印DELETE语句的详细信息
void 	print_delete (const THD *thd, String *str, enum_query_type query_type)
//打印insert语句的详细信息
void 	print_insert (const THD *thd, String *str, enum_query_type query_type)
//打印提示的详细信息。
void 	print_hints (const THD *thd, String *str, enum_query_type query_type)
//打印错误
bool 	print_error (const THD *thd, String *str)
//打印select选项
void 	print_select_options (String *str)
//打印update选项
void 	print_update_options (String *str)
//打印Delete选项
void 	print_delete_options (String *str)
//打印insert选项
void 	print_insert_options (String *str)
//打印表格数组
void 	print_table_references (const THD *thd, String *str, TABLE_LIST *table_list, enum_query_type query_type)
//打印SELECT_LEX对象的items数组
void 	print_item_list (const THD *thd, String *str, enum_query_type query_type)
//打印更新作业数组
void 	print_update_list (const THD *thd, String *str, enum_query_type query_type, const mem_root_deque< Item *> &fields, const mem_root_deque< Item *> &values)
//打印将要执行inserted into的列数组
void 	print_insert_fields (const THD *thd, String *str, enum_query_type query_type)
//打印值列表，用于INSERT和常规VALUES子句。
void 	print_values (const THD *thd, String *str, enum_query_type query_type, const mem_root_deque< mem_root_deque< Item *> *> &values, const char *prefix)
//在FROM子句中打印表列表。
void 	print_from_clause (const THD *thd, String *str, enum_query_type query_type)
//打印WHERE子句中的条件列表。
void 	print_where_cond (const THD *thd, String *str, enum_query_type query_type)
//打印GROUP BY子句中的项目列表
void 	print_group_by (const THD *thd, String *str, enum_query_type query_type)
//打印HAVING子句中的项目列表
void 	print_having (const THD *thd, String *str, enum_query_type query_type)
//打印视图函数的详细信息。
void 	print_windows (const THD *thd, String *str, enum_query_type query_type)
//打印ORDER BY子句中的项目列表
void 	print_order_by (const THD *thd, String *str, enum_query_type query_type)
void 	print_limit (const THD *thd, String *str, enum_query_type query_type)
//保存重复优化所需的准备好的语句的属性
bool 	save_properties (THD *thd)
//接受SELECT和DELETE的函数。
bool 	accept (Select_lex_visitor *visitor)
//清理此子树（此SELECT_LEX以及所有嵌套的SELECT_LEXes和SELECT_LEX_UNIT）。
void 	cleanup (THD *thd, bool full)
void 	cleanup_all_joins ()
//销毁包含的对象，特别是可能具有自己的mem_roots的临时表
void 	destroy ()
//如果此查询块是UNION的一部分，则返回true。
bool 	is_part_of_union () const
bool 	is_empty_query () const
//将查询块设置为不返回数据
void 	set_empty_query ()
bool 	agg_func_used () const 
bool 	json_agg_func_used () const
void 	set_agg_func_used (bool val)
void 	set_json_agg_func_used (bool val)
bool 	right_joins () const
void 	set_right_joins ()
//查找SELECT_LEX类型
enum_explain_type 	type ()
//查找类型字符串
const char * 	get_type_str ()
bool 	is_dependent () const
bool 	is_cacheable () const
bool 	source_table_is_one_row () const
//在查询表达式中包含查询块。
void 	include_down (LEX *lex, SELECT_LEX_UNIT *outer)
//在另一个查询块旁边包括一个查询块。
void 	include_neighbour (LEX *lex, SELECT_LEX *before)
//在查询表达式中包含查询块，但不链接
void 	include_standalone (SELECT_LEX_UNIT *sel, SELECT_LEX **ref)
//将查询块包含到全局列表中
void 	include_in_global (SELECT_LEX **plink)
//将查询块链包括到全局列表中
void 	include_chain_in_global (SELECT_LEX **start)
//对包含的查询表达式的查询块重新编号
void 	renumber (LEX *lex)
//执行查询块本地的永久转换（不会将其合并到另一个块）
bool 	apply_local_transforms (THD *thd, bool prune)
//将此查询块的WHERE条件的一部分推送到实例化派生表
bool 	push_conditions_to_derived_tables (THD *thd)
//返回WHERE / HAVING / ON条件的一次性副本。
bool 	get_optimizable_conditions (THD *thd, Item **new_where, Item **new_having)
//检查仅可用于最外部查询块的选项是否适用于此查询块
bool 	validate_outermost_option (LEX *lex, const char *wrong_option) const
//验证查询块的基本选项。
bool 	validate_base_options (LEX *lex, ulonglong options) const
bool 	walk (Item_processor processor, enum_walk walk, uchar *arg)
//是否将表从数组添加到已用表列表。
bool 	add_tables (THD *thd, const Mem_root_array< Table_ident *> *tables, ulong table_options, thr_lock_type lock_type, enum_mdl_type mdl_type)
//是否在存在ROLLUP的情况下，将窗口函数内的分组依据字段引用替换为引用。
bool 	resolve_rollup_wfs (THD *thd)
//是否解决WHERE条件并加入条件。
bool 	setup_conds (THD *thd)
//是否准备查询块以进行优化
bool 	prepare (THD *thd, mem_root_deque< Item *> *insert_field_list)
//是否优化查询块和所有内部查询表达式
bool 	optimize (THD *thd)
//在传递列表中的所有嵌套联接中设置NESTED_JOIN :: counter = 0
void 	reset_nj_counters (mem_root_deque< TABLE_LIST *> *join_list=nullptr)
bool 	change_group_ref_for_func (THD *thd, Item *func, bool *changed)
bool 	change_group_ref_for_cond (THD *thd, Item_cond *cond, bool *changed) 
Item * 	single_visible_field () const
size_t 	num_visible_fields () const
bool 	field_list_is_empty () const
void 	remove_hidden_fields ()
//更新所有本地表达式的已用表信息。
void 	update_used_tables ()
//恢复为此查询块和所有基础查询表达式准备的语句属性，以便为优化做好准备。
void 	restore_cmd_properties ()
//保存查询块和基础查询表达式的准备好的语句属性。
bool 	save_cmd_properties (THD *thd)

```

公共属性
```
//连接和过滤后所需的所有表达式，即选择列表，按列表分组，具有子句，窗口子句，按子句（包括隐藏字段）。
mem_root_deque< Item * > 	fields
//在选择上定义的所有视图，包括命名视图和内联视图。
List< Window > 	m_windows
//通常是指向ftfunc_list_alloc的指针，但是在UNION中，它用于创建伪造的select_lex，以合并UNION的结果字段。
List< Item_func_match > * 	ftfunc_list
List< Item_func_match > 	ftfunc_list_alloc {}
//表值构造函数的VALUES项
mem_root_deque< mem_root_deque< Item * > * > * 	row_value_list {nullptr}
//为此查询块生成的半联接嵌套的列表。
mem_root_deque< TABLE_LIST * > 	sj_nests
//FROM子句中的表列表-使用TABLE_LIST :: next_local遍历
SQL_I_List< TABLE_LIST > 	table_list {}
//ORDER BY子句数组
SQL_I_List< ORDER > 	order_list {}
Group_list_ptrs * 	order_list_ptrs {nullptr}
//Group by子句数组
SQL_I_List< ORDER > 	group_list {}
Group_list_ptrs * 	group_list_ptrs {nullptr}
Prealloced_array< Item_rollup_group_item *, 4 > 	rollup_group_items
Prealloced_array< Item_rollup_sum_switcher *, 4 > 	rollup_sums
//此查询块的查询块级别提示。
Opt_hints_qb * 	opt_hints_qb {nullptr}
char * 	db {nullptr}
//如果此查询块是递归单元的递归成员：TABLE_LIST，在此递归成员中，引用查询名称。
TABLE_LIST * 	recursive_reference {nullptr}
//对这个查询块所属的LEX的引用。
LEX * 	parent_lex {nullptr}
//在该选择级别的选择列表中引用其字段的那些表的集合。更多...
table_map 	select_list_tables {0}
//来自外部联接的所有内部表的位图
table_map 	outer_join {0}
//除连接表中的列外的所有列引用的名称解析上下文
Name_resolution_context 	context {}
//指向Name res上下文对象列表中第一个对象的指针，该对象具有此查询块作为基本查询块。
Name_resolution_context * 	first_context
//优化之后，它是指向相应JOIN的指针。
JOIN * 	join {nullptr}
//顶级加入列表
mem_root_deque< TABLE_LIST * > 	top_join_list
//当前已解析的联接的列表
mem_root_deque< TABLE_LIST * > * 	join_list
//嵌入上述列表的表格
TABLE_LIST * 	embedding {nullptr}
//指向查询块的第一个叶子表
TABLE_LIST * 	leaf_tables {nullptr}
TABLE_LIST * 	end_lateral_table {nullptr}
//imit子句 
Item * 	select_limit {nullptr}
//limit...offset从句
Item * 	offset_limit {nullptr}
//嵌套查询块中聚合函数的循环链接列表。
Item_sum * 	inner_sum_func_list {nullptr}
//指向“基本”项目的指针数组；
Ref_item_array 	base_ref_items
//查询块数目
uint 	select_number {0}
//WHERE和HAVING子句的保存的值
Item::cond_result 	cond_value {Item::COND_UNDEF}
Item::cond_result 	having_value {Item::COND_UNDEF}
//解析上下文：指示当前表达式的解析位置。
enum_parsing_context 	parsing_place {CTX_NONE}
//解析上下文：如果为正，则在set函数内
uint 	in_sum_expr {0}
//表示查询的一部分正在解决
Resolve_place 	resolve_place
//选择列表或当前选择以及所有内部子选择的where子句中使用的字段数。
uint 	select_n_where_fields {0}
//select_list和HAVING子句中用于增加数量的项目数，然后可以是split_sum_func期间将添加到所有项目列表中的条目数。
uint 	select_n_having_items {0}
//和/或/ xor在何处/具有/在...上的参数数量
uint 	cond_count {0}
//位置/具有/在其上的谓词之间的数量
uint 	between_count {0}
//多个相等元素的最大数量
uint 	max_equal_elems
//此SELECT中Item_sum派生的对象数
uint 	n_sum_items {0}
//子节点和子节点SELECT中Item_sum派生的对象数。
uint 	n_child_sum_items {0}
uint 	n_scalar_subqueries {0}
//在一个查询块中物化衍生表和视图的数目
uint 	materialized_derived_table_count {0}
//分区表的数目
uint 	partitioned_table_count {0}
//SELECT列表中使用的通配符数
uint 	with_wild {0}
//此查询块中叶表的数量。
uint 	leaf_table_count {0}
//此查询块中衍生表的数量。
uint 	derived_table_count {0}
//此查询块中表函数的数量。
uint 	table_func_count {0}
int 	nest_level {0} 
//指示此查询块是否包含WITH ROLLUP子句
olap_type 	olap {UNSPECIFIED_OLAP_TYPE}
enum_condition_context 	condition_context {enum_condition_context::ANDS}
//如果设置，则查询块的格式为VALUES row_list
bool 	is_table_value_constructor {false}
//描述这个查询区块的上下文
sub_select_type 	linkage {UNSPECIFIED_TYPE}
//该查询的结果不能被缓存，位字段可以是：UNCACHEABLE_DEPENDENT UNCACHEABLE_RAND UNCACHEABLE_SIDEEFFECT
uint8 	uncacheable {0}
//是否必须使用此变量才能确保子查询和存储过程正常工作。
bool 	first_execution {true}
//半连接拔出处理完成时为true
bool 	sj_pullout_done {false}
//嵌套scalar_to_derived转换使用
bool 	m_was_implicitly_grouped {false}
//true：在prepare（）调用期间跳过本地转换（由INSERT使用）
bool 	skip_local_transforms {false}
bool 	is_item_list_lookup {false}
//在处理此查询块时调用了fix字段时为true
bool 	having_fix_field {false}
//当在此查询块的处理中调用GROUP BY修订字段时为true
bool 	group_fix_field {false}
//如果包含或聚合集合函数，则为True
bool 	with_sum_func {false}
//HAVING子句包含子查询=>即使我们使用临时表，也无法在查询处理结束之前关闭表。
bool 	subquery_in_having {false}
//如果为true，请使用select_limit限制所选的行数
bool 	m_use_select_limit {false}
//如果为true，则在内部添加限制对象
bool 	m_internal_limit {false}
//从unique_table（）检查中排除此查询块
bool 	exclude_from_table_unique_test {false}
bool 	no_table_names_allowed {false}
uint 	hidden_items_from_optimization {0}

```
私有成员函数
```
//save_properties（）的帮助器
bool 	save_order_properties (THD *thd, SQL_I_List< ORDER > *list, Group_list_ptrs **list_ptrs)
//在选择块中记录联接嵌套信息。
bool 	record_join_nest_info (mem_root_deque< TABLE_LIST *> *tables)
//简化连接尽可能使用内部联接替换外部联接。
bool 	simplify_joins (THD *thd, mem_root_deque< TABLE_LIST *> *join_list, bool top, bool in_sj, Item **new_conds, uint *changelog=nullptr)
//删除此查询块的半联接条件。
void 	clear_sj_expressions (NESTED_JOIN *nested_join)
//为查询块建立半联接条件
bool 	build_sj_cond (THD *thd, NESTED_JOIN *nested_join, SELECT_LEX *subq_select, table_map outer_tables_map, Item **sj_cond)
//是否取消关联WHERE子句或IN或EXISTS谓词中使用的子查询的联接条件。
bool 	decorrelate_condition (Semijoin_decorrelation &sj_decor, TABLE_LIST *join_nest)
//是否将此查询块的子查询谓词转换为TABLE_LIST半联接嵌套
bool 	convert_subquery_to_semijoin (THD *thd, Item_exists_subselect *subq_pred)
//为本查询块查询一个表格数组
TABLE_LIST * 	synthesize_derived (THD *thd, SELECT_LEX_UNIT *unit, Item *join_cond, bool left_outer, bool use_inner_join)
//是否将子查询转换为派生表，并将其插入拥有的查询块的FROM子句中。
bool 	transform_subquery_to_derived (THD *thd, TABLE_LIST **out_tl, SELECT_LEX_UNIT *subs_unit, Item_subselect *subq, bool use_inner_join, bool reject_multiple_rows, Item *join_condition)
//将表子查询（[NOT] {IN，EXISTS}）替换为对派生表的联接
bool 	transform_table_subquery_to_join_with_derived (THD *thd, Item_exists_subselect *subq_pred)
//重新映射查询块中所有表的表号。
void 	remap_tables (THD *thd)
//是否解决涉及子查询的谓词。
bool 	resolve_subquery (THD *thd)
//将函数参数中按字段分组的事件标记为maybe_null，以便在添加汇总包装之前我们不会对其进行优化。
void 	mark_item_as_maybe_null_if_rollup_item (Item *item)
//通过使用Item_rollup_group_items替换与分组表达式匹配的项目并更新属性（maybe_null，PROP_ROLLUP_FIELD）来解析项目（及其树）以进行汇总处理。
Item * 	resolve_rollup_item (THD *thd, Item *item)
//解决SELECT列表和ORDER BY列表中的项目以进行汇总处理。
bool 	resolve_rollup (THD *thd)
//是否用匹配的列引用扩展表达式列表中的所有“ *”
bool 	setup_wild (THD *thd)
//在查询块完全解析之后，进行ORDER BY子句的最终设置。
bool 	setup_order_final (THD *thd)
//是否解决并设置GROUP BY列表。
bool 	setup_group (THD *thd)
void 	fix_after_pullout (SELECT_LEX *parent_select, SELECT_LEX *removed_select)
void 	remove_redundant_subquery_clauses (THD *thd, int hidden_group_field_count)
//遍历表列表并递归加入嵌套，并指向其select_lex指针
void 	repoint_contexts_of_join_nests (mem_root_deque< TABLE_LIST *> join_list)
//对order数组置空
void 	empty_order_list (SELECT_LEX *sl)
//是否解决联接嵌套的联接条件。
bool 	setup_join_cond (THD *thd, mem_root_deque< TABLE_LIST *> *tables, bool in_update)
//是否尝试将标识符与范围内的CTE相匹配
bool 	find_common_table_expr (THD *thd, Table_ident *table_id, TABLE_LIST *tl, Parse_context *pc, bool *found)
//将SELECT列表中的合格标量子查询，查询块[*]的WHERE条件，HAVING条件或JOIN条件转换为LEFT OUTER连接的等效派生表
bool 	transform_scalar_subqueries_to_join_with_derived (THD *thd)
bool 	transform_grouped_to_derived (THD *thd, bool *break_off)
bool 	replace_subquery_in_expr (THD *thd, Item_singlerow_subselect *subquery, TABLE_LIST *tr, Item **expr)
//将生成的派生表推入联接嵌套中的正确位置。
bool 	nest_derived (THD *thd, Item *join_cond, mem_root_deque< TABLE_LIST *> *join_list, TABLE_LIST *new_derived_table)
//是否解决表值构造函数的行并汇总行中每一列的类型
bool 	resolve_table_value_constructor_values (THD *thd)
//从合并的表格中删除未使用的列
void 	delete_unused_merged_columns (mem_root_deque< TABLE_LIST *> *tables)
//fix_prepare_information（）的助手
void 	fix_prepare_information_for_order (THD *thd, SQL_I_List< ORDER > *list, Group_list_ptrs **list_ptrs)
//是否准备表值构造函数查询块以进行优化
bool 	prepare_values (THD *thd)
//运行由ONLY_FULL_GROUP_BY强制执行的检查
bool 	check_only_full_group_by (THD *thd)
//检查偏移量和限制是否对半联接有效。
bool 	is_row_count_valid_for_semi_join ()

```

私有属性
```
//指向用于半/反联接转换的子查询候选集合的指针。
Mem_root_array< Item_exists_subselect * > * 	sj_candidates {nullptr}
//order中有多少个表达式，但不是选择列表
int 	hidden_order_field_count {0}
//同一查询表达式中所有查询块的侵入式双向链接列表。
SELECT_LEX * 	next {nullptr}
SELECT_LEX ** 	prev {nullptr}
//包含该查询块的查询表达式
SELECT_LEX_UNIT * 	master {nullptr}
//该查询块中包含的第一个查询表达式
SELECT_LEX_UNIT * 	slave {nullptr}
//侵入式双链接全局查询块列表
SELECT_LEX * 	link_next {nullptr}
SELECT_LEX ** 	link_prev {nullptr}
//该查询块的查询结果
Query_result * 	m_query_result {nullptr}
//从解析到整个解析所分配的选项，在解析完成后不应修改。
ulonglong 	m_base_options {0}
//激活的选项数目
ulonglong 	m_active_options {0}
//解决外部联接条件时使用
TABLE_LIST * 	resolve_nest
//连接查询块中的所有表后要评估的条件。
Item * 	m_where_cond
//分组后要在分组行上评估的条件
Item * 	m_having_cond
//添加到all_fields的GROUP BY表达式的数量
int 	hidden_group_field_count
//如果查询块具有合并到其中的半联接嵌套，则为True
bool 	has_sj_nests {false}
bool 	has_aj_nests {false}
//如果查询块具有右连接，则为True
bool 	m_right_joins {false}
//允许合并立即未命名的派生表。
bool 	allow_merge_derived {true}
bool 	m_agg_func_used {false}
bool 	m_json_agg_func_used {false}
//如果查询块在聚合之前（在准备过程中确定（不是优化））未生成任何行，则为true。
bool 	m_empty_query {false}
```

## sql解析Lex类
LEX对象当前具有三个不同的用途：
- 它包含SQL命令的一些通用属性，例如sql_command，数据更改语句语法中是否存在IGNORE以及表列表（query_tables）。
- 它包含一些执行状态变量，例如m_exec_started（开始执行时设置为true），插件（语句使用的插件列表），insert_update_values_map（某些INSERT语句使用的对象的映射）等。
- 它包含许多对Sql_cmd的子类来说是本地的成员，例如purge_value_list（对于PURGE命令），kill_value_list（对于KILL命令）。
- 对于由Sql_cmd类表示的SQL命令，LEX对象严格是Sql_cmd类的一部分。对于其余的SQL命令，它是链接到当前THD的独立对象。

LEX对象的生命周期如下：
- LEX对象可以在执行mem_root（对于常规语句），Prepared_statement mem_root（对于预处理语句），SP mem_root（对于存储过程指令）上构造，或者在当前mem_root上创建以用于短期使用。
- 在使用之前，调用lex_start（）初始化LEX对象。这将初始化对象的执行状态部分。它还调用LEX :: reset（）以确保正确初始化所有成员。
- 使用LEX作为工作区来解析并解析该语句。
- 执行一个SQL命令：开始执行时（实际上是开始优化时）调用set_exec_started（）。通常，调用is_exec_started（）来区分SQL命令执行的准备阶段和优化/执行阶段。
- 执行完成后，调用clear_execution（）。这将清除与SQL命令关联的所有执行状态，还包括调用LEX :: reset_exec_started（）。

```
typedef Prealloced_array< plugin_ref, INITIAL_LEX_PLUGIN_LIST_SIZE > 	Plugins_array
//#####继承自Query_tables_list的公共类型
enum  	{ START_SROUTINES_HASH_SIZE = 16 }
//该特定语句中表的锁定状态。
enum  	enum_lock_tables_state { LTS_NOT_LOCKED = 0, LTS_LOCKED }
//所有类型的不安全声明
enum  	enum_binlog_stmt_unsafe {
  BINLOG_STMT_UNSAFE_LIMIT = 0, BINLOG_STMT_UNSAFE_SYSTEM_TABLE, BINLOG_STMT_UNSAFE_AUTOINC_COLUMNS, BINLOG_STMT_UNSAFE_UDF,
  BINLOG_STMT_UNSAFE_SYSTEM_VARIABLE, BINLOG_STMT_UNSAFE_SYSTEM_FUNCTION, BINLOG_STMT_UNSAFE_NONTRANS_AFTER_TRANS, BINLOG_STMT_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE,
  BINLOG_STMT_UNSAFE_MIXED_STATEMENT, BINLOG_STMT_UNSAFE_INSERT_IGNORE_SELECT, BINLOG_STMT_UNSAFE_INSERT_SELECT_UPDATE, BINLOG_STMT_UNSAFE_WRITE_AUTOINC_SELECT,
  BINLOG_STMT_UNSAFE_REPLACE_SELECT, BINLOG_STMT_UNSAFE_CREATE_IGNORE_SELECT, BINLOG_STMT_UNSAFE_CREATE_REPLACE_SELECT, BINLOG_STMT_UNSAFE_CREATE_SELECT_AUTOINC,
  BINLOG_STMT_UNSAFE_UPDATE_IGNORE, BINLOG_STMT_UNSAFE_INSERT_TWO_KEYS, BINLOG_STMT_UNSAFE_AUTOINC_NOT_FIRST, BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN,
  BINLOG_STMT_UNSAFE_SKIP_LOCKED, BINLOG_STMT_UNSAFE_NOWAIT, BINLOG_STMT_UNSAFE_XA, BINLOG_STMT_UNSAFE_DEFAULT_EXPRESSION_IN_SUBSTATEMENT,
  BINLOG_STMT_UNSAFE_ACL_TABLE_READ_IN_DML_DDL, BINLOG_STMT_UNSAFE_COUNT
}

enum  	enum_stmt_accessed_table {
  STMT_READS_TRANS_TABLE = 0, STMT_READS_NON_TRANS_TABLE, STMT_READS_TEMP_TRANS_TABLE, STMT_READS_TEMP_NON_TRANS_TABLE,
  STMT_WRITES_TRANS_TABLE, STMT_WRITES_NON_TRANS_TABLE, STMT_WRITES_TEMP_TRANS_TABLE, STMT_WRITES_TEMP_NON_TRANS_TABLE,
  STMT_ACCESS_TABLE_COUNT
}

```
公共成员函数
```
SELECT_LEX * 	current_select () const
void 	assert_ok_set_current_select ()
void 	set_current_select (SELECT_LEX *select) 
bool 	is_explain () const 
//在语句内找到具有给定名称的用户变量的赋值
bool 	locate_var_assignment (const Name_string &name)
void 	insert_values_map (Item_field *f1, Field *f2)
void 	destroy_values_map ()
void 	clear_values_map () 
bool 	has_values_map () const 
std::map< Item_field *, Field * >::iterator 	begin_values_map ()
std::map< Item_field *, Field * >::iterator 	end_values_map () 
bool 	is_ignore () const
void 	set_ignore (bool ignore_param)
void 	set_has_udf () 
bool 	has_udf () const
//获取为此语句设置的选项
ulonglong 	statement_options ()
//将选项添加到m_statement_options的值
void 	add_statement_options (ulonglong options) 
bool 	is_broken () const
//如果某些永久性转换（例如in2exists）失败，则可能会使LEX处于不一致状态。
void 	mark_broken (bool broken=true)
//检查准备好的语句的准备状态是否无效。
bool 	check_preparation_invalid (THD *thd) 
void 	cleanup (THD *thd, bool full) 
bool 	is_exec_started () const 
void 	set_exec_started ()
void 	reset_exec_started () 
//检查该语句是否已执行（无论是否完成-成功还是错误）
bool 	is_exec_completed () const
void 	set_exec_completed ()
sp_pcontext * 	get_sp_current_parsing_ctx () 
void 	set_sp_current_parsing_ctx (sp_pcontext *ctx)
//检查当前语句是否使用元数据（使用表或存储的例程）。
bool 	is_metadata_used () const
 	LEX () 
virtual 	~LEX ()
//销毁包含的对象，但不销毁LEX对象本身
void 	destroy ()
//将查询上下文重置为初始状态。
void 	reset ()
//在此LEX对象中创建一个空的查询块。
SELECT_LEX * 	new_empty_query_block ()
//创建包含一个查询块的查询表达式对象
SELECT_LEX * 	new_query (SELECT_LEX *curr_select)
//创建查询块并将其附加到当前查询表达式。
SELECT_LEX * 	new_union_query (SELECT_LEX *curr_select, bool distinct)
//是否创建顶级查询表达式和查询块。
bool 	new_top_level_query ()
//在现有内存对象中创建查询表达式和查询块
void 	new_static_query (SELECT_LEX_UNIT *sel_unit, SELECT_LEX *select)
//在current_select下创建查询表达式，并在新查询表达式下创建查询块。
SELECT_LEX_UNIT * 	create_query_expr_and_block (THD *thd, SELECT_LEX *current_select, Item *where_clause, Item *having_clause, enum_parsing_context ctx)
bool 	is_ps_or_view_context_analysis ()
bool 	is_view_context_analysis ()
//在准备或执行语句之后（再执行）之前，清除该语句的执行状态。
void 	clear_execution ()
//将当前查询设置为不可缓存。
void 	set_uncacheable (SELECT_LEX *curr_select, uint8 cause)
//在已使用表的列表中设置此TABLE_LIST对象的初始用途。
void 	set_trg_event_type_for_tables ()
TABLE_LIST * 	unlink_first_table (bool *link_to_local)
void 	link_first_table_back (TABLE_LIST *first, bool link_to_local)
void 	first_lists_tables_same ()
void 	restore_cmd_properties ()
void 	restore_properties_for_insert ()
bool 	save_cmd_properties (THD *thd)
//检查命令是否可以将VIEW与MERGE算法一起使用
bool 	can_use_merged ()
//检查命令是否在命令的任何部分都不能使用合并视图。
bool 	can_not_use_merged () 
bool 	need_correct_ident ()
bool 	which_check_option_applicable ()
void 	cleanup_after_one_table_open ()
bool 	push_context (Name_resolution_context *context)
void 	pop_context ()
//仅在解析期间应调用此方法。
bool 	copy_db_to (char const **p_db, size_t *p_db_length) const 
bool 	copy_db_to (char **p_db, size_t *p_db_length) const
Name_resolution_context * 	current_context ()
void 	reset_n_backup_query_tables_list (Query_tables_list *backup) 
void 	restore_backup_query_tables_list (Query_tables_list *backup)
bool 	table_or_sp_used ()
//检查该语句是否为单级联接
bool 	is_single_level_stmt ()
bool 	accept (Select_lex_visitor *visitor) 
bool 	set_wild (LEX_STRING) 
void 	clear_privileges ()
//使用parse_tree实例化Sql_cmd对象并将其分配给Lex
bool 	make_sql_cmd (Parse_tree_root *parse_tree) 
//获取此语句的辅助引擎执行上下文。
Secondary_engine_execution_context * 	secondary_engine_execution_context () const
//设置此语句的辅助引擎执行上下文
void 	set_secondary_engine_execution_context (Secondary_engine_execution_context *context) 
bool 	is_replication_deprecated_syntax_used ()
void 	set_replication_deprecated_syntax_used ()
//设置复制通道名称。
bool 	set_channel_name (LEX_CSTRING name={})

```
公有属性
```
//最外面的查询表达式
SELECT_LEX_UNIT * 	unit
//第一个查询块
SELECT_LEX * 	select_lex
//所有查询块列表
SELECT_LEX * 	all_selects_list 
bool 	is_explain_analyze = false
LEX_STRING 	name
char * 	help_arg
char * 	to_log
const char * 	x509_subject 
const char * 	x509_issuer
const char * 	ssl_cipher
String * 	wild
Query_result * 	result
//BINLOG事件语句的参数
LEX_STRING 	binlog_stmt_arg
LEX_STRING 	ident
LEX_USER * 	grant_user
LEX_ALTER 	alter_password
enum_alter_user_attribute 	alter_user_attribute
LEX_STRING 	alter_user_comment_text
LEX_GRANT_AS 	grant_as
THD * 	thd
Opt_hints_global * 	opt_hints_global
Plugins_array 	plugins
//将表插入（可能是视图）
TABLE_LIST * 	insert_table
//插入叶表（始终是基表）
TABLE_LIST * 	insert_table_leaf
//SELECT CREATE VIEW语句。
LEX_STRING 	create_view_select
partition_info * 	part_info
LEX_USER * 	definer
List< LEX_USER > 	users_list
List< LEX_COLUMN > 	columns
List< LEX_CSTRING > 	dynamic_privileges
List< LEX_USER > * 	default_roles
ulonglong 	bulk_insert_row_cnt
List< Item > 	purge_value_list
List< Item > 	kill_value_list
List< set_var_base > 	var_list
List< Item_func_set_user_var > 	set_var_list
//准备好的语句的参数的占位符（'？'）列表。
List< Item_param > 	param_list
List< Name_resolution_context > 	context_stack
Item_sum * 	in_sum_func
udf_func 	udf
HA_CHECK_OPT 	check_opt
HA_CREATE_INFO * 	create_info
KEY_CREATE_INFO 	key_create_info
LEX_MASTER_INFO 	mi
LEX_SLAVE_CONNECTION 	slave_connection
Server_options 	server_options
USER_RESOURCES 	mqh
LEX_RESET_SLAVE 	reset_slave_info
ulong 	type
//该字段在解析过程中用作工作字段，以验证聚合函数的使用
nesting_map 	allow_sum_func
//HAVING中不允许使用窗口函数（与组聚合相反），然后我们需要比allow_sum_func严格。
nesting_map 	m_deny_window_func
//如果为true：在准备过程中，我们进行了子查询转换（IN-to-EXISTS，SOME / ANY），该转换当前不适用于子查询到派生表转换。
bool 	m_subquery_to_derived_is_impossible
Sql_cmd * 	m_sql_cmd
bool 	expr_allows_subselect
//如果当前正在重新解析CTE的定义，则这是具有WITH子句的原始语句中该定义的偏移量（以字节为单位）。
uint 	reparse_common_table_expr_at
enum SSL_type 	ssl_type
enum enum_duplicates 	duplicates
enum enum_tx_isolation 	tx_isolation
enum enum_var_type 	option_type
enum_view_create_mode 	create_view_mode
//SHOW PROFILE的查询ID。
my_thread_id 	show_profile_query_id
uint 	profile_options
uint 	grant
uint 	grant_tot_col
bool 	grant_privilege
uint 	slave_thd_opt
uint 	start_transaction_opt
//查询块数（按EXPLAIN）
int 	select_number
uint8 	create_view_algorithm
uint8 	create_view_check
uint8 	context_analysis_only
bool 	drop_if_exists
bool 	drop_temporary
bool 	autocommit
bool 	verbose
bool 	no_write_to_binlog
bool 	m_extended_show
enum enum_yes_no_unknown tx_chain 	tx_release
//给定不变的数据，此查询是否每次都会返回相同的答案。
bool 	safe_to_cache_query
st_parsing_options 	parsing_options 
Alter_info * 	alter_info
LEX_CSTRING 	prepared_stmt_name
LEX_STRING 	prepared_stmt_code
bool 	prepared_stmt_code_is_varref
List< LEX_STRING > 	prepared_stmt_params
sp_head * 	sphead
sp_name * 	spname
bool 	sp_lex_in_use
bool 	all_privileges
bool 	contains_plaintext_password
enum_keep_diagnostics 	keep_diagnostics
uint32 	next_binlog_file_nr
st_sp_chistics 	sp_chistics
Event_parse_data * 	event_parse_data
bool 	only_view
uint8 	create_view_suid
//旨在在以下语句中指向DEFINER子句之后的下一个单词
const char * 	stmt_definition_begin
const char * 	stmt_definition_end
//在名称解析期间，仅在由Name_resolution_context :: first_name_resolution_table和Name_resolution_context :: last_name_resolution_table给出的表列表中搜索
bool 	use_only_table_context
bool 	is_lex_started
//解析ON DUPLICATE KEY UPDATE子句中的值时设置为true
bool 	in_update_value_clause
class Explain_format * 	explain_format
ulong 	max_execution_time
bool 	binlog_need_explicit_defaults_ts
//用于通知解析器是否应该上下文化解析树。
bool 	will_contextualize
//IS模式查询从SE读取一些动态表统计信息
dd::info_schema::Table_statistics 	m_IS_table_stats
dd::info_schema::Tablespace_statistics 	m_IS_tablespace_stats

```

私有属性
```
SELECT_LEX * 	m_current_select
std::map< Item_field *, Field * > * 	insert_update_values_map
//如果语句引用UDF函数，则为True
bool 	m_has_udf {false}
bool 	ignore
bool 	m_broken
//执行开始时设置为true（解析后，打开表并完成查询准备）
bool 	m_exec_started
//当执行完成（即优化已完成且执行成功或错误结束）时设置为true
bool 	m_exec_completed
//当前的SP解析上下文
sp_pcontext * 	sp_current_parsing_ctx
//SELECT_LEX :: make_active_options的语句上下文
ulonglong 	m_statement_options {0}
//辅助存储引擎用于优化和执行期间存储查询状态的上下文对象
Secondary_engine_execution_context * 	m_secondary_engine_context {nullptr}
bool 	m_is_replication_deprecated_syntax_used {false}

```
其他函数
```
//在要准备和执行的每个查询之前，请调用lex_start（）。
bool 	lex_start (THD *thd)
static const char * 	stmt_accessed_table_string (enum_stmt_accessed_table accessed_table)
//设置了从0（含）到BINLOG_STMT_FLAG_COUNT（不含）的所有标志。
static const int 	BINLOG_STMT_UNSAFE_ALL_FLAGS
//将enum_binlog_stmt_unsafe的元素映射到错误代码
static const int 	binlog_stmt_unsafe_errcode [BINLOG_STMT_UNSAFE_COUNT]
```

## TABLE类
表类定义了MySQL 数据库表在 MySQL 内存中的形式。表以两种形式存在——-打开或关闭状态。MySQL要想使用表，必须先将其打开。表描述类是在表被打开时创建。表描述类创建后会被置于表缓存(table_cache)中，等待下一个查询的重用，以提高访问的效率。
表描述类对象经常在查询解析、查询优化、访问控制和查询缓存代码中被引用。所以了解它的组成有助于读者对MySQL底层对表操作的理解。
sql下的table.h
```
//优化和执行后重置字段状态
void 	reset ()
//初始化TABLE实例（新创建的实例，或来自表缓存或THD :: temporary_tables列表的实例），并准备在语句执行期间进一步使用。  
void 	init (THD *thd, TABLE_LIST *tl)
//将表初始化为内部tmp表。
bool 	init_tmp_table (THD *thd, TABLE_SHARE *share, MEM_ROOT *m_root, CHARSET_INFO *charset, const char *alias, Field **fld, uint *blob_fld, bool is_virtual)
//为表中的每一列创建Item_field。
bool 	fill_item_list (mem_root_deque< Item *> *item_list) const
//重置现有的Item_field项目列表以指向该表的Fields    
void 	reset_item_list (const mem_root_deque< Item *> &item_list) const
void 	clear_column_bitmaps (void)
//告诉handler我们将在稍后调用position（）和rnd_pos（）。
void 	prepare_for_position (void)
//根据mark_used将列标记为已读或已写（或无）。
void 	mark_column_used (Field *field, enum enum_mark_columns mark)
//标记键使用的列，但不要重置其他字段
void 	mark_columns_used_by_index_no_reset (uint index, MY_BITMAP *map, uint key_parts=0) const
void 	mark_columns_used_by_index (uint index)
//在读写映射中将自动递增字段标记为已使用字段 
void 	mark_auto_increment_column (void)
//标记更新行所需的列。
void 	mark_columns_needed_for_update (THD *thd, bool mark_binlog_columns)
void 	mark_columns_needed_for_delete (THD *thd) 
void 	mark_columns_needed_for_insert (THD *thd)
void 	mark_columns_per_binlog_row_image (THD *thd)
//在执行更新和插入操作时，更新生成列的write / read_set。
void 	mark_generated_columns (bool is_update)
//将生成的列及其依赖项添加到read_set / write_set位图。
void 	mark_gcol_in_maps (const Field *field)
//在执行更新和插入操作时，使用检查约束评估所需的列更新read_map。
void 	mark_check_constraint_columns (bool is_update)
void 	column_bitmaps_set (MY_BITMAP *read_set_arg, MY_BITMAP *write_set_arg)
void 	column_bitmaps_set_no_signal (MY_BITMAP *read_set_arg, MY_BITMAP *write_set_arg)
void 	use_all_columns ()
void 	default_column_bitmaps ()
//应该重新打开该表的实例吗？ 
bool 	needs_reopen ()
Field ** 	visible_field_ptr () const
uint 	visible_field_count () const
//为物化派生表分配键的空间。
bool 	alloc_tmp_keys (uint new_key_count, uint new_key_part_count, bool modify_share)
//将一个键添加到实例化派生表。    
bool 	add_tmp_key (Field_map *key_parts, bool invisible, bool modify_share)
//对于物化派生表：将KEY定义从某个位置复制到第一个尚未使用的位置（较低的位置）
void 	copy_tmp_key (int old_idx, bool modify_share)
//对于物化的派生表：在copy_tmp_key（）复制了所有已用键的定义之后，在TABLE :: key_info中，我们有一个已用键的头，后跟一个未用键的尾；此功能可消除尾巴。
void 	drop_unused_tmp_keys (bool modify_share) 
void 	set_keyread (bool flag)
//检查给定索引是否具有虚拟生成的列。
bool 	index_contains_some_virtual_gcol (uint index_no) const
//为单个表UPDATE / DELETE查询更新TABLE :: const_key_parts
bool 	update_const_key_parts (Item *conds)
//如果所选的快速读取方法正在使用完全唯一索引，则可以删除读取。
bool 	check_read_removal (uint index)
ptrdiff_t 	default_values_offset () const
bool 	has_storage_handler () const
// 为临时表设置存储handler
void 	set_storage_handler (handler *file_arg)
//如果表已实例化，则返回true，否则返回false
bool 	is_created () const
//将表设置为“ created”，并启用没有实例化表无法启用的存储引擎中的标志。
void 	set_created ()
//删除内容后，将表的内容设置为“删除”，即“未创建”。
void 	set_deleted ()
//将表设置为可为空，即它在某些外部联接的内部。
void 	set_nullable ()
//返回表是否为空
bool 	is_nullable () const
bool 	has_gcol () const
//行缓冲区的生命周期如下 
void 	set_not_started ()
bool 	is_started () const
// 设置行缓冲区的状态：包含行
void 	set_found_row ()
//设置行缓冲区的状态：不包含任何行。
void 	set_no_row ()
//从handler的结果中设置“row found”状态
void 	set_row_status_from_handler (int status)
//将当前行设置为“空行”，以用于空补充的外部联接
void 	set_null_row ()
//对当前行清除设置到“null now”的状态
void 	reset_null_row ()
//为当前行设置”updated"属性 
void 	set_updated_row ()
//为当前行设置“deleted"属性 
void 	set_deleted_row ()
bool 	has_row () const
bool 	has_null_row () const
bool 	has_updated_row () const
bool 	has_deleted_row () const
//将当前行的NULL标志保存到指定的缓冲区中      
void 	save_null_flags ()
//从指定的缓冲区还原当前行的NULL标志。
void 	restore_null_flags ()
//清空内部临时表（删除行，关闭扫描） 
bool 	empty_result_table ()
//初始化优化程序成本模型。
void 	init_cost_model (const Cost_model_server *cost_model_server)
//返回此表的成本模型对象 
const Cost_model_table * 	cost_model () const
//修复表的生成列（GC）和/或默认表达式 
void 	refix_value_generator_items (THD *thd)
//refix_value_generator_items（）的辅助函数，用于修复一列的表达式（无论是GC还是默认表达式）并检查约束表达式。
void 	refix_inner_value_generator_items (Value_generator *g_expr)
//清除与生成的列关联的项目中的任何状态，以准备下一条语句。 
void 	cleanup_value_generator_items ()
void 	set_tmp_table_seq_id (uint arg)
//根据最大读取密钥长度更新覆盖密钥。 
void 	update_covering_prefix_keys (Field *field, uint16 key_read_length, Key_map *covering_prefix_keys)
//该表在当前行中是否有可以使用部分更新来更新的列？ 
bool 	has_binary_diff_columns () const
//获取已为当前行中的给定列收集的二进制差异列表，如果无法对该列使用部分更新，则返回nullptr。
const Binary_diff_vector * 	get_binary_diffs (const Field *field) const
//将给定列标记为可以在执行update语句期间使用部分更新来更新的列。 
bool 	mark_column_for_partial_update (const Field *field)
//此列是否已标记为部分更新？
bool 	is_marked_for_partial_update (const Field *field) const
//该表是否有标记为mark_column_for_partial_update（）的列？
bool 	has_columns_marked_for_partial_update () const
//在此表中启用JSON列的部分更新。
bool 	setup_partial_update (bool logical_diffs)
bool 	setup_partial_update ()
//为使用部分更新更新的列添加二进制差异。
bool 	add_binary_diff (const Field *field, size_t offset, size_t length)
//清除为JSON列的部分更新而收集的差异，并为临时禁用当前行的部分更新的所有列重新启用部分更新。 
void 	clear_partial_update_diffs ()
//清理用于部分更新JSON列的状态。 
void 	cleanup_partial_update ()
//暂时禁用当前行中某一列的二进制差异集合。
void 	disable_binary_diffs_for_current_row (const Field *field)
//暂时禁止收集描述当前行中JSON列的逻辑更改的Json_diff对象。
void 	disable_logical_diffs_for_current_row (const Field *field) const 
//获取一个缓冲区，该缓冲区可用于在执行部分更新时保存部分更新的列值。 
String * 	get_partial_update_buffer ()
//将描述逻辑更改的逻辑JSON差异添加到部分更新中的JSON列 
void 	add_logical_diff (const Field_json *field, const Json_seekable_path &path, enum_json_diff_operation operation, const Json_wrapper *new_value)
//获取已为当前行中的给定列收集的JSON差异列表，如果无法对该列使用部分更新，则返回nullptr。
const Json_diff_vector * 	get_logical_diffs (const Field_json *field) const
//是否在此JSON列上启用了使用二进制差异进行的部分更新？
bool 	is_binary_diff_enabled (const Field *field) const
//是否在此JSON列上启用了使用逻辑差异的部分更新？ 
bool 	is_logical_diff_enabled (const Field *field) const
//BLOB类型的虚拟字段具有标志m_keep_old_value。 
void 	blobs_need_not_keep_old_value ()
//设置变量should_binlog_drop_if_temp_flag，以便可以确定临时表的日志记录。
void 	set_binlog_drop_if_temp (bool should_binlog)
bool 	should_binlog_drop_if_temp (void) const

```
公共属性
```
TABLE_SHARE * 	s {nullptr}
handler * 	file {nullptr}
TABLE * 	next {nullptr}
TABLE * 	prev {nullptr}
//一个位图，标记存在的功能索引存在的隐藏的已生成列。 
MY_BITMAP 	fields_for_functional_indexes
THD * 	in_use {nullptr}
Field ** 	field {nullptr}
//隐藏字段的计数（如果有内部临时表）；否则为0。 
uint 	hidden_field_count {0}
uchar * 	record [2] {nullptr, nullptr}
uchar * 	write_row_record {nullptr}
uchar * 	insert_values {nullptr}
//用于多行读取的缓冲区。最初是空的。 
Record_buffer 	m_record_buffer {0, 0, nullptr}
Key_map 	covering_keys
Key_map 	quick_keys
Key_map 	merge_keys
Key_map 	possible_quick_keys
Key_map 	keys_in_use_for_query
Key_map 	keys_in_use_for_group_by
Key_map 	keys_in_use_for_order_by
KEY * 	key_info {nullptr}
// 生成键的键部分数组，用于物化派生表
KEY_PART_INFO * 	base_key_parts {nullptr}
Field * 	next_number_field {nullptr}
Field * 	found_next_number_field {nullptr}
//指向生成的列的指针 
Field ** 	vfield {nullptr}
//指向具有默认值的字段的指针。
Field ** 	gen_def_fields_ptr {nullptr}
//唯一约束使用的字段。 
Field * 	hash_field {nullptr}
Field * 	fts_doc_id_field {nullptr}
Table_trigger_dispatcher * 	triggers {nullptr}
TABLE_LIST * 	pos_in_table_list {nullptr}
TABLE_LIST * 	pos_in_locked_tables {nullptr}
ORDER * 	group {nullptr}
//表的别名 
const char * 	alias {nullptr}
//指向记录[0]的空标志的指针 
uchar * 	null_flags {nullptr}
//当null_row为true时保存null_flags。 
uchar * 	null_flags_saved
MY_BITMAP 	def_read_set
MY_BITMAP 	def_write_set
MY_BITMAP 	tmp_set
MY_BITMAP 	pack_row_tmp_set
MY_BITMAP 	cond_set
//表字段（列）的位图，在INSERT INTO语句中明确设置 
MY_BITMAP 	def_fields_set_during_insert
//设置优化器打算读取的所有列。
MY_BITMAP * 	read_set {nullptr}
MY_BITMAP * 	write_set {nullptr}
//指向表字段（列）的位图的指针，该字段在INSERT INTO语句中明确设置 
MY_BITMAP * 	fields_set_during_insert {nullptr}
query_id_t 	query_id {0}
ha_rows 	quick_rows [MAX_KEY] {0}
key_part_map 	const_key_parts [MAX_KEY] {0}
uint 	quick_key_parts [MAX_KEY] {0}
uint 	quick_n_ranges [MAX_KEY] {0}
ha_rows 	quick_condition_rows {0}
uint 	lock_position {0}
uint 	lock_data_start {0}
uint 	lock_count {0}
uint 	db_stat {0}
int 	current_lock {0}
Sql_table_check_constraint_list * 	table_check_constraint_list {nullptr}
bool 	null_row {false}
bool 	copy_blobs {false}
bool 	force_index {false}
//语句包含FORCE INDEX FOR ORDER BY时设置的标志，请参见TABLE_LIST :: process_index_hints（） 
bool 	force_index_order {false}
//语句包含FORCE INDEX FOR GROUP BY时设置的标志，请参见TABLE_LIST :: process_index_hints（）
bool 	force_index_group {false}
bool 	const_table {false}
//如果写入此表不应写入行，而仅写入键，则为True。 
bool 	no_rows {false}
//如果设置，优化器发现行检索应仅访问索引树。
bool 	key_read {false}
//某些需要整行的语句将其设置为禁止仅索引访问。
bool 	no_keyread {false}
//如果设置，指示服务器未复制该表
bool 	no_replicate {false}
bool 	fulltext_searched {false}
bool 	no_cache {false}
bool 	open_by_handler {false}
//指示auto_increment字段的值是由用户或其他来源显式提供的 
bool 	autoinc_field_has_explicit_non_null_value {false}
bool 	alias_name_used {false}
bool 	get_fields_in_item_tree {false}
//该表是否必须重新打开，并且不能重复使用 
bool 	m_needs_reopen {false}
//是否物化，true:是的
bool 	materialized {false}
struct {
   class JOIN_TAB *   join_tab {nullptr}
   class QEP_TAB *   qep_tab {nullptr}
   thr_lock_type   lock_type {TL_UNLOCK}
   thr_locked_row_action   locked_row_action {THR_DEFAULT}
   bool   not_exists_optimize {false}
   bool   impossible_range {false}
} 	reginfo
MEM_ROOT 	mem_root
//如果GROUP_CONCAT与ORDER BY | | |一起使用，则在Item_func_group_concat :: setup中为适当的临时表初始化。 DISTINCT和BLOB字段计数>0。 
Blob_mem_storage * 	blob_storage {nullptr}
//不归表所有；仅用于filesort_free_buffers（）
SortingIterator * 	sorting_iterator {nullptr}
SortingIterator * 	duplicate_removal_iterator {nullptr}
//如果对表应用唯一操作（按行ID）的结果 
Sort_result 	unique_result
partition_info * 	part_info {nullptr}
bool 	all_partitions_pruned_away {false}
MDL_ticket * 	mdl_ticket {nullptr}

```
私有属性
```
//Table_cache特定实例中特定表的已使用/未使用TABLE对象列表的链接（换言之，特定Table_cache_element对象）。
TABLE * 	cache_next {nullptr}
TABLE ** 	cache_prev {nullptr}
//如果为true，则此表为内部表。 
bool 	nullable {false}
uint8 	m_status {0}
//针对临时表 
bool 	created {false}
//此表上操作的成本模型对象。
Cost_model_table 	m_cost_model
//内部tmp表序号
uint 	tmp_table_seq_id {0}
//位图，在更新语句中告诉哪些列适合部分更新
MY_BITMAP * 	m_partial_update_columns {nullptr}
//包含执行时间状态的对象，用于部分更新JSON列。
Partial_update_info * 	m_partial_update_info {nullptr}
//这个标志决定了我们是否应该记录放置临时表命令。
bool 	should_binlog_drop_if_temp_flag {false}
```

## Field类
Field类用于描述表中的列或属性。Field是对列数据类型以及属性的定义。Field类是一个抽象类。Field类有许多的具体子类。几乎每种类型的列都有相对应的Field子类。
sql下的Field.h文件 ,其继承派生关系如下
```
Field基类->Field_Num类->Field_real类->Field_decimal类
								   ->Field_float
								   ->Field_double
                     ->Field_new_decimal类
                     ->Field_tiny类->Field_year
                     ->Field_short类
                     ->Field_medium类
                     ->Field_long类
                     ->Field_longlong
        ->Field_bit类->Field_bit_as_char 
        ->Field_str类->Field_longstr类->Field_string
                                     ->Field_varstring
                                     ->Field_blob->Field_geom 
                                                 ->Field_json->Field_typed_array 
					 ->Field_null
					 ->Field_enum->Field_set
					 
	    ->Field_temporal类->Field_temporal_with_date类->Field_temporal_with_date_and_time类->Field_temporal_with_date_and_timef->Field_timestampf
	                               ->Field_datetimef
	                                                                                      ->Field_timestamp
	                                                 ->Field_newdate
	                                                                                      ->Field_datetime 
	                                                 
	                     ->Field_time_common->Field_time 
	                                        ->Field_timef         
	    

```
公共函数
```
 	Field (const Field &)=default
void 	operator= (Field &)=delete
//检查该字段是否标记为具有通用表达式以生成默认值
bool 	has_insert_default_general_value_expression () const
//检查该字段是否标记为具有日期时间值表达式以在插入时生成默认值。
bool 	has_insert_default_datetime_value_expression () const
//检查该字段是否标记为具有日期时间值表达式以在更新时生成默认值。
bool 	has_update_default_datetime_value_expression () const
uchar * 	get_null_ptr ()
virtual void 	set_field_length (uint32 length)
bool 	is_flag_set (unsigned flag) const
void 	set_flag (unsigned flag)
void 	clear_flag (unsigned flag)
uint32 	all_flags () const
//字段时有符号的还是无符号的
virtual bool 	is_unsigned () const
bool 	is_gcol () const
bool 	is_virtual_gcol () const
//设置此字段的隐藏类型
void 	set_hidden (dd::Column::enum_hidden_type hidden)
dd::Column::enum_hidden_type 	hidden () const
bool 	is_hidden_from_user () const
//该字段是否具备函数索引 
bool 	is_field_for_functional_index () const
virtual 	~Field ()=default
void 	reset_warnings ()
//打开该字段的临时可空性
void 	set_tmp_nullable ()
//关闭该字段的临时为空性
void 	reset_tmp_nullable ()
//重置字段的临时NULL值。
void 	reset_tmp_null ()
//设置字段的临时null值
void 	set_tmp_null ()
bool 	is_tmp_nullable () const
bool 	is_tmp_null () const 
virtual type_conversion_status 	store (const char *to, size_t length, const CHARSET_INFO *cs)=0
virtual type_conversion_status 	store (double nr)=0
virtual type_conversion_status 	store (longlong nr, bool unsigned_val)=0
//将时间值以打包longlong格式存储到字段中
virtual type_conversion_status 	store_packed (longlong nr)
virtual type_conversion_status 	store_decimal (const my_decimal *d)=0
//将具有给定十进制位数的MYSQL_TIME值存储到字段中。
virtual type_conversion_status 	store_time (MYSQL_TIME *ltime, uint8 dec_arg)
//当小数位数不重要或未知时，将MYSQL_TYPE值存储到字段中
type_conversion_status 	store_time (MYSQL_TIME *ltime)
type_conversion_status 	store (const char *to, size_t length, const CHARSET_INFO *cs, enum_check_fields check_level) 
virtual double 	val_real () const =0
virtual longlong 	val_int () const =0
//以打包longlong格式返回TIME值
virtual longlong 	val_time_temporal () const
//以打包longlong格式返回DATE/DATETIME值
virtual longlong 	val_date_temporal () const
virtual longlong 	val_time_temporal_at_utc () const
virtual longlong 	val_date_temporal_at_utc () const
//根据字段类型返回TIME或DATE / DATETIME字段的“本机”打包longlong表示形式
longlong 	val_temporal_by_field_type () const
virtual my_decimal * 	val_decimal (my_decimal *) const =0
String * 	val_str (String *str) const
virtual String * 	val_str (String *, String *) const =0
//将字段值解释为整数，但将结果作为字符串返回。 
String * 	val_int_as_str (String *val_buffer, bool unsigned_flag) const
virtual bool 	str_needs_quotes () const
virtual Item_result 	result_type () const =0
// 当它出现在数字上下文中时，返回字段的Item_result类型，例如：SELECT time_column + 1; SELECT SUM（time_column）;
virtual Item_result 	numeric_context_result_type () const
virtual Item_result 	cmp_type () const
virtual Item_result 	cast_to_int_type () const
//检查生成的列的表达式是否相同。
bool 	gcol_expr_is_equal (const Create_field *field) const
virtual bool 	eq (const Field *field) const
virtual bool 	eq_def (const Field *field) const
virtual uint32 	pack_length () const
virtual uint32 	pack_length_in_rec () const
//检查字段大小是否与目标兼容
virtual bool 	compatible_field_size (uint metadata, Relay_log_info *, uint16, int *order) const
virtual uint 	pack_length_from_metadata (uint field_metadata) const
virtual uint 	row_pack_length () const
int 	save_field_metadata (uchar *first_byte)
virtual uint32 	data_length (ptrdiff_t row_offset=0) const
//以压缩格式获取数据的最大大小。
virtual uint32 	max_data_length () const
virtual type_conversion_status 	reset ()
//以struct timeval格式返回UTC组件。
virtual bool 	get_timestamp (struct timeval *tm, int *warnings) const
// 在字段中以timeval格式存储时间戳记值
virtual void 	store_timestamp (const timeval *)
virtual void 	set_default ()
//评估INSERT默认功能并将结果存储在字段中
void 	evaluate_insert_default_function ()
//评估UPDATE默认函数（如果存在），并将结果存储在记录缓冲区中
void 	evaluate_update_default_function ()
virtual bool 	binary () const
virtual bool 	zero_pack () const
virtual enum ha_base_keytype 	key_type () const
virtual uint32 	key_length () const
virtual enum_field_types 	type () const =0
virtual enum_field_types 	real_type () const
virtual enum_field_types 	binlog_type () const
int 	cmp (const uchar *str) const
virtual int 	cmp_max (const uchar *a, const uchar *b, uint max_len) const
virtual int 	cmp (const uchar *, const uchar *) const =0
virtual int 	cmp_binary (const uchar *a, const uchar *b, uint32 max_length=~0L) const
virtual int 	cmp_offset (ptrdiff_t row_offset) const
virtual int 	cmp_binary_offset (ptrdiff_t row_offset) const
virtual int 	key_cmp (const uchar *a, const uchar *b) const
virtual int 	key_cmp (const uchar *str, uint length) const
virtual uint 	decimals () const
virtual bool 	is_text_key_type () const
virtual void 	sql_type (String &str) const =0
//检查整个表的行是否为NULL或字段的值为NULL
bool 	is_null (ptrdiff_t row_offset=0) const
//检查字段的值为NULL（临时还是实际）
bool 	is_real_null (ptrdiff_t row_offset=0) const
//检查此字段的值是否为NULL或参数指定的记录是否为此字段值NULL
bool 	is_null_in_record (const uchar *record) const
//设置字段的值为null
void 	set_null (ptrdiff_t row_offset=0)
//设置字段的值为not null
void 	set_notnull (ptrdiff_t row_offset=0)
//
type_conversion_status 	check_constraints (int mysql_errno)
 	Check NOT NULL constraint on the field after temporary nullability is disabled. More...
 
void 	set_check_for_truncated_fields (enum_check_fields check_for_truncated_fields)
 	Remember the value of THD::check_for_truncated_fields to handle possible NOT-NULL constraint errors after BEFORE-trigger execution is finished. More...
 
bool 	is_nullable () const
uint 	null_offset (const uchar *record) const
uint 	null_offset () const
void 	set_null_ptr (uchar *p_null_ptr, uint p_null_bit)
//使用有关此Field对象表示的列的元数据填充Send_field对象
virtual void 	make_send_field (Send_field *send_field) const
//将当前值的副本写到记录缓冲区中，适合使用逐字节比较进行排序
virtual size_t 	make_sort_key (uchar *buff, size_t length) const =0
virtual bool 	optimize_range (uint idx, uint part) const
virtual bool 	can_be_compared_as_longlong () const
virtual void 	mem_free ()
virtual Field * 	new_field (MEM_ROOT *root, TABLE *new_table) const
Field * 	new_field (MEM_ROOT *root, TABLE *new_table, uchar *new_ptr, uchar *new_null_ptr, uint new_null_bit) const
virtual Field * 	new_key_field (MEM_ROOT *root, TABLE *new_table, uchar *new_ptr, uchar *new_null_ptr, uint new_null_bit) const
Field * 	new_key_field (MEM_ROOT *root, TABLE *new_table, uchar *new_ptr) const
//对字段对象做浅拷贝
virtual Field * 	clone (MEM_ROOT *mem_root) const =0
void 	move_field (uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg)
virtual void 	move_field_offset (ptrdiff_t ptr_diff)
virtual void 	get_image (uchar *buff, size_t length, const CHARSET_INFO *) const
virtual void 	set_image (const uchar *buff, size_t length, const CHARSET_INFO *)
virtual size_t 	get_key_image (uchar *buff, size_t length, imagetype type) const
virtual void 	set_key_image (const uchar *buff, size_t length)
longlong 	val_int_offset (ptrdiff_t row_offset)
longlong 	val_int (uchar *new_ptr)
String * 	val_str (String *str, uchar *new_ptr)
//使用与字段类型匹配的正确Protocol :: store *（）函数通过协议发送此字段的值。
virtual bool 	send_to_protocol (Protocol *protocol) const
//将字段打包成适合存储和传输的格式
virtual uchar * 	pack (uchar *to, const uchar *from, size_t max_length) const
uchar * 	pack (uchar *to) const
//从行数据中解压缩字段。
virtual const uchar * 	unpack (uchar *to, const uchar *from, uint param_data)
const uchar * 	unpack (const uchar *from)
//此函数与pack（）的功能相同，不同之处在于max_length并不表示输出中的字节数，而是输入的最大字段长度（必须精确地是field-> max_field_length（））
virtual uchar * 	pack_with_metadata_bytes (uchar *to, const uchar *from, uint max_length) const
//以diff格式写入二进制日志的字段
virtual bool 	pack_diff (uchar **to, ulonglong value_options) const
virtual uint 	max_packed_col_length () const
uint 	offset (uchar *record) const
void 	copy_data (ptrdiff_t src_record_offset)
virtual bool 	get_date (MYSQL_TIME *ltime, my_time_flags_t fuzzydate) const
virtual bool 	get_time (MYSQL_TIME *ltime) const
virtual const CHARSET_INFO * 	charset () const
const CHARSET_INFO * 	charset_for_protocol () const
virtual const CHARSET_INFO * 	sort_charset () const
virtual bool 	has_charset () const
virtual bool 	match_collation_to_optimize_range () const
virtual enum Derivation 	derivation () const
virtual uint 	repertoire () const
virtual void 	set_derivation (enum Derivation)
//是否发出有关已保存到字段中的数据的警告或注释
bool 	set_warning (Sql_condition::enum_severity_level level, unsigned int code, int cut_increment)
//是否发出有关已保存到字段中的数据的警告或注释。
bool 	set_warning (Sql_condition::enum_severity_level level, uint code, int cut_increment, const char *view_db, const char *view_name)
//是否处理十进制库返回码，并发出溢出和截断警告
bool 	warn_if_overflow (int op_result)
virtual void 	init (TABLE *table_arg)
virtual uint32 	max_display_length () const =0
//创建的字段是否与现有字段类型兼容。
virtual uint 	is_equal (const Create_field *new_field) const
//从十进制转换为longlong
longlong 	convert_decimal2longlong (const my_decimal *val, bool unsigned_flag, bool *has_overflow)
virtual uint32 	char_length () const
virtual geometry_type 	get_geometry_type () const
void 	dbug_print () const
ha_storage_media 	field_storage_type () const
void 	set_storage_type (ha_storage_media storage_type_arg)
column_format_type 	column_format () const
void 	set_column_format (column_format_type column_format_arg)
virtual type_conversion_status 	validate_stored_val (THD *thd)
virtual void 	hash (ulong *nr, ulong *nr2) const
//获取MySQL整数和浮点类型的上限。 
virtual ulonglong 	get_max_int_value () const
//返回指向记录缓冲区中实际数据的const指针
virtual const uchar * 	data_ptr () const
//返回指向字段在记录缓冲区中存储位置的const指针
const uchar * 	field_ptr () const
//返回指向字段在记录缓冲区中存储位置的指针
uchar * 	field_ptr ()
void 	set_field_ptr (uchar *ptr_arg)
//检查字符串字段是否为write_set的一部分。
virtual bool 	is_updatable () const
//考虑到索引扩展标志，检查字段是否为索引的一部分。
bool 	is_part_of_actual_key (THD *thd, uint cur_index, KEY *cur_index_info) const
//获取覆盖前缀键
Key_map 	get_covering_prefix_keys () const
//该字段是否为类型数组。
virtual bool 	is_array () const
//返回字段长度占用的字节数。
virtual uint32 	get_length_bytes () const
//是否必须处理字段的旧值。
bool 	handle_old_value () const
//设置字段索引
virtual void 	set_field_index (uint16 fieldC++_index)
//返回字段索引
uint16 	field_index () const

```
公共属性
```
TABLE * 	table
//指向原始数据库名称的指针，对于临时表仅是非NULL
const char * 	orig_db_name {nullptr}
//指向原始表名的指针，对于临时表仅非空
const char * 	orig_table_name {nullptr}
const char ** 	table_name
const char * 	field_name
LEX_CSTRING 	comment
Key_map 	key_start
//除前缀键外，包含此字段的键
Key_map 	part_of_key
//前缀关键字
Key_map 	part_of_prefixkey
Key_map 	part_of_sortkey
//包含此字段但存储引擎未扩展以包含主键列的所有键 
Key_map 	part_of_key_not_extended
uint32 	field_length
uchar 	null_bit
//标志的位图，指示默认情况下和/或更新时是否自动生成字段值，以及采用哪种方式。 
uchar 	auto_flags
//如果为true，则从NULL值在create_tmp_field_from_item中创建此字段。
bool 	is_created_from_null_item
//如果此字段属于某个索引，则为true（与part_of_key不同，该索引可能仅具有前缀）。
bool 	m_indexed
LEX_CSTRING 	m_engine_attribute = EMPTY_CSTR
LEX_CSTRING 	m_secondary_engine_attribute = EMPTY_CSTR
Value_generator * 	gcol_info {nullptr}
bool 	stored_in_db
//包含用于生成默认值的表达式
Value_generator * 	m_default_val_expr {nullptr}

```