---
layout: post
categories: [Mongodb]
description: none
keywords: MongoDB
---
# MongoDB源码概述
学习下MongoDB源码，了解MongoDB源码的情况。

## 存储服务器的启动
mongod是mongodb的存储服务器，其代码入口在mongo/db/db.cpp中,MongoDB的大部分代码都在mongo/db这个文件夹中。
```C
int main(int argc, char* argv[]) {  
    int exitCode = mongoDbMain(argc, argv);  
    ::_exit(exitCode);  
}  
static int mongoDbMain(int argc, char* argv[]) {
    static StaticObserver staticObserver;
    getcurns = ourgetns;
 
    //下面几部分就是mongod的主要启动选项类别,具体有哪些选项可以参考mongodb相应的文档。
    po::options_description general_options("General options");
#if defined(_WIN32)
    po::options_description windows_scm_options("Windows Service Control Manager options");
#endif
    po::options_description replication_options("Replication options");
    po::options_description ms_options("Master/slave options");
    po::options_description rs_options("Replica set options");
    po::options_description sharding_options("Sharding options");
    po::options_description visible_options("Allowed options");
    po::options_description hidden_options("Hidden options");
    po::options_description ssl_options("SSL options");

```
跟随源码来到这里
```c
        Module::configAll( params );//这里module的配置,mms是其中部分，但是调试时发现module中没有任何模块，没有设置实例吧。
        dataFileSync.go();//mongodb使用内存文件映射管理数据,所以过一段时间有必要把脏数据写回磁盘，这里开启一个线程干的就是这个事情
          //默认是60s刷一次，启动时可以用--syncdelay加秒数来设置多少时间刷新一次若设置为0则反而不刷新，而只是执行5s的睡眠，然后继续
        if (params.count("command")) {//睡眠5s,直到通过db.adminCommand({"setParameter":1,syncdelay:20})设置时间后再刷新
            vector<string> command = params["command"].as< vector<string> >();
 
            if (command[0].compare("run") == 0) {
                if (command.size() > 1) {
                    cout << "Too many parameters to 'run' command" << endl;
                    cout << visible_options << endl;
                    return 0;
                }
 
                initAndListen(cmdLine.port);
                return 0;
            }
```
最后到这里:
```C
StartupTest::runTests();//启动测试，有几十项，主要是做些sanity check,测试失败则mongod启动失败，具体可自己分析源码
    initAndListen(cmdLine.port);//cmdLine.port可配置,若不设置默认为27017
    dbexit(EXIT_CLEAN);
```
接下来
```C
    void _initAndListen(int listenPort ) {//这里删除了些无关代码，贴出了主要的代码
 
        Client::initThread("initandlisten");
 
        Database::_openAllFiles = false;
 
        Logstream::get().addGlobalTee( new RamLog("global") );
 
        bool is32bit = sizeof(int*) == 4;
 
        acquirePathLock(forceRepair);//文件锁，保证一个目录下启动只能有一个mongod实例，若另一个实例启动起来则因为前一个实例的这个锁失败。
        boost::filesystem::remove_all( dbpath + "/_tmp/" );
 
        FileAllocator::get()->start();//专门的文件分配线程，mongodb分配文件时预分配文件时就是通过这里启动的线程预分配文件
 
        MONGO_ASSERT_ON_EXCEPTION_WITH_MSG( clearTmpFiles(), "clear tmp files" );
 
        dur::startup();//mongodb的日志,后面专门文章来分析mongo的journal
 
        if( cmdLine.durOptions & CmdLine::DurRecoverOnly )
            return;
 
        // comes after getDur().startup() because this reads from the database
        clearTmpCollections();
        Module::initAll();//调试的时候发现没有启动的module，mms应该属于这里
 
        if ( scriptingEnabled ) {
            ScriptEngine::setup();
            globalScriptEngine->setCheckInterruptCallback( jsInterruptCallback );
            globalScriptEngine->setGetInterruptSpecCallback( jsGetInterruptSpecCallback );
        }
 
        repairDatabasesAndCheckVersion();
 
        /* we didn't want to pre-open all files for the repair check above. for regular
           operation we do for read/write lock concurrency reasons.
        */
        Database::_openAllFiles = true;
 
        if ( shouldRepairDatabases )
            return;
 
        /* this is for security on certain platforms (nonce generation) */
        srand((unsigned) (curTimeMicros() ^ startupSrandTimer.micros()));
 
        snapshotThread.go();//似乎是统计没一段时间内的插入查询修改删除等状况的线程,没仔细看有待研究
        d.clientCursorMonitor.go();//报告内存使用情况和过时过时删除客户端游标的线程,不会分析，感兴趣自己研究吧
        PeriodicTask::theRunner->go();//执行任务的线程，其它部分向它提交任务
        if (missingRepl) {
            log() << "** warning: not starting TTL monitor" << startupWarningsLog;
            log() << "**          if this member is not part of a replica set and you want to use "
                  << startupWarningsLog;
            log() << "**          TTL collections, remove local.system.replset and restart"
                  << startupWarningsLog;
        }
        else {
            startTTLBackgroundJob();//2.2的特性，创建索引时设置一个超时时间，超过时间后自动删除数据如:db.log.events.ensureIndex({"status:1"},{expireAfterS				    //econds:3600})。这里专门启动一个线程来做这件事。
 
        }
        listen(listenPort);
        exitCleanly(EXIT_NET_ERROR);
}
```
mongodb有两种replcation模式
```c
    void listen(int port) {
        //testTheDb();
        MessageServer::Options options;
        options.port = port;
        options.ipList = cmdLine.bind_ip;
 
        MessageServer * server = createServer( options , new MyMessageHandler() );
        server->setAsTimeTracker();
 
        startReplication();//mongodb有两种replcation模式，master/slave,和replset模式，这两种模式都在这里启动后面分析时会分析到
        if ( !noHttpInterface )//启动一个webService线程，使得我们可以在浏览器中访问mongod的一些信息，端口为server的端口加1000,默认server端口为27017,所以其			       //默认端口为28017
            boost::thread web( boost::bind(&webServerThread, new RestAdminAccess() /* takes ownership */));
 
#if(TESTEXHAUST)
        boost::thread thr(testExhaust);
#endif
        server->run();//服务器的启动
    }
```
server->run这里执行流程是这样的:PostMessageServer::run->listener::initAndListen。
initAndListen执行流程:绑定IP(这里IP可以是多IP地址,若是多IP地址则绑定到每一个IP地址上)，通过select侦听来自客户端的连接请求,接收请求后来到:
```C
        virtual void acceptedMP(MessagingPort * p) {
 
            if ( ! connTicketHolder.tryAcquire() ) {//这里超过了配置的最大连接数，windows默认的连接数为20000，其它系统则查看系统限制，最大还是20000，
//若系统限制小于20000，则连接数为系统限制的数目
                log() << "connection refused because too many open connections: " << connTicketHolder.used() << endl;
 
                // TODO: would be nice if we notified them...
                p->shutdown();
                delete p;
                sleepmillis(2); // otherwise we'll hard loop
                return;
            }
 
            try {
#ifndef __linux__  // TODO: consider making this ifdef _WIN32
                {
                    boost::thread thr( boost::bind( &pms::threadRun , p ) );
                }
#else
                pthread_attr_t attrs;
                pthread_attr_init(&attrs);
                pthread_attr_setdetachstate(&attrs, PTHREAD_CREATE_DETACHED);
 
                static const size_t STACK_SIZE = 1024*1024; // if we change this we need to update the warning
 
                struct rlimit limits;
                verify(getrlimit(RLIMIT_STACK, &limits) == 0);
                if (limits.rlim_cur > STACK_SIZE) {//因为连接数多了后每一个连接开一个线程栈空间占用大这里显示的配置占空间大小为1M
                    pthread_attr_setstacksize(&attrs, (DEBUG_BUILD
                                                        ? (STACK_SIZE / 2)
                                                        : STACK_SIZE));
                } else if (limits.rlim_cur < 1024*1024) {
                    warning() << "Stack size set to " << (limits.rlim_cur/1024) << "KB. We suggest 1MB" << endl;
                }
 
 
                pthread_t thread;
                int failed = pthread_create(&thread, &attrs, (void*(*)(void*)) &pms::threadRun, p);//创建服务线程
 
                pthread_attr_destroy(&attrs);
 
                if (failed) {
                    log() << "pthread_create failed: " << errnoWithDescription(failed) << endl;
                    throw boost::thread_resource_error(); // for consistency with boost::thread
                }
#endif
            }
        }
```
最后描述下threadRun流程，首先其接收来自客户端的连接请求，然后接收数据，然后出来，最后断掉连接类似代码如下:
```C
threadrun(){
handler->connected()//若是来自本机的连接请求则设置_isLocalHost=true,和_isLocalHostAndLocalHostIsAuthorizedForAll=true，当然再检查admin.system.users是否
//有数据，有则_isLocalHostAndLocalHostIsAuthorizedForAll=false，要不然本机读取到用户了怎么行呢
p->recv()   //接收数据
handler->process()//处理请求
handler->disconnect()
}
```
分析到这里mongod的启动部分也就完成了。

## 客户端启动
mongo是mongodb的一个C++写的javascript交互式的可执行客户端。为了分析mongod对于服务请求的响应，这里分析下mongo。先来看看mongo的启动,mongo的启动代码在mongo/shell/dbshell.cpp中。其支持两个javascript 引擎，因为用visual stdio2012调试时默认编译的是spidermonkey，那么就分析spidermonkey那边吧。
当我们使用mongodb时最简单的一个保存命令是db.coll.save({a:1}),我们知道db是javascript对象，也是数据库名，coll是数据集collection,这里将{a:1}保存到coll的集合中，但是这里有一个疑问，javascript对象对于未定义的属性的访问不是通过db[coll]访问的吗,coll这里本应该是undefined,但是为什么结果成功的保存了呢。当我在阅读源码时就有这么个疑问，还好终于从源码中找到了答案，好了废话不多说了，直接分析。
```C
    po::options_description shell_options( "options" );//同样是一大堆启动命令，具体含义不说了，自己可以看相关的文档
    po::options_description hidden_options( "Hidden options" );
    po::options_description cmdline_options( "Command line options" );
    po::positional_options_description positional_options;
 
    shell_options.add_options()
    ( "shell", "run the shell after executing files" )
    ( "nodb", "don't connect to mongod on startup - no 'db address' arg expected" )
    ( "norc", "will not run the \".mongorc.js\" file on start up" )
    ( "quiet", "be less chatty" )
    ( "port", po::value<string>( &port ), "port to connect to" )
    ( "host", po::value<string>( &dbhost ), "server to connect to" )
    ( "eval", po::value<string>( &script ), "evaluate javascript" )
    ( "username,u", po::value<string>(&username), "username for authentication" )
    ( "password,p", new mongo::PasswordValue( &password ), "password for authentication" )
    ( "help,h", "show this usage information" )
    ( "version", "show version information" )
    ( "verbose", "increase verbosity" )
    ( "ipv6", "enable IPv6 support (disabled by default)" )

```
客户端连接DB
```C
    if ( !nodb ) { // connect to db
        //if ( ! mongo::cmdLine.quiet ) cout << "url: " << url << endl;
        //如果启动时没有指定nodb,那么这里将生成一串javascript代码,用来连接mongod
        stringstream ss;
        if ( mongo::cmdLine.quiet )
            ss << "__quiet = true;";
        ss << "db = connect( \"" << fixHost( url , dbhost , port ) << "\")";
 
        mongo::shell_utils::_dbConnect = ss.str();
 
        if ( params.count( "password" ) && password.empty() )
            password = mongo::askPassword();
 
        if ( username.size() && password.size()) {
            stringstream ss;
            ss << "if ( ! db.auth( \"" << username << "\" , \"" << password << "\" ) ){ throw 'login failed'; }";
            mongo::shell_utils::_dbAuth = ss.str();
        }
    }
```
连接成功后的回调
```C
mongo::ScriptEngine::setConnectCallback( mongo::shell_utils::onConnect );//这个回调函数用来做连接成功后的记录工作
    mongo::ScriptEngine::setup();
    mongo::globalScriptEngine->setScopeInitCallback( mongo::shell_utils::initScope );
    auto_ptr< mongo::Scope > scope( mongo::globalScriptEngine->newScope() );
    shellMainScope = scope.get();
```
现在来看看mongo::globalScriptEngine->newScope(),在mongo::ScriptEngine::setup()函数中globalScriptEngine=new SMEngine()。
```C++
        virtual Scope * newScope() {
            Scope *s = createScope();
            if ( s && _scopeInitCallback )//_scopeInitCallback对应上面的mongo::shell_utils::initScope
                _scopeInitCallback( *s );
            installGlobalUtils( *s );
            return s;
        }
```
createScope对应spideMonkey则为new SMScope()
```C

        SMScope() ://spideMonkey的初始化
            _this( 0 ),
            _reportError( true ),
            _externalSetup( false ),
            _localConnect( false ) {
            smlock;
            _context = JS_NewContext( globalSMEngine->_runtime , 8192 );
            _convertor = new Convertor( _context );
            massert( 10431 ,  "JS_NewContext failed" , _context );
 
            JS_SetOptions( _context , JSOPTION_VAROBJFIX);
            //JS_SetVersion( _context , JSVERSION_LATEST); TODO
            JS_SetErrorReporter( _context , errorReporter );
 
            _global = JS_NewObject( _context , &global_class, NULL, NULL);
            massert( 10432 ,  "JS_NewObject failed for global" , _global );
            JS_SetGlobalObject( _context , _global );
            massert( 10433 ,  "js init failed" , JS_InitStandardClasses( _context , _global ) );
 
            JS_SetOptions( _context , JS_GetOptions( _context ) | JSOPTION_VAROBJFIX );
 
            JS_DefineFunctions( _context , _global , globalHelpers );//预先定义的几个函数
 
            JS_DefineFunctions( _context , _convertor->getGlobalObject( "Object" ), objectHelpers );
 
            //JS_SetGCCallback( _context , no_gc ); // this is useful for seeing if something is a gc problem
 
            _postCreateHacks();
        }

```

```C
    JSFunctionSpec globalHelpers[] = {//这里定义的几个函数映射,javascript中执行相应的函数则会调用这里的本地函数。
        { "print" , &native_print , 0 , 0 , 0 } ,
        { "nativeHelper" , &native_helper , 1 , 0 , 0 } ,
        { "load" , &native_load , 1 , 0 , 0 } ,
        { "gc" , &native_gc , 1 , 0 , 0 } ,
        { "UUID", &_UUID, 0, 0, 0 } ,
        { "MD5", &_MD5, 0, 0, 0 } ,
        { "HexData", &_HexData, 0, 0, 0 } ,
        { 0 , 0 , 0 , 0 , 0 }
    };
```
继续到newScope函数，接下来调用了_scopeInitCallback()函数，其实就是之前设置的initScope回调函数
```C

        void initScope( Scope &scope ) {
            scope.externalSetup();
            mongo::shell_utils::installShellUtils( scope );
            scope.execSetup(JSFiles::servers);//执行相应的javascript文件，相当于初始化javascript环境，以后命令行中执行相应代码时
            scope.execSetup(JSFiles::shardingtest);//就能正确的找到环境了。
            scope.execSetup(JSFiles::servers_misc);
            scope.execSetup(JSFiles::replsettest);
            scope.execSetup(JSFiles::replsetbridge);
 
            if ( !_dbConnect.empty() ) {//执行登录代码
                uassert( 12513, "connect failed", scope.exec( _dbConnect , "(connect)" , false , true , false ) );
                if ( !_dbAuth.empty() ) {//用户账号登陆认证
                    installGlobalUtils( scope );
                    uassert( 12514, "login failed", scope.exec( _dbAuth , "(auth)" , true , true , false ) );
                }
            }
        }
```
initScope->externalSetup->initMongoJS
```C
    void initMongoJS( SMScope * scope , JSContext * cx , JSObject * global , bool local ) {
//JS Class的初始化过程，几乎所有的mongodb使用到的class都在这里创建，所有new XXX对象的构建都是下面这里的函数完成的,比如说db,collection,dbquery
        verify( JS_InitClass( cx , global , 0 , &mongo_class , local ? mongo_local_constructor : mongo_external_constructor , 0 , 0 , mongo_functions , 0 , 0 ) );
 
        verify( JS_InitClass( cx , global , 0 , &object_id_class , object_id_constructor , 0 , 0 , 0 , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &db_class , db_constructor , 2 , 0 , 0 , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &db_collection_class , db_collection_constructor , 4 , 0 , 0 , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &internal_cursor_class , internal_cursor_constructor , 0 , 0 , internal_cursor_functions , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &dbquery_class , dbquery_constructor , 0 , 0 , 0 , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &dbpointer_class , dbpointer_constructor , 0 , 0 , dbpointer_functions , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &bindata_class , bindata_constructor , 0 , 0 , bindata_functions , 0 , 0 ) );
//        verify( JS_InitClass( cx , global , 0 , &uuid_class , uuid_constructor , 0 , 0 , uuid_functions , 0 , 0 ) );
 
        verify( JS_InitClass( cx , global , 0 , ×tamp_class , timestamp_constructor , 0 , 0 , 0 , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &numberlong_class , numberlong_constructor , 0 , 0 , numberlong_functions , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &numberint_class , numberint_constructor , 0 , 0 , numberint_functions , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &minkey_class , 0 , 0 , 0 , 0 , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &maxkey_class , 0 , 0 , 0 , 0 , 0 , 0 ) );
 
        verify( JS_InitClass( cx , global , 0 , &map_class , map_constructor , 0 , 0 , map_functions , 0 , 0 ) );
 
        verify( JS_InitClass( cx , global , 0 , &bson_ro_class , bson_cons , 0 , 0 , bson_functions , 0 , 0 ) );
        verify( JS_InitClass( cx , global , 0 , &bson_class , bson_cons , 0 , 0 , bson_functions , 0 , 0 ) );
 
        static const char *dbrefName = "DBRef";
        dbref_class.name = dbrefName;
        verify( JS_InitClass( cx , global , 0 , &dbref_class , dbref_constructor , 2 , 0 , bson_functions , 0 , 0 ) );
 
        scope->execCoreFiles();
    }

```
这里local为false，使用的是mongo_external_constructor函数。先看看mongo_class：

```C
    JSClass mongo_class = {//为映射javascript对象而设置的函数，当javascript中new Mongo对象时会调用mongo_external_constructor来构造一个对象
        "Mongo",                                        // class name
        JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE,      // flags
        JS_PropertyStub,                                // addProperty
        JS_PropertyStub,                                // delProperty
        JS_PropertyStub,                                // getProperty
        JS_PropertyStub,                                // setProperty
        JS_EnumerateStub,                               // enumerate
        JS_ResolveStub,                                 // resolve
        JS_ConvertStub,                                 // convert
        mongo_finalize,                                 // finalize
        JSCLASS_NO_OPTIONAL_MEMBERS                     // optional members
    };
```
再看看  mongo_functions:
```C
    JSFunctionSpec mongo_functions[] = {//当在javascript中调用相应的函数时，这里对应的native函数将会被调用到，
        { "auth" , mongo_auth , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
        { "logout", mongo_logout, 0, JSPROP_READONLY | JSPROP_PERMANENT, 0 },
        { "find" , mongo_find , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
        { "update" , mongo_update , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
        { "insert" , mongo_insert , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
        { "remove" , mongo_remove , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
        { 0 }
    };
```
我们继续看，现在是出来上面的问题了db.coll.save({a:1})为什么没有问题。
```C
    JSClass db_collection_class = {
        "DBCollection",                                 // class name
        JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE,      // flags
        JS_PropertyStub,                                // addProperty
        JS_PropertyStub,                                // delProperty
        JS_PropertyStub,                                // getProperty
        JS_PropertyStub,                                // setProperty
        JS_EnumerateStub,                               // enumerate
        (JSResolveOp)db_collection_resolve,             // 注意这里，这是关键
        JS_ConvertStub,                                 // convert
        JS_FinalizeStub,                                // finalize
        JSCLASS_NO_OPTIONAL_MEMBERS                     // optional members
    };
```

```C
    JSBool db_collection_resolve( JSContext *cx, JSObject *obj, jsval id, uintN flags, JSObject **objp ) {
        try {
            if ( flags & JSRESOLVE_ASSIGNING )
                return JS_TRUE;
 
            Convertor c( cx );
            string collname = c.toString( id );
 
            if ( isSpecialName( collname ) )
                return JS_TRUE;
 
            if ( obj == c.getGlobalPrototype( "DBCollection" ) )
                return JS_TRUE;
 
            JSObject * proto = JS_GetPrototype( cx , obj );
            if ( c.hasProperty( obj , collname.c_str() ) || ( proto && c.hasProperty( proto , collname.c_str() )  ) )
                return JS_TRUE;
 
            string name = c.toString( c.getProperty( obj , "_shortName" ) );
            name += ".";
            name += collname;
 
            jsval db = c.getProperty( obj , "_db" );
            if ( ! JSVAL_IS_OBJECT( db ) )
                return JS_TRUE;
 
            JSObject * coll = doCreateCollection( cx , JSVAL_TO_OBJECT( db ) , name );//这个地方创建了个集合，当调用db.coll.save()时,javascript调用
            if ( ! coll )     //resolve函数时在这里将coll集合创建了出来,所以coll不为undefined
                return JS_FALSE;                                                     //原来如此,spidermonkey的具体流程就不清楚了，有感兴趣的自己去看吧
            c.setProperty( obj , collname.c_str() , OBJECT_TO_JSVAL( coll ) );
            *objp = obj;
        }
        catch ( const AssertionException& e ) {
            if ( ! JS_IsExceptionPending( cx ) ) {
                JS_ReportError( cx, e.what() );
            }
            return JS_FALSE;
        }
        catch ( const std::exception& e ) {
            log() << "unhandled exception: " << e.what() << ", throwing Fatal Assertion" << endl;
            fassertFailed( 16303 );
        }
        return JS_TRUE;
    }
```
下面来看看登录:
```C
ss << "db = connect( \"" << fixHost( url , dbhost , port ) << "\")";
```
这里就是产生的javascript连接代码:
```javascript

string fixHost( string url , string host , string port ) {//url传进来初始化值为test,这里就可以看出为啥默认连接到了test数据库了。
    //cout << "fixHost url: " << url << " host: " << host << " port: " << port << endl;//若什么都没设置也知道为什么连接到了
                                                          //127.0.0.1:27017
    if ( host.size() == 0 && port.size() == 0 ) {
        if ( url.find( "/" ) == string::npos ) {
            // check for ips
            if ( url.find( "." ) != string::npos )
                return url + "/test";
 
            if ( url.rfind( ":" ) != string::npos &&
                    isdigit( url[url.rfind(":")+1] ) )
                return url + "/test";
        }
        return url;
    }
 
    if ( url.find( "/" ) != string::npos ) {
        cerr << "url can't have host or port if you specify them individually" << endl;
        ::_exit(-1);
    }
 
    if ( host.size() == 0 )
        host = "127.0.0.1";
 
    string newurl = host;
    if ( port.size() > 0 )
        newurl += ":" + port;
    else if ( host.find(':') == string::npos ) {
        // need to add port with IPv6 addresses
        newurl += ":27017";
    }
 
    newurl += "/" + url;
 
    return newurl;
}
```
下面来看看javascript代码connect
```C

connect = function( url , user , pass ){
    chatty( "connecting to: " + url )
 
    if ( user && ! pass )
        throw "you specified a user and not a password.  either you need a password, or you're using the old connect api";
 
    var idx = url.lastIndexOf( "/" );
    
    var db;
    
    if ( idx < 0 )
        db = new Mongo().getDB( url );//这里创建了Mongo对象,上面代码分析时已经提到New Mongo()会调用本地函数:mongo_external_constructor
    else 
        db = new Mongo( url.substring( 0 , idx ) ).getDB( url.substring( idx + 1 ) );
    
    if ( user && pass ){
        if ( ! db.auth( user , pass ) ){
            throw "couldn't login";
        }
    }
    
    return db;
}
```
我们回到C++函数:mongo_external_constructor
```C
    JSBool mongo_external_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
        try {
            smuassert( cx ,  "0 or 1 args to Mongo" , argc <= 1 );
 
            string host( "127.0.0.1" );
            Convertor c( cx );
            if ( argc > 0 )
                host = c.toString( argv[0] );
 
            string errmsg;//注意这里的ConnectionString,其形式可为:server   server:port   foo/server:port,server:port  server,server,server
            ConnectionString cs = ConnectionString::parse( host , errmsg );//可同时配置多个IP,还记得在QQ群里有个人问，使用replset模式时如
            if ( ! cs.isValid() ) {//果主服务器挂了，那么php中怎么配置呢，我不知道php怎么配置，
                JS_ReportError( cx , errmsg.c_str() );                    //但是看到这里大家应该明白了，mongo的连接地址配置其实是可以是
                return JS_FALSE;                                          //多地址的,其connection有几种模式具体参见:ConnectionString
 
            }
 
            shared_ptr< DBClientWithCommands > conn( cs.connect( errmsg ) );//这里通过了ConnectionString屏蔽了具体的连接过程
            if ( ! conn ) {
                JS_ReportError( cx , errmsg.c_str() );
                return JS_FALSE;
            }
 
            try {
                ScriptEngine::runConnectCallback( *conn );//连接成功调用上面说的函数mongo::shell_utils::onConnect记录连接
            }
            catch ( const AssertionException& e ){
                // Can happen if connection goes down while we're starting up here
                // Catch so that we don't get a hard-to-trace segfault from SM
                JS_ReportError( cx, ((string)( str::stream() << "Error during mongo startup." << causedBy( e ) )).c_str() );
                return JS_FALSE;
            }
            catch ( const std::exception& e ) {
                log() << "unhandled exception: " << e.what() << ", throwing Fatal Assertion" << endl;
                fassertFailed( 16294 );
            }
 
            verify( JS_SetPrivate( cx , obj , (void*)( new shared_ptr< DBClientWithCommands >( conn ) ) ) );
            jsval host_val = c.toval( host.c_str() );
            verify( JS_SetProperty( cx , obj , "host" , &host_val ) );
        }
        catch ( const AssertionException& e ) {
            if ( ! JS_IsExceptionPending( cx ) ) {
                JS_ReportError( cx, e.what() );
            }
            return JS_FALSE;
        }
        catch ( const std::exception& e ) {
            log() << "unhandled exception: " << e.what() << ", throwing Fatal Assertion" << endl;
            fassertFailed( 16295 );
        }
        return JS_TRUE;
    }
```
继续回到initScope,来看看认证过程。
```C
ss << "if ( ! db.auth( \"" << username << "\" , \"" << password << "\" ) ){ throw 'login failed'; }";
```
通过上面的分析可知这里直接调用了函数mongo_auth。这个函数调用DBClientWithCommands::auth函数执行具体的认证动作。
```C

    bool DBClientWithCommands::auth(const string &dbname, const string &username, const string &password_text, string& errmsg, bool digestPassword, Auth::Level * level) {
        string password = password_text;
        if( digestPassword )
            password = createPasswordDigest( username , password_text );//将用户名密码按照user:mongo:passwd做md5
 
        if ( level != NULL )
                *level = Auth::NONE;
 
        BSONObj info;
        string nonce;
        if( !runCommand(dbname, getnoncecmdobj, info) ) {//执行命令{getnonce:1}从服务端得到一个nonce的值
            errmsg = "getnonce fails - connection problem?";
            return false;
        }
        {
            BSONElement e = info.getField("nonce");
            verify( e.type() == String );
            nonce = e.valuestr();
        }
 
        BSONObj authCmd;
        BSONObjBuilder b;
        {
 
            b << "authenticate" << 1 << "nonce" << nonce << "user" << username;
            md5digest d;
            {
                md5_state_t st;
                md5_init(&st);
                md5_append(&st, (const md5_byte_t *) nonce.c_str(), nonce.size() );
                md5_append(&st, (const md5_byte_t *) username.data(), username.length());
                md5_append(&st, (const md5_byte_t *) password.c_str(), password.size() );
                md5_finish(&st, d);
            }
            b << "key" << digestToString( d );
            authCmd = b.done();
        }
 
        if( runCommand(dbname, authCmd, info) ) {//执行命令authenticate验证用户,数据发送到服务端后服务端验证用户通过后会将其加入到
            if ( level != NULL ) {//一个map中，其保存了认证的数据库,用户名,以及权限，权限只有读或者写
                if ( info.getField("readOnly").trueValue() )
                    *level = Auth::READ;
                else
                    *level = Auth::WRITE;
            }
            return true;
        }
 
        errmsg = info.toString();
        return false;
    }
```
到这里initscope执行完毕，javascript初始化完毕。进入读取用户输入执行用户输入的javascript代码的流程中,部分代码如下:
```C
            bool wascmd = false;
            {
                string cmd = linePtr;
                if ( cmd.find( " " ) > 0 )
                    cmd = cmd.substr( 0 , cmd.find( " " ) );
 
                if ( cmd.find( "\"" ) == string::npos ) {
                    try {//这里判断用户的输入是否是命令比如说use database,it这种命令
                        scope->exec( (string)"__iscmd__ = shellHelper[\"" + cmd + "\"];" , "(shellhelp1)" , false , true , true );
                        if ( scope->getBoolean( "__iscmd__" )  ) {//这里确实是命令，那么就去执行这些命令
                            scope->exec( (string)"shellHelper( \"" + cmd + "\" , \"" + code.substr( cmd.size() ) + "\");" , "(shellhelp2)" , false , true , false );
                            wascmd = true;
                        }
                    }
                    catch ( std::exception& e ) {
                        cout << "error2:" << e.what() << endl;
                        wascmd = true;
                    }
                }
            }
 
            if ( ! wascmd ) {
                try {//不是确切的命令，按照一般javascript的代码规则执行
                    if ( scope->exec( code.c_str() , "(shell)" , false , true , false ) )
                        scope->exec( "shellPrintHelper( __lastres__ );" , "(shell2)" , true , true , false );//打印结果,比如说用户查询
                }                                                                                            //结果就是这里打印出来的
                catch ( std::exception& e ) {
                    cout << "error:" << e.what() << endl;
                }
            }
 
            shellHistoryAdd( code.c_str() );//记录这个代码，下次可以使用，用户可以按上下键调出就像linux shell一样。
            free( line );
        }
 
        shellHistoryDone();
    }
```
至此mongo的启动流程就分析完了，具体来说可以分为:
1. javascript环境的初始化(包括了一些辅助函数的注入如native_print和mongodb对象的注入如collection,db,dbquery)。
2. 客户端的登录流程(需要注意的是配置服务端地址时可设置多服务端地址，具体可参考ConnectionString这个类的实现)。












