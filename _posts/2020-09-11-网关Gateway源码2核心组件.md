---
layout: post
categories: [Gateway]
description: none
keywords: Gateway
---
# 网关Gateway源码2核心组件

## spring-cloud-gateway的工作机制
- 接收client请求；
- client请求与网关配置的路由规则进行匹配，匹配失败的不会发往后端服务；
- 请求经过网关配置的过滤器链，涉及处理request的filter逻辑被执行，比如为request添加header（AddRequestHeaderGatewayFilterFactory）；
- 请求被转发至后端服务，后端服务处理完返回响应；
- 响应经过过滤器链，涉及处理response的filter逻辑被执行，比如为response添加header（AddResponseHeaderGatewayFilterFactory）；
- 后端服务的响应被网关返回给client。

## 基础组件

### Route
封装了路由信息的配置，spring-cloud-gateway可以配置多个Route规则：
```java
public class Route implements Ordered {

	private final String id;

	private final URI uri;

	private final int order;

	private final AsyncPredicate<ServerWebExchange> predicate;

	private final List<GatewayFilter> gatewayFilters;

	private final Map<String, Object> metadata;
	}
```
- id：类比一下主键，每个合法的Route实例ID应该是唯一的（默认是UUID）
- uri：client请求的uri，比如：10.10.220.45:8080/hello
- order：看到实现了Spring的Ordered接口，就知道是老朋友了，责任链模式里天天见的套路。作用就是配置一个优先级，假设请求的uri有多个Route配置，那么根据优先级排序，order值小的排前面优先匹配：匹配成功则往下继续走这个Route过滤器链的逻辑；匹配失败就匹配下一个Route配置，直到这些Route全部匹配完，还没有匹配到的话，就不发往后端服务
- predicate：匹配成功的前置条件，满足了才能往下走过滤器链
- gatewayFilters：过滤器列表，每个过滤器可能是修改发往后端服务的request，也可能是修改后端服务返回的response。具体有哪些实现，可以鼠标单击GatewayFilter类的类名，然后ctrl + alt + b（win）/ command + option + b（mac），显示所有GatewayFilter的实现类。大多数以lambda和匿名内部类的形式存在于各XxxFilterFactory中：
- metadata：用于携带一些额外的自定义属性，在对Route进行处理时可以作为额外的参考，比如设置一个响应超时时间，判断响应时间是否超过了我们在metadata里配置的阈值：
```java
public class NettyRoutingFilter implements GlobalFilter, Ordered {

	private Duration getResponseTimeout(Route route) {
		Object responseTimeoutAttr = route.getMetadata().get(RESPONSE_TIMEOUT_ATTR);
		Long responseTimeout = null;
		if (responseTimeoutAttr != null) {
			if (responseTimeoutAttr instanceof Number) {
				responseTimeout = ((Number) responseTimeoutAttr).longValue();
			}
			else {
				responseTimeout = Long.valueOf(responseTimeoutAttr.toString());
			}
		}
		return responseTimeout != null ? Duration.ofMillis(responseTimeout)
				: properties.getResponseTimeout();
	}
}
```
一般也只涉及到RouteMetadataUtils中的两个属性，顾名思义，就不多解释了：
```
public final class RouteMetadataUtils {

	/**
	 * Response timeout attribute name.
	 */
	public static final String RESPONSE_TIMEOUT_ATTR = "response-timeout";

	/**
	 * Connect timeout attribute name.
	 */
	public static final String CONNECT_TIMEOUT_ATTR = "connect-timeout";

	private RouteMetadataUtils() {
		throw new AssertionError("Must not instantiate utility class.");
	}

}
```

## AsyncPredicate
即在Route中定义的匹配规则，满足规则才会才用这个Route。
```java
public interface AsyncPredicate<T> extends Function<T, Publisher<Boolean>> {

	default AsyncPredicate<T> and(AsyncPredicate<? super T> other) {
		return new AndAsyncPredicate<>(this, other);
	}

	default AsyncPredicate<T> negate() {
		return new NegateAsyncPredicate<>(this);
	}

	default AsyncPredicate<T> not(AsyncPredicate<? super T> other) {
		return new NegateAsyncPredicate<>(other);
	}

	default AsyncPredicate<T> or(AsyncPredicate<? super T> other) {
		return new OrAsyncPredicate<>(this, other);
	}

}
```
- and：类比if条件中的a && b就行了
- negate：取反，类比为 !a
- not：也是取反，但不是取自己的，类比为：a && !b
- or：a || b
已经有了默认实现DefaultAsyncPredicate，上述四种条件组合方式分别对应的实现类，参见这四个方法里new的类型，此外还有少数的匿名内部类存在。这四种运算的作用在于组合多个匹配条件，将它们合并为一个（Route里就只有一个）。

## GatewayFilter
在前面网关的工作机制里，步骤3和步骤5提到了filter可能会对request和response做一些修改。这种pre() + post()的套路是不是似曾相识，我们可爱的老朋友BeanPostProcessor、AOP before() + after()/around()。

其实但凡存在一个中间层，或者说介入者、中介人的时候，总是免不了会有类似的模式：前置处理+后置处理。比如ShardingProxy或者其他的一些中间件，甚至也可以把它们看做一个个切面。而且这些切面是可以链在一起拼起来的，就像过滤器链一样，比如把好几个中间件顺序组合在一起使用形成一种可扩展的架构模式。

同理，由于过滤器是通过filter chain来调用的，增加filter并不需要修改太多额外的代码。依托于控制反转的设计模式，比如模版模式，让框架基于给定的配置自动管理filter的注册和调用。
```java
public interface GatewayFilter extends ShortcutConfigurable {

	String NAME_KEY = "name";


	String VALUE_KEY = "value";
    
	Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);

}
```
FilterChain：
```java
public interface GatewayFilterChain {

	/**
	 * Delegate to the next {@code WebFilter} in the chain.
	 * @param exchange the current server exchange
	 * @return {@code Mono<Void>} to indicate when request handling is complete
	 */
	Mono<Void> filter(ServerWebExchange exchange);

}
```
GatewayFilterChain只有一个默认实现DefaultGatewayFilterChain：
```java
	private static class DefaultGatewayFilterChain implements GatewayFilterChain {

		private final int index;

		private final List<GatewayFilter> filters;

		DefaultGatewayFilterChain(List<GatewayFilter> filters) {
			this.filters = filters;
			this.index = 0;
		}

		private DefaultGatewayFilterChain(DefaultGatewayFilterChain parent, int index) {
			this.filters = parent.getFilters();
			this.index = index;
		}

		public List<GatewayFilter> getFilters() {
			return filters;
		}

		@Override
		public Mono<Void> filter(ServerWebExchange exchange) {
			return Mono.defer(() -> {
				if (this.index < filters.size()) {
					GatewayFilter filter = filters.get(this.index);
					DefaultGatewayFilterChain chain = new DefaultGatewayFilterChain(this,
							this.index + 1);
					return filter.filter(exchange, chain);
				}
				else {
					return Mono.empty(); // complete
				}
			});
		}

	}
```
就是根据List<GatewayFilter>的下标顺序执行每个filter的filter()方法，会对请求或者响应去做一些处理，比如：AddRequestHeaderGatewayFilterFactory、AddResponseHeaderGatewayFilterFactory，顾名思义，这俩兄弟就是分别给请求和响应加header参数的。其它的filter实现有兴趣可以去深入研究下，这里就不占用过多篇幅分析了。

## 如何配置一个Route

### yml配置
```yaml
spring:
  cloud:
    gateway: 
      routes: # 定义的路由信息列表
      - id: cookie_route # 路由规则的ID
        uri: 10.10.220.54:8080/hello # 对应请求地址的uri
        predicates: # 匹配条件列表，这里的多个条件最终会被合成为一个AsyncPredicate
        - Cookie=username, root # cookie里要有username=root的键值对才能匹配
        filters: # 过滤器列表
        - AddRequestHeader=username, root # 往请求头里加username=root的参数
```

### builder配置
```
@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
    return builder.routes() // 配置路由规则列表
            // 配置路由规则：指定了client请求的host和path
            .route(r -> r.host("**.abc.org").and().path("/hello")
                // 配置filter列表
                .filters(f ->
                        // 为request添加一个username=root的header
                        f.addRequestHeader("username", "root"))
                // 真正要转发到的后端服务uri
                .uri("http://10.10.220.54:8080")
            )
            .build();
}
```

## Route构建原理
GatewayAutoConfiguration作为自动装配的核心类，它所对应的ConfigurationProperties配置类为GatewayProperties，yml里routes部分的配置会被映射成它：
```java
public class Route implements Ordered {

	private final String id;

	private final URI uri;

	private final int order;
	}
```
所以我们先从GatewayProperties出发，探索配置是怎么逐步转化为路由规则运作的。
```java
@ConfigurationProperties(GatewayProperties.PREFIX)
@Validated
public class GatewayProperties {

	/**
	 * Properties prefix.
	 */
	public static final String PREFIX = "spring.cloud.gateway";

	private final Log logger = LogFactory.getLog(getClass());

	/**
	 * List of Routes.
	 */
	@NotNull
	@Valid
	private List<RouteDefinition> routes = new ArrayList<>();

	/**
	 * List of filter definitions that are applied to every route.
	 */
	private List<FilterDefinition> defaultFilters = new ArrayList<>();
	}
```
- routes：
通过上图我们可以看出yml里的routes配置，实际被parse到了routes字段里，List<RouteDefinition>里的每一个RouteDefinition对应了yml中的一个route规则。和我们的老熟人BeanDefinition其实就是一个套路：

Spring把bean的定义读到BeanDefinition里保存起来，然后通过BeanDefinition生成bean；
spring-cloud-gateway把Route的定义读到RouteDefinition里保存起来，再通过RouteDefinition生成Route。

- defaultFilters:
老套路了，把一些通用的过滤逻辑配置为默认的过滤器列表，这些默认的filter会应用到每个Route上，其实就是把每个Route的filters.addAll(defaultFilters);

### RouteDefinition
上面已经说了它的作用了，它最终会被RouteLocator解析成Route。

### FilterDefinition
看到这个XxxDefinition已经不用多说它是干嘛的了，但是它保存属性的方式比较特殊，要单独提一下：
```
@Validated
public class FilterDefinition {

    @NotNull
    private String name;

    private Map<String, String> args = new LinkedHashMap<>();
}
```
对于下面这段filter的yml配置：
```
filters: # 过滤器列表
  - AddRequestHeader=username, root # 往请求头里加username=root的参数
```
AddRequestHeader会被解析成name
username, root会被用逗号做分词，分成 username、root两个token，以键值对：_genkey_0, username和_genkey_1, root的形式解析成args
```
	public FilterDefinition(String text) {
		int eqIdx = text.indexOf('=');
		if (eqIdx <= 0) {
			setName(text);
			return;
		}
		setName(text.substring(0, eqIdx));

		String[] args = tokenizeToStringArray(text.substring(eqIdx + 1), ",");

		for (int i = 0; i < args.length; i++) {
			this.args.put(NameUtils.generateName(i), args[i]);
		}
	}
```
## PredicateDefinition
相信聪明的你都看烦了，还能不能有点新花样？和FilterDefinition的结构一毛一样，就不提了。

## RoutePredicateFactory
所有predicate factory的顶级接口，看到factory就知道它是生产predicate的了。
```java
@FunctionalInterface
public interface RoutePredicateFactory<C> extends ShortcutConfigurable, Configurable<C> {

	/**
	 * Pattern key.
	 */
	String PATTERN_KEY = "pattern";
}
```
这个Configurable<C>接口定义，是让整一配置类实现这个接口，然后根据配置类的属性去生成Predicate<C>实例。简单理解就是，希望工厂造啥样的东西，就自己定个标准让工厂生产。这样做的好处就是避免了像简单工厂方法那样，只能生产固定的类型，更加灵活了。

## GatewayFilterFactory
和上面这老兄一个样，就是生产filter的。

## RouteDefinitionLocator
个人觉得叫RouteDefinitionLoader可能会更好点，它的作用是加载RouteDefinition列表。
```
public interface RouteDefinitionLocator {

	Flux<RouteDefinition> getRouteDefinitions();

}
```
## RouteLocator
类似于RouteDefinitionLocator，只是它是把RouteDefinition转成Route。它俩的关系就像BeanFactory和BeanDefinitionRegistry的关系。

## RouteDefinitionRouteLocator
这名字咋就这么难受呢。其实就是RouteLocator的主要实现类，把RouteDefinition转成了Route，所以简单粗暴的来了个 RouteDefinition + RouteLocator的名字...
```
public class RouteDefinitionRouteLocator
		implements RouteLocator, BeanFactoryAware, ApplicationEventPublisherAware {

	/**
	 * Default filters name.
	 */
	public static final String DEFAULT_FILTERS = "defaultFilters";

	protected final Log logger = LogFactory.getLog(getClass());

	private final RouteDefinitionLocator routeDefinitionLocator;
	}
```

## RouteLocator$Builder$Lambda
lambda表达式实现的自定义RouteLocator（也有匿名内部类实现的，但仅存于测试方法中）

## CompositeRouteLocator
它把RouteDefinitionRouteLocator和自定义的RouteLocator$Builder$Lambda 作为delegates，要取所有Route时，就委托这两个老哥分别去取，然后合并结果返回。与它的行为模式类似的还有CompositeRouteDefinitionLocator，是取RouteDefinition的。

## CachingRouteLocator
然而这个才是真正的人生人生赢家，直接窃取CompositeRouteLocator的革命成果（虽然它也是让RouteDefinitionRouteLocator和自定义RouteLocator干苦力）：

列表注入时，Spring会把容器中指定类型的所有Bean捞出来作为参数，所以它间接通过CompositeRouteLocator获取了所有的Route配置：


本篇介绍了spring-cloud-gateway核心组件的协作关系与Route的构建流程。主要涉及的核心组件有：

- Route：路由信息，包括：请求地址uri、匹配条件predicate、过滤器列表filters
- AsyncPredicate：匹配条件，符合条件的才能被转发到目标uri
- GatewayFilter：责任链与AOP思想，主要负责request和response的流程中插入一些操作

生成御三家的核心实现类：
- CachingRouteLocator：加载Route
- RoutePredicateFactory：AsyncPredicate的生产工厂
- GatewayFilterFactory：GatewayFilter生产工厂










