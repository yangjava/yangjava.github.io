---
layout: post
categories: [JUC]
description: none
keywords: JUC
---
# 并发编程线程组
详细讲解有关ThreadGroup的知识以及各个API的使用情况。

## ThreadGroup与Thread
创建线程的时候如果没有显式地指定ThreadGroup，那么新的线程会被加入与父线程相同的ThreadGroup中。

在Java程序中，默认情况下，新的线程都会被加入到main线程所在的group中，main线程的group名字同线程名。如同线程存在父子关系一样，ThreadGroup同样也存在父子关系。

无论如何，线程都会被加入某个Thread Group之中。

## 创建ThreadGroup
创建ThreadGroup的语法如下：
```
public ThreadGroup(String name)

public ThreadGroup(ThreadGroup parent,String name)
```
创建ThreadGroup的语法非常简单，可通过上面某个构造函数来创建

第一个构造函数为ThreadGroup赋予了名字，但是该ThreadGroup的父ThreadGroup是创建它的线程所在的ThreadGroup

第二个ThreadGroup的构造函数赋予group名字的同时又显式地指定了父Group。

```
public class ThreadGroupCreator
{
    public static void main(String[] args)
{
        //① 获取当前线程的group
        ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();
        //② 定义一个新的group
        ThreadGroup group1 = new ThreadGroup("Group1");

        //③ 程序输出true
        System.out.println(group1.getParent() == currentGroup);

        //④ 定义group2，指定group1为其父group
        ThreadGroup group2 = new ThreadGroup(group1, "Group2");

        //⑤ 程序输出true
        System.out.println(group2.getParent() == group1);

    }
}
```
定义了一个group1，没有指定父group，所以默认父group为当前线程所在的group

在构造group2时，显式地指定了其父group为group1

## 复制Thread数组和ThreadGroup数组
在一个ThreadGroup中会加入若干个线程以及子ThreadGroup，ThreadGroup为我们提供了若干个方法，可以复制出线程和线程组。

### 复制Thread数组
先来看如下两个方法：
```
public int enumerate(Thread[] list)

public int enumerate(Thread[] list,boolean recurse)
```
上述两个方法，会将ThreadGroup中的active线程全部复制到Thread数组中，其中recurse参数如果为true，则该方法会将所有子group中的active线程都递归到Thread数组中。

enumerate（Thread[]list）实际上等价于enumerate（Thread[]true），上面两个方法都调用了ThreadGroup的私有方法enumerate：
```
private int enumerate(Thread list[], int n, boolean recurse) {
        int ngroupsSnapshot = 0;
        ThreadGroup[] groupsSnapshot = null;
        synchronized (this) {
            if (destroyed) {
                return 0;
            }
            int nt = nthreads;
            if (nt > list.length - n) {
                nt = list.length - n;
            }
            for (int i = 0; i < nt; i++) {
                if (threads[i].isAlive()) {
                    list[n++] = threads[i];
                }
            }
            if (recurse) {
                ngroupsSnapshot = ngroups;
                if (groups != null) {
                    groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
                } else {
                    groupsSnapshot = null;
                }
            }
        }
        if (recurse) {
            for (int i = 0 ; i < ngroupsSnapshot ; i++) {
                n = groupsSnapshot[i].enumerate(list, n, true);
            }
        }
        return n;
    }
```

下面，我们再写个简单的例子来演示一下如何使用这两个方法，首先定义一个ThreadGroup，并且将该group加入到main group中，

然后定义一个线程thread并将其加入到myGroup中，最后分别调用enumerate的递归和非递归方法
```
import java.util.concurrent.TimeUnit;
public class ThreadGroupEnumerateThreads
{
    public static void main(String[] args)
            throws InterruptedException
    {
        //创建一个ThreadGroup
        ThreadGroup myGroup = new ThreadGroup("MyGroup");
        //创建线程传入threadgroup
        Thread thread = new Thread(myGroup, () ->
        {
            while (true)
            {
                try
                {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e)
                {
                }
            }
        }, "MyThread");
        thread.start();

        TimeUnit.MILLISECONDS.sleep(2);
        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();


        Thread[] list = new Thread[mainGroup.activeCount()];
        int recurseSize = mainGroup.enumerate(list);
        System.out.println(recurseSize);

        recurseSize = mainGroup.enumerate(list, false);
        System.out.println(recurseSize);
    }
}
```
上面的代码运行之后，最后一个输出会比第一个少1，那是因为代码中将递归recurse设置为了false，myGroup中的线程将不会包含在内。

- enumerate方法获取的线程仅仅是个预估值，并不能百分之百地保证当前group的活跃线程，比如在调用复制之后，某个线程结束了生命周期或者新的线程加入了进来，都会导致数据的不准确。

- enumerate方法的返回值int相较Thread[]的长度更为真实，比如定义了数组长度的Thread数组，那么enumerate方法仅仅会将当前活跃的thread分别放进数组中，而返回值int则代表真实的数量，并非Thread数组的长度，可能是早期版本就有这个方法的缘故（JDK1.0），其实用List（JDK1.1版本才引入）会更好一些。

## ThreadGroup操作
ThreadGroup并不能提供对线程的管理，ThreadGroup的主要功能是对线程进行组织。将详细介绍ThreadGroup的主要方法。

### ThreadGroup的基本操作
- activeCount（）用于获取group中活跃的线程，这只是个估计值，并不能百分之百地保证数字一定正确，原因前面已经分析过，该方法会递归获取其他子group中的活跃线程。
- activeGroupCount（）用于获取group中活跃的子group，这也是一个近似估值，该方法也会递归获取所有的子group。
- getMaxPriority（）用于获取group的优先级，默认情况下，Group的优先级为10，在该group中，所有线程的优先级都不能大于group的优先级。
- getName（）用于获取group的名字。
- getParent（）用于获取group的父group，如果父group不存在，则会返回null，比如system group的父group就为null。
- list（）该方法没有返回值，执行该方法会将group中所有的活跃线程信息全部输出到控制台，也就是System.out。
- parentOf（ThreadGroup g）会判断当前group是不是给定group的父group，另外如果给定的group就是自己本身，那么该方法也会返回true。
- setMaxPriority（int pri）会指定group的最大优先级，最大优先级不能超过父group的最大优先级，执行该方法不仅会改变当前group的最大优先级，还会改变所有子group的最大优先级。

下面我们给出一个简单的例子来测试一下上面的几个方法。
```
import java.util.concurrent.TimeUnit;

public class ThreadGroupBasic
{
    public static void main(String[] args) throws InterruptedException
    {

        /*
         * Create a thread group and thread.
         */
        ThreadGroup group = new ThreadGroup("group1");
        Thread thread = new Thread(group, () ->
        {
            while (true)
            {
                try
                {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
        }, "thread");
        thread.setDaemon(true);
        thread.start();

        //make sure the thread is started
        TimeUnit.MILLISECONDS.sleep(1);

        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();

        System.out.println("activeCount=" + mainGroup.activeCount());
        System.out.println("activeGroupCount=" + mainGroup.activeGroupCount());
        System.out.println("getMaxPriority=" + mainGroup.getMaxPriority());
        System.out.println("getName=" + mainGroup.getName());
        System.out.println("getParent=" + mainGroup.getParent());
        mainGroup.list();
        System.out.println("--------------------------");
        System.out.println("parentOf="+mainGroup.parentOf(group));
    System.out.println("parentOf="+mainGroup.parentOf(mainGroup));
    }
}
```
执行结果如下，大家可以自行分析一下。
```
activeCount=3
activeGroupCount=1
getMaxPriority=10
getName=main
getParent=java.lang.ThreadGroup[name=system,maxpri=10]
java.lang.ThreadGroup[name=main,maxpri=10]
    Thread[main,5,main]
    Thread[Monitor Ctrl-Break,5,main]
    java.lang.ThreadGroup[name=group1,maxpri=10]
        Thread[thread,5,group1]
--------------------------
parentOf=true
parentOf=true

Process finished with exit code 0
```
这里需要特别说明的是setMaxPriority，我们通过分析源码得出结论，线程的最大优先级，不能高于所在线程组的最大优先级，但是如果我们把代码写成下面这样会怎么样呢？

```
import java.util.concurrent.TimeUnit;

public class ThreadGroupPriority
{
    public static void main(String[] args)
    {
        /*
         * Create a thread group and thread.
         */
        ThreadGroup group = new ThreadGroup("group1");
        Thread thread = new Thread(group, () ->
        {
            while (true)
            {
                try
                {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
        }, "thread");
        thread.setDaemon(true);
        thread.start();

    System.out.println("group.getMaxPriority()="+group.getMaxPriority());

    System.out.println("thread.getPriority()="+thread.getPriority());
    //① 改变group的最大优先级
    group.setMaxPriority(3);

    System.out.println("group.getMaxPriority()="+group.getMaxPriority());

    System.out.println("thread.getPriority()="+thread.getPriority());
    }
}
```

运行上面的程序，会出现thread的优先级大于所在group最大优先级的情况，如下所示：
```
group.getMaxPriority()=10
thread.getPriority()=5
group.getMaxPriority()=3
thread.getPriority()=5
```
虽然出现了已经加入该group的线程的优先级大于group最大优先级的情况，但是后面加入该group的线程再不会大于新设置的值：3，这一点需要大家注意。

## ThreadGroup的interrupt
interrupt一个thread group会导致该group中所有的active线程都被interrupt。

也就是说该group中每一个线程的interrupt标识都被设置了，下面是ThreadGroup interrupt方法的源码：
```
public final void interrupt() {
    int ngroupsSnapshot;
    ThreadGroup[] groupsSnapshot;
    synchronized (this) {
        checkAccess();
        for (int i = 0 ; i < nthreads ; i++) {
            threads[i].interrupt();
        }
        ngroupsSnapshot = ngroups;
        if (groups != null) {
            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
        } else {
            groupsSnapshot = null;
        }
    }
    for (int i = 0 ; i < ngroupsSnapshot ; i++) {
        groupsSnapshot[i].interrupt();
    }
}
```
分析上述源码，我们可以看出在interrupt内部会执行所有thread的interrupt方法，

并且会递归获取子group，然后执行它们各自的interrupt方法，下面我们写个简单的程序测试一下：
```
import java.util.concurrent.TimeUnit;

public class ThreadGroupInterrupt
{
    public static void main(String[] args) throws InterruptedException
    {

        ThreadGroup group = new ThreadGroup("TestGroup");

        new Thread(group, () ->
        {
            while (true)
            {
                try
                {
                    TimeUnit.MILLISECONDS.sleep(2);
                } catch (InterruptedException e)
                {
                    //received interrupt SIGNAL and clear quickly
                    break;
                }
            }
            System.out.println("t1 will exit.");
        }, "t1").start();

        new Thread(group, () ->
        {
            while (true)
            {
                try
                {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e)
                {
                    //received interrupt SIGNAL and clear quickly
                    break;
                }
            }
            System.out.println("t2 will exit.");
        }, "t2").start();

        //make sure all of above threads started.
        TimeUnit.MILLISECONDS.sleep(2);

        group.interrupt();
    }
}
```
上面的代码足够简单，不必多做解释，从运行结果中可以看出，group中的active thread都将被interrupt。

## ThreadGroup的destroy
destroy用于销毁ThreadGroup，该方法只是针对一个没有任何active线程的group进行一次destroy标记，调用该方法的直接结果是在父group中将自己移除：
```
Destroys this thread group and all of its subgroups. This thread  group must be empty, indicating that all threads that had been in this thread group have since stopped.

（销毁ThreadGroup及其子ThreadGroup，在该ThreadGroup中所有的线程必须是空的，也就是说ThreadGroup或者子ThreadGroup所有的线程都已经停止运行，如果有Active线程存在，调用destroy方法则会抛出异常。）
```

下面我们写一个简单的代码对其进行测试：
```
public class ThreadGroupDestroy
{

    public static void main(String[] args)
    {
        ThreadGroup group = new ThreadGroup("TestGroup");

        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();
        System.out.println("group.isDestroyed=" + group.isDestroyed());
        mainGroup.list();

        group.destroy();

        System.out.println("group.isDestroyed=" + group.isDestroyed());
        mainGroup.list();
    }
}
```

程序的运行结果如下所示，其中isDestroyed方法是判断ThreadGroup是否被destroy了：
```
ggroup.isDestroyed=false
java.lang.ThreadGroup[name=main,maxpri=10]
    Thread[main,5,main]
    Thread[Monitor Ctrl-Break,5,main]
    java.lang.ThreadGroup[name=TestGroup,maxpri=10]
group.isDestroyed=true
java.lang.ThreadGroup[name=main,maxpri=10]
    Thread[main,5,main]
    Thread[Monitor Ctrl-Break,5,main]
```

## 守护ThreadGroup
线程可以设置为守护线程，ThreadGroup也可以设置为守护ThreadGroup，但是若将一个ThreadGroup设置为daemon，也并不会影响线程的daemon属性，

如果一个ThreadGroup的daemon被设置为true，那么在group中没有任何active线程的时候该group将自动destroy，下面我们给出一个简单的例子来对其进行说明：

```
import java.util.concurrent.TimeUnit;

public class ThreadGroupDaemon
{
    public static void main(String[] args)
            throws InterruptedException
    {

        ThreadGroup group1 = new ThreadGroup("Group1");
        new Thread(group1, () ->
        {
            try
            {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        }, "group1-thread1").start();

        ThreadGroup group2 = new ThreadGroup("Group2");
        new Thread(group2, () ->
        {
            try
            {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        }, "group2-thread1").start();

        //设置daemon为true
        group2.setDaemon(true);

        TimeUnit.SECONDS.sleep(3);
        System.out.println(group1.isDestroyed());
        System.out.println(group2.isDestroyed());
    }
}
```
在上面的代码中，第二个group的daemon被设置为true，当其中没有active线程的时候，该group将会自动被destroy，而第一个group则相反。





