---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++STL std::literals是什么以及怎么用 

## 前言
学c++20标准里面的信号量的时候遇到了std::literals,一时懵逼。实际上很简单，literals翻译过来就是字面量。比如有个参数是3毫秒，我们可以直接写成3ms，编译器自动把3ms转成对应的类型。比如3小时，我们可以写成3h，编译器自动转换成函数参数对应的类型。看完下面的例子就懂了。

C++11标准里有个计时类chrono，让当前线程sleep六秒钟的用法如下。
```
#include <iostream>
#include <sstream>
#include <time.h>
#include <chrono>
#include <ratio>
#include <thread>

/// <summary>
/// 打印当前时间
/// </summary>
void printCurrentTime()
{
	time_t now = time(NULL);
	tm tm_t;
	int ret = localtime_s(&tm_t, &now);
	std::stringstream ss;
	ss << tm_t.tm_hour << ":" << tm_t.tm_min << ":" << tm_t.tm_sec << std::endl;
	std::cout << ss.str();
}

int main()
{
	// duration 翻译是一段时间一段时间一段
	// 定义计时器要用到的秒类型

	typedef std::chrono::duration<int> seconds_type;//[注释：duration的类型定义]

	seconds_type seconds_6(6);//6秒
	printCurrentTime();
	std::this_thread::sleep_for(seconds_6);//sleep 6秒钟
	printCurrentTime();
	
}

```
阅读代码得知，如果用到chrono则难以避免要用到duration类型，而duration类型的定义又比较复杂。所以std::literals就出来了，还是直接看例子。
```
// testChrono.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <sstream>
#include <time.h>
#include <chrono>
#include <ratio>
#include <thread>

/// <summary>
/// 打印当前时间
/// </summary>
void printCurrentTime()
{
	time_t now = time(NULL);
	tm tm_t;
	int ret = localtime_s(&tm_t, &now);
	std::stringstream ss;
	ss << tm_t.tm_hour << ":" << tm_t.tm_min << ":" << tm_t.tm_sec << std::endl;
	std::cout << ss.str();
}

int main()
{
	using namespace std::literals;
	printCurrentTime();
	std::this_thread::sleep_for(3s);//sleep 三秒
	printCurrentTime();
}


```
使用了using namespace std::literals;之后，我们可以3s直接表示3秒、3ms表示3毫秒、3h表示3小时…

## 自定义字面量
字面量（literal）是指在源代码中写出的固定常量，它们在 C++98 里只能是原生类型，如：

"hello"，字符串字面量，类型是 const char[6]
1，整数字面量，类型是 int
0.0，浮点数字面量，类型是 double
3.14f，浮点数字面量，类型是 float
123456789ul，无符号长整数字面量，类型是 unsigned long
C++11 引入了自定义字面量，可以使用 operator"" 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。下面这个程序展示了它们的用法：
```
#include <chrono>
#include <complex>
#include <iostream>
#include <string>
#include <thread>
 
using namespace std;
 
int main()
{
  cout << "i * i = " << 1i * 1i
       << endl;
  cout << "Waiting for 500ms"
       << endl;
  this_thread::sleep_for(500ms);
  cout << "Hello world"s.substr(0, 5)
       << endl;
}
```
输出是：
```
i * i = (-1,0)
Waiting for 500ms
Hello
```
上面这个例子展示了 C++ 标准里提供的帮助生成虚数、时间和 basic_string 字面量的后缀 。一个需要注意的地方是，我在上面使用了 using namespace std，这会同时引入 std 名空间和里面的内联名空间（inline namespace），包括了上面的字面量运算符所在的三个名空间:

std::literals::complex_literals
std::literals::chrono_literals
std::literals::string_literals
在产品项目中，一般不会（也不应该）全局使用 using namespace std（不过，为节约篇幅起见，专栏里的很多例子，特别是不完整的例子，还是默认使用了 using namespace std）。这种情况下，应当在使用到这些字面量的作用域里导入需要的名空间，以免发生冲突。在类似上面的例子里，就是在函数体的开头写：
```
using namespace std::literals::
  chrono_literals;
```
要在自己的类里支持字面量也相当容易，唯一的限制是非标准的字面量后缀必须以下划线 _ 打头。比如，假如我们有下面的长度类：
```
struct length {
  double value;
  enum unit {
    metre,
    kilometre,
    millimetre,
    centimetre,
    inch,
    foot,
    yard,
    mile,
  };
  static constexpr double factors[] =
    {1.0,    1000.0,  1e-3,
     1e-2,   0.0254,  0.3048,
     0.9144, 1609.344};
  explicit length(double v,
                  unit u = metre)
  {
    value = v * factors[u];
  }
};
 
length operator+(length lhs,
                 length rhs)
{
  return length(lhs.value +
                rhs.value);
}
 
// 可能有其他运算符
```
我们可以手写 length(1.0, length::metre) 这样的表达式，但估计大部分开发人员都不愿意这么做吧。反过来，如果我们让开发人员这么写，大家应该还是基本乐意的：
```
1.0_m + 10.0_cm
```
要允许上面这个表达式，我们只需要提供下面的运算符即可：
```
length operator"" _m(long double v)
{
  return length(v, length::metre);
}
 
length operator"" _cm(long double v)
{
  return length(v, length::centimetre);
}
```
