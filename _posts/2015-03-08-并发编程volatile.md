---
layout: post
categories: [JUC]
description: none
keywords: JUC
---
# 并发编程volatile
自Java 1.5版本起，volatile关键字所扮演的角色越来越重要，该关键字也成为并发包的基础，所有的原子数据类型都以此作为修饰，相比synchronized关键字，volatile被称为“轻量级锁”，能实现部分synchronized关键字的语义。

- 通过一个简单的例子引入volatile关键字的使用场景，然后详细介绍Java的内存模型以及CPU Cache模型等，很好地掌握JMM以及CPU Cache等知识，对理解volatile关键字会有很大的帮助。
- 从并发编程所要注意的三个主要特性：原子性、可见性、有序性入手，然后分析了在Java内存模型中应通过何种方式来保证这三个特性，最后深入分析了volatile关键字的语义、原理和使用场景。

## volatile关键字的介绍
正如我们前面所说的，volatile是一个非常重要的关键字，虽然看起来很简单，但是想要彻底弄清楚volatile的来龙去脉还是需要具备Java内存模型、CPU缓存模型等知识的。

## 初识volatile关键字
下面这段程序分别启动了两个线程，一个线程负责对变量进行修改，一个线程负责对变量进行输出，根据本书第一部分的知识讲解，该变量就是共享资源（数据），那么在多线程操作的情况下，很有可能会引起数据不一致等线程安全的问题。
```
import java.util.concurrent.TimeUnit;

public class VolatileFoo
{
    //init_value的最大值
    final static int MAX = 5;
    //init_value的初始值
    static int init_value = 0;

    public static void main(String[] args)
{
        //启动一个Reader线程，当发现local_value和init_value不同时，则输出init_value被修改的信息
        new Thread(() ->
        {
            int localValue = init_value;
            while (localValue < MAX)
            {
                if (init_value != localValue)
                {
                    System.out.printf("The init_value is updated to [%d]\n", init_value);
                    //对localValue进行重新赋值
                    localValue = init_value;
                }
            }
        }, "Reader").start();

        //启动Updater线程，主要用于对init_value的修改，当local_value>=5的时候则退出生命周期
        new Thread(() ->
        {
            int localValue = init_value;
            while (localValue < MAX)
            {
                //修改init_value
                System.out.printf("The init_value will be changed to [%d]\n", ++localValue);
                init_value = localValue;
                try
                {
                    //短暂休眠，目的是为了使Reader线程能够来得及输出变化内容
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
        }, "Updater").start();
    }
}
```
在运行上面的程序之前，想象一下程序的输出将会是怎样的呢？Updater线程的每一次修改都会使得Reader线程进行一次输出？如果你是这样认为的，那么事实会让你大跌眼镜，输出如下：
```
The init_value will be changed to [1]
The init_value will be changed to [2]
The init_value will be changed to [3]
The init_value will be changed to [4]
The init_value will be changed to [5]
```

通过控制台的输出信息我们不难发现，Reader线程压根就没有感知到init_value的变化而进入了死循环，这是为什么呢？我们将init_value的定义做一次小小的调整，代码如下：
```
static volatile int init_value = 0;
```
这里为init_value变量增加volatile关键字的修饰。再次运行修改后的程序，你会发现Reader线程会感知到init_value变量的变化，并且在条件不满足时退出运行，输出如下：
```
The init_value will be changed to [1]
The init_value is updated to [1]
The init_value will be changed to [2]
The init_value is updated to [2]
The init_value will be changed to [3]
The init_value is updated to [3]
The init_value will be changed to [4]
The init_value is updated to [4]
The init_value will be changed to [5]
The init_value is updated to [5]
```
为什么会出现这样的情况呢，其实这一切都是volatile关键字所起的作用。

**volatile关键字只能修饰类变量和实例变量，对于方法参数、局部变量以及实例常量，类常量都不能进行修饰，比如上面代码中的MAX就不能使用volatile关键字进行修饰。**

## 机器硬件CPU
在计算机中，所有的运算操作都是由CPU的寄存器来完成的，CPU指令的执行过程需要涉及数据的读取和写入操作，CPU所能访问的所有数据只能是计算机的主存（通常是指RAM）。

虽然CPU的发展频率不断地得到提升，但受制于制造工艺以及成本等的限制，计算机的内存反倒在访问速度上并没有多大的突破，因此CPU的处理速度和内存的访问速度之间的差距越拉越大，通常这种差距可以达到上千倍，极端情况下甚至会在上万倍以上。

### CPU Cache模型





