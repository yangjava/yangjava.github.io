---
layout: post
categories: [Prometheus,PromQL]
description: none
keywords: Prometheus
---
# 监控信息采集

## 服务性能监控之Micrometer
Micrometer 为基于 JVM 的应用程序的性能监测数据收集提供了一个通用的 API，支持多种度量指标类型，这些指标可以用于观察、警报以及对应用程序当前状态做出响应。

## 模块架构

```
micrometer-core
  annotation
  aop
  instrument [插桩]
    binder [绑定]
      cache [针对缓存的度量采集,ehcache guava jcache等]
      commonspool2
      db [postgresql等度量采集]
      grpc[grpc客服端服务端度量采集]
      http[Java_servlet度量采集]
      httpcomponents[Apache http-client度量采集]
      hystrix
      server
      jetty
      jpa
      jvm
      kafka
      logging
      mongodb
      okhttp3
      system
      tomcat
```

## 源码解读
MeterRegistry有两大类[SimpleMeterRegistry,CompositeMeterRegistry]单注册源和多注册源

MeterRegistry针对不同数据源实现包含
    - HealthMeterRegistry
    - PrometheusMeterRegistry
    - AtlasMeterRegistry etc…

PrometheusMeterRegistry负责创建micrometer的度量,比如PrometheusCounter,DefaultGauge等,同时为每个度量创建一个MicrometerCollector
MicrometerCollector负责注册prometheus的CollectorRegistry,采集时通过MicrometerCollector收集PrometheusCounter或者其他度量的指标信息

## Prometheus
通过添加如下依赖可以将 Micrometer 收集的服务指标数据发布到 Prometheus 中。
```xml
<dependency>
  <groupId>io.micrometer</groupId>
  <artifactId>micrometer-registry-prometheus</artifactId>
  <version>${micrometer.version}</version>
</dependency>
```
当然如果你还没有确定好接入哪种监测系统，也可以先直接依赖micrometer-core，然后创建一个SimpleMeterRegistry。

## 可接入监控系统
Micrometer 有一组包含各种监控系统实现的模块，其中的每一种实现被称为registry。

在深入了解 Micrometer 之前，我们首先来看一下监控系统的三个重要特征：
- 维度（Dimensionality）：描述系统是否支持多维度数据模型。
- 速率聚合（Rate Aggregation）：指的是在规定的时间间隔内的一组样本聚合。一种是指标数据发送前在客户端做速率聚合，另一种是直接发送聚合值。
- 发布（Publishing）：描述的是指标数据的发布方式，一种是客户端定时将数据推送给监控系统，还有一种是监控系统在空闲时间自己调客户端接口拉数据。

## Registry
Meter是一个用于收集应用程序各项指标数据的接口，Micrometer 中的所有的Meters都通过MeterRegistry创建并管理，Micrometer 支持的每一种监控系统都有对应的MeterRegistry实现。

最简单的Register就是SimpleMeterRegistry（在 Spring-based 的应用程序中自动装配），它会在内存中保存每个meter的最新值，但是不会将这个值发布到任何地方。
```
MeterRegistry registry = new SimpleMeterRegistry();
```

Composite Registries
Micrometer 提供了一个CompositeMeterRegistry，允许开发者通过添加多个 registry 的方式将指标数据同时发布到多个监控系统中。
```
CompositeMeterRegistry composite = new CompositeMeterRegistry();

Counter compositeCounter = composite.counter("counter");
// 此处increment语句处于等待状态，直到CompositeMeterRegistry注册了一个registry。
// 此时counter计数器值为0
compositeCounter.increment(); (1)

SimpleMeterRegistry simple = new SimpleMeterRegistry();
// counter计数器注册到simple registry
composite.add(simple); (2)

// simple registry counter 与CompositeMeterRegistry中的其他registries的counter一起递增
compositeCounter.increment(); (3)
```

Global Registry
Micrometer 提供了一个全局注册表Metrics.globalRegistry，它也是一个CompositeMeterRegistry，其内部提供了一系列用于构建 meters 的方法。
```
public class Metrics {
    public static final CompositeMeterRegistry globalRegistry = new CompositeMeterRegistry();
    private static final More more = new More();

    /**
     * 当使用Metrics.counter(…)之类的方法构建meters之后，就可以向globalRegistry中添加registry了
     * 这些meters会被添加到每个registry中
     *
     * @param registry Registry to add.
     */
    public static void addRegistry(MeterRegistry registry) {
        globalRegistry.add(registry);
    }

    /**
     * Remove a registry from the global composite registry. Removing a registry does not remove any meters
     * that were added to it by previous participation in the global composite.
     *
     * @param registry Registry to remove.
     */
    public static void removeRegistry(MeterRegistry registry) {
        globalRegistry.remove(registry);
    }

    /**
     * Tracks a monotonically increasing value.
     *
     * @param name The base metric name
     * @param tags Sequence of dimensions for breaking down the name.
     * @return A new or existing counter.
     */
    public static Counter counter(String name, Iterable<Tag> tags) {
        return globalRegistry.counter(name, tags);
    }

    ...
}
```

自定义 Registry
Micrometer 为我们提供了很多开箱即用的 Registry，基本上可以满足大多数的业务场景。同时也支持用户根据实际场景需求，自定义 registry。

通常我们可以通过继承MeterRegistry, PushMeterRegistry, 或者 StepMeterRegistry来创建定制化的 Registry。
```
// 自定义registry config
public interface CustomRegistryConfig extends StepRegistryConfig {

  CustomRegistryConfig DEFAULT = k -> null;

  @Override
  default String prefix() {
    return "custom";
  }

}


// 自定义registry
public class CustomMeterRegistry extends StepMeterRegistry {

  public CustomMeterRegistry(CustomRegistryConfig config, Clock clock) {
    super(config, clock);

    start(new NamedThreadFactory("custom-metrics-publisher"));
  }

  @Override
  protected void publish() {
    getMeters().stream().forEach(meter -> System.out.println("Publishing " + meter.getId()));
  }

  @Override
  protected TimeUnit getBaseTimeUnit() {
    return TimeUnit.MILLISECONDS;
  }

}

/**
 *
 */
@Configuration
public class MetricsConfig {

  @Bean
  public CustomRegistryConfig customRegistryConfig() {
    return CustomRegistryConfig.DEFAULT;
  }

  @Bean
  public CustomMeterRegistry customMeterRegistry(CustomRegistryConfig customRegistryConfig, Clock clock) {
    return new CustomMeterRegistry(customRegistryConfig, clock);
  }

}
```

## Meters
Micrometer 支持多种类型的度量器，包括Timer, Counter, Gauge, DistributionSummary, LongTaskTimer, FunctionCounter, FunctionTimer以及TimeGauge。

在 Micrometer 中，通过名称和维度（dimensions，也可以称为"tags"，即 API 中的Tag标签）来唯一确定一种meter。引入维度的概念便于我们对某一指标数据进行更细粒度的拆分研究。

### Naming Meters
每种监控系统都有自己的命名风格，不同系统间的命名规则可能是不兼容的。Micrometer 采用的命名约定是通过.来分隔小写单词。在 Micrometer 中，针对每种监控系统的不同实现都会将这种.分隔单词的命名风格转换为各个监控系统推荐的命名约定，同时也会去除命名中禁止出现的特殊字符。

```
// Micrometer naming convention
registry.timer("http.server.requests");

// Prometheus naming convention
registry.timer("http_server_requests_duration_seconds");

// Atlas naming convention
registry.timer("httpServerRequests");

// Graphite naming convention
registry.timer("http.server.requests");

// InfluxDB naming convention
registry.timer("http_server_requests");
```

当然，我们可以通过实现NamingConvention接口来覆盖默认的命名约定规则：
```
registry.config().namingConvention(myCustomNamingConvention);
```

### Tag Naming
对于 Tag 的命名，建议也采用跟 meter 一致的点号分隔小写单词的方式，这同样有助于将命名风格转换为各个监控系统推荐的命名模式。
```
registry.counter("database.calls", "db", "users")
registry.counter("http.requests", "uri", "/api/users")
```
这种命名方式为我们分析数据提供了足够的上下文语义，设想如果我们只通过 name 分析数据，得到的数据也是有意义的。比如，选择database.calls，那我们就可以得到针对所有数据库的访问情况。接下来如果想要深入分析，就可以通过Tag标签db来对数据做进一步的筛选。

错误示例
```
registry.counter("calls",
    "class", "database",
    "db", "users");

registry.counter("calls",
    "class", "http",
    "uri", "/api/users");
```
再来看一下上面这种命名方式，此时如果仅仅通过 name 属性calls来查看数据，得到的是包含了 db 访问和 http 调用的所有的指标数据。显然这种数据对于我们分析生产问题来说是毫无意义的，需要进一步选择class标签来细化数据维度。

### Common Tags
common tags 属于 registry 级别的 tag，它会被应用到报告给监控系统的所有 metric 中，这类 tag 通常是系统维度的一些属性，比如 host、instance、region、堆栈信息等等。

```
registry.config().commonTags("stack", "prod", "region", "us-east-1");
registry.config().commonTags(Arrays.asList(Tag.of("stack", "prod"), Tag.of("region", "us-east-1"))); // equivalently
```
common tags 必须在添加任何 meter 之前就被加入到 registry 中。

### Tag Values
首先，tag values 不能为空。

除此之外，我们还需要做的就是对 tag 值做规范化，对其可能取值做限制。比如针对 HTTP 请求中的 404 异常响应，可以将这类异常的响应值设置为统一返回NOT_FOUND，否则指标数据的度量维度将会随着这类找不到资源异常数量的增加而增长，导致本该聚合的指标数据变得很离散。

## Meter Filters
Meter Filter 用于控制meter注册时机、可以发布哪些类型的统计数据，我们可以给每一个 registry 配置过滤器。

过滤器提供以下三个基本功能：
- 拒绝/接受meter注册。
- 变更meter的 ID 信息（io.micrometer.core.instrument.Meter.Id）
- 针对某些类型的meter配置分布统计。
```
registry.config()
    // 多个filter配置按顺序生效
    .meterFilter(MeterFilter.ignoreTags("too.much.information"))
    .meterFilter(MeterFilter.denyNameStartsWith("jvm"));
```

拒绝/接受Meters
用于配置只接受指定形式的meters，或者屏蔽某些meters。
```
new MeterFilter() {
    @Override
    public MeterFilterReply accept(Meter.Id id) {
       if(id.getName().contains("test")) {
          return MeterFilterReply.DENY;
       }
       return MeterFilterReply.NEUTRAL;
    }
}


public enum MeterFilterReply {
    // 拒绝meter注册请求，registry将会返回一个该meter的NOOP版本（如NoopCounter、NoopTimer）
    DENY,

    // 当没有任何过滤器返回DENY时，meter的注册流程继续向前推进
    NEUTRAL,

    // 表示meter注册成功，无需继续向下流转“询问”其他filter的accept(...)方法
    ACCEPT
}
```
针对Meter的 deny/accept 策略， MeterFilter为我们提供了一些常用的方法：
- accept()：接受所有的meter注册，该方法之后的任何 filter 都是无效的。
- accept(Predicate<Meter.Id>)：接收满足给定条件的meter注册。
- acceptNameStartsWith(String)：接收 name 以指定字符打头的meter注册。
- deny()：拒绝所有meter的注册请求，该方法之后的任何 filter 都是无效的。
- denyNameStartsWith(String)：拒绝所有 name 以指定字符串打头的meter的注册请求。
- deny(Predicate<Meter.Id>)：拒绝满足特定条件的meter的注册请求。
- maximumAllowableMetrics(int)：当已注册的meters数量达到允许的注册上限时，拒绝之后的所有注册请求。
- maximumAllowableTags(String meterNamePrefix, String tagKey, int maximumTagValues, MeterFilter onMaxReached)：设置一个tags上限，达到这个上限时拒绝之后的注册请求。
- denyUnless(Predicate<Meter.Id>)：白名单机制，拒绝不满足给定条件的所有meter的注册请求。

### 变更Meter的 ID 信息
```
new MeterFilter() {
    @Override
    public Meter.Id map(Meter.Id id) {
       if(id.getName().startsWith("test")) {
          return id.withName("extra." + id.getName()).withTag("extra.tag", "value");
       }
       return id;
    }
}
```

常用方法：
- commonTags(Iterable<Tag>)：为所有指标添加一组公共 tags。通常建议开发者为应用程序名称、host、region 等信息添加公共 tags。
- ignoreTags(String…)：用于从所有meter中去除指定的 tag key。比如当我们发现某个 tag 具有过高的基数，并且已经对监控系统构成压力，此时可以在无法立即改变所有检测点的前提下优先采用这种方式来快速减轻系统压力。
- replaceTagValues(String tagKey, Function<String, String> replacement, String…​ exceptions)：替换满足指定条件的所有 tag 值。通过这种方式可以某个 tag 的基数大小。
- renameTag(String meterNamePrefix, String fromTagKey, String toTagKey)：重命名所有以给定前缀命名的metric的 tag key。

配置分布统计信息
```
new MeterFilter() {
    @Override
    public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) {
        if (id.getName().startsWith(prefix)) {
            return DistributionStatisticConfig.builder()
                    // ID名称以指定前缀开头的请求提供指标统计直方图信息
                    .publishPercentiles(0.9, 0.95)
                    .build()
                    .merge(config);
        }
        return config;
    }
};
```

## 速率聚合
速率聚合可以在指标数据发布之前在客户端完成，也可以作为服务器查询的一部分在服务端临时聚合。Micrometer 可以根据每种监控系统的风格

并不是所有的指标都需要被视为一种速率来发布或查看。例如，gauge值或者长期定时任务中的活跃任务数都不是速率。

## 服务端聚合
执行服务端速率计算的监控系统期望能在每个发布间隔报告计数绝对值。例如，从应用程序启动开始 counter 计数器在每个发布间隔产生的所有增量的绝对计数和。

当服务重启时 counter 的计数值就会降为零。一旦新的服务实例启动成功，速率聚合图示曲线将会返回到 55 左右的数值。

## 客户端聚合
在实际应用中，有以下两类监控系统期望客户端在发布指标数据之前完成速率聚合。

期望得到聚合数据。生产环境中大多数情况下我们都需要基于服务指标的速率作出决策，这种情况下服务端需要做更少的计算来满足查询要求。
查询阶段只有少量或者根本没有数学计算允许我们做速率聚合。对于这些系统，发布一个预先聚合的数据是非常有意义的事情。

## 指标类型

### Counters
Counters 用于报告一个单一的计数指标。Counter 接口允许按照一个固定正向值递增。

当使用counter构建图表和报警时，通常我们最感兴趣的是事件在给定的时间间隔内发生的速率。例如给定一个队列，我们可以使用counter度量数据项写入队列以及从队列中移除的速度。
```
Normal rand = ...; // a random generator

MeterRegistry registry = ...
Counter counter = registry.counter("counter"); (1)

Flux.interval(Duration.ofMillis(10))
        .doOnEach(d -> {
            if (rand.nextDouble() + 0.1 > 0) { (2)
                counter.increment(); (3)
            }
        })
        .blockLast();

// counter流式调用
Counter counter = Counter
    .builder("counter")
    .baseUnit("beans") // optional
    .description("a description of what this counter does") // optional
    .tags("region", "test") // optional
    .register(registry);
```

### Gauges
gauge用于获取当前值。常见的应用场景比如实时统计当前运行的线程数。

gauge对于监测那些具有自然上限的属性来说比较有用。它不适合用于统计应用程序的请求数，因为请求数会随着服务生命周期的增加而无限延长。

永远不要用gauge度量那些本可以使用counter计数的数据。
```
List<String> list = registry.gauge("listGauge", Collections.emptyList(), new ArrayList<>(), List::size); (1)
List<String> list2 = registry.gaugeCollectionSize("listSize2", Tags.empty(), new ArrayList<>()); (2)
Map<String, Integer> map = registry.gaugeMapSize("mapGauge", Tags.empty(), new HashMap<>());

// maintain a reference to myGauge
AtomicInteger myGauge = registry.gauge("numberGauge", new AtomicInteger(0));

// ... elsewhere you can update the value it holds using the object reference
myGauge.set(27);
myGauge.set(11);
```
还有一种特殊类型的Gauge-MultiGauge，可以一次发布一组 metric。
```
// SELECT count(*) from job group by status WHERE job = 'dirty'
MultiGauge statuses = MultiGauge.builder("statuses")
    .tag("job", "dirty")
    .description("The number of widgets in various statuses")
    .baseUnit("widgets")
    .register(registry);

...

// run this periodically whenever you re-run your query
statuses.register(
    resultSet.stream()
        .map(result -> Row.of(Tags.of("status", result.getAsString("status")), result.getAsInt("count"))));
```







