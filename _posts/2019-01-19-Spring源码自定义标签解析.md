---
layout: post
categories: [Spring]
description: none
keywords: Spring
---
# Spring源码自定义标签解析

## 自定义标签的解析
当完成从配置文件到Document的转换并提取对应的root后,将开始了所有元素的解析,而在这一过程中便开始了默认标签与自定义标签两中格式的区分。
```
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                else {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        delegate.parseCustomElement(root);
    }
}

```
核心方法: parseCustomElement(root)。当Spring拿到一个元素时首先要做的是根据命名空间进行解析,如果是默认的命名空间,则使用parseDefaultElement方法进行元素解析,否则使用parseCustomElement方法进行解析.

```
public BeanDefinition parseCustomElement(Element ele) {
    return parseCustomElement(ele, null);
}

//containingBd为父类bean，对顶层元素的解析应设置为null
public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {
    //获取对应的命名空间
    String namespaceUri = getNamespaceURI(ele);
    //根据命名空间找到对应的NamespaceHandler
    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
    if (handler == null) {
        error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele);
        return null;
    }
    //调用自定义的NamespaceHandler进行解析
    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
}
```
上述代码的大致流程：

根据对应的bean获取对应的命名空间,根据命名空间解析对应的处理器,然后根据用户自定义的处理器进行解析。

## 获取标签的命名空间
无论是区分Spring中默认标签和自定义标签还是区分自定义标签中不同标签的处理器都是以标签所提供的命名空间为基础的,而至于如何提取对应元素的命名空间其实不需要我们亲自去实现,在org.w3c.dom.Node中已经提供了方法供我们直接调用。
```
public String getNamespaceURI(Node node){
    return node.getNamespaceURI();
}
```

## 提取自定义标签处理器

有了命名空间,就可以进行NamespaceHandler的提取了,继续之前的parseCustomElement方法的跟踪,分析NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);,

在readerContext初始化的时候其属性namespaceHandlerResolver已经被初始化为了DefaultNamespaceHandlerResolver的实例,所以这里调用的resolve方法其实调用的是DefaultNamespaceHandlerResolver类中的方法.我们进入DefaultNamespaceHandlerResolver的resolve方法进行查看.

```
	@Override
	public NamespaceHandler resolve(String namespaceUri) {
        //获取所有已配置的handler映射
		Map<String, Object> handlerMappings = getHandlerMappings();
        //根据命名空间找到对应的信息
		Object handlerOrClassName = handlerMappings.get(namespaceUri);
		if (handlerOrClassName == null) {
			return null;
		}
		else if (handlerOrClassName instanceof NamespaceHandler) {
            //已经做过解析的情况，直接从缓存读取
			return (NamespaceHandler) handlerOrClassName;
		}
		else {
            //没有做过解析，返回的是类路径
			String className = (String) handlerOrClassName;
			try {
                //使用反射把类路径转化为类
				Class<?> handlerClass = ClassUtils.forName(className, this.classLoader);
				if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {
					throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri +
							"] does not implement the [" + NamespaceHandler.class.getName() + "] interface");
				}
                //初始化类
				NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);
                //调用自定义的namespaceHandler初始化方法
				namespaceHandler.init();
                //记录在缓存
				handlerMappings.put(namespaceUri, namespaceHandler);
				return namespaceHandler;
			}
			catch (ClassNotFoundException ex) {
				throw new FatalBeanException("NamespaceHandler class [" + className + "] for namespace [" +
						namespaceUri + "] not found", ex);
			}
			catch (LinkageError err) {
				throw new FatalBeanException("Invalid NamespaceHandler class [" + className + "] for namespace [" +
						namespaceUri + "]: problem with handler class file or dependent class", err);
			}
		}
	}

```

上述代码起作用的重要条件：

在Spring.handlers文件中配置命名空间与命名空间处理的映射关系.只有这样,Spring才能根据映射关系找到匹配的处理器,而寻找匹配的处理器就是在上面方法中实现,当获取到自定义的NamespaceHandler之后就可以进行处理器初始化并解析了.

当得到自定义命名空间处理后会马上执行namespaceHandler.init()来进行自定义BeanDefinitionParser的注册.在这里,可以注册多个标签解释器,当前实例中只有支持<myname:user>的写法,也可以在这里注册多个解析器,如<myname:A> <myname:B>等,是的myname的命名空间中可以支持多种标签解析.

注册后,命名空间处理器就可以根据标签的不同来调用不同的解析器进行解析.那么,根据上面的函数与之前介绍过的例子,我们基本上可以推断getHandlerMappings的主要功能就是读取Spring.handlers配置文件并将配置文件缓存在map中.

```
/**
 * 懒惰地加载指定的NamespaceHandler映射。
 */
private Map<String, Object> getHandlerMappings() {
    //如果没有被缓存则开始进行缓存
    if (this.handlerMappings == null) {
        synchronized (this) {
            if (this.handlerMappings == null) {
                try {
                    //this.handlerMappingsLocation 在构造函数中已经被初始化为 META-INF/Spring.handlers
                    Properties mappings =
                            PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);
                    if (logger.isDebugEnabled()) {
                        logger.debug("Loaded NamespaceHandler mappings: " + mappings);
                    }
                    Map<String, Object> handlerMappings = new ConcurrentHashMap<String, Object>(mappings.size());
                    //将Properties格式文件合并到Map格式的handlerMappings中
                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);
                    this.handlerMappings = handlerMappings;
                }
                catch (IOException ex) {
                    throw new IllegalStateException(
                            "Unable to load NamespaceHandler mappings from location [" + this.handlerMappingsLocation + "]", ex);
                }
            }
        }
    }
    return this.handlerMappings;
}

```

## 标签解析
得到了解析器以及要分析的元素后,Spring就可以将解析工作委托给自定义解析器去解析了.在Spring中的代码为:
```
return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd))
```
查看父类NamespaceHandlerSupport中的parse方法.
```
@Override
public BeanDefinition parse(Element element, ParserContext parserContext) {
    //找到解析器并进行解析操作
    return findParserForElement(element, parserContext).parse(element, parserContext);
}

```
解析过程中首先是寻找元素对应的解析器,进而调用解析器中的parse方法,那么结合示例来讲,其实就是首先获取在MyNameSpaceHandler类中的init方法中注册的对应的UserBeanDefinitionParser实例,并调用其parse方法进行进一步解析.
```
private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {
    // 获取元素名称,也就是<myname:user中的user,若在示例中,此时localName为user
    String localName = parserContext.getDelegate().getLocalName(element);
    //根据user找到对应的解析器，也就是在registerBeanDefinitionParser("user", new UserBeanDefinitionParser());注册的解析器
    BeanDefinitionParser parser = this.parsers.get(localName);
    if (parser == null) {
        parserContext.getReaderContext().fatal(
                "Cannot locate BeanDefinitionParser for element [" + localName + "]", element);
    }
    return parser;
}

```

对于parse方法的处理
```
@Override
public final BeanDefinition parse(Element element, ParserContext parserContext) {
    //important!!!
    AbstractBeanDefinition definition = parseInternal(element, parserContext);
    if (definition != null && !parserContext.isNested()) {
        try {
            String id = resolveId(element, definition, parserContext);
            if (!StringUtils.hasText(id)) {
                parserContext.getReaderContext().error(
                        "Id is required for element '" + parserContext.getDelegate().getLocalName(element)
                                + "' when used as a top-level tag", element);
            }
            String[] aliases = null;
            if (shouldParseNameAsAliases()) {
                String name = element.getAttribute(NAME_ATTRIBUTE);
                if (StringUtils.hasLength(name)) {
                    aliases = StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));
                }
            }
            // // 将AbstractBeanDefinition转化为BeanDefinitionHolder并注册
            BeanDefinitionHolder holder = new BeanDefinitionHolder(definition, id, aliases);
            registerBeanDefinition(holder, parserContext.getRegistry());
            if (shouldFireEvents()) {
                 // 需要通知监听器则进行处理
                BeanComponentDefinition componentDefinition = new BeanComponentDefinition(holder);
                postProcessComponentDefinition(componentDefinition);
                parserContext.registerComponent(componentDefinition);
            }
        }
        catch (BeanDefinitionStoreException ex) {
            parserContext.getReaderContext().error(ex.getMessage(), element);
            return null;
        }
    }
    return definition;
}

```
虽说是对自定义配置文件的解析,但是,我们可以看到,在这个方法中大部分的代码是用来处理将解析后的AbstractBeanDefinition转化为BeanDefinitionHolder并注册的功能,而真正去做解析的事情委托给了函数parseInternal,正是这句代码调用了我们自定义的解析函数.

在parseInternal中并不是直接调用自定义的doParse函数,而是进行了一系列的数据准备,包括对beanClass scope lazyInit等属性的准备.

```
protected final AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();
    String parentName = getParentName(element);
    if (parentName != null) {
        builder.getRawBeanDefinition().setParentName(parentName);
    }
    // 获取自定义标签中的class,此时会调用自定义解析器如UserBeanDefinitionParser中的getBeanClass方法
    Class<?> beanClass = getBeanClass(element);
    if (beanClass != null) {
        builder.getRawBeanDefinition().setBeanClass(beanClass);
    }
    else {
        // 若子类没有重写getBeanClass方法则尝试检查子类是否重写getBeanClassName方法
        String beanClassName = getBeanClassName(element);
        if (beanClassName != null) {
            builder.getRawBeanDefinition().setBeanClassName(beanClassName);
        }
    }
    builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));
    if (parserContext.isNested()) {
        // Inner bean definition must receive same scope as containing bean.
        //若存在父类则使用父类的scope属性
        builder.setScope(parserContext.getContainingBeanDefinition().getScope());
    }
    if (parserContext.isDefaultLazyInit()) {
        // Default-lazy-init applies to custom bean definitions as well.
        //设置延迟加载
        builder.setLazyInit(true);
    }
    //调用子类的doParse方法进行解析
    doParse(element, parserContext, builder);
    return builder.getBeanDefinition();
}

```
回顾一下全部的自定义标签处理过程,虽然在实例中我们定义UserBeanDefinitionParser,但是在其中我们只是做了与自己业务逻辑相关的部分.不过我们没做但是并不代表没有,在这个处理过程中同样也是按照Spring中默认标签的处理方式进行,包括创建BeanDefinition以及进行相应默认属性的设置,对于这些工作Spring都默默地帮我们实现了,只是暴露出一些接口来供用户实现个性化的业务.

到此为止我们已经完成了Spring中全部的解析工作,也就是说到现在为止我们已经理解了Spring将bean从配置文件到加载到内存中的全过程,而接下来的任务便是如何使用这些bean.





































































