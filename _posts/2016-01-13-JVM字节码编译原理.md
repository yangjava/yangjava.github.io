---
layout: post
categories: [JVM]
description: none
keywords: JVM
---
# JVM字节码编译原理
Java最初诞生的目的就是为了在不依赖于特定的物理硬件和操作系统环境下运行，那么也就是说Java程序实现跨平台特性的基石其实就是字节码。

## 编译原理
Java之所以能够解决程序的安全性问题、跨平台移植性等问题，最主要的原因就是Java源代码的编译结果并非是本地机器指令，而是字节码。

当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无需再次编译，也就是说Java源码只需一次编译就可处处运行，这就是“Write Once， Run Anywhere”的思想。

所以注定了Java程序在任何物理硬件和操作系统环境下都能够顺利运行，只要对应的平台装有特定的Java运行环境，Java程序都可以运行，虽然各个平台的Java虚拟机内部实现细节不尽相同，但是它们共同执行的字节码内容却是一样的。

那么想要让一个Java程序正确地运行在JVM中，Java源码就必须要被编译为符合JVM规范的字节码。关于规范，开发人员在使用Java语言编写一个Java程序时需要遵循Java语法规范，而将源码编译为字节码的时候又需要符合JVM规范，简单来说，前端编译器的主要任务就是负责将符合Java语法规范的Java代码转换为符合JVM规范的字节码文件。

## javac编译器简介
Java源码的编译结果为什么不是跟C/C++一样的本地机器指令，而是字节码呢？其实相信大家也都知道，这与Java与生俱来的与平台无关性是密不可分的，Java之所以能够实现“Write Once，Run Anywhere”（一次编译，处处运行），最主要的就是归功于字节码。

简单来说，字节码就相当于是一份通用的契约，尽管不同平台上的Java虚拟机的实现细节不尽相同，但是它们共同执行的字节码内容却是一样的，这也就是为什么Java的设计者们会将Java的编译结果设定为具有平台通用性的字节码而非本地机器指令的目的所在。

Java源码的编译结果屏蔽了与底层操作系统和物理硬件相关的一些特性，使得开发人员尽可能地只需关注于自身业务。因为只有这样，体系结构中立、与平台无关等特性才能够真正地构建起来，否则Java技术就是一门传统的静态编译型语言，而非今天的动态编译型语言。

或许时至今日仍然有许多非Java开发人员在质疑Java的程序运行性能，但是请大家相信，Java早已不再是遭人唾弃，贴上低效性能标签的一门编程语言。其实说这些话的人，大部分都并不了解Java技术，在JDK1.0版本时，Java程序的运行效率确实不尽如人意，这是因为Java当时的解释器非常低效，但这却并不代表Java语言自身低效，

也就是说，程序的运行性能与编程语言其实是没有多大直接关系，真正决定程序运行性能的是编译器。不过在当时，由于技术限制等原因，JVM中只有解释器，而没有如今先进高效的JIT编译器，可是现在，Java突破了这些技术限制，程序的运行性能已经达到了可以和C/C++程序一较高下的地步，并且Java技术自身的诸多优势同样也是C/C++无法比拟的，所谓各有所长就是这个道理。

在此大家需要注意，世界上永远没有最好的编程语言，只有最适用于具体应用场景的编程语言。

Java源码的编译结果是字节码，那么肯定需要有一种编译器能够将Java源码编译为字节码，承担这个重任的就是配置在“PATH”环境变量中的javac编译器。javac是一种能够将Java源码编译为字节码的前端编译器

## javac与Eclipse Compiler for Java编译器
HotSpot VM并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范都可以被JVM所识别，所以在Java的前端编译器领域，除了javac之外，还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的ECJ（Eclipse Compiler for Java）编译器。相信有不少开发人员会误以为Eclipse中同样也是使用JDK或者OpenJDK中的javac编译器来编译字节码，其实不是这样的，Eclipse中所使用的ECJ前端编译器完全是自主研发的，并且可以和javac相媲美，甚至可以比javac更优秀。

和javac的全量式编译不同，ECJ是一种增量式编译器。在Eclipse中，当开发人员编写完代码后，使用“Ctrl+S”快捷键时，ECJ编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此ECJ的编译效率会比javac更加迅速和高效，当然编译质量和javac相比其实大致还是一样的。这里大家需要注意，前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责。

ECJ不仅是Eclipse的缺省内置前端编译器，在Tomcat中同样也是使用ECJ编译器来编译jsp文件。由于ECJ编译器是采用GPL v2的开源协议进行源代码公开，所以，大家可以登录http://archive.eclipse.org/下载ECJ编译器的源码进行阅读和学习甚至是二次开发。

## javac的使用与标准选项配置
如果你是第一次使用javac编译器来将Java的源代码编译为字节码，那么可以在控制台中输入命令“javac -help”查阅javac编译器的具体使用方式和一些标准选项配置。

具体用法:
```
    javac <选项> <源文件>
```
-g	生成所有调试信息
-g:none	不生成任何调试信息
-g:{lines,vars,source}	只生成某些调试信息
-nowarn	不生成任何警告
-verbose	输出有关编译器正在执行的操作的消息
-deprecation	输出使用已过时的API的源位置
-classpath <路径>	指定查找用户类文件和注释处理程序的位置
-cp <路径>	指定查找用户类文件和注释处理程序的位置
-sourcepath <路径>	指定查找输入源文件的位置
-bootclasspath <路径>	覆盖引导类文件的位置
-extdirs <目录>	覆盖安装的扩展目录的位置
-endorseddirs <目录>	覆盖签名的标准路径的位置
-proc:{none,only}	控制是否执行注释处理和/或编译
-processor <class1>[,<class2>,<class3>...]	要运行的注释处理程序的名称；绕过默认的搜索进程
-processorpath <路径>	指定查找注释处理程序的位置
-d <目录>	指定存放生成的类文件的位置
-s <目录>	指定存放生成的源文件的位置
-implicit:{none,class}	指定是否为隐式引用文件生成类文件
-encoding <编码>	指定源文件使用的字符编码
-source <版本>	提供与指定版本的源兼容性
-target <版本>	生成特定VM版本的类文件
-version	版本信息
-help	输出标准选项的提要
-Akey[=value]	传递给注释处理程序的选项
-X	输出非标准选项的提要
-J<标志>	直接将 <标志> 传递给运行时系统

## 编译原理
JVM并不会与Java语言“终生绑定”，任何语言编写的程序都可以运行在JVM中，前提是源码的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。

当弄清楚这些基本概念之后，接下来我们再来了解javac的编译原理，其实所谓编译原理，大家可以理解为Java源码编译为字节码时所需要经历的一些编译步骤。javac编译器在将Java源码编译为一个有效的字节码文件，

主要会经历4个步骤，分别是：词法解析→语法解析→语义解析→生成字节码

编译的第一步是词法解析，那么究竟什么是词法解析呢？在Java语言中，关键字相信大家都非常熟悉，所谓关键字指的就是Java API内部预定义的一些字符集合（如public、private、class等）。那么词法解析要做的事情就是将Java源码中的关键字和标示符等内容转换为符合Java语法规范的Token序列，然后按照指定的顺序规则进行匹配校验，这就是词法解析步骤。

当词法解析执行结束后，javac就会进入到编译的第二个阶段，也就是语法解析。所谓语法解析指的就是将词法解析后的Token序列整合为一棵结构化的抽象语法树，因为我们知道，一个try语句后面肯定会接上一个catch或者finally子句，这就是语法解析步骤。

当通过语法解析步骤后，javac就会进入到生成字节码之前的最后一个阶段，也就是语义解析。由于语法解析器所解析出来的语法树并不能直接应用于生成字节码文件，这是因为这棵语法树相对来说还并不完善，所以语义解析的目的就是为了将之前语法解析步骤所产生的语法树扩充得更加完善，后续编译器将会使用语义解析后的语法树来生成字节码。

当javac完成词法解析、语法解析和语义解析等3个步骤后，最后一步就是执行字节码编译。这个步骤无疑是整个编译过程中最重要和最核心的地方，不过大家只有在彻底弄清楚前三个编译步骤之后，才能真正理解javac编译器的编译原理。





## 词法解析步骤
词法解析是javac编译器执行字节码编译的第一步。在词法解析的过程中，词法解析器最主要的任务就是将Java源码中的关键字和标示符等内容转换为符合Java语法规范的Token序列，然后按照指定的顺序规则进行匹配校验，以便为后续的语法解析步骤做准备。

在javac编译器中，词法解析器接口是com.sun.tools.javac.parser.Lexer，它的直接派生实现是位于同包下的Scanner类，该类的对象实例由ScannerFactory工厂负责创建。Scanner类的主要任务就是按照单个字符的方式读取Java源文件中的关键字和标示符等内容，然后将其转换为符合Java语法规范的Token序列。在此大家需要注意，负责词法解析工作的并非是Scanner类，而是com.sun.tools.javac.parser.JavacParser类，该类的对象实例由ParserFactory工厂负责创建。也就是说，由JavacParser类负责控制词法解析时的具体细节，而Scanner类仅仅只是负责读取源码中的字符集合以及与Token序列之间的转换任务

那么接下来我们就开始一步一步地深入到compile()的方法内部细节中去。

首先由compile()方法调用com.sun.tools.javac.main.javacompiler类的parseFiles()方法，该方法的主要任务就是调用parse()方法获取JavacParser类的对象实例，然后调用JavacParser类的parseCompilationUnit()方法执行词法解析，如下所示：
```
   protected JCCompilationUnit parse(JavaFileObject filename,
            CharSequence content) {
        long msec = now();
        JCCompilationUnit tree = make.TopLevel(
                List.<JCTree.JCAnnotation> nil(), null, List.<JCTree> nil());
        if(content != null) {
            if(verbose) {
                log.printVerbose("parsing.started", filename);
            }
            if(taskListener != null) {
                TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, filename);
                taskListener.started(e);
            }
            /* 创建JavacParser 对象实例 */
            Parser parser = parserFactory.newParser(content, keepComments(),
                genEndPos, lineDebugInfo);
            /* 调用parseCompilationUnit()方法执行词法解析 */
            tree = parser.parseCompilationUnit();
            if(verbose) {
                log.printVerbose("parsing.done", Long.toString(elapsed(msec)));
            }
        }
        tree.sourcefile = filename;
        if(content != null&& taskListener != null) {
            TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, tree);
            taskListener.finished(e);
        }
        return  tree;
    }
```
上述代码示例中，由ParserFactory工厂的newParser()方法负责创建JavacParser类的对象实例。JavacParser类派生于com.sun.tools.javac.parser.Parser接口，并重写了Parser接口的parseCompilationUnit()方法。parseCompilationUnit()方法可以说是词法解析步骤的核心所在，由该方法负责调用Scanner类的nextToken()方法获取出Token后再按照指定的顺序规则进行匹配校验。

## Token序列
词法解析器在成功读取到Java源码中的关键字和标示符等内容后，会将其转换为符合Java语法规范的Token序列，那么究竟什么是Token呢？实际上Token无非就是一组对应源码字符集合的单词序列。简单来说，Token其实就一个枚举类型，其内部定义了许多符合Java语法规范并与源码字符集合相对应的枚举常量。为了使大家阅读更方便，本书示例了包含在com.sun.tools.javac.parser.Token类中的所有枚举常量，如下所示：
```
    EOF,
    ERROR,
    IDENTIFIER,
    ABSTRACT

("abstract"),
    ASSERT

("assert"),
    BOOLEAN

("boolean"),
    BREAK

("break"),
    BYTE

("byte"),
    CASE

("case"),
    CATCH

("catch"),
    CHAR

("char"),
    CLASS

("class"),
    CONST

("const"),
    CONTINUE

("continue"),
    DEFAULT

("default"),
    DO

("do"),
    DOUBLE

("double"),
    ELSE

("else"),
    ENUM

("enum"),
    EXTENDS

("extends"),
    FINAL

("final"),
    FINALLY

("finally"),
    FLOAT

("float"),
    FOR

("for"),
    GOTO

("goto"),
    IF

("if"),
    IMPLEMENTS

("implements"),
    IMPORT

("import"),
    INSTANCEOF

("instanceof"),
    INT

("int"),
    INTERFACE

("interface"),
    LONG

("long"),
    NATIVE

("native"),
    NEW

("new"),
    PACKAGE

("package"),
    PRIVATE

("private"),
    PROTECTED

("protected"),
    PUBLIC

("public"),
    RETURN

("return"),
    SHORT

("short"),
    STATIC

("static"),
    STRICTFP

("strictfp"),
    SUPER

("super"),
    SWITCH

("switch"),
    SYNCHRONIZED

("synchronized"),
    THIS

("this"),
    THROW

("throw"),
    THROWS

("throws"),
    TRANSIENT

("transient"),
    TRY

("try"),
    VOID

("void"),
    VOLATILE

("volatile"),
    WHILE

("while"),
    INTLITERAL,
    LONGLITERAL,
    FLOATLITERAL,
    DOUBLELITERAL,
    CHARLITERAL,
    STRINGLITERAL,
    TRUE

("true"),
    FALSE

("false"),
    NULL

("null"),
    LPAREN

("("),
    RPAREN

(")"),
    LBRACE

("{"),
    RBRACE

("}"),
    LBRACKET

("["),
    RBRACKET

("]"),
    SEMI

(";"),
    COMMA

(","),
    DOT

("."),
    ELLIPSIS

("..."),
    EQ

("="),
    GT

(">"),
    LT

("<"),
    BANG

("!"),
    TILDE

("~"),
    QUES

("?"),
    COLON

(":"),
    EQEQ

("=="),
    LTEQ

("<="),
    GTEQ

(">="),
    BANGEQ

("!="),
    AMPAMP

("&&"),
    BARBAR

("||"),
    PLUSPLUS("++"),
    SUBSUB

("--"),
    PLUS

("+"),
    SUB

("-"),
    STAR

("*"),
    SLASH

("/"),
    AMP

("&"),
    BAR

("|"),
    CARET

("^"),
    PERCENT("％"),
    LTLT

("<<"),
    GTGT

(">>"),
    GTGTGT

(">>>"),
    PLUSEQ

("+="),
    SUBEQ

("-="),
    STAREQ

("*="),
    SLASHEQ

("/="),
    AMPEQ

("&="),
    BAREQ

("|="),
    CARETEQ

("^="),
    PERCENTEQ("％="),
    LTLTEQ

("<<="),
    GTGTEQ

(">>="),
    GTGTGTEQ

(">>>="),
    MONKEYS_AT

("@"),
    CUSTOM;
```

## 源码字符集合与Token之间的对应关系
请大家仔细思考一下，由于编译器在执行词法解析过程中，只会对Token按照指定的顺序规则进行匹配校验，并不会直接采用源码字符集合的方式执行词法解析，那么在此就产生了两个疑问：首先源码字符集合究竟是如何转换成Token的？其次将源码字符集合转换成Token后，词法解析器又是采用什么方式保存源码字符集合与Token之间的对应关系？

笔者先从第二个疑问开始解答。词法解析器在将源码字符集合转换为Token之前，会先将每一个字符集合都转换为一个对应的Name对象，也就是说，每一个源码字符集合其实就是一个Name对象，然后再由com.sun.tools.javac.parser.Keywords类负责实际的Token转换任务。Keywords类会将Token中的所有枚举常量全部都转换为Name对象，然后将其存储在Name对象的内部类Table中，这样一来源码字符集合与Token之间的对应关系就成功构建起来了。

当成功构建对应关系后，词法解析器还需要一个存储媒介用于保存这些对应关系，那么Keywords类中的数组key就用于保存源码字符集合与Token之间的对应关系。

当大家弄清楚源码字符集合与Token之间是如何构建起对应关系后，接下来笔者再来为大家解答之前的第一个疑问。对应关系既然是存储在Keywords类的数组key中的，那么设想一下，既然Name对象与Token之间构建一种one-to-one的对应关系，那么是否通过Name对象就可以将源码字符集合转换为对应的Token？确实是这样的，当词法解析器需要将源码字符集合转换为Token时，就会通过Names类去调用Name类的fromChars()方法获取一个Name对象，然后在调用Keywords类的key()方法时传入这个Name对象就可以成功获取出对应的Token，这样一来词法解析器即可成功地将源码将字符集合转换为Token。如下所示：
```
   /* 通过Names 调用Name 的fromChars()方法获取出Name 对象 */
    name = names.fromChars(sbuf, 0, sp);
    /* 根据Name 对象获取出与之对应的Token */
    token = keywords.key(name);
```

### 调用key()方法获取指定Token
每一个源码字符集合其实就是一个Name对象，一旦源码字符集合与Token之间成功构建起对应关系后，当词法解析器调用Keywords类的key()方法时，传入与Token对应的Name对象就可以成功获取指定的Token。如下所示：
```
   public Token key(Name name) {
    return  (name.getIndex() > maxKey) ? IDENTIFIER : key[name.getIndex()];
   }
```
上述代码示例中，源码字符集合与Token之间的对应关系就保存在数组key中，其中Name类的getIndex()方法用于返回Name对象的当前索引，通过这个索引就可以从数组key中获取出指定的Token。

### 调用nextToken()方法计算Token的获取规则
如果一个源文件中包含package关键字声明、import关键字声明以及class主体信息等内容，那么当编译器在执行词法解析步骤时，首先会由词法解析器调用Keywords类的key()

方法将源码字符集合转换为对应的Token。当成功获取到指定的Token后，JavacParser类就会匹配当前的第一个Token是否是Token.PACKAGE，如果匹配成功的话，再由词法解析器获取出下一个Token，继续匹配是否是Token.IDENTIFIER，Token.IDENTIFIER对应的字符集合就是源码中的标示符，接下来再匹配Token.DOT、Token.IDENTIFIER和Token.SEMI，与这行Token序列对应的字符集合就是“package标示符1.标示符2;”。经过这行Token序列匹配步骤之后，一个完整的package关键字声明就解析完成了。

之后JavacParser类还会按照这个匹配规则继续匹配后续的其他Token信息。

不知大家是否发现Keywords类的key()方法仅仅只是根据Name对象获取出对应的Token，然而为什么词法解析器每一次获取的Token都符合词法解析的匹配规则？其实调用key()方法的无非就是Scanner类的nextToken()方法，那么nextToken()方法中必然会定义符合Java语法规范的Token读取顺序规则。

### 调用parseCompilationUnit()方法执行词法解析
词法解析的核心就是校验当前Token是否匹配com.sun.tools.javac.parser.JavacParser类在parseCompilationUnit()方法中定义的匹配规则。Token的读取顺序是在Scanner类的nextToken()方法中进行控制的，那么当成功读取到Token后， parseCompilationUnit()方法便会按照Java语法规范校验Token的匹配顺序。也就是说，Token的读取顺序与Token的匹配顺序必然需要保持一致，Token的读取规则决定规定了什么情况下应该出现什么Token，这样一来，词法解析器便会按照指定的Token读取顺序返回与匹配顺序一致的Token。为了使大家阅读更方便，本书示例了parseCompilationUnit()方法的完整代码，如下所示：
```
    public

 JCTree.JCCompilationUnit parseCompilationUnit() {
        int

 pos = S.pos();
        JCExpression pid = null

;
        String dc = S.docComment();
        JCModifiers mods = null

;
        List<JCAnnotation> packageAnnotations = List.nil

();
            /* 解析访问修饰符 */
            if (S.token() == MONKEYS_AT

)
            mods = modifiersOpt();
    
          /* 解析package 关键字 */
        if

 (S.token() == PACKAGE

) {
            if

 (mods != null

) {
                checkNoMods(mods.flags);
                packageAnnotations = mods.annotations;
                mods = null

;
            }
            S.nextToken();
            pid = qualident();
            accept(SEMI

);
        }
        ListBuffer<JCTree> defs = new

 ListBuffer<JCTree>();
        boolean

 checkForImports = true;


        while

 (S.token() != EOF

) {
            if

 (S.pos() <= errorEndPos) {
                // error recovery
                skip(checkForImports, false, false, false

);
                if

 (S.token() == EOF

)
                    break;


            }
            /* 解析import 关键字 */
            if

 (checkForImports && mods == null

 && S.token() == IMPORT

) {
                defs.append(importDeclaration());
            }
            else {
            /* 解析类主体信息并转换为语法树 */
                JCTree def = typeDeclaration(mods);
                if

 (keepDocComments && dc != null

 && docComments.get(def) == dc) {
                    // If the first type declaration has consumed the first doc
                    // comment, then don't use it for the top level comment as well.
                    dc = null

;
                }
                if

 (def instanceof

 JCExpressionStatement)
                    def = ((JCExpressionStatement)def).expr;
                defs.append(def);
                if

 (def instanceof

 JCClassDecl)
                    checkForImports = false;


                mods = null;


            }
        }
        JCTree.JCCompilationUnit toplevel = F.at(pos).
            TopLevel(packageAnnotations, pid, defs.toList());
        attach(toplevel, dc);
        if

 (defs.elems.isEmpty())
            storeEnd(toplevel, S.prevEndPos());
        if

 (keepDocComments)
            toplevel.docComments = docComments;
        if

 (keepLineMap)
            toplevel.lineMap = S.getLineMap();
        return

 toplevel;
    }
```
上述代码示例中，parseCompilationUnit()方法会按照Token的匹配规则依次解析出package关键字声明、import关键字声明，当这些Token都匹配成功后，词法解析的最后一步就是解析class主体信息。直到词法解析步骤全部执行完成后，parseCompilationUnit()方法就会将Token序列整合为一棵结构化的抽象语法树。


## 语法解析步骤
当词法解析器成功将Java源码中的关键字和标示符等内容转换为符合Java语法规范的Token序列，并按照指定的顺序规则进行匹配校验后，编译器就会进入到下一个编译阶段，即语法解析步骤。所谓语法解析，指的就是将匹配后的Token序列整合为一棵结构化的抽象语法树。也就是说，词法解析后的Token序列其实还并不完善，因为这些Token所代表的只是一个对应的单个源码字符集合，还并没有按照指定的语法规则将其相关的一组或者一段Token整合起来。而语法解析的主要任务恰恰就是要将这些零散的Token按照指定的Java语法规范整合起来形成一个有机的整体，比如一个try语句后面肯定会接上一个catch或者finally子句，这就是语法解析步骤的任务。

在语法解析步骤中，不得不提到的就是com.sun.tools.javac.tree.JCTree类。JCTree类实际上与语法树中的每一个语法节点都保持着密不可分的关系，因为语法树中的每一个语法节点实际上都直接或者间接地继承了JCTree类，并且这些语法节点对象都以静态内部类的形式定义在该类中

语法树中的每一个语法节点实际上都直接或者间接地继承了JCTree类，并且这些语法节点还会实现与节点名称想对应的Tree接口，比如语法节点JCCatch就实现了com.sun.source.tree.CatchTree接口并同时继承了JCTree类，JCTree节点所代表的就是一个异常处理语句中的cache子句。

### 调用qualident()方法解析package语法节点
当编译器执行词法解析步骤时，parseCompilationUnit()方法会按照Token的匹配规则依次解析出package关键字声明、import关键字声明，当这些Token都匹配成功后，词法解析的最后一步就是解析class主体信息。在此大家需要注意，尽管parseCompilationUnit()方法会负责控制词法解析时的具体细节，但语法解析步骤其实同样也发生在该方法内部，由它调用其他的语法解析方法执行语法解析。

当词法解析器成功地将package关键字声明转换为Token并完成词法解析后，就会调用qualident()方法根据Token.PACKAGE解析为package语法节点。如下所示：
```
    public

 JCExpression qualident() {
        /* 解析为JCIdent 语法节点 */
        JCExpression t = toP(F.at(S.pos()).Ident(ident()));
        while

 (S.token() == DOT

) {
            int

 pos = S.pos();
            S.nextToken();
            /* 解析为JCFieldAccess 语法节点 */
            t = toP(F.at(pos).Select(t, ident()));
        }
        return t;
    }

```
在语法解析步骤中，由com.sun.tools.javac.tre.TreeMaker类负责创建JCTree类的所有语法节点对象实例，实际上TreeMaker类就是一个语法解析器，不过语法解析时的具体细节则是由parseCompilationUnit()方法进行控制。如果package关键字声明中只定义一级目录时， qualident()方法就会调用语法解析器将其解析为一个JCIdent语法节点。如下所示：
```
    public

 JCIdent Ident(Name name) {
            /* 根据Name 对象解析出一个JCIdent 语法节点 */
            JCIdent tree = new JCIdent(name, null);
            tree.pos = pos;
            return

 tree;
    }
```
上述代码示例中，由于package关键字声明中只定义一级目录，所以语法解析器只会将其解析为一个JCIdent语法节点。反之当package关键字声明中定义有多级目录时， qualident()方法就会通过循环迭代的方式调用语法解析器将package关键字声明解析为嵌套的JCFieldAccess语法节点。如下所示：
```
    public

 JCFieldAccess Select(JCExpression selected, Name selector) {
            /* 根据Name 对象解析出嵌套JCFieldAccess 语法节点 */
            JCFieldAccess tree = new JCFieldAccess(selected, selector, null);
            tree.pos = pos;
            return

 tree;
    }
```
词法解析器之所以需要将源码字符集合转换为Token序列，是因为编译器在执行词法解析过程中只会对Token按照指定的顺序规则进行匹配校验，那么语法解析器是否可以直接使用Token序列将其解析为语法树或者语法节点呢？仔细观察Ident()和Select()方法的方法参数，其实并非是一个Token，而是与Token对应的Name对象。也就是说，在解析语法树或者语法节点时，首先需要将Token转换为对应的Name对象。

在解析JCIdent语法节点的Ident()方法参数中调用了ident()方法，该方法会返回一个与Token对应的Name对象。如下所示：
```
    Name ident() {
            if

 (S.token() == IDENTIFIER

) {
            Name name = S.name();
            S.nextToken();
            return

 name;
        } else if

 (S.token() == ASSERT

) {
            if

 (allowAsserts) {
                error(S.pos(), "assert.as.identifier");
                S.nextToken();
                return

 names.error;
            } else

 {
                warning(S.pos(), "assert.as.identifier");
                Name name = S.name();
                S.nextToken();
                return

 name;
            }
        } else if

 (S.token() == ENUM

) {
            if

 (allowEnums) {
                error(S.pos(), "enum.as.identifier");
                S.nextToken();
                return

 names.error;
            } else

 {
                warning(S.pos(), "enum.as.identifier");
                Name name = S.name();
                S.nextToken();
                return

 name;
            }
        } else

 {
            accept(IDENTIFIER

);
            return

 names.error;
        }
    }
```
在qualident()方法中，当调用语法解析器的Ident()方法解析JCIdent语法节点时，其方法参数为ident()方法的返回值。ident()方法的返回值生成规则是通过Token.name的方式将Token转换为对应的Name对象，这样一来，语法解析器就可以根据Name对象成功解析出一个JCIdent语法节点。

### 调用importDeclaration()方法解析import语法树
当成功解析package语法节点后，语法解析的下一步就是解析import语法树。编译器在执行词法解析过程中，会匹配当前Token是否是Token.IMPORT，如果Token匹配成功， parseCompilationUnit()方法就会调用importDeclaration()方法根据Token.IMPORT解析为import语法树。如下所示：
```
    JCTree importDeclaration() {
        int

 pos = S.pos();
        S.nextToken();
        boolean

 importStatic = false;


        /* 匹配Token.STATIC */
        if (S.token() == STATIC

) {
            checkStaticImports();
            importStatic = true;


            S.nextToken();
        }
        /* 根据Name 对象解析出一个JCIdent 语法节点 */
        JCExpression pid = toP(F.at(S.pos()).Ident(ident()));
        do

 {
            int

 pos1 = S.pos();
            accept(DOT

);
            /* 根据Name 对象解析出嵌套JCFieldAccess 语法节点 */
            if

 (S.token() == STAR

) {
                pid = to(F.at(pos1).Select(pid, names.asterisk));
                S.nextToken();
                break;
            } else

 {
                pid = toP(F.at(pos1).Select(pid, ident()));
            }
        } while

 (S.token() == DOT

);
        accept(SEMI

);
        /* 将JCIdent 和JCFieldAccess 语法节点整合为一个JCImport 语法树 */
        return toP(F.at(pos).Import(pid, importStatic));
    }
```
上述代码示例中，首先会匹配Token.STATIC，用于检测import关键字声明中是否包含static静态导入。接下来importDeclaration()方法便会调用语法解析器的Ident()方法解析出一个JCIdent语法节点，如果import关键字声明中定义多级目录时，则会调用语法解析器的Select()方法，将其解析为嵌套的JCFieldAccess语法节点，这和之前解析package语法节点是一样的。

当语法解析器成功解析JCIdent和JCFieldAccess语法节点后，importDeclaration()方法就会调用语法解析器的Import()方法，将之前解析过的语法节点整合为一棵JCImport语法树，如下所示：
```
   public

 JCImport Import(JCTree qualid, boolean

 importStatic) {
        /* 解析JCImport 语法树 */
        JCImport tree = new

 JCImport(qualid, importStatic);
        tree.pos = pos;
        return

 tree;
    }
```
语法解析器的Import()方法会将JCIdent和JCFieldAccess语法节点整合为一棵JCImport语法树，这样一来，JCIdent和JCFieldAccess语法节点就会作为JCImport语法树的子节点存在。由于在实际的开发过程中，有可能会包含多个import关键字声明，那么parseCompilationUnit()方法内部则会通过循环迭代的方式解析JCImport语法树，然后将其存储在一个集合中。

当成功解析package和import语法节点后，语法解析的最后一步就是将class主体信息解析为一棵JCClassDecl语法树。

### 调用classDeclaration()方法解析class语法树
语法解析步骤已经逐渐接近尾声，那么还剩下最后一步就是解析class主体信息。当语法解析器成功将import关键字声明解析为JCIdent和JCFieldAccess语法节点并整合为一棵JCImport语法树后，在parseCompilationUnit()的方法内部就会通过typeDeclaration()方法调用classOrInterfaceOrEnumDeclaration()方法将class主体信息解析为一棵JCClassDecl语法树。如下所示：
```
    JCStatement classOrInterfaceOrEnumDeclaration(JCModifiers mods, String dc) {
        /* 匹配Token.CLASS */
        if

 (S.token() == CLASS

) {
            /* 将类类型解析为一颗JCClassDecl 语法树 */
            return classDeclaration(mods, dc);
        }
        /* 匹配Token.INTERFACE */
        else if

 (S.token() == INTERFACE

) {
            /* 将接口类型解析为一颗JCClassDecl 语法树 */
            return interfaceDeclaration(mods, dc);
        } else if

 (allowEnums) {
            /* 匹配Token.ENUM */
            if

 (S.token() == ENUM

) {
                /* 将枚举类型解析为一颗JCClassDecl 语法树 */
                return enumDeclaration(mods, dc);
            } else

 {
                int

 pos = S.pos();
                List<JCTree> errs;
                if

 (S.token() == IDENTIFIER

) {
                    errs = List
                        .<JCTree> of(mods, toP(F.at(pos).Ident(ident())));
                    setErrorEndPos(S.pos());
                } else

 {
                    errs = List.<JCTree> of

(mods);
                }
                return

 toP(F.Exec(syntaxError(pos, errs, "expected3", CLASS

,
                    INTERFACE, ENUM)));
            }
        } else

 {
            /* 匹配Token.ENUM */
            if

 (S.token() == ENUM

) {
                error(S.pos(), "enums.not.supported.in.source", source.name);
                allowEnums = true;


                /* 将枚举类型解析为一颗JCClassDecl 语法树 */
                return enumDeclaration(mods, dc);
            }
            int

 pos = S.pos();
            List<JCTree> errs;
            if

 (S.token() == IDENTIFIER

) {
                errs = List.<JCTree> of(mods, toP(F.at(pos).Ident(ident())));
                setErrorEndPos(S.pos());
            } else

 {
                errs = List.<JCTree> of

(mods);
            }
            return

 toP(F.Exec(syntaxError(pos, errs, "expected2", CLASS

,
                INTERFACE)));
        }
    }
```
编译器在执行词法解析过程中会校验classOrInterfaceOrEnumDeclaration()方法中的当前Token是否匹配Token.CLASS，如果匹配成功就调用classDeclaration()方法将class主体信息解析为一棵JCClassDecl语法树，否则将继续匹配Token.INTERFACE或者Token.ENUM。

在此大家需要注意，无论当前类型是类类型、接口类型或者是枚举类型，语法解析器都会将其解析为一棵JCClassDecl语法树。那么假设classOrInterfaceOrEnumDeclaration()方法中当前Token匹配Token.CLASS，则会由该方法负责调用classDeclaration()方法将类类型解析为一颗JCClassDecl语法树。如下所示：
```
   JCClassDecl classDeclaration(JCModifiers mods, String dc) {
        int

 pos = S.pos();
        accept(CLASS

);
        Name name = ident();
     
        List<JCTypeParameter> typarams = typeParametersOpt();
        
        JCExpression extending = null

;
        if

 (S.token() == EXTENDS

) {
        S.nextToken();
        extending = parseType();
        }
        List<JCExpression> implementing = List.nil

();
        if

 (S.token() == IMPLEMENTS

) {
        S.nextToken();
        implementing = typeList();
        }
        /* 解析类中的所有成员信息，并存储在集合中 */
        List<JCTree> defs = classOrInterfaceBody(name, false);
        /* 将类中的所有成员信息整合为一棵JCClassDecl 语法树 */
        JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams,
        extending, implementing, defs));
        attach(result, dc);
        return

 result;
    }
```
上述代码示例中，classBody的解析由classOrInterfaceBody()方法负责。那么classBody中的内容信息就包括了一个类中的所有变量、方法以及内部类，当成功这些类成员信息全部都解析完成后，就会存储在一个List集合中，并由语法解析器的ClassDef()方法将其整合为一棵JCClassDecl语法树。如下所示：
```
    public

 JCClassDecl ClassDef(JCModifiers mods, Name name,
            List<JCTypeParameter> typarams, JCExpression extending,
            List<JCExpression> implementing, List<JCTree> defs) {
        /* 解析JCClassDecl 语法树 */
        JCClassDecl tree = new JCClassDecl(mods, name, typarams, extending,
                implementing, defs, null);
        tree.pos = pos;
        return

 tree;
    }
```
当成功将classBody中的内容信息解析并整合为一棵JCClassDecl语法树后， parseCompilationUnit()方法就会调用语法解析器的TopLevel()方法将之前解析过的package语法节点、import语法树和class语法树等内容信息全部整合为一棵JCCompilationUnit语法树。如下所示：
```
    public

 JCCompilationUnit TopLevel(List<JCAnnotation> packageAnnotations,
            JCExpression pid, List<JCTree> defs) {
        Assert.checkNonNull

(packageAnnotations);
        for

 (JCTree node : defs)
            Assert.check

(
                   node instanceof

 JCClassDecl
                         || node instanceof

 JCImport
                         || node instanceof

 JCSkip
                         || node instanceof

 JCErroneous
                         || (node instanceof

 JCExpressionStatement
                   && ((JCExpressionStatement) node).
                   expr instanceof

 JCErroneous), node.getClass().
                   getSimpleName());
        JCCompilationUnit tree = new

 JCCompilationUnit(packageAnnotations, pid,
        defs, null, null, null, null

);
        tree.pos = pos;
        return

 tree;
    }
```
上述代码示例中，JCCompilationUnit类将会作为整个语法树的根节点，由它持有整个语法树中的所有子节点。

当编译步骤经过了词法解析和语法解析后，可以说编译器在生成字节码之前，编译雏形已经成功构建好了。接下来编译器将会进入到生成字节码之前的最后一个阶段，也就是语义解析步骤。

## 语义解析步骤
在讲解语义解析步骤之前，我们首先来回顾下词法解析和语法解析这两个编译步骤。词法解析是整个编译步骤的第一个阶段，由词法解析器负责将Java源码中的关键字和标示符等内容转换为符合Java语法规范的Token序列，然后按照指定的顺序规则进行匹配校验。当词法解析结束后，编译器就会进入到编译的第二个阶段，也就是语法解析。所谓语法解析指的就是将词法解析后的Token序列整合为一棵结构化的抽象语法树。在此大家需要注意，由语法解析器解析后的语法树还并不能直接进入到字节码编译阶段，这是因为这颗语法树相对来说还并不完善，而语义解析的任务就是为了将之前语法解析步骤中所产生的语法树扩充得更加完善。在语义解析步骤中会经历的一些操作，如下所示：

- 为没有构造方法的类型添加缺省的无参构造方法；
- 检查任何类型的变量在使用前是否都已经经历过初始化；
- 检查变量类型是否与值匹配；
- 将String类型的常量进行合并处理；
- 检查代码中的所有操作语句是否可达；
- 异常检查；
- 解除Java语法糖。
当大家在编写一个Java程序时，如果程序中并没有显式地为其定义构造方法，那么编译器在执行语义解析时，会由语义解析器为目标类型添加一个无参的缺省构造方法。如下所示：
```
   /**
      * 语义解析之前
      *
      * @author

 JohnGao
      */
    public class Test {
        public static void

 main(String[] args) {
            new

 Test();
        }
    }
    /**
      * 语义解析之后
      *
      * @author

 JohnGao
      */
    public class Test {
        public

 Test(){}
        public static void

 main(String[] args) {
            new

 Test();
        }
    }
```
Java是一门强类型的编程语言，在初始化任何一个变量之前，首先必须明确变量的具体数据类型，所以除了为类型添加无参的缺省构造方法外，语义解析器还会检查指定的变量类型与所持有的原始值或者引用值之间是否匹配。异常检查同样也属于语义解析步骤时的工作，会由语义解析器负责检查程序中所有的非运行时异常，是否都使用了try-catch语句进行捕获，或者是否使用了throws关键字向外进行抛出。这里有一个比较有趣的现象，或许这还是大多数开发人员在参加面试时都碰见过的一个问题，那就是一个String类型的变量中如果包含多个常量信息并通过符号“+”组合在一起时，底层究竟创建了多少个String对象？从表面上来看，相信大家都会误以为String的对象数量与常量数量是等价的，可是事实并非如此。编译器在执行语义解析时，会检查String变量中是否包含多个常量信息并通过符号“+”组合在一起，如果确实存在，语义解析器则会将其合并为一个字符串，这就是常量折叠操作。如下所示：
```
  /* 语义解析器合并字符串信息之前 */
        String str= "Java 虚拟机精讲," + "作者：高翔龙";
        /* 语义解析器合并字符串信息之后 */
    String str= "Java 虚拟机精讲,作者：高翔龙";

```
既然本节谈到了String类型，那么笔者再提一个问题，我们都知道Java语法层面提供4类8种原始数据类型，其中使用Unicode编码格式的char类型可以用于存储世界上所有的文字信息，但该类型的二进制位数只有16bit，也就是说，char类型的变量只能够存储单个字符，而String类型究竟是如何存储字符串信息的？或许你会想到使用char数组的方式来进行存储，其实阅读String类的源码后不难发现，String类型就是Java语法层面定义的一种专门用于存储字符串信息的数据结构，其底层实现无非就是替大家实现了这个封装过程而已。

当经历过这一系列的语义解析步骤之后，就构成了一个完善的编译前提，编译器将会使用这个扩充后的语法树将其编译为Java字节码。

## 生成字节码
成功经历过词法分析、语法分析和语义分析等步骤之后，所解析出来的语法树已经非常完善了，那么javac编译器最后的任务就是调用com.sun.tools.javac.jvm.Gen类将这棵语法树编译为Java字节码文件。其实所谓编译字节码，无非就是将符合Java语法规范的Java代码转换为符合JVM规范的字节码文件。在此大家需要注意，JVM的架构模型是基于栈的，也就是说，在JVM中所有的操作都需要经过入栈和出栈来完成。













