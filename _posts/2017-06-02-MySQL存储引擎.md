---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL存储引擎
主要讲述的是InnoDB的一些重要内容，包括InnoDB的源代码目录结构、InnoDB存储引擎的体系结构、文件系统、存储引擎启动关闭、数据字典及表对象缓存等内容。

## InnoDB的源代码目录结构
源码目录下的storage目录就是关于存储引擎的，里面有一个innobase目录，目录名解释说明如下。

## InnoDB存储引擎文件组织
使用过MySQL及InnoDB存储引擎的同学应该比较清楚InnoDB的文件组织结构。

最左边的是一些MySQL的日志文件，包括如下3个文件。
- slow.log文件，会记录慢查询日志，当一条语句执行时间超过在配置参数long_query_time中指定的值时，这条语句就会被记录在这个文件中。
- error.log文件，会记录一些系统启动或运行时的错误或警告信息，通过配置参数log_error来设置。
- general.log文件，会记录所有在数据库上执行的语句，经常用来追踪问题，但会影响一点性能，所以一般不会打开，只有在调试的时候会偶尔开启。当然，在系统QPS不大的情况下，还是可以打开的，因为查找问题时，问题已经发生了，不好复现，所以general_log是一个很好的查找问题的途径。只是在QPS很高的情况下，这个文件有可能会非常大，不太好处理，所以需要自己权衡利弊。

在MySQL系统的datadir目录下，还有一个目录叫mysql。在MySQL数据库系统中，一个数据库就是一个目录，所以如果用户手动在datadir目录下创建一个目录的话，在执行show databases语句时，也会被显示出来。这个mysql目录实际上是MySQL数据库的一些系统表，比如权限、用户等，但这些表都是MyISAM存储引擎的表。不过据说在MySQL 8.0版本中，系统表做了翻天覆地的大改变，我们所熟悉的mysql数据库会不复存在，同样，熟知的.frm文件也将被去除，这些信息都会被存储到ibdata中去。虽然，系统表改变之后，一些熟知的信息不存在了，但我自己看来，倒是一点都不会想念，因为这样的改变会给运维带来极大的好处，算是MySQLDBA的福音，但也别太乐观，我们还会处于并将长期处于一个过渡阶段。

### information_schema
information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式，也就是通常所说的Metadata。Metadata是关于数据的数据，如数据库名或表名、列的数据类型或访问权限等，用于表述该信息的其他术语包括“数据词典”和“系统目录”。

在MySQL中，information_schema被看作是一个数据库，确切地说是信息数据库。其中保存着关于MySQL服务器维护的所有其他数据库的信息，如数据库名、数据库表、表列的数据类型及访问权限等。在information_schema中，有数个只读表。它们实际上是视图，而不是基本表，因此，无法看到与之相关的任何文件。如果想看它包含什么信息的话，只需要进入这个数据库，然后一个个地执行show create table tablename即可，这样就可以看到每一个表的功能了。

这个库在很多情况下，可以帮助我们做一些自动化处理的工作，比如巡检程序找到所有的MyISAM表，或者是找到所有的自增列快达到上限的表，等等。更重要的是，这是很多工具的信息来源，比如我们所熟知的Percona Toolkit工具包，它在查一些信息的时候也是通过在这个库上执行SQL语句来做的。

但是，这个库也有其明显的缺点。它在每次查找的时候，都会现场统计相应的信息，这需要将相应信息加载到内存中，做成内存表，然后将信息返回给客户端，但如果表比较多的话，这些语句的执行会非常慢，造成一些不可预知故障的风险，所以使用这个库的话，需要谨慎处理。

关于内存表的问题，可以通过show create table tablename;语句看到，表的存储引擎为MEMORY。

针对监控方面，有很多表都是对show status结果的一个汇总，使得监控变得相对更容易一些，比如表INNODB_METRICS就是其中一个。

### performance_schema
performance_schema数据库是在MySQL 5.5中新增的，命名为performance_schema，从名字中也可以初步了解到，它是针对性能的，主要用于收集数据库服务器性能参数。performance_schema提供如下功能。
- 提供进程等待的详细信息，包括锁、互斥变量、文件信息。
- 保存历史事件汇总信息，为判断MySQL服务器性能做出详细的依据。
- 添加或删除监控事件点都非常容易，并可以随意改变MySQL服务器的监控周期。

### sys
sys数据库是MySQL 5.7中首次加入的一个系统信息库，这个库类似Oracle中的动态视图，通过这个库可以快速地了解系统的元数据信息，并非常方便地让DBA发现数据库的很多信息，在解决性能瓶颈、自动化运维等方面都提供了巨大的帮助。这个库在MySQL 5.7中是默认存在的，在MySQL 5.6版本及以上可以手动导入，数据库包可以在Github上自行下载并导入，但功能可能并不太完善，还是需要系统内部做一些支持。

这个库是通过视图的形式把information_schema和performance_schema结合起来的，查询出让人更加容易理解的结果。但前提是，sys库本身的信息来源要依赖information_schema，而information_schema又有自身的缺点，所以使用sys的时候也需要格外注意一下，在了解的情况下再使用，以确保万无一失。

InnoDB存储引擎自己的东西了，包括默认的两个日志文件，日志文件大小通过参数innodb_log_file_size来设置，个数通过参数innodb_log_files_in_group来设置。这几个日志文件的大小被设置后在运行过程中都是固定不变的，如果想要修改大小或者个数，需要关闭数据库，修改参数之后将原来的日志文件删除，然后重启，即可完成修改。

有一个目录userdb，这是用户创建的数据库，里面有三个表，分别是t1、t2、t3，对应三个.frm文件，但可以看到只有一个ibd文件，这是因为InnoDB有一个参数innodb_file_per_table可以对创建表时是否使用单独的表空间进行设置，很明显，t1是在这个参数为ON的情况下创建的，另外两个表使用了共享表空间，也就是说这两个表的数据会被存储到ibdata中。

另外，还有一个小文件，就是db.opt。这个文件存储的是MySQL数据库的一些配置信息，例如编码、排序的信息，如果在创建数据库时指定一些非默认的参数的话，就会在这个文件中存储这些信息。

### MySQL 8.0 数据字典表
MySQL 8.0 重构数据字典之后，废除了 MySQL 5.7 中用于保存元数据的磁盘文件：.frm、.par、.TRN、.TRG、.isl、db.opt、ddl_log.log。

如果想要了解上面这些磁盘文件都保存了什么元数据，可以参照 MySQL 官方文档：https://dev.mysql.com/doc/refman/8.0/en/data-dictionary-file-removal.html

这些文件被废除之后，原本保存到这些文件中的元数据，都保存到数据字典表中了。

数据字典表本身也大变样了：

数据字典表不再位于 InnoDB 系统表空间，而是迁移到 mysql 库中，mysql 库位于 mysql 表空间，磁盘文件为 mysql.ibd。
SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS 这 4 个数据字典表也不再完全依赖硬编码在源码中的元数据了，而是和其它表一样，使用保存在 mysql 库的数据字典表中的元数据。

按照官方文档的定义，MySQL 8.0 一共有 31 张数据字典表：
```
dd_properties
innodb_ddl_log
catalogs
character_sets
check_constraints
collations
column_statistics
column_type_elements
columns
events
foreign_key_column_usage
foreign_keys
index_column_usage
index_partitions
index_stats
indexes
parameter_type_elements
parameters
resource_groups
routines
schemata
st_spatial_reference_systems
table_partition_values
table_partitions
table_stats
tables
tablespace_files
tablespaces
triggers
view_routine_usage
view_table_usage
```
上面列出的数据字典表中，有 4 个需要重点介绍，因为不管是数据字典表本身，还是用户表，都离不开这 4 个表：
- tables：存储表的元数据，包括表空间 ID、数据库 ID、表 ID、表名、表注释、行格式等信息，对应 MySQL 5.7 中的数据字典表 SYS_TABLES。
- columns：存储表中字段的元数据，包括表 ID、字段 ID、字段名、字段注释、字段类型、是否自增等信息，对应 MySQL 5.7 中的数据字典表 SYS_COLUMNS。
- indexes：存储表的索引元数据，包括表空间 ID、表 ID、索引 ID、索引名、索引注释、是否是隐藏索引等信息，对应 MySQL 5.7 中的数据字典表 SYS_INDEXES。
- index_column_usage：存储索引中字段的元数据，包括索引 ID、字段 ID、字段在索引中的编号（从 1 开始）、索引字段长度（如果是前缀索引字段，则是前缀的长度）、索引字段排序、是否隐藏，共 6 个字段，对应 MySQL 5.7 中的数据字典表 SYS_FIELDS。
这个表中没有包含更详细的字段信息，如果需要，可以通过字段 ID 到 columns 表获取。

数据字典表用于存储用户表的元数据，这个比较好理解，因为创建用户表的时候，所有数据字典表都已经存在了，把用户表的各种元数据插入到相应的数据字典表就可以了。

数据字典表本身的元数据也会保存到数据字典表里，但是某个数据字典表创建的时候，有一些数据字典表还没有创建，这就有问题了。

我们以 columns、indexes 这 2 个数据字典表为例来说明：columns 表先于 indexes 表创建，columns 表创建成功之后，需要把索引元数据保存到 indexes 表中，而此时 indexes 表还没有创建，columns 表的索引元数据自然也就没办法保存到 indexes 表中了。

MySQL 解决这个问题的方案是引入一个中间层，用于临时存放所有数据字典表的各种元数据，等到所有数据字典表都创建完成之后，再把临时存放在中间层的所有数据字典表的元数据保存到相应的数据字典表中。

这里所谓的中间层实际上是一个存储适配器，源码中对应的类名为 Storage_adapter，这是一个实现了单例模式的类。

MySQL 在初始化数据目录的过程中，Storage_adapter 类的实例属性 m_core_registry 就是所有数据字典表元数据的临时存放场所。

#### 创建数据字典表
我们安装 MySQL 完成之后，想让 MySQL 运行起来，要做的第一件事就是初始化 MySQL，实际上就是初始化 MySQL 数据目录。

初始化过程会创建 MySQL 运行时需要的各种表空间、数据库、表，其中就包含数据字典表。

创建数据字典表的过程分为 3 个步骤进行：

第 1 步，把代表每个数据字典表的 Object_table 对象注册到 System_tables 类的实例属性 m_registry 中。

除了数据字典表，m_registry 中还包含了 mysql 库中的其它 MySQL 系统表。

第 2 步，循环 m_registry 中的所有表，通过 Object_table 得到数据字典表的 DDL，然后调用 dd::execute_query() 执行 DDL 语句创建数据字典表。

dd::execute_query() 创建数据字典表的过程中，会把表的元数据临时存放到 Storage_adapter 类的实例属性 m_core_registry 中，而不会保存到各种元数据对应的数据字典表中，这么做的原因在上一小节中介绍数据字典表的元数据在哪里时，已经介绍过了，这里不再赘述。

dd::execute_query() 执行完一个数据字典表的 DDL 语句之后，这个数据字典表在表空间中就已经存在了，m_registry 中的所有表都处理完成之后，所有数据字典表就都存在了。

MySQL 8.0 数据字典表
第 3 步，循环 m_registry 中的所有表，把每个表本身的元数据（数据库 ID、表 ID、表名、注释、字段数量等）保存到 mysql.tables 数据字典表中，然后把表的字段、索引等元数据保存到对应的数据字典表中。

所有数据字典表的元数据都从 Storage_adapter 类的实例属性 m_core_registry 中读取。

#### 打开数据字典表
数据字典表保存着 MySQL 运行过程中需要的一系列关键数据，使用频次很高，MySQL 启动过程中就会把数据字典表的元数据都加载到内存中，这就是打开表的过程。

也就是说，打开数据字典表是在 MySQL 启动过程中完成的。

前面我们介绍过，数据字典表的元数据也是保存在数据字典表中的。

MySQL 启动过程中，要先打开数据字典表才能拿到数据字典表的元数据，而要拿到数据字典表的元数据，又必须先打开数据字典表。

这个过程很绕，不是很好理解，我们来打个比方：数据字典表是一个房间，数据字典表的元数据是打开房间门的钥匙。

现在问题来了，因为 MySQL 把数据字典表的元数据保存在数据字典表中，这就相当于把打开房间门的钥匙落在房间里了。

要想打开房间，必须先拿到钥匙，而要想拿到钥匙又必须先打开房间，这样一转换，问题是不是更好理解点了？

我们先来想想怎么解决房间和钥匙问题，如果把打开房间的钥匙落在房间里了，有哪些办法可以解决？

我能想到的有以下 3 种解决方案：

暴力破解，把锁撬开。
找专业的开锁师傅把锁打开。
用备用钥匙开门。这个方法最好，但是有个前提条件：已经提前准备好了备用钥匙。
MySQL 里没有前 2 种方案，而是留了一把备用钥匙，也就是第 3 种方案，接下来我们看看 MySQL 打开数据字典表的过程：

第 1 步，和创建数据字典表一样，把代表每个数据字典表的 Object_table 对象注册到 System_tables 类的实例属性 m_registry 中。

每个数据字典表的 Object_table 对象中，都定义了这个表的表名、字段、索引、外键等信息。

Object_table 对象中保存的并不是 DDL 语句，却类似于我们建表时的 DDL 语句。

下面这个例子是源码中表空间数据字典表 mysql.tablespaces Object_table 对象中定义的该表的信息：

## InnoDB体系结构
InnoDB是MySQL众多存储引擎中比较流行的一个，现在已经成为MySQL默认的存储引擎。目前，在全球知名的大公司中都已经在大规模地使用，并且因为它是开源的，这些公司都有自己的增强版本。

InnoDB是MySQL中支持事务安全的存储引擎，它的设计实现方式与Oracle比较相似，InnoDB的体系结构比较清晰

最上层部分是提供给MySQLServer及InnoDBNoSQL的接口，因为存储引擎相对Server层在下层，通过Server与Storage Engine之间的公共接口连接起来。公共接口对应的接口定义在文件sql/handler.h中，通过如下定义的类实现。

这个类中所有的声明都是针对不同存储引擎而设计的公共虚函数接口，相应的定义需要每个存储引擎自己来实现，而对于某些存储引擎，不支持的功能不实现即可，因为在定义的时候有默认实现。

下面的两层都是一些InnoDB的逻辑对象，对InnoDB的所有访问都离不开它们。每一个访问都会涉及事务，事务处理会产生锁，包括表锁、行锁等，处理的对象是表、索引及B树。对数据页面的访问都离不开m ini-transaction（物理事务），为了防止页面写入的不一致性，需要对页面加读写锁，就是所谓的闩（LATCH）。为了可以更高效准确地定位某一个页面的位置、管理组织一个B树的所有页面，或分配销毁某些页面等，就需要用到其中的“文件管理系统”。但这些都是逻辑上的，是为了更好地管理组织下层物理对象，通过上层的逻辑来指导下层物理数据的变更，从而保证事务的ACID特性的。

再下一层，就是物理层了，而物理事务正是逻辑层与物理层之间一个很美好的过渡。这一层都是一些缓存，包括日志缓存及数据页的Buffer缓存。日志是上层的逻辑事务在通过物理事务修改数据页面（Buffer页面）时产生的，如果页面已经在Buffer缓冲区存在，则直接加锁修改并产生脏页；如果不存在，就从ibdata/ibd文件中载入，然后再修改。可以看出，日志与Buffer是紧密关联的，对Buffer数据页面的修改产生了日志，而在数据库恢复时，日志又使得数据页面载入Buffer并被修改。

再下层可以算作是操作系统的IO层，这一层主要就是用于处理下层物理文件与上层缓存（日志缓存及Buffer数据页面缓存）之间的交互，基本包括如下两方面的IO。

- REDO日志IO
当日志缓冲区（一般比较小，也就几MB，可以设置）满了，或者做了检查点（checkpoint），或者进行了逻辑事务提交（具体行为与innodb_flush_log_at_trx_comm it参数有关系）等之后，日志必须落地刷到磁盘，这是日志的IO。
- 数据页面的IO
对于Buffer缓冲区的IO，具体来说也包括两部分，分别是索引数据页面的IO和回滚段页面的IO。当上层要使用某一个页面时，就从文件中载入这个页面，而当某一个页面不再被使用，或者系统在做检查点时，对应的页面就会被刷到磁盘文件中。

## InnoDB存储引擎启动与关闭
对于InnoDB，它的初始化入口为innobase_init。

innobase_init函数最初的作用是初始化一些全局变量，为启动做准备。

接着下面第一个很重要的函数是innobase_start_or_create_for_mysql，主要完成的是InnoDB的启动过程，首先初始化一些系统模块，比如在函数srv_general_init中初始化了同步控制系统、内存管理系统、日志恢复变量等，srv_init函数中初始化了后台线程（srv_sys->sys_threads）同步控制系统。

接下来，buf_pool_init函数所做的操作就是通常所说的InnoDB的BufferPool的初始化，它是根据系统配置的参数innodb_buffer_pool_size（InnoDBBuffer Pool总大小）及innodb_buffer_ pool_instances（InnoDBBuffer Pool的实例个数）来初始化的。Buffer Pool的详细实现原理，请参考第11章。

再后面，是函数log_init，它所做的工作是初始化日志系统，这是关于整个InnoDB存储引擎所有日志相关的初始化工作，包括日志写入、LSN管理、检查点（checkpointpoint）、日志刷盘及数据恢复等操作。关于日志，后面会在第11章来做更详尽的讲述。

再接下来，是创建IO异步线程io_handler_thread，总共创建innodb_write_io_threads+innodb_read_io_threads个，所做的工作是当上层对Buffer Pool发出读写请求时，主操作线程会将这个操作交给异步IO线程来做。读写操作的不同之处是，读操作需要在请求之后等待异步读的完成，然后才能继续后面的操作（因为只有读到了完整的数据，才能继续后面的工作）；而写操作就不需要等待及通知了，InnoDB不会对单独页面的写操作做通知及等待，因为这是没有必要的（写不完，也可以继续后面的操作），只有做检查点或批量刷盘操作时，才会等待这个批量操作的完成，因为这种操作具有里程碑的意义，只有完成了，确实写入文件中了，才能将对应的日志废弃掉，而单独页面的写请求只需要保证它完成即可。可以看出，这个异步IO处理线程所做的工作就是不断地接收请求、读写数据页面，以及在无请求时进行等待。

再接下来，是函数recv_sys_init，其作用是初始化日志恢复系统。当数据库异常关闭，再次启动时，会用初始化后的系统来存储、解析日志内容并做恢复，这一点在第11章中会有更详尽的讲解。

再下来，就是执行函数open_or_create_data_files。望文可生义，这是用来打开或创建系统数据文件（ibdata）的。如果文件存在，则打开，并且读取一些文件头信息，比如LSN（与日志文件中的不同，后面会在第11章专门做介绍）；如果文件不存在，则会创建新的文件，此时相当于初始化一个新的数据库实例。这个函数执行完成之后，就可以知道当前是在初始化一个新的数据库实例，还是在启动一个已经存在的数据库。

如果是新创建的数据库，它还会创建若干个新的日志文件，这个由设置参数决定，并且将日志文件内容都初始化，然后将所有日志文件加入到日志文件系统组中管理。因为后面日志文件数量及大小都不会改变，所以加入到文件管理组后使用起来非常方便，并且在计算剩余空间大小、LSN及刷日志时会经常用到。

如果是打开一个已经存在的数据库，则只需要将数据文件（ibdata）打开，然后打开对应的日志文件（如果存在则打开，不存在则新建），同样加入到文件管理系统中，至此，就完成了数据文件的打开或创建及文件系统的初始化了。

打开文件之后，接着是MySQL 5.6中才引入的一个新功能，即srv_undo_tablespaces_init，其主要涉及的模块就是回滚段的存储。在5.6版本之前，回滚段是被强制分配在ibdata中的，不可以选择，也就是与InnoDB系统表放在一个文件中，而5.6版本之后，对这点做了改进不至于因为一些大事务导致ibdata扩展到很大。因为回滚段存储在ibdata中，在RR隔离级别下，如果一个读事务长期不提交，那么这个事务之后的所有写事务的回滚段都不能释放空间出来，必须要存储起来，为了防止这样的事务再次读取老数据，就必须要将回滚段的数据存起来。而实际上，有时候这并非真正的需求，而是一些误操作导致的，但作为一个支持MVCC的关系型数据库而言，为了支持读去老数据的功能，不得不这么做。那么，这样的数据一旦因为一些大事务而不能释放，就会导致回滚段空间一直膨胀，将ibdata撑大，而这个文件一旦被撑大了，就很难再回去了。所以要尽量避免这样的问题出现。

根据上面有可能出现的问题，引入了将回滚段分离出来使用单独文件存储的功能。回滚段的个数通过新增参数innodb_undo_tablespace来控制，如果设置为0，则使用5.6之前的方式将所有回滚段在ibdata文件中分配，而如果设置为1～126（最大值为126）之间的值，则会创建innodb_undo_tablespace个文件。但这里有一点，InnoDB规定（由于其检查方式实现的问题），只有在创建新库时，才能新建undo文件，不然启动不成功。如果是启动一个已经存在的库，InnoDB会从回滚段索引槽（后面在第11章中会详细介绍回滚段的实现）中读取所有使用到的undo tablespace，然后统计并找到所有undo文件，如果有某一个或者多个文件打开有问题或者找不到，就会启动失败。undo文件的全名规则以undo开头，后面跟着以0补全的文件编号，最小值为1（因为ibdata的表空间值为0），最大值为126，例如undo120。在找到并打开所有的undo文件之后，将它们全部加入到文件管理系统中，作为系统文件，这些对象在内存中是永驻的。

接下来的操作，对于新建库与启动已经存在的库是完全不同的。

先说新建库。首先初始化文件，执行函数fsp_header_init，作用是在系统文件ibdata的一开始分配空间，以便可以存储管理一些系统模块，比如事务系统、Inode页面（后面会在第8章做详细阐述）、回滚段系统页面及数据字典管理页面等。这些页面都存储在ibdata的头几个页面中。

下面，是执行函数trx_sys_create_sys_pages，所做的工作就是上面提到的事务系统存储初始化，事务系统使用的页面为5号页面，也就是ibdata的第六个页面。这个页面存储的一个比较重要的东西就是事务ID，因为事务ID在MVCC及事务的ACID管理中很重要，并且不能重复，所以这个值被固化在这个页面中。

接下来，是一个很重要的函数——dict_create。因为是新建库，所以需要创建新的数据字典，这里所做的操作与上面相似，首先分配一个ibdata文件中的第八个页面，用来存储数据字典使用到的几个ID值，分别是ROW ID、表ID、索引ID、当前最大表空间ID等。这些与前面事务ID比较类似，所以有相同的处理。然后，为每一个系统表创建一个B树，用来存储在系统启动之后，用户创建的数据库对象，比如表、索引等。最后，通过调用函数dict_boot把所有的系统表加载到内存中，以便在后面处理用户的DDL请求。这些表结构是常驻内存的，结构不会被修改，所以常驻内存不会有任何问题。

上面说的是新建库的内容，接着是打开已经存在的库所要做的操作。首先，第一个很重要的函数是recv_recovery_from_checkpoint_start（简称recovery_start），这个函数很重要的工作是扫描日志文件，将需要恢复的日志一块一块扫描出来，然后分析其完整性，将完整的日志按照页面号归类并且做REDO操作，这部分是InnoDB日志实现的核心部分，后面的第11章会专门来讲述日志相关的所有问题。

接下来是一个熟悉的函数dict_boot，但这里与新建库不同的是，这里只将所有系统表加载到内存中，而不会创建数据字典及初始化字典存储页面。

接着是执行函数trx_sys_init_at_db_start，用来初始化事务系统，并且将所有回滚段中需要处理的事务加载进来，包括INSERT回滚段及UPDATE回滚段，用来为后面的操作做准备。因为马上要执行的是recv_recovery_from_checkpoint_finish（简称recovery_finish），这个函数最主要的作用就是执行回滚操作（UNDO），这里需要先说明一点，从函数recovery_start开始，到recovery_finish为止，执行顺序是有逻辑关系的。首先，recovery_start是纯物理操作，因为它完全是REDO操作，将所有没有写入到数据页面的日志重做一遍，后面在执行trx_sys_init_at_db_start时，需要加载所有需要处理的事务，要找到每个事务的回滚段，这些数据需要在恢复完成后才可以读取，因为在这之前，这些回滚段的页面和数据页面一样也是通过Buffer Pool来读写的，并不能保证这些数据的正确性。

而recovery_finish在执行的时候，所处理的是逻辑的操作，因为回滚操作是针对每一个事务而言的，所以是逻辑的，需要在trx_sys_init_at_db_start执行之后，才能执行recovery_finish。而与此同时，在执行recovery_finish时，需要保证的是回滚段数据的正确性，因为回滚段的读写也是通过Buffer Pool来实现的，所以必须要在REDO恢复完成之后，回滚段的数据才是完整的，才能做回滚操作，正因为这些原因，所以上面的函数必须是以它们既定的顺序来执行。

接下来的工作，不管是新建库还是打开已经存在的库，都需要做。首先是创建两次写缓存（double_write），对应函数为buf_dblw r_create，它在InnoDB中是一个比较具有InnoDB特色的功能，同时也是一个用来保证数据正确性的很重要的功能，第10章会专门来讲述两次写。再接下来，就是创建几个很重要的系统线程。首先是我们所熟悉的master线程（srv_master_ thread）。master线程现在在5.6版本中精简了很多，功能很简单，就是每隔一秒钟进行一次后台循环，在空闲与繁忙的阶段分别做不太相同的事情，但就其根本而言是基本相同的，所做的事情主要包括：后台删除废弃表、检查日志空间是否足够、后台合并InsertBuffer缓存、日志刷盘、做检查点。

再接下来，就是创建线程srv_purge_coordinator_thread与srv_worker_thread，这两个线程通过互相配合，来完成整个InnoDB系统的PURGE操作。它们类似生产者与消费者的关系，第一个线程为生产者，后面的工作线程是消费者，但这个需要通过配置参数purge_threads，只有当它大于0时，才创建purge_threads个工作线程。也就是说，如果没有配置这个参数，所有的PURGE操作将由调度线程来完成，就是所谓的自给自足。而如果是创建多个工作线程，调度线程在产生任务之后，会从所有工作线程中找到空闲的一个，然后交给它来处理这个任务。关于具体更详尽的PURGE的原理及实现，将在第11章中进行阐述。

再接下来，是创建线程buf_flush_page_cleaner_thread，这个线程的主要工作是在后台每隔一秒钟，试图去刷一次Buffer页面，但具体刷多少，需要根据当前系统的负载来决定。如果InnoDB处于活动状态，则每次只刷一个比例的页面即可，以防给系统造成太大的压力，而如果InnoDB处于空闲状态，则每次都刷100%的页面。当然，这只是台后刷盘而已，刷盘还包括好几个时机，具体的将会在后面Buffer系统中有详细的讲述。

到此为止，InnoDB的启动已经完成，可以看出，它做了很多的操作。从它的启动过程，也可以对InnoDB有一个更清晰的认识，可以知道作为一个强大的存储引擎，包括哪些模块、启动的流程是什么、启动过程不同阶段的意义等。而知道这些，对平时运维及学习MySQL是很有帮助的。












































