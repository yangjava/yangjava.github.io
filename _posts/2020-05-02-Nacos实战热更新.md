---
layout: post
categories: [Nacos]
description: none
keywords: Nacos
---
# Nacos实战热更新
nacos实现配置文件的热更新，服务不用重启即可读取到nacos配置中心修改发布后的最新值。

## 
@NacosConfigurationProperties，@NacosPropertySource，@ConfigurationProperties，@NacosValue，@value，@RefreshScope，@EnableNacosConfig。

## nacos配置文件热更新
热更新，顾名思义就是在不用重启服务的情况下，实现配置的更新，服务的重启可能对项目的影响很大，所以nacos肯定是支持热更新的。

新建项目，pom引入
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>NacosConfig</artifactId>
    <packaging>pom</packaging>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>NacosValueExample</module>
    </modules>

    <properties>
        <spring-boot.version>2.2.8.RELEASE</spring-boot.version>
        <spring-cloud.version>Hoxton.RELEASE</spring-cloud.version>
        <spring-cloud-alibaba.version>2.2.0.RELEASE</spring-cloud-alibaba.version>
        <nacos-spring-context.version>0.2.2-RC1</nacos-spring-context.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>com.alibaba.nacos</groupId>
                <artifactId>nacos-spring-context</artifactId>
                <version>${nacos-spring-context.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

</project>
```
子模块引入pom
```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba.nacos</groupId>
            <artifactId>nacos-spring-context</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-context</artifactId>
        </dependency>
    </dependencies>

```

### 使用@RefreshScope+@Value实现nacos热更新
在nacos配置中心新建config-teacher.yaml配置文件
内容如下：
```yaml
teacher:
  name: 老李
  age: 45
```
项目中新建bootstrap.yml配置文件，将config-teacher.yaml配置进去
```yaml
spring:
  application:
    name: test-config
  cloud:
    # nacos 配置
    nacos:
      config:
        file-extension: yaml
        refresh-enabled: true
        enabled: true
        server-addr: 127.0.0.1:8848
        group: DEFAULT_GROUP
        #添加配置时 Group 的值一定要和 spring.cloud.nacos.config.group 的配置值一致。
        #group: NACOS-DEMO
        ## 可以配置多个 Data Id 同时配置时，他的优先级关系是 [n]其中 n 的值越大，优先级越高。
        extension-configs[0]:
          data-id: config-student.yaml
          group: DEFAULT_GROUP
          refresh: true
        extension-configs[1]:
          data-id: config-teacher.yaml
          group: DEFAULT_GROUP
          refresh: true
      discovery:
        server-addr: 127.0.0.1:8848
```

启动类
```java
@SpringBootApplication
// 增加@EnableNacosConfig才能使用@NacosValue注解和@NacosConfigurationProperties注解获取nacos配置中心的配置文件内容
@EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = "127.0.0.1:8848"))
public class ConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigApplication.class, args);
    }
}

```
读取配置文件代码
```java
package com.nacos.example.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.stereotype.Component;

@Component
@RefreshScope
public class TestValue3 {
    @Value("${teacher.name}")
    private String name;
    @Value("${teacher.age}")
    private Integer age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}

```

### 使用@RefreshScope+@ConfigurationProperties实现nacos热更新
配置文件不变，读取配置文件的代码：
```java
@Component
@RefreshScope
@ConfigurationProperties(prefix = "teacher")
public class TestRefreshScope1 {

    private String name;
    private Integer age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}

```

### 使用@NacosConfigurationProperties实现nacos热更新
读取配置代码
```java
@Component
@NacosConfigurationProperties(dataId = "config-teacher.yaml", prefix = "teacher", autoRefreshed = true)
public class TestNacosConfiguration1 {
    private String name;
    private Integer age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}

```

### 使用@NacosPropertySource和@ConfigurationProperties实现nacos热更新
读取配置的代码：
```
@Component
@NacosPropertySource(dataId = "config-teacher.yml", autoRefreshed = true)
@ConfigurationProperties(prefix = "teacher")
public class TestConfiguration3 {

    private String name;
    private Integer age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}

```

## @NacosConfigurationProperties怎么实现配置文件热更新
两种实现方式：
- NacosConfigEnvironmentProcessor：负责在应用程序启动前加载远程配置
- NacosConfigAutoConfiguration：负责完成Nacos配置管理相关功能的配置加载与初始化
@NacosConfigurationProperties怎么被识别的? Nacos提供了NacosConfigurationPropertiesBindingPostProcessor

扫描类上的是否有@NacosConfigurationProperties注解
```
public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {

		NacosConfigurationProperties nacosConfigurationProperties = findAnnotation(
				bean.getClass(), NacosConfigurationProperties.class);

		if (nacosConfigurationProperties != null) {
			bind(bean, beanName, nacosConfigurationProperties);
		}

		return bean;
	}

```
获取@NacosConfigurationProperties构造器实例
```
private void bind(Object bean, String beanName,
			NacosConfigurationProperties nacosConfigurationProperties) {

		NacosConfigurationPropertiesBinder binder;
		try {
			binder = applicationContext.getBean(
					NacosConfigurationPropertiesBinder.BEAN_NAME,
					NacosConfigurationPropertiesBinder.class);
			if (binder == null) {
				binder = new NacosConfigurationPropertiesBinder(applicationContext);
			}

		}
		catch (Exception e) {
			binder = new NacosConfigurationPropertiesBinder(applicationContext);
		}

		binder.bind(bean, beanName, nacosConfigurationProperties);

	}

```
获取NacosConfigService服务
创建监听，并将监听器添加到NacosConfigService服务中
```
protected void bind(final Object bean, final String beanName,
			final NacosConfigurationProperties properties) {

		Assert.notNull(bean, "Bean must not be null!");

		Assert.notNull(properties, "NacosConfigurationProperties must not be null!");

		// support read data-id and group-id from spring environment
		final String dataId = NacosUtils.readFromEnvironment(properties.dataId(),
				environment);
		final String groupId = NacosUtils.readFromEnvironment(properties.groupId(),
				environment);
		final String type;
		
		ConfigType typeEunm = properties.yaml() ? ConfigType.YAML : properties.type();
		if (ConfigType.UNSET.equals(typeEunm)) {
			type = NacosUtils.readFileExtension(dataId);
		}
		else {
			type = typeEunm.getType();
		}

		final ConfigService configService = configServiceBeanBuilder
				.build(properties.properties());

		// Add a Listener if auto-refreshed
		if (properties.autoRefreshed()) {
			
			String content = getContent(configService, dataId, groupId);
			
			if (hasText(content)) {
				doBind(bean, beanName, dataId, groupId, type, properties, content,
						configService);
			}

			Listener listener = new AbstractListener() {
				@Override
				public void receiveConfigInfo(String config) {
					doBind(bean, beanName, dataId, groupId, type, properties, config,
							configService);
				}
			};
			try {//
				if (configService instanceof EventPublishingConfigService) {
					((EventPublishingConfigService) configService).addListener(dataId,
							groupId, type, listener);
				}
				else {
					configService.addListener(dataId, groupId, listener);
				}
			}
			catch (NacosException e) {
				if (logger.isErrorEnabled()) {
					logger.error(e.getMessage(), e);
				}
			}
		}
	}

```
更新数据
当在配置更新时，回调listener监听器，执行NacosBootConfigurationPropertiesBinder.doBind方法

注解配置的配置文件临时加入到默认的StandardEnvironment中
通过SpringBoot Binder将StandardEnvironment配置项绑定(注入)到bean
解析完成后再移除注入
```
protected void doBind(Object bean, String beanName, String dataId, String groupId,
			String configType, NacosConfigurationProperties properties, String content,
			ConfigService configService) {
		synchronized (this) {
			String name = "nacos-bootstrap-" + beanName;
			NacosPropertySource propertySource = new NacosPropertySource(name, dataId, groupId, content, configType);
			environment.getPropertySources().addLast(propertySource);
			Binder binder = Binder.get(environment);
			ResolvableType type = getBeanType(bean, beanName);
			Bindable<?> target = Bindable.of(type).withExistingValue(bean);
			binder.bind(properties.prefix(), target);
			publishBoundEvent(bean, beanName, dataId, groupId, properties, content, configService);
			publishMetadataEvent(bean, beanName, dataId, groupId, properties);
			environment.getPropertySources().remove(name);
		}
	}

```

## Nacos配置热更新的实现原理

### Nacos客户端如何监控和通知更新的
Nacos客户端在启动的时候会启动一个NacosContextRefresher的监听器用于在Springboot启动完成之后接收ApplicationReadyEvent事件(标识Spring启动完成)
接收事件,用来注册需要监听变化的配置文件——监听格式为(dataID+groupId+tenant)[项目启动时tenant一般不会改变]
```
//com.alibaba.cloud.nacos.refresh.NacosContextRefresher#registerNacosListener (注册配置文件监听)
private void registerNacosListener(final String groupKey, final String dataKey) {
   String key = NacosPropertySourceRepository.getMapKey(dataKey, groupKey);
   Listener listener = listenerMap.computeIfAbsent(key,
         lst -> new AbstractSharedListener() {
            @Override
            public void innerReceive(String dataId, String group,
                  String configInfo) {
               refreshCountIncrement();
               nacosRefreshHistory.addRefreshRecord(dataId, group, configInfo);
               // 发送刷新事件,通知Spring
               applicationContext.publishEvent(
                     new RefreshEvent(this, null, "Refresh Nacos config"));
               if (log.isDebugEnabled()) {
                  log.debug(String.format("Refresh Nacos config group=%s,dataId=%s,configInfo=%s", group, dataId, configInfo));
               }
            }
         });
   try {
      configService.addListener(dataKey, groupKey, listener);
   }catch (NacosException e) {
      log.warn(String.format("register fail for nacos listener ,dataId=[%s],group=[%s]", dataKey,groupKey), e);
   }
}
```
在这之前,NacosConfigService启动时(也就是项目启动时) 构建ClientWorker会构建定时任务,长轮训监听配置变化,如果发生变化通过上面注册的监听发送 RefreshEvent事件.
```
//com.alibaba.nacos.client.config.impl.ClientWorker#ClientWorker (启动定时轮训,监控配置变化)
public ClientWorker(final HttpAgent agent, final ConfigFilterChainManager configFilterChainManager,final Properties properties) {
	//...省略无关代码
    this.executor.scheduleWithFixedDelay(new Runnable() {
        @Override
        public void run() {
            try {
                checkConfigInfo();
            } catch (Throwable e) {
                LOGGER.error("[" + agent.getName() + "] [sub-check] rotate check error", e);
            }
        }
    }, 1L, 10L, TimeUnit.MILLISECONDS);
}
/**
* Check config info.
*/
public void checkConfigInfo() {
        // 注册上来的需要监控的配置文件
        int listenerSize = cacheMap.size();
        // 比对是否有新的配置文件需要监控
        int longingTaskCount = (int) Math.ceil(listenerSize /ParamUtil.getPerTaskConfigSize());
        if (longingTaskCount > currentLongingTaskCount) {
            for (int i = (int) currentLongingTaskCount; i < longingTaskCount; i++) {
				//执行长轮训比对任务
                executorService.execute(new LongPollingRunnable(i));
            }
            currentLongingTaskCount = longingTaskCount;
        }
    }

class LongPollingRunnable implements Runnable {
    private final int taskId;
    public LongPollingRunnable(int taskId) {
        this.taskId = taskId;
    }
    @Override
    public void run() {
        //....省略代码

        //比对是否发生变化
        List<String> changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);
        if (!CollectionUtils.isEmpty(changedGroupKeys)) {
            LOGGER.info("get changedGroupKeys:" + changedGroupKeys);
        }

        //....省略代码

        for (CacheData cacheData : cacheDatas) {
            if (!cacheData.isInitializing() || inInitializingCacheList
                    .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) {
                //比对MD5是否改变,触发对应监听器
                cacheData.checkListenerMd5();
                cacheData.setInitializing(false);
            }
        }
        //....省略代码
    } catch (Throwable e) {
        LOGGER.error("longPolling error : ", e);
        executorService.schedule(this, taskPenaltyTime, TimeUnit.MILLISECONDS);
    }
 }
}
```
总结:nacos在启动的时开启长轮训监听使用的配置文件,是否发生变化(MD5比对),当发生变化时(前后md5不一致),会发送RefreshEvent事件,通知对应监听器

Nacos发送了刷新事件后,SpringCloud提供了RefreshEventListener进行监听对应的刷新事件
```
//org.springframework.cloud.endpoint.event.RefreshEventListener (事件刷新)   
	private ContextRefresher refresh;
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof ApplicationReadyEvent) {
            handle((ApplicationReadyEvent) event);
        }
        else if (event instanceof RefreshEvent) {
            handle((RefreshEvent) event);
        }
    }
    public void handle(RefreshEvent event) {
        if (this.ready.get()) {
            //触发Spring上下文刷新
            Set<String> keys = this.refresh.refresh();
        }
    }


//org.springframework.cloud.context.refresh.ContextRefresher#refresh(实际刷新的位置)
	private RefreshScope scope;
	public synchronized Set<String> refresh() {
      //Spring上下文刷新
		Set<String> keys = refreshEnvironment();
      //对应scope内容更新(RefreshScope)
		this.scope.refreshAll();
		return keys;
    }
```
这里我们也能看出刷新的顺序,先刷新Spring环境变量.再触发Scope更新.

@RereshScope是@Scope("refresh")的派生的注解,使用此注解在构建Bean的时候会将作用域改为refresh,并在在Bean创建时,默认使用CGLIB生成代理对象。

这里简单说明一下:如果作用域不是单例(single)和原型(prototype)的bean的话将交给对应的Socpe去获取bean,而创建bean方式和单例bean是一样的(详情搜索:spring生命周期)

RefreshScope Bean的创建
```
//org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean
//refresh作用域对应bean的创建过程
// Create bean instance.
if (mbd.isSingleton()) {
    //单例创建
}else if (mbd.isPrototype()) {
    //原型创建
}else {
    //获取作用域名称,现在是refresh
    String scopeName = mbd.getScope();
    if (!StringUtils.hasLength(scopeName)) {
        throw new IllegalStateException("No scope name defined for bean ´" + beanName + "'");
    }
    //获取对应作用域对象,这里是RereshScope
    Scope scope = this.scopes.get(scopeName);
    if (scope == null) {
        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
    }
    try {
        //创建bean对象,这里是传递的是,bean的名称和objectFactory
        Object scopedInstance = scope.get(beanName, () -> {
            beforePrototypeCreation(beanName);
            try {
                return createBean(beanName, mbd, args);
            }finally {
                afterPrototypeCreation(beanName);
            }
        });
        //如果是工厂bean,获取真实的bean对象
        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
    }catch (IllegalStateException ex) {
        throw new BeanCreationException(beanName,"Scope '" + scopeName + "' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton",ex);
    }
}
```
@Scope("refresh”)对应的Scope类为:RereshScope (这个如果不知道为什么,自己去查吧 spring的scope)
```
//org.springframework.cloud.context.scope.GenericScope#get(获取bean对象)
@Override
public Object get(String name, ObjectFactory objectFactory) {
  //这里可以发现,@RefreshScope 创建的对象实际上会bean封装成一个BeanLifecycleWrapper对象
   BeanLifecycleWrapper value = this.cache.put(name,
         new BeanLifecycleWrapper(name, objectFactory));
   this.locks.putIfAbsent(name, new ReentrantReadWriteLock());
   try {
      return value.getBean();
   }
   catch (RuntimeException e) {
      this.errors.put(name, e);
      throw e;
   }
}
//bean生命周期的封装
private static class BeanLifecycleWrapper {
    //bean的名称
    private final String name;
    //bean创建工厂
    private final ObjectFactory<?> objectFactory;
    //缓存bean
    private Object bean;
    //销毁回调
    private Runnable callback;
    //获取bean
    public Object getBean() {
      //如果为空,重新创建bean
        if (this.bean == null) {
            synchronized (this.name) {
                if (this.bean == null) {
                    this.bean = this.objectFactory.getObject();
                }
            }
        }
        return this.bean;
    }
    //销毁bean
    public void destroy() {
        if (this.callback == null) {
            return;
        }
        synchronized (this.name) {
            Runnable callback = this.callback;
            if (callback != null) {
                callback.run();
            }
            this.callback = null;
            this.bean = null;
        }
    }
}
```
上面是针对于@RefreshScope声明的bean创建和被引用的过程,在bean没有被销毁钱,每次getBean获取的都是BeanLifecycleWrapper里面存储的bean对象,不会被改变

### RefreshScope Bean的刷新
前面描述 RefreshEvent 事件时,我们看见了 有一行代码为 this.scope.refreshAll(); 这里刷新的就是RefreshScope
```
//org.springframework.cloud.context.scope.refresh.RefreshScope#refreshAll
@ManagedOperation(description = "Dispose of the current instance of all beans "
      + "in this scope and force a refresh on next method execution.")
public void refreshAll() {
   super.destroy();
   this.context.publishEvent(new RefreshScopeRefreshedEvent());
}

@Override
public void destroy() {
  List<Throwable> errors = new ArrayList<Throwable>();
  //将所有的RefreshScope的对象全部销毁
  Collection<BeanLifecycleWrapper> wrappers = this.cache.clear();
  for (BeanLifecycleWrapper wrapper : wrappers) {
    try {
      Lock lock = this.locks.get(wrapper.getName()).writeLock();
      lock.lock();
      try {
        //实际上调用的就是BeanLifecycleWrapper中的destroy
        //将属性中的bean销毁
        wrapper.destroy();
      }
      finally {
        lock.unlock();
      }
    }
    catch (RuntimeException e) {
      errors.add(e);
    }
  }
  if (!errors.isEmpty()) {
    throw wrapIfNecessary(errors.get(0));
  }
  this.errors.clear();
}
```
总结:refresh作用域的Bean是由RefreshScope缓存控制，即当配置中心在触发刷新时RefreshScope会删除Socpe缓存的Bean,那么下次获取或者是执行时就会用新的Environment重新创建基于新配置Bean,这样就达到了配置的自动更新。

扩展:为什么需要生成代理对象
因为Bean装配是一次性的，假设没有代理的情况下，在另一个bean注入这个refreshBean之后就无法改变了，就算refreshBean刷新时"销毁"（只是RefreshScope缓存中引用的Bean置为null) 并后面重新生成了，但是之前引用还是老的bean，这也是为什么没有加@RefreshScope注解而导致配置自动刷新失效了。所以如果想要代码中配置能够刷新,就需要保证获取配置是通过这个代理对象。

### SpringCloud中@ConfigurationProperties如何实现更新的
@ConfigurationProperties对象的数据填充

@ConfigurationProperties本身是Spring提供的一个注解; 基于spring机制(自动装配)会有一个扩展类ConfigurationPropertiesBindingPostProcessor通过postProcessBeforeInitialization完成带有@ConfigurationProperties注解bean的属性填充

postProcessBeforeInitialization发生在bean创建,初始化之前
```
//org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor
private ConfigurationPropertiesBinder binder;
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
   bind(ConfigurationPropertiesBean.get(this.applicationContext, bean, beanName));
   return bean;
}
private void bind(ConfigurationPropertiesBean bean) {
   if (bean == null || hasBoundValueObject(bean.getName())) {
      return;
   }
   Assert.state(bean.getBindMethod() == BindMethod.JAVA_BEAN, "Cannot bind @ConfigurationProperties for bean '" + bean.getName() + "'. Ensure that @ConstructorBinding has not been applied to regular bean");
   try {
     //填充数据
      this.binder.bind(bean);
   }
   catch (Exception ex) {
      throw new ConfigurationPropertiesBindException(bean, ex);
   }
}


//org.springframework.boot.context.properties.ConfigurationPropertiesBinder#bind
BindResult<?> bind(ConfigurationPropertiesBean propertiesBean) {
  Bindable<?> target = propertiesBean.asBindTarget();
  ConfigurationProperties annotation = propertiesBean.getAnnotation();
  BindHandler bindHandler = getBindHandler(target, annotation);
  //这里是Springboot2.x之后提供了一个填充bean属性的工具
  return getBinder().bind(annotation.prefix(), target, bindHandler);
}
```
除了Springboot中提供的填充机制,在SpringCloud下会额外记录@ConfigurationProperties的bean对象信息
```
//org.springframework.cloud.context.properties.ConfigurationPropertiesBeans
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
      throws BeansException {
   if (isRefreshScoped(beanName)) {
      return bean;
   }
  //封装成ConfigurationPropertiesBean对象,在后续销毁事
   ConfigurationPropertiesBean propertiesBean = ConfigurationPropertiesBean
         .get(this.applicationContext, bean, beanName);
   if (propertiesBean != null) {
     //记录bean的信息
      this.beans.put(beanName, propertiesBean);
   }
   return bean;
}
```
@ConfigurationProperties对象的数据的刷新

前面说了nacos配置修改的时候会触发RefreshEvent,在刷新时会刷新环境变量,同时这个里面会发送一个环境变量的事件
```
public synchronized Set refreshEnvironment() {
  //提取历史的数据
   Map before = extract(this.context.getEnvironment().getPropertySources());
  //加载新读取的配置文件
   addConfigFilesToEnvironment();
  //新的数据与老得数据比对
   Set keys = changes(before,
        extract(this.context.getEnvironment().getPropertySources())).keySet();
  //发送环境变量变更事件
   this.context.publishEvent(new EnvironmentChangeEvent(this.context, keys));
   return keys;
}
```
SpringCloud中提供了一个ConfigurationPropertiesRebinder来监听环境变量的改变
```
//org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder
private ConfigurationPropertiesBeans beans;

private ApplicationContext applicationContext;

@ManagedOperation
public void rebind() {
   this.errors.clear();
  //将springcloud记录的所有ConfigurationProperties对象更新
   for (String name : this.beans.getBeanNames()) {
      rebind(name);
   }
}

@ManagedOperation
public boolean rebind(String name) {
   if (!this.beans.getBeanNames().contains(name)) {
      return false;
   }
   if (this.applicationContext != null) {
      try {
         Object bean = this.applicationContext.getBean(name);
         if (AopUtils.isAopProxy(bean)) {
            bean = ProxyUtils.getTargetObject(bean);
         }
         if (bean != null) {
           //忽略不需要热更新的be an
            if (getNeverRefreshable().contains(bean.getClass().getName())) {
               return false; // ignore
            }
           //这里需要注意一下,这个销毁只是调用销毁防范,不是bean==null,引用还在
            this.applicationContext.getAutowireCapableBeanFactory()
                  .destroyBean(bean);
           //重新初始化bean(初始化和创建是两个过程不要弄错了)
            this.applicationContext.getAutowireCapableBeanFactory()
                  .initializeBean(bean, name);
            return true;
         }
      }
      catch (RuntimeException e) {
         this.errors.put(name, e);
         throw e;
      }
      catch (Exception e) {
         this.errors.put(name, e);
         throw new IllegalStateException("Cannot rebind to " + name, e);
      }
   }
   return false;
}
//监听事件
@Override
public void onApplicationEvent(EnvironmentChangeEvent event) {
  if (this.applicationContext.equals(event.getSource())
      // Backwards compatible
      || event.getKeys().equals(event.getSource())) {
    rebind();
  }
}
```
总结
@ConfigurationProperties注解的bean可以热更新是Springcloud独有的方法,在spring和springboot项目中是不支持的,需要注意.
@ConfigurationProperties热更新与@RefreshScope热更新的原理基本一致,都是通过对bean销毁,在初始化,来完成.
而整个Nacos配置变更,到对应bean属性热更新的过程都是依靠 Spring机制中的事件通知完成

nacos轮训监听配置文件的变化,发送RefreshEvent事件
SpringCloud监听RefreshEvent事件,触发上下文刷新
Spring 重新读取配置文件到Environment,并且发送Environment变更事件
刷新bean对象,对bean先destroy,在重新initialize













