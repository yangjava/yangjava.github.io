---
layout: post
categories: [Spark]
description: none
keywords: Spark
---
# SparkSQL逻辑计划
逻辑计划阶段在整个流程中起着承前启后的作用。在此阶段，字符串形态的SQL语句转换为树结构形态的逻辑算子树，SQL中所包含的各种处理逻辑（过滤、剪裁等）和数据信息都会被整合在逻辑算子树的不同节点中。逻辑计划本质上是一种中间过程表示，与Spark平台无关，后续阶段会进一步将其映射为可执行的物理计划。

## Spark SQL逻辑计划概述
Spark SQL逻辑计划在实现层面被定义为LogicalPlan类。从SQL语句经过SparkSqlParser解析生成Unresolved LogicalPlan，到最终优化成为Optim ized LogicalPlan，这个流程主要经过3个阶段。

这3个阶段分别产生Unresolved LogicalPlan、Analyzed LogicalPlan和Optim ized LogicalPlan，其中Optimized LogicalPlan传递到下一个阶段用于物理执行计划的生成。

具体来讲，这3个阶段所完成的工作分别如下。

- 由SparkSqlParser中的AstBuilder执行节点访问，将语法树的各种Context节点转换成对应的LogicalPlan节点，从而成为一棵未解析的逻辑算子树（Unresolved LogicalPlan），此时的逻辑算子树是最初形态，不包含数据信息与列信息等。
- 由Analyzer将一系列的规则作用在Unresolved LogicalPlan上，对树上的节点绑定各种数据信息，生成解析后的逻辑算子树（Analyzed LogicalPlan）。
- 由Spark SQL中的优化器（Optim izer）将一系列优化规则作用到上一步生成的逻辑算子树中，在确保结果正确的前提下改写其中的低效结构，生成优化后的逻辑算子树（Optim ized LogicalPlan）。

## LogicalPlan简介
LogicalPlan作为数据结构记录了对应逻辑算子树节点的基本信息和基本操作，包括输入输出和各种处理逻辑等。

### QueryPlan概述
在介绍LogicalPlan之前，有必要先介绍一下其父类QueryPlan。为了从整体视角了解QueryPlan的所有功能，图5.2列举了其全部操作，并进行了简单的类型划分。

QueryPlan的主要操作分为6个模块，分别是输入输出、字符串、规范化、表达式操作、基本属性和约束。

下面简单介绍这6个模块，读者可结合实际代码阅读。
- 输入输出
QueryPlan的输入输出定义了5个方法，其中output是返回值为Seq[Attribute]的虚函数，具体内容由不同子节点实现，而outputSet是将output的返回值进行封装，得到AttributeSet集合类型的结果。获取输入属性的方法inputSet的返回值也是AttributeSet，节点的输入属性对应所有子节点的输出；producedAttributes表示该节点所产生的属性；m issingInput表示该节点表达式中涉及的但是其子节点输出中并不包含的属性。
- 基本属性
表示QueryPlan节点中的一些基本信息，其中schema对应output输出属性的schema信息，allAttributes记录节点所涉及的所有属性（Attribute）列表，aliasMap记录节点与子节点表达式中所有的别名信息，references表示节点表达式中所涉及的所有属性集合，subqueries和innerChildren都默认实现该QueryPlan节点中包含的所有子查询。
- 字符串
这部分方法主要用于输出打印QueryPlan树型结构信息，其中schema信息也会以树状展示。需要注意的一个方法是statePrefix，用来表示节点对应计划状态的前缀字符串。在QueryPlan的默认实现中，如果该计划不可用（invalid），则前缀会用感叹号（“！”）标记。
- 规范化
类似Expression中的方法定义，对QueryPlan节点类型也有规范化（Canonicalize）的概念。在QueryPlan的默认实现中，canonicalized直接赋值为当前的QueryPlan类；此外，在sameResult方法中会利用canonicalized来判断两个QueryPlan的输出数据是否相同。
- 表达式操作
Spark SQL丰富的表达式体系，其典型的特点就是不需要驱动，直接执行。而在QueryPlan各个节点中，包含了各种表达式对象，各种逻辑操作一般也都是通过表达式来执行的。在QueryPlan的方法定义中，表达式相关的操作占据重要的地位，其中expressions方法能够得到该节点中的所有表达式列表，其他方法很容易根据命名了解对应功能，具体的实现细节可以参看代码。
- 约束（Constraints）
本质上也属于数据过滤条件（Filter）的一种，同样是表达式类型。相对于显式的过滤条件，约束信息可以“推导”出来，例如，对于“a>5”这样的过滤条件，显然a的属性不能为null，这样就可以对应地构造isNotNull（a）约束；又如“a=5”和“a=b”的谓词，能够推导得到“b=5”的约束条件。在实际情况下，SQL语句中可能会涉及很复杂的约束条件处理，如约束合并、等价性判断等。在QueryPlan类中，提供了大量方法用于辅助生成constraints表达式集合以支持后续优化操作。例如，validConstraints方法返回该QueryPlan所有可用的约束条件，比较常用的constructIsNotNullConstraints方法，会针对特定的列构造isNotNull的约束条件。

## LogicalPlan基本操作与分类
进行LogicalPlan类的分析，介绍逻辑算子树节点都有哪些功能。同样的，在内容上首先从整体列出LogicalPlan中的所有方法，使读者对LogicalPlan有一个宏观的概念。读者可结合代码阅读。

LogicalPlan继承自QueryPlan，包含了两个成员变量和17个方法。两个成员变量一个是resolved，用来标记该LogicalPlan是否为经过了解析的布尔类型值；另一个是canonicalized，重载了QueryPlan中的对应赋值，默认实现消除了子查询别名之后的LogicalPlan。

根据操作的内容进行了分类，前3个方法与resolved成员变量相关，其中childrenResolved标记子节点是否已经被解析。中间的5个方法设定了该LogicalPlan中的一些基本信息，其中statePrefix重载了QueryPlan中的实现，如果该逻辑算子树节点未经过解析，则输出的字符串前缀会加上单引号（‘）；isStream ing方法用来表示当前逻辑算子树中是否包含流式数据源；statistics记录了当前节点的统计信息，例如默认实现的sizeInBytes信息，一般来讲如果当前节点不包含子节点，则必须重载实现该方法；maxRows记录了当前节点可能计算的最大行数，一般常用于Lim it算子；refresh方法会递归地刷新当前计划中的元数据等信息。剩下的则是LogicalPlan中定义的与resolve相关的9个分析方法，用来执行对数据表、表达式、schema和列属性等类型的解析，具体实现可以参见代码。

同样的，LogicalPlan仍然是抽象类，根据子节点数目，绝大部分的LogicalPlan可以分为3类，即叶子节点LeafNode类型（不存在子节点）、一元节点UnaryNode类型（仅包含一个子节点）和二元节点BinaryNode类型（包含两个子节点）。此外，还有几个子类直接继承自LogicalPlan，不属于这3种类型，将在后面单独介绍。

## LeafNode类型的LogicalPlan
在LogicalPlan所有类型的节点中，LeafNode类型的数目最多，共有70多种。为了便于进行分析，本小节将这些子类按照其所属的包进行了分类

LeafNode类型的LogicalPlan节点对应数据表和命令（Command）相关的逻辑，因此这些LeafNode子类中有很大一部分都属于datasources包和command包。值得一提的是，实现RunnableCommand特质（Trait）的类共有40多个，是数量最为庞大的LogicalPlan类型。顾名思义，RunnableCommand是直接运行的命令，主要涉及12种情形，包括Database相关命令、Table相关命令、View相关命令、DDL相关命令、Function相关命令和Resource相关命令等。例如，Database相关命令有两个，分别是ShowDatabasesCommand和SetDatabaseCommand，用于显示当前数据库名称和切换当前数据库到相应的数据库。

以SetDatabaseCommand命令为例，其实现比较简单，如以下代码所示，该Command对应SQL中的“usedatabase”语句。可以看到，该命令直接调用的是Catalog中的set方法。

## UnaryNode类型的LogicalPlan
在LogicalPlan所有类型的节点中，UnaryNode类型的节点应用非常广泛，共有34种，常见于对数据的逻辑转换操作，包括过滤等











