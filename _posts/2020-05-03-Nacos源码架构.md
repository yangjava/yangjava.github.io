---
layout: post
categories: [Nacos]
description: none
keywords: Nacos
---
# Nacos源码架构
nacos是主要是用来做分布式服务的发现和治理的，同时nacos还具有担任配置中心的能力。

## Nacos整体架构
nacos整体架构可以分为三个部分，位于核心C位的nacos服务，方便用户直观查看和操作的nacos控制台，以及使用nacos功能的客户端服务

### nacos服务架构
nacos服务主要是由功能访问入口OpenAPI，注册中心Naming Service，配置中心Config Service，nacos core核心包，以及一致性协议等部分组成
外部服务，包括nacos客户端服务，nacos控制台服务，都是通过OpenAPI操作使用注册中心和配置中心的，而一致性协议，保证了nacos集群各节点之间的数据同步。

## 源码结构
- address模块: 服务地址生成和管理，主要查询nacos集群中节点个数以及IP的列表。
- api模块: 主要给客户端调用的api接口的抽象;
- auth模块：认证相关，支持grpc和http协议。登录和鉴权处理
- client模块: 支持远程连接，指标统计，客户端命名，http或者grpc调用服务端等。主要是对依赖api模块和common模块,对api的接口的实现,给nacos的客户端使用;
- cmdb模块: 主要是操作的数据的存储在内存中,该模块提供一个查询数据标签的接口;
- config模块: 主要是服务配置的管理, 提供api给客户端拉去配置信息,以及提供更新配置 的,客户端通过长轮询的更新配置信息.数据存储是Mysql;
- naming模块: 主要是作为服务注册中心的实现模块,具备服务的注册和服务发现的功能;
- console模块: 主要是实现与前端进行交互.具有权限校验、服务状态、健康检查等功能;
- core模块: 主要初始化属性加载，监听器相关内容，用于加载nacos的default的配置信息，config和naming都依赖于这个包；
- common模块：缓存，编码，事件处理，http支持，通知，spi， trace等
- consistency模块：cp和ap的实现
- distribution模块: 主要是打包nacos-server的操作,使用maven-assembly-plugin进行自定义打包,
- nacos-plugin-default-impl: 插件默认实现原理
## 源码启动
找到console目录，Nacos类就是启动类。发现报错consistency.entity不存在

打开console下的resources目录下的application.properties配置文件，配置连接数据库。

在MySQL创建nacos的database，并执行以上sql脚本（12张表）

在此处配置nacos单机启动，写入以下内容：
```
-Dnacos.standalone=true
```

##  Nacos权限认证源码
Nacos的权限控制，目标是能够满足用户基本的鉴权需求，同时能够保持扩展性，可以支持去对接用户自带的用户管理系统或者鉴权系统，包括后面和K8S生态以及Service Mesh生态能够无缝的融合。基于这样的考虑，目前Nacos权限控制的设计是自带一个基本的实现，然后可以支持用户扩展。具体的设计如下。

### 模块设计
整体的模块设计是尽量将鉴权的逻辑抽象出来，不在服务发现模块或者配置管理模块添加相关的逻辑。通过配置文件可以选择当前使用的鉴权系统。Nacos自带的认证系统使用JWT Token，自带的鉴权系统使用的是RBAC。

### 认证算法
对于用户来说，不管是在控制台还是在客户端，都是上传用户名和密码来获取一个token，然后后续的每一次到Nacos的请求都会带上这个token来表明身份。这个token会有一个失效时间，对于控制台来说，只需要直接提示用户重新登录即可，对于客户端则需要有一个定期到Nacos刷新token的逻辑。

### 数据模型
鉴权的数据模型也是基于标准的RBAC来设计的，分为用户、角色和权限三部分。用户就是由用户名和密码组成的用户信息，角色则是一个逻辑上的用户组，Nacos启动时会自带一个全局管理员的角色，只有这个全局管理员的角色可以进行添加用户、添加角色、添加授权等操作，保证安全性。而权限则是由资源+动作来组成。

### 接口设计
以下接口涉及到登录和鉴权的所有逻辑，这些接口除了登录接口，其他接口都只能由全局管理员来调用。

- 用户管理
创建用户
```
POST /nacos/v1/auth/users?username=xx&password=yy
```
删除用户
```
DELETE /nacos/v1/auth/users?username=xx&password=yy
```
更新用户
```
PUT /nacos/v1/auth/users?username=xx&oldPassword=yy&newPassword=zz
```
登录
```
POST  /nacos/v1/auth/users/login?username=xxx&password=yyy
```

- 角色管理
创建角色/绑定用户到角色
```
POST /nacos/v1/auth/roles?role=xx&username=yy
```
删除某个用户的角色
```
DELETE /nacos/v1/auth/roles?role=xx&username=yy
```
获取用户的所有角色
```
GET /nacos/v1/auth/roles?username=xxx
```

- 权限管理
给角色添加权限
```
POST /nacos/v1/auth/permissions?role=xxx&resource=yyy&action=zzz
```
从角色删除权限
```
DELETE /nacos/v1/auth/permissions?role=xxx&resource=yyy&action=zzz
```
获取某个角色的权限
```
GET /nacos/v1/auth/permissions?role=xxx
```

### Nacos登陆
鉴权功能默认没有开启，开启后的效果就是 Nacos 的接口需要用户登录并且具有权限才能调用该接口。例如注册实例、发布配置等。

接口实现源码在nacos-plugin-default-impl
```
    @PostMapping("/login")
    public Object login(@RequestParam String username, @RequestParam String password, HttpServletResponse response,
            HttpServletRequest request) throws AccessException {
        
        if (AuthSystemTypes.NACOS.name().equalsIgnoreCase(authConfigs.getNacosAuthSystemType())
                || AuthSystemTypes.LDAP.name().equalsIgnoreCase(authConfigs.getNacosAuthSystemType())) {
            NacosUser user = iAuthenticationManager.authenticate(request);
            
            response.addHeader(AuthConstants.AUTHORIZATION_HEADER, AuthConstants.TOKEN_PREFIX + user.getToken());
            
            ObjectNode result = JacksonUtils.createEmptyJsonNode();
            result.put(Constants.ACCESS_TOKEN, user.getToken());
            result.put(Constants.TOKEN_TTL, jwtTokenManager.getTokenTtlInSeconds(user.getToken()));
            result.put(Constants.GLOBAL_ADMIN, iAuthenticationManager.hasGlobalAdminRole(user));
            result.put(Constants.USERNAME, user.getUserName());
            return result;
        }
        
        // create Authentication class through username and password, the implement class is UsernamePasswordAuthenticationToken
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username,
                password);
        
        try {
            // use the method authenticate of AuthenticationManager(default implement is ProviderManager) to valid Authentication
            Authentication authentication = authenticationManager.authenticate(authenticationToken);
            // bind SecurityContext to Authentication
            SecurityContextHolder.getContext().setAuthentication(authentication);
            // generate Token
            String token = jwtTokenManager.createToken(authentication);
            // write Token to Http header
            response.addHeader(AuthConstants.AUTHORIZATION_HEADER, "Bearer " + token);
            return RestResultUtils.success("Bearer " + token);
        } catch (BadCredentialsException authentication) {
            return RestResultUtils.failed(HttpStatus.UNAUTHORIZED.value(), null, "Login failed");
        }
    }
```

### Nacos SPI 鉴权机制
默认未开启鉴权，需要启用。
```properties
nacos.core.auth.enabled=true
```
Nacos 鉴权系统使用 SPI 机制实现，这意味着用户可以自己实现扩展一个鉴权系统。Nacos 默认也提供了两个默认实现。鉴权 SPI 接口是 com.alibaba.nacos.plugin.auth.spi.server.AuthPluginService，所有鉴权类都实现此接口。

下来看看默认实现 NacosAuthPluginService 的鉴权源码
com.alibaba.nacos.plugin.auth.impl.NacosAuthPluginService
```
    @Override
    public boolean validateIdentity(IdentityContext identityContext, Resource resource) throws AccessException {
        checkNacosAuthManager();
        String token = resolveToken(identityContext);
        NacosUser nacosUser;
        if (StringUtils.isNotBlank(token)) {
            nacosUser = authenticationManager.authenticate(token);
        } else {
            String userName = (String) identityContext.getParameter(AuthConstants.PARAM_USERNAME);
            String password = (String) identityContext.getParameter(AuthConstants.PARAM_PASSWORD);
            nacosUser = authenticationManager.authenticate(userName, password);
        }
        identityContext.setParameter(AuthConstants.NACOS_USER_KEY, nacosUser);
        identityContext.setParameter(com.alibaba.nacos.plugin.auth.constant.Constants.Identity.IDENTITY_ID,
                nacosUser.getUserName());
        return true;
    }
```
validateIdentity 验证身份。用户登录，用户登录的过程就是拿到token，然后校验token，校验通过就从token中获取到用户

### 后台管理 / HTTP 接口鉴权
首先使用 @Secured 定义了受保护资源，然后使用 com.alibaba.nacos.core.auth.AuthFilter 进行解析处理

AuthFilter 是一个 Servlet 的 Filter，拦截了全部请求。接下来看看 AuthFilter 的 filter 如何实现
```java
public class AuthFilter implements Filter {
    
    private final AuthConfigs authConfigs;
    
    private final ControllerMethodsCache methodsCache;
    
    private final HttpProtocolAuthService protocolAuthService;
    
    public AuthFilter(AuthConfigs authConfigs, ControllerMethodsCache methodsCache) {
        this.authConfigs = authConfigs;
        this.methodsCache = methodsCache;
        this.protocolAuthService = new HttpProtocolAuthService(authConfigs);
        this.protocolAuthService.initialize();
    }
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        if (!authConfigs.isAuthEnabled()) {
            chain.doFilter(request, response);
            return;
        }
        
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        
        if (authConfigs.isEnableUserAgentAuthWhite()) {
            String userAgent = WebUtils.getUserAgent(req);
            if (StringUtils.startsWith(userAgent, Constants.NACOS_SERVER_HEADER)) {
                chain.doFilter(request, response);
                return;
            }
        } else if (StringUtils.isNotBlank(authConfigs.getServerIdentityKey()) && StringUtils.isNotBlank(
                authConfigs.getServerIdentityValue())) {
            String serverIdentity = req.getHeader(authConfigs.getServerIdentityKey());
            if (StringUtils.isNotBlank(serverIdentity)) {
                if (authConfigs.getServerIdentityValue().equals(serverIdentity)) {
                    chain.doFilter(request, response);
                    return;
                }
                Loggers.AUTH.warn("Invalid server identity value for {} from {}", authConfigs.getServerIdentityKey(),
                        req.getRemoteHost());
            }
        } else {
            resp.sendError(HttpServletResponse.SC_FORBIDDEN,
                    "Invalid server identity key or value, Please make sure set `nacos.core.auth.server.identity.key`"
                            + " and `nacos.core.auth.server.identity.value`, or open `nacos.core.auth.enable.userAgentAuthWhite`");
            return;
        }
        
        try {
            
            Method method = methodsCache.getMethod(req);
            
            if (method == null) {
                chain.doFilter(request, response);
                return;
            }
            
            if (method.isAnnotationPresent(Secured.class) && authConfigs.isAuthEnabled()) {
                
                if (Loggers.AUTH.isDebugEnabled()) {
                    Loggers.AUTH.debug("auth start, request: {} {}", req.getMethod(), req.getRequestURI());
                }
                
                Secured secured = method.getAnnotation(Secured.class);
                if (!protocolAuthService.enableAuth(secured)) {
                    chain.doFilter(request, response);
                    return;
                }
                Resource resource = protocolAuthService.parseResource(req, secured);
                IdentityContext identityContext = protocolAuthService.parseIdentity(req);
                boolean result = protocolAuthService.validateIdentity(identityContext, resource);
                if (!result) {
                    // TODO Get reason of failure
                    throw new AccessException("Validate Identity failed.");
                }
                injectIdentityId(req, identityContext);
                String action = secured.action().toString();
                result = protocolAuthService.validateAuthority(identityContext, new Permission(resource, action));
                if (!result) {
                    // TODO Get reason of failure
                    throw new AccessException("Validate Authority failed.");
                }
            }
            chain.doFilter(request, response);
        } catch (AccessException e) {
            if (Loggers.AUTH.isDebugEnabled()) {
                Loggers.AUTH.debug("access denied, request: {} {}, reason: {}", req.getMethod(), req.getRequestURI(),
                        e.getErrMsg());
            }
            resp.sendError(HttpServletResponse.SC_FORBIDDEN, e.getErrMsg());
        } catch (IllegalArgumentException e) {
            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, ExceptionUtil.getAllExceptionMsg(e));
        } catch (Exception e) {
            Loggers.AUTH.warn("[AUTH-FILTER] Server failed: ", e);
            resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Server failed, " + e.getMessage());
        }
    }
    
    /**
     * Set identity id to request session, make sure some actual logic can get identity information.
     *
     * <p>May be replaced with whole identityContext.
     *
     * @param request         http request
     * @param identityContext identity context
     */
    private void injectIdentityId(HttpServletRequest request, IdentityContext identityContext) {
        String identityId = identityContext.getParameter(
                com.alibaba.nacos.plugin.auth.constant.Constants.Identity.IDENTITY_ID, StringUtils.EMPTY);
        request.getSession()
                .setAttribute(com.alibaba.nacos.plugin.auth.constant.Constants.Identity.IDENTITY_ID, identityId);
        request.getSession().setAttribute(com.alibaba.nacos.plugin.auth.constant.Constants.Identity.IDENTITY_CONTEXT,
                identityContext);
    }
}

```
整体主流程概括下就是：获取到请求的数据、验证身份、验证权限。

鉴权功能的实现就是 验证身份、验证权限 这两个功能的实现
- 验证身份 protocolAuthService.validateIdentity()
- 验证权限 protocolAuthService.validateAuthority()
看看这两个方法如何实现
```java

// com.alibaba.nacos.auth.AbstractProtocolAuthService
public abstract class AbstractProtocolAuthService<R> implements ProtocolAuthService<R> {
    
    @Override
    public boolean validateIdentity(IdentityContext identityContext, Resource resource) throws AccessException {
        Optional<AuthPluginService> authPluginService = AuthPluginManager.getInstance()
                .findAuthServiceSpiImpl(authConfigs.getNacosAuthSystemType());
        if (authPluginService.isPresent()) {
            return authPluginService.get().validateIdentity(identityContext, resource);
        }
        return true;
    }
    
    
    @Override
    public boolean validateAuthority(IdentityContext identityContext, Permission permission) throws AccessException {
        Optional<AuthPluginService> authPluginService = AuthPluginManager.getInstance()
                .findAuthServiceSpiImpl(authConfigs.getNacosAuthSystemType());
        if (authPluginService.isPresent()) {
            return authPluginService.get().validateAuthority(identityContext, permission);
        }
        return true;
    }
}

```
解释一下
```
Optional<AuthPluginService> authPluginService = AuthPluginManager.getInstance()
                .findAuthServiceSpiImpl(authConfigs.getNacosAuthSystemType());
```
authConfigs.getNacosAuthSystemType() 为获取到当前系统配置的 授权类型

因为鉴权系统是 SPI 机制的，所以意味着用户可以自己扩展，而默认是 Nacos 默认的实现，可以通过配置文件更改为自己实现的。
```properties
### The auth system to use, currently only 'nacos' and 'ldap' is supported:
nacos.core.auth.system.type='nacos'
```
可以发现 SPI 接口 AuthPluginService 实现类 Nacos 实现了 2 个 LdapAuthPluginService、NacosAuthPluginService（默认）。就是根据这里的 authServiceName 找到了这个鉴权实现类

### 客户端 / GRPC 接口鉴权
客户端需要配置账号才能有权限注册服务，否则报错403 无权限
SpringCloud nacos 的配置
```yaml
spring:
  cloud:
    nacos:
      discovery:
        username: nacos
        password: nacos
```
请求 GRPC 接口需要 传入 accessToken，accessToken 从哪里来？就是下面这段代码：

在创建 NamingFactory.createNamingService(Properties properties) 里初始化过程中，最终调用了以下 initSecurityProxy 方法

该方法内容：
创建一个可调度的1个线程的线程池。根据配置的 username password 请求 nacos server 做一次登录。可调度线程池 每5秒 定时调度任务 登录一次，也就是每隔 5 秒就请求登录接口。

由于 Nacos Client 2.x 版本之后使用的是 GRPC 请求了，所以不走 HTTP 了，那么鉴权如何实现呢 答案就是 过滤器，没错还是过滤器，不过不是 Servlet 的AuthFilter了，而是专门给 GRPC 做的过滤器。 
RemoteRequestAuthFilter GRPC 过滤器就是在每次接收到 GRPC 请求之后，先调用过滤器来实现的。





# 参考资料
源码下载地址：https://github.com/alibaba/nacos
```properties
http://10.1.1.223:8848/nacos/v1/cs/configs?dataId=kqc-gateway.yaml&group=kqc-gateway&tenant=kqc_dev
```


