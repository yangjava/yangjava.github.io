---
layout: post
categories: [DataStructure]
description: none
keywords: DataStructure
---
# 图
图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V,E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

## 图的定义
在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。这和一对父母可以有多个孩子，但每个孩子却只能有一对父母是一个道理。可现实中，人与人之间关系就非常复杂，比如我认识的朋友，可能他们之间也互相认识，这就不是简单的一对一、一对多，研究人际关系很自然会考虑多对多的情况。那就是我们今天要研究的主题——图。图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。

图是一种数据结构，是继树后一种相对复杂且非线性的数据结构。下面我们来认识一下图这种结构，或者说它应该长成什么样子。

图一共有两部分组成，一部分叫做顶点，另一部分叫做依托顶点而衍生出来的边。我们将顶点与边的集合叫做图。下面呢，咱们来看一下图的内存结构，在正式学习前，我们先对图这种结构有个简单的了解和认识。关于图结构的数据模型，如下所示：
```
  (A)——(B)
        |
       (C) 
```
如上图所示，上面是咱们最常见的图结构，也就是图这种数据结构的数据模型。我们前面说在图这种数据结构中，有两个主角，一是顶点，二是边。

图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V,E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

对于图的定义，我们需要明确几个注意的地方。
- 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点（Vertex）。
- 线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。那么对于图呢？我记得有一个笑话说一个小朋友拿着一张空白纸给别人却说这是他画的一幅“牛吃草”的画，“那草呢？”“草被牛吃光了。”“那牛呢？”“牛吃完草就走了呀。”之所以好笑是因为我们根本不认为一张空白纸算作画的。同样，在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。
- 线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。

## 图的基本术语

### 顶点
顶点在图中起着至关重要的作用，它主要是构成图的主要骨架，有了顶点以后，咱们将其按照相应的规则连接起来，也就形成了咱们最终的图。在上述的内存模型中，咱们每个端点则就是一个顶点，例如：像咱们A B C这些端点都是咱们当前图结构中的顶点。

### 边
有了顶点的概念以后，那么什么是边呢？边就是两个顶点连接起来的一条线，我们其实可以很简单理解，所谓最简单的图，我们可以类比之前数学学过的几何一样。最简单的图也就是一条线段，两个端点叫做顶点，其中两个端点之间连接的直线也就叫做咱们的边。所以说，咱们的边一定是依赖顶点衍生出来的，不存在没有顶点却有边的情况。在上图中：例如A和B之间、B和C之间的链接等等，咱们称之为图中的边。

### 相邻顶点
经过同一条边连接起来的顶点怎们称之为相邻顶点。如上图所示，在该图中，A和B通过同一条边相连，B和C通过同一条边相连。我们可以说A和B为相邻顶点，也可以说B和C叫做相邻顶点，但是A和C没有经过同一条边连接，我们此时就不能说a和c为相邻顶点。

### 顶点的度
顶点的度这个概念也很好理解，其实就是指某个顶点衍生出来边的个数，咱们也就成为当前顶点的度。

### 子图

### 路径
从某个顶点到另外一个顶点所经过的顶点顺序咱们称之为路径。

### 环
从一个顶点出发最后经过一大堆路径又回到本身，就像是在玩迷宫游戏一样，最后兜兜转转又回到原地。

### 无向图 （Undirected Graph）
无向图（Undirected Graph），也称为无向图形，是一种图的类型，其中图中的边没有方向。在无向图中，边连接两个顶点，表示两个顶点之间的关系或连接，但没有指定从一个顶点到另一个顶点的单向性。

无向图可以看作是由无序的边集和顶点集组成的集合。每条边连接两个顶点，而两个顶点之间存在双向通行的能力。例如，如果存在一条边连接顶点A和顶点B，则可以从A到B，同时也可以从B到A。

无向图在许多情况下都有实际应用，如社交网络中的人际关系、计算机网络中的通信连接以及地图中的道路网络等。

无向图可以用多种方式表示，包括邻接矩阵和邻接表。对于无向图的算法和遍历，可以直接应用深度优先搜索（DFS）和广度优先搜索（BFS）等常用的图遍历算法。在遍历无向图时，不需要考虑边的方向性，因为边没有指定的方向。

### 有向图 （Directed Graph）
有向图（Directed Graph），也称为有向图形或有向网络，是一种图的类型，其中图中的边有方向。在有向图中，边从一个顶点指向另一个顶点，并且具有确定的方向，顶点表示图中的实体或节点，而有向边表示节点之间的有向关系或连接。

每条边从一个顶点（称为起始顶点或源顶点）指向另一个顶点（称为终止顶点或目标顶点），因此存在一个从起始顶点到终止顶点的指向性。

与有向图不同，无向图中的边没有方向，可以双向通行。有向图可以用来表示许多现实世界中的关系，如网页之间的链接、交通路线、依赖关系等。

有向图可以用多种方式表示，包括邻接矩阵和邻接表。对于有向图的算法和遍历，需要考虑边的方向性。例如，深度优先搜索（DFS）和广度优先搜索（BFS）算法可以应用于有向图，但在遍历时需注意边的方向以防止形成死循环。

### 连通图
每个顶点都能通过直接或间接的方式访问到的情况我们称之为连通图。

### 连通子图
在一幅图中，可能整幅图并不具备连通图的条件，但是它的某子图一定满足连通图的条件，此时我们称之为整幅图的连通子图。

## 各种图定义
### 无向边
若顶点vi到vj之间的边没有方向，则称这条边为无向边（Edge），用无序偶对（vi,vj）来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）。

例如： 无向图，由于是无方向的，连接顶点A与D的边，可以表示成无序对（A,D），也可以写成（D,A）。

无向图G1来说，G1=（V1,{E1}），其中顶点集合V1={A,B,C,D}；边集合E1={（A,B）,（B,C）,（C,D）,（D,A）,（A,C）}

### 有向边
若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧（Arc）。用有序偶<vi, vj>来表示，vi称为弧尾（Tail），vj称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）。

例如：有向图。连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，<A，D>表示弧，注意不能写成<D，A>。

有向图G2来说，G2=（V2,{E2}），其中顶点集合V2={A,B,C,D}；弧集合E2={<A,D>,<B,A>,<C,A>,<B,C>}。

看清楚了，无向边用小括号“（）”表示，而有向边则是用尖括号“<>”表示。

在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。

在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有条n*(n-1)/2条边。

在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n×（n－1）条边。

从这里也可以得到结论，对于具有n个顶点和e条边数的图，无向图0≤e≤n（n －1）/2，有向图0≤e≤n（n－1）。

有很少条边或弧的图称为稀疏图，反之称为稠密图。这里稀疏和稠密是模糊的概念，都是相对而言的。比如我去上海世博会那天，参观的人数差不多50万人，我个人感觉人数实在是太多，可以用稠密来形容。可后来听说，世博园里人数最多的一天达到了103万人，啊，50万人是多么的稀疏呀。

有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight）。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网（Network）。

假设有两个图G=（V,{E}）和G’=（V’,{E’}），如果V’⊆V且E’⊆E，则称G’为G的子图（Subgraph）。

## 图的顶点与边间关系
对于无向图G=（V,{E}），如果边（v,v’）∈E，则称顶点v和v’互为邻接点（Adjacent），即v和v’相邻接。边（v,v’）依附（incident）于顶点v和v’，或者说（v,v’）与顶点v和v’相关联。顶点v的度（Degree）是和v相关联的边的数目，记为TD（v）。

对于有向图G=（V,{E}），如果弧<v,v’>∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧<v,v’>和顶点v，v’相关联。以顶点v为头的弧的数目称为v的入度（InDegree），记为ID（v）；以v为尾的弧的数目称为v的出度（OutDegree），记为OD（v）；顶点v的度为TD（v）=ID（v）+OD（v）。

无向图G=（V,{E}）中从顶点v到顶点v’的路径（Path）是一个顶点序列（v=vi,0,vi,1,…,vi,m=v’），其中（vi,j-1,vi,j）∈E，1≤j≤m。

如果G是有向图，则路径也是有向的，顶点序列应满足<vi,j-1,vi,j>∈E，1≤j≤m。

路径的长度是路径上的边或弧的数目。

第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点vi、vj∈E，vi和vj都是连通的，则称G是连通图（Connected Graph）。

无向图中的极大连通子图称为连通分量。注意连通分量的概念，它强调：
- 要是子图；
- 子图要是连通的；
- 连通子图含有极大顶点数；
- 具有极大顶点数的连通子图包含依附于这些顶点的所有边。

在有向图G中，如果对于每一对vi、vj∈V、vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。

如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。对有向树的理解比较容易，所谓入度为0其实就相当于树中的根结点，其余顶点入度为1就是说树的非根结点的双亲只有一个。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

## 图的定义与术语总结
术语终于介绍得差不多了，可能有不少同学有些头晕，我们再来整理一下。

图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分。

图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。

图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。

图上的边或弧上带权则称为网。

图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。

无向图中连通且n个顶点n－1条边叫生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。

## 图的抽象数据类型
图作为一种数据结构，它的抽象数据类型带有自己特点，正因为它的复杂，运用广泛，使得不同的应用需要不同的运算集合，构成不同的抽象数据操作。我们这里就来看看图的基本操作。
```
ADT   图(Graph)
Data  顶点的有穷非空集合和顶点之间边的集合
Operation 
      
```

## 图的存储结构
图的存储结构相较线性表与树来说就更加复杂了。首先，我们口头上说的“顶点的位置”或“邻接点的位置”只是一个相对的概念。其实从图的逻辑结构定义来看，图上任何一个顶点都可被看成是第一个顶点，任一顶点的邻接点之间也不存在次序关系。

也正由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。而多重链表的方式，即以一个数据域和多个指针域组成的结点表示图中的一个顶点，尽管可以实现图结构，但其实在树中，我们也已经讨论过，这是有问题的。如果各个顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很多存储单元的浪费，而若按每个顶点自己的度数设计不同的顶点结构，又带来操作的不便。因此，对于图来说，如何对它实现物理存储是个难题，不过我们的前辈们已经解决了，现在我们来看前辈们提供的五种不同的存储结构。

### 邻接矩阵
考虑到图是由顶点和边或弧两部分组成。合在一起比较困难，那就很自然地考虑到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。于是我们的邻接矩阵的方案就诞生了。

图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。

设图G有n个顶点，则邻接矩阵是一个n×n的方阵。

那么邻接矩阵是如何实现图的创建的呢？我们先来看看图的邻接矩阵存储的结构，代码如下。
```
    typedef char VertexType;                  /* 顶点类型应由用户定义 */
    typedef int EdgeType;                     /* 边上的权值类型应由用户定义 */
    #define MAXVEX 100                        /* 最大顶点数，应由用户定义 */
    #define INFINITY 65535                    /* 用65535来代表∞ */
    typedef struct
    {
        VertexType vexs[MAXVEX];              /* 顶点表 */
        EdgeType arc[MAXVEX][MAXVEX];         /* 邻接矩阵，可看作边表 */
        int numVertexes, numEdges;            /* 图中当前的顶点数和边数 */
    }MGraph;
```

### 邻接表
邻接矩阵是不错的一种图存储结构，但是我们也发现，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。

因此我们考虑另外一种存储结构方式。回忆我们在线性表时谈到，顺序存储结构就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。

再回忆我们在树中谈存储结构时，讲到了一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间浪费问题。这个思路同样适用于图的存储。我们把这种数组与链表相结合的存储方法称为邻接表（Adjacency List）。

邻接表的处理办法是这样。
- 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。
- 图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。

有了这些结构的图，下面关于结点定义的代码就很好理解了。
```
    typedef char VertexType;       /* 顶点类型应由用户定义 */
    typedef int EdgeType;          /* 边上的权值类型应由用户定义 */

    typedef struct EdgeNode        /* 边表结点 */
    {
        int adjvex;                /* 邻接点域，存储该顶点对应的下标 */
        EdgeType weight;           /* 用于存储权值，对于非网图可以不需要 */
        struct EdgeNode *next;     /* 链域，指向下一个邻接点   */
    }EdgeNode;

    typedef struct VertexNode      /* 顶点表结点 */
    {
        VertexType data;           /* 顶点域，存储顶点信息*/
        EdgeNode *firstedge;       /* 边表头指针 */
    }VertexNode, AdjList[MAXVEX];

    typedef struct
    {
        AdjList adjList;
        int numVertexes,numEdges; /* 图中当前顶点数和边数 */
    }GraphAdjList;
```

### 邻接表实现
邻接表是一种表示图的数据结构，其中每个顶点都与其相邻顶点列表相关联。以下是一个示表表示：

顶点1: 2, 3, 4
顶点2: 1, 3
顶点3: 1, 2, 4
顶点4: 1, 3

在这个示例中，图由四个顶点组成。顶点1与顶点2、3、4相邻，顶点2与顶点1、3相邻，以此类推。邻接表，我们可以轻松地查找每个顶点的相邻顶点列表。

### 十字链表
那么对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。有没有可能把邻接表与逆邻接表结合起来呢？答案是肯定的，就是把它们整合在一起。这就是我们现在要讲的有向图的一种存储方法：十字链表（Orthogonal List）。

十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。

### 邻接多重表
讲了有向图的优化存储结构，对于无向图的邻接表，有没有问题呢？如果我们在无向图的应用中，关注的重点是顶点，那么邻接表是不错的选择，但如果我们更关注边的操作，比如对已访问过的边做标记，删除某一条边等操作，那就意味着，需要找到这条边的两个边表结点进行操作，这其实还是比较麻烦的。

## 图的遍历
图的遍历是和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）。

图就复杂多了，因为它的任一顶点都可能和其余的所有顶点相邻接，极有可能存在沿着某条路径搜索后，又回到原顶点，而有些顶点却还没有遍历到的情况。因此我们需要在遍历过程中把访问过的顶点打上标记，以避免访问多次而不自知。具体办法是设置一个访问数组visited[n]，n是图中顶点的个数，初值为0，访问过后设置为1。这其实在小说中常常见到，一行人在迷宫中迷了路，为了避免找寻出路时屡次重复，所以会在路口用小刀刻上标记。

对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：它们是深度优先遍历和广度优先遍历。

### 深度优先遍历
深度优先遍历（Depth_First_Search），也有称为深度优先搜索，简称为DFS。它的具体思想就如同我刚才提到的找钥匙方案，无论从哪一间房间开始都可以，比如主卧室，然后从房间的一个角开始，将房间内的墙角、床头柜、床上、床下、衣柜里、衣柜上、前面的电视柜等挨个寻找，做到不放过任何一个死角，所有的抽屉、储藏柜中全部都找遍，形象比喻就是翻个底朝天，然后再寻找下一间，直到找到为止。

它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。事实上，我们这里讲到的是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

DFS（Depth-First Search）即深度优先搜索，是一种用于图和树的遍历算法。它通过尽可能深地探索图的分支直到无法继续为止，然后回溯到上一个未完全探索的节点，继续探索其他分支。

以下是使用DFS算法遍历图的示例代码：
```java
import java.util.*;

// 图的顶点类
class GraphNode {
    int val;
    List<GraphNode> neighbors;

    public GraphNode(int val) {
        this.val = val;
        this.neighbors = new ArrayList<>();
    }
}

public class DFS {
    private Set<GraphNode> visited; // 用于记录访问过的顶点

    public DFS() {
        this.visited = new HashSet<>();
    }

    // 图的深度优先搜索
    public void depthFirstSearch(GraphNode node) {
        if (visited.contains(node)) {
            return;
        }

        visited.add(node);
        System.out.print(node.val + " ");

        for (GraphNode neighbor : node.neighbors) {
            depthFirstSearch(neighbor);
        }
    }

    public static void main(String[] args) {
        // 创建图的顶点
        GraphNode node1 = new GraphNode(1);
        GraphNode node2 = new GraphNode(2);
        GraphNode node3 = new GraphNode(3);
        GraphNode node4 = new GraphNode(4);

        // 设置顶点之间的关系
        node1.neighbors.add(node2);
        node1.neighbors.add(node3);
        node2.neighbors.add(node3);
        node3.neighbors.add(node4);

        DFS dfs = new DFS();
        dfs.depthFirstSearch(node1);
    }
}
```
在这个示例中，我们创建了一个有向图，并使用GraphNode类表示图的顶点。DFS类实现了深度优先搜索算法，其中depthFirstSearch方法接收一个图的顶点作为输入，并通过递归方式深度遍历与该顶点直接相连的顶点，并打印它们的值。

在main方法中，我们创建了一个有向图，并设置了顶点之间的关系。然后创建DFS对象并调用depthFirstSearch方法，从图的始顶点开始进行深度优先搜索。

### 广度优先遍历
广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。还是以找钥匙的例子为例。小孩子不太可能把钥匙丢到大衣柜顶上或厨房的油烟机里去，深度优先遍历意味着要彻底查找完一个房间才查找下一个房间，这未必是最佳方案。所以不妨先把家里的所有房间简单看一遍，看看钥匙是不是就放在很显眼的位置，如果全走一遍没有，再把小孩在每个房间玩得最多的地方或各个家俱的下面找一找，如果还是没有，那看一下每个房间的抽屉，这样一步步扩大查找的范围，直到找到为止。事实上，我在全屋查找的第二遍时就在抽水马桶后面的地板上找到了。

## 最小生成树
我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）。

找连通网的最小生成树，经典的有两种算法，普里姆算法和克鲁斯卡尔算法。我们就分别来介绍一下。

### 普里姆算法

## 最短路径
在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。

## 关键路径
我们如果要对一个流程图获得最短时间，就必须要分析它们的拓扑关系，并且找到当中最关键的流程，这个流程的时间就是最短时间。

在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网（Activity On Edge Network）。我们把AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。由于一个工程，总有一个开始，一个结束，所以正常情况下，AOE网只有一个源点一个汇点。

## 总结回顾
图是计算机科学中非常常用的一类数据结构，有许许多多的计算问题都是用图来定义的。由于图也是最复杂的数据结构，对它讲解时，涉及到数组、链表、栈、队列、树等之前学的几乎所有数据结构。因此从某种角度来说，学好了图，基本就等于理解了数据结构这门课的精神。

我们在图的定义这一节，介绍了一大堆定义和术语，一开始可能会有些迷茫，不过一回生二回熟，多读几遍，基本都可以理解并记住它们的特征，在图的定义这一节的末尾，我们已经有所总结，这里就不再赘述了。

图的存储结构我们一共讲了五种，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。

图的遍历分为深度和广度两种，各有优缺点，就像人在追求卓越时，是着重深度还是看重广度，总是很难说得清楚。

图的应用是我们这一章浓墨重彩的一部分，一共谈了三种应用：最小生成树、最短路径和有向无环图的应用。

最小生成树，我们讲了两种算法：普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。

最短路径的现实应用非常多，我们也介绍了两种算法。迪杰斯特拉（Dijkstra）算法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算法代码相对复杂。而弗洛伊德（Floyd）算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解有难度，但算法编写很简洁。

有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心的是工程能否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析出一个有向图是否存在环，如果不存在，那它的拓扑序列是什么？另一方面关心的是整个工程完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。


# 参考资料
大厂必备技能：数据结构图[http://www.ai2news.com/blog/2759898/]


