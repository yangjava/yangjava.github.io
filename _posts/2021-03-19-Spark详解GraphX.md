---
layout: post
categories: [Spark]
description: none
keywords: Spark
---
# Spark详解GraphX
Spark GraphX是一个新的Spark API，它用于图和分布式图(graph-parallel)的计算。GraphX 综合了 Pregel 和 GraphLab 两者的优点，即接口相对简单，又保证性能，可以应对点分割的图存储模式，胜任符合幂律分布的自然图的大型计算。

## 图切分
图的切分总体上说有点切分和边切分两种方式。
- 点切分
通过点切分之后，每条边只保存一次，并且出现在同一台机器上。邻居多的点会被分发到不同的节点上，增加了存储空间，并且有可能产生同步问题。但是，它的优点是减少了网络通信。

- 边切分
通过边切分之后，顶点只保存一次，切断的边会打断保存在两台机器上。在基于边的操作时，对于两个顶点分到两个不同的机器的边来说，需要进行网络传输数据。这增加了网络传输的数据量，但好处是节约了存储空间。

以上两种切分方式虽然各有优缺点，但是点切分还是占有优势。GraphX以及后文提到的Pregel、GraphLab都使用到了点切分。

## BSP模型特点
在BSP中，一次计算过程由一系列全局超步组成，每一个超步由并发计算、通信和同步三个步骤组成。同步完成，标志着这个超步的完成及下一个超步的开始。BSP模式的准则是批量同步(bulk synchrony)，其独特之处在于超步(superstep)概念的引入。

一个BSP程序同时具有水平和垂直两个方面的结构。从垂直上看,一个BSP程序由一系列串行的超步(superstep)组成。
从水平上看，在一个超步中，所有的进程并行执行局部计算。一个超步可分为三个阶段：
- 本地计算阶段，每个处理器只对存储在本地内存中的数据进行本地计算；
- 全局通信阶段，对任何非本地数据进行操作；
- 栅栏同步阶段，等待所有通信行为的结束。

BSP模型有如下几个特点：
- 1 将计算划分为一个一个的超步(superstep)，有效避免死锁;
- 2 将处理器和路由器分开，强调了计算任务和通信任务的分开，而路由器仅仅完成点到点的消息传递，不提供组合、复制和广播等功能，这样做既掩盖具体的互连网络拓扑，又简化了通信协议；
- 3 采用障碍同步的方式、以硬件实现的全局同步是可控的粗粒度级，提供了执行紧耦合同步式并行算法的有效方式。

## 图计算框架

### Pregel
Pregel是一种面向图算法的分布式编程框架，采用迭代的计算模型：在每一轮，每个顶点处理上一轮收到的消息，并发出消息给其它顶点，并更新自身状态和拓扑结构（出、入边）等。

在Pregel计算模式中，输入是一个有向图，该有向图的每一个顶点都有一个相应的由字符串描述的vertex identifier。每一个顶点都有一些属性，这些属性可以被修改，其初始值由用户定义。 每一条有向边都和其源顶点关联，并且也拥有一些用户定义的属性和值，并同时还记录了其目的顶点的ID。

一个典型的Pregel计算过程如下：读取输入，初始化该图，当图被初始化好后，运行一系列的超步，每一次超步都在全局的角度上独立运行，直到整个计算结束，输出结果。在每一次超步中，顶点的计算都是并行的，并且执行用户定义的同一个函数。每个顶点可以修改其自身的状态信息或以它为起点的出边的信息，从前序超步中接受消息，并传送给其后续超步，或者修改整个图的拓扑结构。边，在这种计算模式中并不是核心对象，没有相应的计算运行在其上。算法是否能够结束取决于是否所有的顶点都已经vote标识其自身已经达到halt状态了。在superstep 0中，所有顶点都置于active状态，每一个active的顶点都会在计算的执行中在某一次的superstep中被计算。顶点通过将其自身的状态设置成halt来表示它已经不再active。这就表示该顶点没有进一步的计算需要进行，除非被其他的运算触发，而Pregel框架将不会在接下来的superstep中计算该顶点，除非该顶点收到一个其他superstep传送的消息。如果顶点接收到消息，该消息将该顶点重新置active，那么在随后的计算中该顶点必须再次deactive其自身。整个计算在所有顶点都达到inactive状态，并且没有消息在传送的时候宣告结束。

Pregel选择了一种纯消息传递的模式，忽略远程数据读取和其他共享内存的方式，这样做有两个原因。第一，消息的传递有足够高效的表达能力，不需要远程读取（remote reads）。第二，性能的考虑。在一个集群环境中，从远程机器上读取一个值是会有很高的延迟的，这种情况很难避免。而消息传递模式通过异步和批量的方式传递消息，可以缓解这种远程读取的延迟。图算法其实也可以被写成是一系列的链式MapReduce作业。选择不同的模式的原因在于可用性和性能。Pregel将顶点和边在本地机器进行运算，而仅仅利用网络来传输信息，而不是传输数据。而MapReduce本质上是面向函数的，所以将图算法用MapReduce来实现就需要将整个图的状态从一个阶段传输到另外一个阶段，这样就需要许多的通信和随之而来的序列化和反序列化的开销。另外，在一连串的MapReduce作业中各阶段需要协同工作也给编程增加了难度，这样的情况能够在Pregel的各轮超步的迭代中避免。这个模型虽然简单，但是缺陷明显，那就是对于邻居数很多的顶点，它需要处理的消息非常庞大，而且在这个模式下，它们是无法被并发处理的。所以对于符合幂律分布的自然图，这种计算模型下很容易发生假死或者崩溃。

### GraphLab
GraphLab将数据抽象成Graph结构，将基于顶点切分的算法的执行过程抽象成Gather、Apply、Scatter三个步骤。

需要完成对邻接顶点的求和计算，串行实现中，对其所有的邻接点进行遍历，累加求和。而GraphLab中，将顶点进行切分，将的边关系以及对应的邻接点部署在两台处理器上，各台机器上并行进行部分求和运算，然后通过master顶点和mirror顶点的通信完成最终的计算。对于分割的某个顶点，它会被部署到多台机器，一台机器作为master顶点，其余机器作为mirror。master作为所有mirror的管理者，负责给mirror安排具体计算任务;mirror作为该顶点在各台机器上的代理执行者，与master数据的保持同步。对于某条边，GraphLab将其唯一部署在某一台机器上，而对边关联的顶点进行多份存储，解决了边数据量大的问题。同一台机器上的所有顶点和边构成一个本地图（local graph）,在每台机器上，存在一份本地id到全局id的映射表。顶点是一个进程上所有线程共享的，在并行计算过程中，各个线程分摊进程中所有顶点的gather->apply->scatter操作。

执行过程：每个顶点每一轮迭代会经过gather -> apple -> scatter三个阶段。Gather阶段，工作顶点的边从连接顶点和自身收集数据。这一阶段对工作顶点、边都是只读的。Apply阶段，mirror将gather阶段计算的结果发送给master顶点，master进行汇总并结合上一步的顶点数据，按照业务需求进行进一步的计算，然后更新master的顶点数据，并同步给mirror。Apply阶段中，工作顶点可修改，边不可修改。Scatter阶段，工作顶点更新完成之后，更新边上的数据，并通知对其有依赖的邻结顶点更新状态。在scatter过程中，工作顶点只读，边上数据可写。在执行模型中，GraphLab通过控制三个阶段的读写权限来达到互斥的目的。在gather阶段只读，apply对顶点只写，scatter对边只写。并行计算的同步通过master和mirror来实现，mirror相当于每个顶点对外的一个接口人，将复杂的数据通信抽象成顶点的行为。

## GraphX
GraphX也是基于BSP模式。GraphX公开了一个类似Pregel的操作，它是广泛使用的Pregel和GraphLab抽象的一个融合。在GraphX中，Pregel操作者执行一系列的超步，在这些超步中，顶点从之前的超步中接收进入(inbound)消息，为顶点属性计算一个新的值，然后在以后的超步中发送消息到邻居顶点。不像Pregel而更像GraphLab，消息通过边triplet的一个函数被并行计算，消息的计算既会访问源顶点特征也会访问目的顶点特征。在超步中，没有收到消息的顶点会被跳过。当没有消息遗留时，Pregel操作停止迭代并返回最终的图。

### 点分割存储
GraphX借鉴powerGraph，使用的是点分割方式存储图。这种存储方式特点是任何一条边只会出现在一台机器上，每个点有可能分布到不同的机器上。当点被分割到不同机器上时，是相同的镜像，但是有一个点作为主点,其他的点作为虚点，当点的数据发生变化时,先更新主点的数据，然后将所有更新好的数据发送到虚点所在的所有机器，更新虚点。这样做的好处是在边的存储上是没有冗余的，而且对于某个点与它的邻居的交互操作，只要满足交换律和结合律，就可以在不同的机器上面执行，网络开销较小。

但是这种分割方式会存储多份点数据，更新点时，会发生网络传输，并且有可能出现同步问题。GraphX在进行图分割时，有几种不同的分区(partition)策略，它通过PartitionStrategy专门定义这些策略。在PartitionStrategy中，总共定义了EdgePartition2D，EdgePartition1D，RandomVertexCut以及CanonicalRandomVertexCut这四种不同的分区策略。

## 图运算操作

### 转换操作
GraphX中的转换操作主要有mapVertices,mapEdges和mapTriplets三个，它们在Graph文件中定义，在GraphImpl文件中实现。

### 结构操作
当前的GraphX仅仅支持一组简单的常用结构性操作：reverse操作返回一个新的图，这个图的边的方向都是反转的；subgraph操作利用顶点和边的判断式（predicates），返回的图仅仅包含满足顶点判断式的顶点、满足边判断式的边以及满足顶点判断式的triple；mask操作构造一个子图，这个子图包含输入图中包含的顶点和边。它的实现很简单，顶点和边均做inner join操作即可。这个操作可以和subgraph操作相结合，基于另外一个相关图的特征去约束一个图；groupEdges操作合并多重图中的并行边(如顶点对之间重复的边)。在大量的应用程序中，并行的边可以合并（它们的权重合并）为一条边从而降低图的大小。

### 关联操作
在许多情况下，有必要将外部数据加入到图中。例如，有额外的用户属性需要合并到已有的图中或者从一个图中取出顶点特征加入到另外一个图中。这些任务可以用join操作完成。joinVertices操作join输入RDD和顶点，返回一个新的带有顶点特征的图。这些特征是通过在连接顶点的结果上使用用户定义的map函数获得的。没有匹配的顶点保留其原始值。主要有joinVertices和outerJoinVertices两种。

### 聚合操作
GraphX中提供的聚合操作有aggregateMessages、collectNeighborIds和collectNeighbors三个，其中aggregateMessages在GraphImpl中实现，collectNeighborIds和collectNeighbors在GraphOps中实现。aggregateMessages是GraphX最重要的API，用于替换mapReduceTriplets。目前mapReduceTriplets最终也是通过aggregateMessages来实现的。它主要功能是向邻边发消息，合并邻边收到的消息，返回messageRDD；aggregateMessages方法分为Map和Reduce两个阶段；collectNeighbors方法的作用是收集每个顶点的邻居顶点的顶点id和顶点属性；collectNeighborIds方法的作用是收集每个顶点的邻居顶点的顶点id。它的实现和collectNeighbors非常相同。

### 缓存操作
在Spark中，RDD默认是不缓存的。为了避免重复计算，当需要多次利用它们时，我们必须显示地缓存它们。GraphX中的图也有相同的方式。当利用到图多次时，确保首先访问Graph.cache()方法。GraphX中的缓存操作有cache,persist,unpersist和unpersistVertices。

## Pregel API
图本身是递归数据结构，顶点的属性依赖于它们邻居的属性，这些邻居的属性又依赖于自己邻居的属性。所以许多重要的图算法都是迭代的重新计算每个顶点的属性，直到满足某个确定的条件。一系列的图并发(graph- parallel)抽象已经被提出来用来表达这些迭代算法。GraphX公开了一个类似Pregel的操作，它是广泛使用的Pregel和GraphLab抽象的一个融合。

GraphX中实现的这个更高级的Pregel操作是一个约束到图拓扑的批量同步（bulk- synchronous）并行消息抽象。Pregel操作者执行一系列的超步（super steps），在这些步骤中，顶点从之前的超步中接收进入(inbound)消息的总和，为顶点属性计算一个新的值，然后在以后的超步中发送消息到邻居顶点。不像Pregel而更像GraphLab，消息通过边triplet的一个函数被并行计算，消息的计算既会访问源顶点特征也会访问目的顶点特征。在超步中，没有收到消息的顶点会被跳过。当没有消息遗留时，Pregel操作停止迭代并返回最终的图。注意，与标准的Pregel实现不同的是，GraphX中的顶点仅仅能发送信息给邻居顶点，并且可以利用用户自定义的消息函数并行地构造消息。这些限制允许对GraphX进行额外的优化。

Pregel计算模型中有三个重要的函数，分别是vertexProgram，sendMessage和messageCombiner。其中，vertexProgram：用户定义的顶点运行程序。它作用于每一个顶点，负责接收进来的信息，并计算新的顶点值；sendMsg：发送消息；mergeMsg：合并消息