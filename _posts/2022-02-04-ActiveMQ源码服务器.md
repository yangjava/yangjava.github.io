---
layout: post
categories: [MQ,ActiveMQ]
description: none
keywords: MQ,ActiveMQ
---
# ActiveMQ源码服务器

## 嵌入式Broker
用ActiveMQ Broker作为独立的消息服务器来构建java应用。ActiveMQ也支持在虚拟机中通信，基于嵌入式的broker，能够无缝的集成其他java应用

### pom.xml中引入包
```xml
  <!--activemq-->
    <dependency>
      <groupId>org.apache.activemq</groupId>
      <artifactId>activemq-all</artifactId>
      <version>5.15.9</version>
    </dependency>
    <!--fastjson-->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.9</version>
    </dependency>
```
broker代码
```
import org.apache.activemq.broker.BrokerService;

/**
 */
public class EmbedBroker {
    public static void main(String[] args) throws Exception {
        //ActiveMQ也支持在虚拟机中通信,嵌入broker
        BrokerService brokerService=new BrokerService();
        //将activeMQ嵌入到java程序中
        brokerService.setUseJmx(true);
        //现在是将activeMQ嵌入到java程序中，所以使用本机
        brokerService.addConnector("tcp://127.0.0.1:61616");
        // true表示开启持久化
        brokerService.setPersistent(true);
        //启动程序
        brokerService.start();
        // 主线程await，直到brokerService状态是stop
        brokerService.waitUntilStopped();
    }

}
```

## 持久化机制
为了避免意外宕机以后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会采用持久化机制

ActiveMQ持久化机制有：JDBC、AMQ、KahaDB和LevelDB，无论哪种持久化方式，消息的存储逻辑都是一致的。

就是在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等再试图将消息发送给接收者，成功则将消息从内存中删除，失败则继续尝试发送。

消息中心启动后首先要检查指定位置，如果有未发送成功的消息，则需要把消息发送出去。

## 存储原理
正常情况下，非持久化消息是存储在内存中的，持久化消息是存储在文件中的。能够存储的最大消息数据在${ActiveMQ_HOME}/conf/activemq.xml文件中的systemUsage节点SystemUsage配置设置了一些系统内存和硬盘容量
```xml
		<systemUsage>
            <systemUsage>
                <memoryUsage>
            //该子标记设置整个ActiveMQ节点的“可用内存限制”。这个值不能超过ActiveMQ本身设置的最大内存大小。其中的percentOfJvmHeap属性表示百分比。占用70%的堆内存
                    <memoryUsage percentOfJvmHeap="70" />
                </memoryUsage>
                <storeUsage>
            //该标记设置整个ActiveMQ节点，用于存储“持久化消息”的“可用磁盘空间”。该子标记的limit属性必须要进行设置
                    <storeUsage limit="100 gb"/>
                </storeUsage>
                <tempUsage>
            //一旦ActiveMQ服务节点存储的消息达到了memoryUsage的限制，非持久化消息就会被转储到 temp store区域，虽然我们说过非持久化消息不进行持久化存储，但是ActiveMQ为了防止“数据洪峰”出现时非持久化消息大量堆积致使内存耗尽的情况出现，还是会将非持久化消息写入到磁盘的临时区域——temp store。这个子标记就是为了设置这个tempstore区域的“可用磁盘空间限制”
                    <tempUsage limit="50 gb"/>
                </tempUsage>
            </systemUsage>
        </systemUsage>
```
从上面的配置我们需要get到一个结论，当非持久化消息堆积到一定程度的时候，也就是内存超过指定的设置阀值时，ActiveMQ会将内存中的非持久化消息写入到临时文件，以便腾出内存。但是它和持久化消息的区别是，重启之后，持久化消息会从文件中恢复，非持久化的临时文件会直接删除

## 消息的持久化策略分析
消息持久性对于可靠消息传递来说是一种比较好的方法，即时发送者和接受者不是同时在线或者消息中心在发送者发送消息后宕机了，在消息中心重启后仍然可以将消息发送出去。消息持久性的原理很简单，就是在发送消息出去后，消息中心首先将消息存储在本地文件、内存或者远程数据库，然后把消息发送给接受者，发送成功后再把消息从存储中删除，失败则继续尝试。接下来我们来了解一下消息在broker上的持久化存储实现方式

## 持久化存储支持类型
ActiveMQ支持多种不同的持久化方式，主要有以下几种，不过，无论使用哪种持久化方式，消息的存储逻辑都是一致的。
- KahaDB存储（默认存储方式）
- JDBC存储
- Memory存储
- LevelDB存储
- JDBC With ActiveMQ Journal
- AMQ Message Store

## AMQ Message Store
基于文件存储方式，以前默认的消息存储方式，现在基本不用。AMQ是一种文件存储形式，它具有写入速度快和容易恢复的特点。消息存储在一个一个文件当中，文件默认大小为32M，当一个存储文件被全部消费，那么这个文件会被标识为可删除，在下一个清除阶段被删除

## KahaDB存储
KahaDB是目前默认的存储方式,可用于任何场景,提高了性能和恢复能力。消息存储使用一个事务日志和仅仅用一个 索引文件来存储它所有的地址。

KahaDB是一个专门针对消息持久化的解决方案,它对典型的消息使用模式进行了优化。在Kaha中,数据被追加到 data logs中。当不再需要log文件中的数据的时候,log文件会被丢弃。

KahaDB的配置方式
```xml
    <persistenceAdapter>
        <kahaDB directory="${activemq.data}/kahadb"/>
    </persistenceAdapter>
```

### KahaDB的存储原理
在data/kahadb这个目录下，会生成四个文件
- db.data 它是消息的索引文件，本质上是B-Tree（B树），使用B-Tree作为索引指向db-.log里面存储的消息
- db.redo 用来进行消息恢复
- db-.log 存储消息内容。新的数据以APPEND的方式追加到日志文件末尾。属于顺序写入，因此消息存储是比较快的。默认是32M，达到阀值会自动递增
- lock文件 锁，表示当前获得kahadb读写权限的broker

## JDBC存储
使用JDBC持久化方式，数据库会创建3个表：activemq_msgs，activemq_acks和activemq_lock。
- ACTIVEMQ_MSGS 消息表，queue和topic都存在这个表中
- ACTIVEMQ_ACKS 存储持久订阅的信息和最后一个持久订阅接收的消息ID
- ACTIVEMQ_LOCKS 锁表，用来确保某一时刻，只能有一个ActiveMQ broker实例来访问数据库

### JDBC存储实践
```xml
<persistenceAdapter>
	<jdbcPersistenceAdapter dataSource="# MySQL-DS " createTablesOnStartup="true" />
</persistenceAdapter>
```
dataSource指定持久化数据库的bean，createTablesOnStartup是否在启动的时候创建数据表，默认值是true，这样每次启动都会去创建数据表了，一般是第一次启动的时候设置为true，之后改成false

### Mysql持久化Bean配置
```xml
<bean id="Mysql-DS" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
	<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
	<property name="url" value="jdbc:mysql://192.168.11.156:3306/activemq?relaxAutoCommit=true"/>
	<property name="username" value="root"/>
	<property name="password" value="root"/>
</bean>
```
添加Jar包依赖 放在lib目录下

## LevelDB存储
LevelDB持久化性能高于KahaDB，虽然目前默认的持久化方式仍然是KahaDB。并且，在ActiveMQ 5.9版本提供了基于LevelDB和Zookeeper的数据复制方式，用于Master-slave方式的首选数据复制方案。
不过，据ActiveMQ官网对LevelDB的表述：LevelDB官方建议使用以及不再支持，推荐使用的是KahaDB
```
<persistenceAdapter>
	<levelDBdirectory="activemq-data"/>
</persistenceAdapter>
```

## Memory 消息存储
基于内存的消息存储，内存消息存储主要是存储所有的持久化的消息在内存中。broker标签 persistent=”false”,表示不设置持久化存储，直接存储到内存中
```xml
<beans>
	<broker brokerName="test-broker" persistent="false" xmlns="http://activemq.apache.org/schema/core">
		<transportConnectors>
			<transportConnector uri="tcp://localhost:61635"/>
		</transportConnectors> 
    </broker>
</beans>
```

## JDBC Message store with ActiveMQ Journal
这种方式克服了JDBC Store的不足，JDBC每次消息过来，都需要去写库和读库。
ActiveMQ Journal，使用高速缓存写入技术，大大提高了性能。
当消费者的消费速度能够及时跟上生产者消息的生产速度时，journal文件能够大大减少需要写入到DB中的消息。举个例子，生产者生产了1000条消息，这1000条消息会保存到journal文件，如果消费者的消费速度很快的情况下，在journal文件还没有同步到DB之前，消费者已经消费了90%的以上的消息，那么这个时候只需要同步剩余的10%的消息到DB。
如果消费者的消费速度很慢，这个时候journal文件可以使消息以批量方式写到DB。

配置方法：
将原来的标签注释掉
添加如下标签
```xml
<persistenceFactory>
	<journalPersistenceAdapterFactory dataSource="#Mysql-DS" dataDirectory="activemq-data"/>
</persistenceFactory>
```
在服务端循环发送消息。可以看到数据是延迟同步到数据库的

## 源码解析
addConnector
构建了BrokerService对象，第4行addConnector构建了连接器，该方法创建了TransportConnector并添加到BrokerService中。
```
 public TransportConnector addConnector(URI bindAddress) throws Exception {
 　　return addConnector(createTransportConnector(bindAddress));
 }
```
进入createTransportConnector方法，构造TransportConnector之前通过共产构建了TransportServer
```
 protected TransportConnector createTransportConnector(URI brokerURI) throws Exception {
     TransportServer transport = TransportFactorySupport.bind(this, brokerURI);
     return new TransportConnector(transport);
 }
```
再进入bind方法，选择了TransportFactory并调用其doBind方法完成TransportServer的创建。比如HttpTransportServer由HttpTransportFactory来创建。
```
  public static TransportServer bind(BrokerService brokerService, URI location) throws IOException {
      TransportFactory tf = TransportFactory.findTransportFactory(location); // 根据schema找到factory
      if( brokerService!=null && tf instanceof BrokerServiceAware) {
          ((BrokerServiceAware)tf).setBrokerService(brokerService);
      }
      try {
          if( brokerService!=null ) {
              SslContext.setCurrentSslContext(brokerService.getSslContext());
          }
         return tf.doBind(location); // 构建Transportserver
     } finally {
         SslContext.setCurrentSslContext(null);
     }
 }
```
总的来说，addConnector方法就是创建了一个TransportConnector其中包含了TransportServer用于处理通信（比如Http通信由HttpTransportServer实现）。

start
brokerService调用start方法，进入方法，该方法核心在于启动broker

startBroker(startAsync)
```
 private void startBroker(boolean async) throws Exception {
      if (async) {
          new Thread("Broker Starting Thread") {
              @Override
              public void run() {
                  // ...
                  doStartBroker();
                  // ...
              }
         }.start();
     } else {
         doStartBroker();
     }
 }
```
跟进doStartBroker
```
 // ...
 broker = getBroker(); // 获取broker实例对象
 // ...
 broker.start(); // 启动broker, region, destination
 // ...
 startAllConnectors(); // 启动connectors连接器
 // ...
```
getBroker方法创建了Broker的实现类RegionBroker，其中包含了QueueRegion和TopicRegion等region实现。

start方法启动broker，以及启动所有region
```
 public void start() throws Exception {
     started = true; // 修改broker的状态
     // 启动region，region下的所有destination也会启动
     queueRegion.start(); // 启动queue region
     topicRegion.start(); // 启动topic region
     tempQueueRegion.start(); // 启动temp queue region
     tempTopicRegion.start(); // 启动temp topic region
     // ...
 }
```
startAllConnectors方法启动我们创建的所有TransportConnector









