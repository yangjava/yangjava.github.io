---
layout: post
categories: Spring
description: none
keywords: Spring
---
# Spring容器源码

## 执行的流程如下：
- 容器刷新前的准备工作
- 创建bean工厂
- 加载xml配置文件到bean工厂中
- 对bean工厂进行赋值
- 执行beanFactoryPostProcessors
- 注册BeanPostProcessors
- 初始化消息资源 国际化设置
- 初始化应用的多播器
- 注册监听器到多播器里面
- 实例化非懒加载的实例对象
- 事件发布

## Spring容器入口
Spring通过应用上下文（Application Context）来行使容器的工作。Spring自带了多种类型的应用上下文实现，每种都以具体的类表示。下面是常用的几个：

- AnnotationConfigApplicationContext ：从Java配置类中加载Spring应用上下文。
- AnnotationConfigWebApplicationContext ：从Java配置类中加载Spring Web应用上下文。
- ClassPathXmlApplicationContext ：从ClassPath下的XML配置文件中加载Spring应用上下文。
- FileSystemXmlApplicationContext ：从文件系统的XML配置文件中加载Spring应用上下文。
- XmlWebApplicationContext ：从Web应用中的XML配置文件中加载Spring Web应用上下文。

## Spring源码核心refresh()方法
在Spring中，refresh方法起着至关重要的作用，也是阅读源码的最合适的入口。它能够帮助Spring完成beanFactory的创建和记载、bean的加载、以及后置处理器的注册等功能。这个方法包括了整个Spring的执行流程和bean的完整生命周期。首先从new ClassPathXmlApplicationContext(“xxx.xml”)开始。
```
	public ClassPathXmlApplicationContext(
			String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
			throws BeansException {

		super(parent);
		// 设置资源路径（"xxx.xml"）
		setConfigLocations(configLocations);
		if (refresh) {
			// 直接调用refresh
			refresh();
		}
	}
```
refresh方法中层次和逻辑非常清楚，而且包含了ApplicationContext的所有功能。从bean工厂的创建到bean对象的实例化和初始化再到完成Spring容器完成加载，都能在这里找到源码。
```
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			// 初始化前的准备工作，主要是一些系统属性、环境变量的校验，比如Spring启动需要某些环境变量，可以在这个地方进行设置和校验
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			// 获取bean工厂，ConfigurableListableBeanFactory是默认的容器，在这一步会完成工厂的创建以及beanDefinition的读取
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			// 进入prepareBeanFactory前spring以及完成了对配置的解析，Spring的拓展从这里开始
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				// 留给子类覆盖做拓展，这里一般不做任何处理
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				// 调用所有的BeanFactoryPostProcessors，将结果存入参数beanFactory中
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				// 注册BeanPostProcessors，这里只是注册，真正的调用是在doGetBean中
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				// 初始化消息原，比如国际化
				initMessageSource();

				// Initialize event multicaster for this context.
				// 初始化消息广播器
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				// 留给子类类初始化其他的bean
				onRefresh();

				// Check for listener beans and register them.
				// 注册监听器
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				// 初始化剩下的单例bean，在这里才开始真正的对bean进行实例化和初始化
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				// 完成刷新，通知生命周期处理器刷新过程。
				finishRefresh();
			}
		}
	}
```
### prepareRefresh()
Spring初始化前的一些准备工作，主要是一些系统属性、环境变量的校验。设置Spring的活跃状态为以及开始时间。

设置active为true，代表当前applicationContext是活动的，可以看到对active的赋值操作是同步的，同步对象为activeMonitor，查看active的引用点，可以看到所有对 active的操作都是同步在activeMonitor下的，在调用cancelRefresh()和doClose()两个方法的时候会把它设置为false，其中cancelRefresh()代表中止refresh，doClose()则是当前applicationContext的关闭销毁方法
```
	protected void prepareRefresh() {
		// Switch to active.
		this.startupDate = System.currentTimeMillis();
		// 切换容器为可修改状态
		this.closed.set(false);
		this.active.set(true);
        
        // 确认Log记录已经开启 
		if (logger.isDebugEnabled()) {
			if (logger.isTraceEnabled()) {
				logger.trace("Refreshing " + this);
			}
			else {
				logger.debug("Refreshing " + getDisplayName());
			}
		}
        // 初始化占位符资源，该方法为空
		// Initialize any placeholder property sources in the context environment.
		initPropertySources();

        // 确认运行环境配置正确 
		// Validate that all properties marked as required are resolvable:
		// see ConfigurablePropertyResolver#setRequiredProperties
		getEnvironment().validateRequiredProperties();
        
        // 创建早期时间监听器容集合，保存早期监听器，也就是在之前已经初始化的监听器。
		// Store pre-refresh ApplicationListeners...
		if (this.earlyApplicationListeners == null) {
			this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
		}
		else {
			// Reset local application listeners to pre-refresh state.
			this.applicationListeners.clear();
			this.applicationListeners.addAll(this.earlyApplicationListeners);
		}

        // 创建早期事件集合
		// Allow for the collection of early ApplicationEvents,
		// to be published once the multicaster is available...
		this.earlyApplicationEvents = new LinkedHashSet<>();
	}
```
### obtainFreshBeanFactory()
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory() 该方法会解析所有 Spring 配置文件

初始化bean工厂，其返回的ConfigurableListableBeanFactory内部其实新建了一个DefaultListableBeanFactory(Spring默认的容器，是Spring中功能最完整、最成熟的容器)，并设置DefaultListableBeanFactory为全局变量。读取资源文件加载beanDefinition存入容器。

主要的代码是在refreshBeanFactory中，在refreshBeanFactory方法中Spring会new一个DefaultListableBeanFactory 对象，DefaultListableBeanFactory 是Spring中默认的BeanFactory，接着对这个beanFactory进行定制化处理，调用XmlBeanDefinition的loadBeanDefinitions方法从xml文件中加载所有的beanDefinition并加载到这个DefaultListableBeanFactory 中。而这个this.beanFactory = beanFactory则是将该DefaultListableBeanFactory 设置为全局变量，变成整个Spring容器默认的beanFactory。
```
	protected final void refreshBeanFactory() throws BeansException {
		// 判断是否以及存在BeanFactory，如果已经存在就销毁
		if (hasBeanFactory()) {
			destroyBeans();
			closeBeanFactory();
		}
		try {
			// 创建一个DefaultListableBeanFactory(Spring容器的基础，成熟、功能完善的容器) 为我们的Spring应用上下文对象创建我们的beanFactory
			DefaultListableBeanFactory beanFactory = createBeanFactory();
			// 为容器设置一个序列化ID
			beanFactory.setSerializationId(getId());
			// 加载我们的bean定义
			customizeBeanFactory(beanFactory);
			loadBeanDefinitions(beanFactory);
			this.beanFactory = beanFactory;
		}
		catch (IOException ex) {
			throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
		}
	}
```
留意一下beanFactoryMonitor同步标志，里面若已经存在了 就销毁beanFactory ->destroyBeans 调用了beanFactory对象的destroySingletons()方法来销毁所有单例bean;

closeBeanFactory 依旧是同步的情况下处理beanFactory属性，首先调用setSerializationId(null)，然后把beanFactory属性设置为null;

然后为我们的Spring应用上下文对象创建我们的beanFactory -> createBeanFactory() 调用该方法创建一个beanFactory对象；

customizeBeanFactory(beanFactory) -> allowBeanDefinitionOverriding 是否允许覆盖同名称的不同定义的对象，allowCircularReferences 是否允许bean之间循环引用

loadBeanDefinitions(DefaultListableBeanFactory beanFactory) -> XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); 新建一个bean定义读取类；BeanDefinitionReader 的作用是读取 Spring 配置文件中的内容，将其转换为 IoC 容器内部的数据结构：BeanDefinition。

beanDefinitionReader -> entityResolver属性为一个新的ResourceEntityResolver对象，输入参数resourceLoader为当前对象，这个数要是用来解析xml的beanDefinitionReader的validationMode以及namespaceAware，参数是当前对象的validating属性，主要用于xml校检最后一行是做了xml配置文件的读取

loadBeanDefinitions -> 有个细节是会循环加载configResources、configLocations两个里面的文件

### prepareBeanFactory(beanFactory)
对bean工厂进行填充属性。初始化beanFactory，为beanFactory设置属性，比如添加属性编辑器、对SPEL表达式的支持、Aware回调接口的处理器、忽略的依赖和注册依赖。
```
	protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		// Tell the internal bean factory to use the context's class loader etc.
		//设置bean工厂的类加载器为当前application应用的加载器
		beanFactory.setBeanClassLoader(getClassLoader());
		//为bean工厂设置我们标准的SPEL表达式解析器对象StandardBeanExpressionResolver
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
		//为我们的bean工厂设置了一个propertityEditor 属性资源编辑器对象(用于后面的给bean对象赋值使用)
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

		// Configure the bean factory with context callbacks.
		// 添加回调接口的支持 注册了一个完整的ApplicationContextAwareProcessor 后置处理器用来处理ApplicationContextAware接口的回调方法
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
		// 如果是EnvironmentAware、EmbeddedValueResolverAware等接口的实现类，就不进行自动装配
		// 这些回调接口会通过实现类的setter将自身的一些属性注入
		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

		// BeanFactory interface not registered as resolvable type in a plain factory.
		// MessageSource registered (and found for autowiring) as a bean.
		// Spring检测到一下接口的实现类时便会将其注入
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);

		// Register early post-processor for detecting inner beans as ApplicationListeners.
		// 添加监听器
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

		// Detect a LoadTimeWeaver and prepare for weaving, if found.
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			// Set a temporary ClassLoader for type matching.
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}

		// Register default environment beans.
		// 设置环境变量
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
		}
	}
```

### postProcessBeanFactory(beanFactory)
留给子类覆盖做拓展，这里一般不做任何处理。后置处理器，留个子类去实现该接口

### invokeBeanFactoryPostProcessors(beanFactory)
调用我们的bean工厂的后置处理器。调用所有的BeanFactoryPostProcessors，将结果存入参数beanFactory中。
```
	public static void invokeBeanFactoryPostProcessors(
			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

		// Invoke BeanDefinitionRegistryPostProcessors first, if any.
		Set<String> processedBeans = new HashSet<>();
		// 传进来的beanFactory之前新建的DefaultListableBeanFactory，实现了BeanDefinitionRegistry接口，判断为true
		if (beanFactory instanceof BeanDefinitionRegistry) {
			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
			// 存放BeanFactoryPostProcessor的容器
			List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
			// 存放BeanDefinitionRegistryPostProcessor的容器
			List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
            // 遍历作为参数传进来的beanFactoryPostProcessors
			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				// 优先调用BeanDefinitionRegistryPostProcessor，并区分开BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
				    //进行强制转化
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					// 如果是BeanDefinitionRegistryPostProcessor，直接调用postProcessBeanDefinitionRegistry方法
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					// 存入集合
					registryProcessors.add(registryProcessor);
				}
				else {
					// 普通的BeanFactoryPostProcessor集合
					regularPostProcessors.add(postProcessor);
				}
			}

			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.k

			// 下面是开始寻找Spring上下文中的BeanDefinitionRegistryPostProcessor
			// 存放BeanDefinitionRegistryPostProcessor的集合
			List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			 /**
			   * 首先处理的是BeanDefinitionRegistryPostProcessor
			  * 1.拿到所有的首先处理的是BeanDefinitionRegistryPostProcessor的beanName
			  * 2.如果BeanDefinitionRegistryPostProcessor实现了PriorityOrdered接口，就添加到currentRegistryProcessors集合中
			  * 3.调用invokeBeanDefinitionRegistryPostProcessors，将结果注册到registry(Spring默认的容器DefaultListableBeanFactory中)
			  * 4.清理空集合，加载调用实现 Ordered的BeanDefinitionRegistryPostProcessor
			  * 5.清理空集合，加载其他BeanDefinitionRegistryPostProcessor
			   */
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			// 排序
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			// 排完序后将所有的BeanDefinitionRegistryPostProcessor注册
			registryProcessors.addAll(currentRegistryProcessors);
			// 调用
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			// 清除容器
			currentRegistryProcessors.clear();

			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			// 调用实现 Ordered 的 BeanDefinitionRegistryPostProcessors，方法和上面差不多
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();

			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			// 循环调用其他的BeanDefinitionRegistryPostProcessors，直到调用完毕
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
				for (String ppName : postProcessorNames) {
					if (!processedBeans.contains(ppName)) {
						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
						processedBeans.add(ppName);
						reiterate = true;
					}
				}
				sortPostProcessors(currentRegistryProcessors, beanFactory);
				registryProcessors.addAll(currentRegistryProcessors);
				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
				currentRegistryProcessors.clear();
			}

			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
		}

		else {
			// 下面处理非BeanDefinitionRegistry的处理器
			// Invoke factory processors registered with the context instance.
			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		// 拿到所有的BeanFactoryPostProcessor的beanName
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		// 将实现了Ordered、PriorityOrdered接口的、其他的BeanFactoryPostProcessors放在不同容器
		List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		// 遍历beanName，区分不同的BeanFactoryPostProcessors，放在不同的容器
		for (String ppName : postProcessorNames) {
			if (processedBeans.contains(ppName)) {
				// skip - already processed in first phase above
			}
			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
		// 首先调用实现了PriorityOrdered接口的BeanFactoryPostProcessors
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
		// 接着调用实现了BeanFactoryPostProcessors
		List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>();
		for (String postProcessorName : orderedPostProcessorNames) {
			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

		// Finally, invoke all other BeanFactoryPostProcessors.
		// 最后再调用其他的处理器
		List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>();
		for (String postProcessorName : nonOrderedPostProcessorNames) {
			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

		// Clear cached merged bean definitions since the post-processors might have
		// modified the original metadata, e.g. replacing placeholders in values...
		// 清除缓存
		beanFactory.clearMetadataCache();
	}
```

在这个方法中主要做三件事：
- 加载入参的beanFactoryPostProcessors
优先加载BeanDefinitionRegistryPostProcessor类型的，并且会直接调用一次registryProcessor.postProcessBeanDefinitionRegistry(registry)方法，然后分别将BeanDefinitionRegistryPostProcessor类型的和BeanFactoryPostProcessor放入不同类型的容器中。

- 加载上下文的BeanDefinitionRegistryPostProcessor。
  1.拿到所有的首先处理的是BeanDefinitionRegistryPostProcessor的beanName
  2.如果BeanDefinitionRegistryPostProcessor实现了PriorityOrdered接口，就添加到currentRegistryProcessors集合中
  3.调用invokeBeanDefinitionRegistryPostProcessors，将结果注册到registry(Spring默认的容器DefaultListableBeanFactory中)
  4.清理空集合，加载调用实现 Ordered的BeanDefinitionRegistryPostProcessor
  5.清理空集合，加载其他BeanDefinitionRegistryPostProcessor

- 加载上下文的BeanFactoryPostProcessor
和第二步顺序一样也是按照PriorityOrdered、Ordered、和其他的BeanFactoryPostProcessor的顺序加载。

整个 invokeBeanFactoryPostProcessors 方法围绕两个接口，BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor，其中 BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor 。BeanDefinitionRegistryPostProcessor 主要用来在常规 BeanFactoryPostProcessor 检测开始之前注册其他 Bean 定义，说的简单点，就是 BeanDefinitionRegistryPostProcessor 具有更高的优先级，执行顺序在 BeanFactoryPostProcessor 之前。

### registerBeanPostProcessors(beanFactory)
注册BeanPostProcessors，和调用BeanFactoryPostProcessor的步骤差差不多。不过invokeBeanFactoryPostProcessors会调用后置处理器的方法，而这个仅仅是注册而已，不会调用其中的方法。
```
final class PostProcessorRegistrationDelegate {

	public static void invokeBeanFactoryPostProcessors(
			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

		// Invoke BeanDefinitionRegistryPostProcessors first, if any.
		Set<String> processedBeans = new HashSet<>();
		// 传进来的beanFactory之前新建的DefaultListableBeanFactory，实现了BeanDefinitionRegistry接口，判断为true
		if (beanFactory instanceof BeanDefinitionRegistry) {
			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
			// 存放BeanFactoryPostProcessor的容器
			List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
			// 存放BeanDefinitionRegistryPostProcessor的容器
			List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
            // 遍历作为参数传进来的beanFactoryPostProcessors
			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				// 优先调用BeanDefinitionRegistryPostProcessor，并区分开BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					// 如果是BeanDefinitionRegistryPostProcessor，直接调用postProcessBeanDefinitionRegistry方法
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					// 存入集合
					registryProcessors.add(registryProcessor);
				}
				else {
					// 普通的BeanFactoryPostProcessor集合
					regularPostProcessors.add(postProcessor);
				}
			}

			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.k

			// 下面是开始寻找Spring上下文中的BeanDefinitionRegistryPostProcessor
			// 存放BeanDefinitionRegistryPostProcessor的集合
			List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			 /**
			   * 首先处理的是BeanDefinitionRegistryPostProcessor
			  * 1.拿到所有的首先处理的是BeanDefinitionRegistryPostProcessor的beanName
			  * 2.如果BeanDefinitionRegistryPostProcessor实现了PriorityOrdered接口，就添加到currentRegistryProcessors集合中
			  * 3.调用invokeBeanDefinitionRegistryPostProcessors，将结果注册到registry(Spring默认的容器DefaultListableBeanFactory中)
			  * 4.清理空集合，加载调用实现 Ordered的BeanDefinitionRegistryPostProcessor
			  * 5.清理空集合，加载其他BeanDefinitionRegistryPostProcessor
			   */
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			// 排序
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			// 排完序后将所有的BeanDefinitionRegistryPostProcessor注册
			registryProcessors.addAll(currentRegistryProcessors);
			// 调用
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			// 清除容器
			currentRegistryProcessors.clear();

			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			// 调用实现 Ordered 的 BeanDefinitionRegistryPostProcessors，方法和上面差不多
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();

			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			// 循环调用其他的BeanDefinitionRegistryPostProcessors，直到调用完毕
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
				for (String ppName : postProcessorNames) {
					if (!processedBeans.contains(ppName)) {
						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
						processedBeans.add(ppName);
						reiterate = true;
					}
				}
				sortPostProcessors(currentRegistryProcessors, beanFactory);
				registryProcessors.addAll(currentRegistryProcessors);
				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
				currentRegistryProcessors.clear();
			}

			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
		}

		else {
			// 下面处理非BeanDefinitionRegistry的处理器
			// Invoke factory processors registered with the context instance.
			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		// 拿到所有的BeanFactoryPostProcessor的beanName
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		// 将实现了Ordered、PriorityOrdered接口的、其他的BeanFactoryPostProcessors放在不同容器
		List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		// 遍历beanName，区分不同的BeanFactoryPostProcessors，放在不同的容器
		for (String ppName : postProcessorNames) {
			if (processedBeans.contains(ppName)) {
				// skip - already processed in first phase above
			}
			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
		// 首先调用实现了PriorityOrdered接口的BeanFactoryPostProcessors
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
		// 接着调用实现了BeanFactoryPostProcessors
		List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>();
		for (String postProcessorName : orderedPostProcessorNames) {
			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

		// Finally, invoke all other BeanFactoryPostProcessors.
		// 最后再调用其他的处理器
		List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>();
		for (String postProcessorName : nonOrderedPostProcessorNames) {
			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

		// Clear cached merged bean definitions since the post-processors might have
		// modified the original metadata, e.g. replacing placeholders in values...
		// 清楚缓存
		beanFactory.clearMetadataCache();
	}

	public static void registerBeanPostProcessors(
			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

		// 获取所有postProcessor的名称
		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

		// Register BeanPostProcessorChecker that logs an info message when
		// a bean is created during BeanPostProcessor instantiation, i.e. when
		// a bean is not eligible for getting processed by all BeanPostProcessors.
		// 注册 BeanPostProcessorChecker，它会在 BeanPostProcessor 实例化期间创建 bean 时记录一条信息消息，即当 bean 不符合所有 BeanPostProcessor 处理的条件时。
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

		// Separate between BeanPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		// 创建不同的集合来区分实现了PriorityOrdered、Ordered和其他BeanPostProcessors
		List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		for (String ppName : postProcessorNames) {
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
				priorityOrderedPostProcessors.add(pp);
				// 注册MergedBeanDefinitionPostProcessor类型的
				if (pp instanceof MergedBeanDefinitionPostProcessor) {
					internalPostProcessors.add(pp);
				}
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				// 实现了Ordered接口
				orderedPostProcessorNames.add(ppName);
			}
			else {
				// 普通的BeanPostProcessor
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, register the BeanPostProcessors that implement PriorityOrdered.
		// 注册实现了PriorityOrdered接口的BeanPostProcessors
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

		// Next, register the BeanPostProcessors that implement Ordered.
		// 注册实现了Ordered接口的BeanPostProcessors
		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>();
		for (String ppName : orderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			orderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, orderedPostProcessors);

		// Now, register all regular BeanPostProcessors.
		// 注册普通的BeanPostProcessors
		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>();
		for (String ppName : nonOrderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			nonOrderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

		// Finally, re-register all internal BeanPostProcessors.
		sortPostProcessors(internalPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, internalPostProcessors);

		// Re-register post-processor for detecting inner beans as ApplicationListeners,
		// moving it to the end of the processor chain (for picking up proxies etc).
		// 添加应用监听器
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
	}
```
### initMessageSource()
初始化Message源，对不同语言的消息体进行国际化处理。该工具就是通过不同的xml文本一键切换语言。

### initApplicationEventMulticaster()
初始化消息广播器。初始化事件监听多路广播器，注册SimpleApplicationEventMulticaster
```
protected void initApplicationEventMulticaster() {
	ConfigurableListableBeanFactory beanFactory = getBeanFactory();
	/**
	 * 判断容器中是否存在bdName为applicationEventMulticaster的bd
	 * 也就是自定义的事件监听多路广播器，必须实现ApplicationEventMulticaster接口
	 */
	if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
		this.applicationEventMulticaster =
				beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
		}
	}
	else {
		/**
		 * 如果没有，则默认采用SimpleApplicationEventMulticaster
		 */
		this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
		if (logger.isDebugEnabled()) {
			logger.debug("Unable to locate ApplicationEventMulticaster with name '" +
					APPLICATION_EVENT_MULTICASTER_BEAN_NAME +
					"': using default [" + this.applicationEventMulticaster + "]");
		}
	}
}
```
### onRefresh()
留给子类初始化其他的bean。这是个待重写方法，查看实现关系看出 ，在web应用使用时，会重写改函数方法；

### registerListeners()
注册监听器。主要就是通过addApplicationListener(listen)注册监听器，自定义事件可以在该函数上注册；在前面，spring只是初始化的广播器，但是并没有为广播器绑定Listener。Spring在此方法中进行了绑定。
```
/**
* Add beans that implement ApplicationListener as listeners.
* Doesn’t affect other listeners, which can be added without being beans.
*/
protected void registerListeners() {
//获取容器中所有的监听器对象
// 这个时候正常流程是不会有监听器的
// （因为监听器不会在这之前注册，在initApplicationEventMulticaster后在registerListeners之前，只有一个可能在：在onRefresh里面注册了监听器）
for (ApplicationListener<?> listener : getApplicationListeners()) {
//把监听器挨个的注册到我们的多播器上去
getApplicationEventMulticaster().addApplicationListener(listener);
}
	//获取bean定义中的监听器对象
	String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
	//把监听器的名称注册到我们的多播器上
	for (String listenerBeanName : listenerBeanNames) {
		getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
	}

	//在这里获取我们的早期事件
	Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
	// 在这里赋null。  也就是值此之后都将没有早期事件了
	this.earlyApplicationEvents = null;
	if (earlyEventsToProcess != null) {
		//通过多播器进行播发早期事件
		for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
			getApplicationEventMulticaster().multicastEvent(earlyEvent);
		}
	}
}
```

### finishBeanFactoryInitialization(beanFactory)
这个方法也是重点，Spring就是在这里完成非懒加载的单例bean的加载的。其中bean的加载和初始化就是在preInstantiateSingletons中，如果getBean的结果为null，Spring就会通过beanName在工厂中拿到对应的beaDefinition，开始加载bean。
```
	public void preInstantiateSingletons() throws BeansException {
		if (logger.isDebugEnabled()) {
			logger.debug("Pre-instantiating singletons in " + this);
		}

		// Iterate over a copy to allow for init methods which in turn register new bean definitions.
		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
		// 获取所有的beanName
		List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

		// Trigger initialization of all non-lazy singleton beans...
		// 遍历BeanName
		for (String beanName : beanNames) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			// 如果BeanDefinition符合单例、非懒加载、非抽象的类，就开始加载bean
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
					// 获取bean
					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
					// FactoryBean是特殊的bean，需要特殊处理。FactoryBean是通过getObject方法获取真正的对象
					if (bean instanceof FactoryBean) {
						FactoryBean<?> factory = (FactoryBean<?>) bean;
						boolean isEagerInit;
						if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
							isEagerInit = AccessController.doPrivileged(
									(PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit,
									getAccessControlContext());
						}
						else {
							isEagerInit = (factory instanceof SmartFactoryBean &&
									((SmartFactoryBean<?>) factory).isEagerInit());
						}
						if (isEagerInit) {
							getBean(beanName);
						}
					}
				}
				else {
					// 获取bean
					getBean(beanName);
				}
			}
		}

		// Trigger post-initialization callback for all applicable beans...
		// 触发所有bean的回调
		for (String beanName : beanNames) {
			Object singletonInstance = getSingleton(beanName);
			if (singletonInstance instanceof SmartInitializingSingleton) {
				SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
				if (System.getSecurityManager() != null) {
					AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
						smartSingleton.afterSingletonsInstantiated();
						return null;
					}, getAccessControlContext());
				}
				else {
					smartSingleton.afterSingletonsInstantiated();
				}
			}
		}
	}
```
这里就生成了真正的Bean，doGetBean
```
/**
	 * 返回bean的实例,该实例可能是单例bean 也有可能是原型的bean
	 * @param name bean的名称 也有可能是bean的别名
	 * @param requiredType 需要获取bean的类型
	 * @param args 通过该参数传递进来,到调用构造方法时候发现有多个构造方法,我们就可以通过该参数来指定想要的构造方法了
	 *             不需要去推断构造方法(因为推断构造方法很耗时)
	 * @param typeCheckOnly 判断当前的bean是不是一个检查类型的bean 这类型用的很少.
	 * @return 返回一个bean实例
	 * @throws BeansException 如何bean不能被创建 那么就回抛出异常
	 */
	@SuppressWarnings("unchecked")
	protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

		/**
		 * 在这里 传入进来的name 可能是 别名, 也有可能是工厂bean的name,所以在这里需要转换
		 */
		final String beanName = transformedBeanName(name);
		Object bean;

		//尝试去缓存中获取对象
		Object sharedInstance = getSingleton(beanName);

		if (sharedInstance != null && args == null) {
			if (logger.isDebugEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.debug("Returning eagerly cached instance of singleton bean '" + beanName +
							"' that is not fully initialized yet - a consequence of a circular reference");
				}
				else {
					logger.debug("Returning cached instance of singleton bean '" + beanName + "'");
				}
			}
			/**
			 * /*
			 * 如果 sharedInstance 是普通的单例 bean，下面的方法会直接返回。但如果
			 * sharedInstance 是 FactoryBean 类型的，则需调用 getObject 工厂方法获取真正的
			 * bean 实例。如果用户想获取 FactoryBean 本身，这里也不会做特别的处理，直接返回
			 * 即可。毕竟 FactoryBean 的实现类本身也是一种 bean，只不过具有一点特殊的功能而已。
			 */
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

		else {

			/**
			 * spring 只能解决单例对象的setter 注入的循环依赖,不能解决构造器注入
			 */
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}

			/**
			 * 判断AbstractBeanFacotry工厂是否有父工厂(一般情况下是没有父工厂因为abstractBeanFactory直接是抽象类,不存在父工厂)
			 * 一般情况下,只有Spring 和SpringMvc整合的时才会有父子容器的概念,
			 * 比如我们的Controller中注入Service的时候，发现我们依赖的是一个引用对象，那么他就会调用getBean去把service找出来
			 * 但是当前所在的容器是web子容器，那么就会在这里的 先去父容器找
			 */
			BeanFactory parentBeanFactory = getParentBeanFactory();
			//若存在父工厂,切当前的bean工厂不存在当前的bean定义,那么bean定义是存在于父beanFacotry中
			if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
				//获取bean的原始名称
				String nameToLookup = originalBeanName(name);
				//若为 AbstractBeanFactory 类型，委托父类处理
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				else if (args != null) {
					//  委托给构造函数 getBean() 处理
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else {
					// 没有 args，委托给标准的 getBean() 处理
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
			}

			/**
			 * 方法参数 typeCheckOnly ，是用来判断调用 #getBean(...) 方法时，表示是否为仅仅进行类型检查获取 Bean 对象
			 * 如果不是仅仅做类型检查，而是创建 Bean 对象，则需要调用 #markBeanAsCreated(String beanName) 方法，进行记录
			 */
			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}

			try {
				/**
				 * 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象
				 *   <bean id="tulingParentCompent" class="com.tuling.testparentsonbean.TulingParentCompent" abstract="true">
				        <property name="tulingCompent" ref="tulingCompent"></property>
				    </bean>
				 	<bean id="tulingSonCompent" class="com.tuling.testparentsonbean.TulingSonCompent" parent="tulingParentCompent"></bean>
				 */
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				//检查当前创建的bean定义是不是抽象的bean定义
				checkMergedBeanDefinition(mbd, beanName, args);

				/**
			      *
				  * @Bean
				   public DependsA dependsA() {
						return new DependsA();
				   }

					 @Bean
					 @DependsOn(value = {"dependsA"})
					 public DependsB dependsB() {
					    return new DependsB();
					 }
				 * 处理dependsOn的依赖(这个不是我们所谓的循环依赖 而是bean创建前后的依赖)
				 */
				//依赖bean的名称
				String[] dependsOn = mbd.getDependsOn();
					if (dependsOn != null) {
					// <1> 若给定的依赖 bean 已经注册为依赖给定的 bean
					// 即循环依赖的情况，抛出 BeanCreationException 异常
					for (String dep : dependsOn) {
						//beanName是当前正在创建的bean,dep是正在创建的bean的依赖的bean的名称
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
						}
						//保存的是依赖 beanName 之间的映射关系：依赖 beanName - > beanName 的集合
						registerDependentBean(dep, beanName);
						try {
							//获取depentceOn的bean
							getBean(dep);
						}
						catch (NoSuchBeanDefinitionException ex) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
						}
					}
				}

				//创建单例bean
				if (mbd.isSingleton()) {
					//把beanName 和一个singletonFactory 并且传入一个回调对象用于回调
					sharedInstance = getSingleton(beanName, () -> {
						try {
							//进入创建bean的逻辑
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							//创建bean的过程中发生异常,需要销毁关于当前bean的所有信息
							destroySingleton(beanName);
							throw ex;
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}

				else if (mbd.isPrototype()) {
					// It's a prototype -> create a new instance.
					Object prototypeInstance = null;
					try {
						beforePrototypeCreation(beanName);
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						afterPrototypeCreation(beanName);
					}
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				else {
					String scopeName = mbd.getScope();
					final Scope scope = this.scopes.get(scopeName);
					if (scope == null) {
						throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
					}
					try {
						Object scopedInstance = scope.get(beanName, () -> {
							beforePrototypeCreation(beanName);
							try {
								return createBean(beanName, mbd, args);
							}
							finally {
								afterPrototypeCreation(beanName);
							}
						});
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
					}
					catch (IllegalStateException ex) {
						throw new BeanCreationException(beanName,
								"Scope '" + scopeName + "' is not active for the current thread; consider " +
								"defining a scoped proxy for this bean if you intend to refer to it from a singleton",
								ex);
					}
				}
			}
			catch (BeansException ex) {
				cleanupAfterBeanCreationFailure(beanName);
				throw ex;
			}
		}

		// Check if required type matches the type of the actual bean instance.
		if (requiredType != null && !requiredType.isInstance(bean)) {
			try {
				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
				if (convertedBean == null) {
					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
				}
				return convertedBean;
			}
			catch (TypeMismatchException ex) {
				if (logger.isDebugEnabled()) {
					logger.debug("Failed to convert bean '" + name + "' to required type '" +
							ClassUtils.getQualifiedName(requiredType) + "'", ex);
				}
				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			}
		}
		return (T) bean;
	}
```
主要做了以下4件事
- 对name进行转换
```
transformedBeanName(name)方法
```
这里传递的是 name，可能是beanName、aliasName、FactoryBean，所以需要调用该方法对name进行转换

- 命中单例的缓存时
从缓存中得到的bean，还则需要调用getObjectForBeanInstance方法对bean进行实例化处理，因为缓存中记录的是最原始的bean状态。

- 不命中单例的缓存时
  - 原型模式下如果有循环依赖，直接抛出异常。
  - 获取parentBeanFactory ，如果parentBeanFactory存在但并未包含当前bean的定义，递归调用父工厂中的getBean方法得到实例。 
  - typeCheckOnly==false ,做记录 
  - 得到RootBeanDefinition，校验RootBeanDefinition。将配置文件中GenericBeanDefinition转换为RootBeanDefinition，如果beanName是子bean的话，会合并父类的属性
  - 处理依赖，先实例化该bean依赖的bean，并且注册依赖 
  - 得到bean的实例如果是单例，按照单例的策略初始化bean，调用getSingleton方法，传入一个类似回调函数的类ObjectFactory，实现该类的getObject回调方法，在该回调方法中调AbstractAutowireCapableBeanFactory的createBean，实际上是调用它的doCreateBean在做Bean实例化的逻辑
  - 如果是原型，按照原型的策略创建一个实例，先调beforePrototypeCreation方法，再调createBean方法，再调afterPrototypeCreation方法。
  - 如果既不是单例也不是原型，按照另一套策略来创建一个实例，调用scope的get方法，传入一个类似回调函数的类ObjectFactory，实现该类的getObject回调方法，在该回调方法中调用beforePrototypeCreation方法、调AbstractAutowireCapableBeanFactory的createBean方法，调用afterPrototypeCreation方法

- 检测需要的类型是否符合Bean的实际类型


### finishRefresh()
完成refresh方法，通知生命周期处理器刷新过程，并发出广播通知别人。最后容器刷新 发布刷新事件(Spring cloud也是从这里启动的)
```
	/**
	 * Finish the refresh of this context, invoking the LifecycleProcessor's
	 * onRefresh() method and publishing the
	 * {@link org.springframework.context.event.ContextRefreshedEvent}.
	 */
	protected void finishRefresh() {
		// Clear context-level resource caches (such as ASM metadata from scanning).清除上下文级别的资源缓存（例如来自扫描的ASM元数据）
		clearResourceCaches();

		// Initialize lifecycle processor for this context.
		// 注册lifecycleProcessor 声明周期处理器
		//  	作用：当ApplicationContext启动或停止时，它会通过LifecycleProcessor来与所有声明的bean的周期做状态更新
		initLifecycleProcessor();

		// Propagate refresh to lifecycle processor first.
		// 为实现了SmartLifecycle并且isAutoStartup 自动启动的Lifecycle调用start()方法
		getLifecycleProcessor().onRefresh();

		// Publish the final event.
		// 发布容器启动完毕事件
		publishEvent(new ContextRefreshedEvent(this));

		// Participate in LiveBeansView MBean, if active.
		//  注册当前spring容器到LiveBeansView
		//  提供servlet(LiveBeansViewServlet)在线查看所有的bean json 、 为了支持Spring Tool Suite的智能提示
		LiveBeansView.registerApplicationContext(this);
	}
```






































