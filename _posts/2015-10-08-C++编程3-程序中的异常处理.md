---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++编程指南-程序中的异常处理

## 亡羊补牢——程序中的异常处理
“这是哪个笨蛋程序员写的程序，程序出错又崩溃了！”

“神马？这个程序一打开文件就死了，怎么回事啊？”

“就因为程序的崩溃，我一上午的心血啊，如同滔滔江水滚滚东去了！”

我们是不是经常听到这样咒骂程序和程序员的声音？这都是因为应用程序没有进行很好的异常处理，程序运行遇到错误异常时导致程序无法响应，甚至造成系统崩溃。用白花花的银子买的程序总是崩溃，难免让人心烦忍不住骂两句。虽然我们可以用“程序员也是人，是人就会犯错误。同时程序运行的情况千差万别，程序在运行过程中出现错误也在所难免”这样的说辞来为自己开脱。但是对于一个负责的程序员，程序出现异常不是你的错，但是出现异常后不进行合理的异常处理降低用户的损失就是你的错了。所以，如果不想被人骂作笨蛋，不想让用户的成果付诸东流，现在就来学习C++中的亡羊补牢之术——异常处理吧！

## 异常处理
在程序运行过程中，一些外界环境的异常情况的发生，有可能导致程序执行出错获得错误的结果。例如，我们想要打开某个文件写入数据，在文件未被占用的正常情况下，程序可以成功执行获得正确结果。可是如果程序在执行的时候，这个文件已经被占用，在这种不正常的情况下程序就会执行失败。这就是所谓的程序执行过程中的异常——不正常的特殊情况，常见的还有数组下标访问越界、系统内存不足、以0作除数等。一旦程序执行过程中发生异常，则可能引发算法失效、程序运行时无故停止，甚至程序崩溃等严重后果，这才出现了本节开始的那一幕幕惨剧。虽然程序中的异常就像现实世界中的地震一样，难以预料也无法避免，但是我们可以在开发程序的时候进行必要的异常处理，在异常发生的时候将用户的损失降到最低。为此，C++专门提供了亡羊补牢的异常处理机制。C++的异常处理机制给程序提供了一种可以在运行时对出现的异常情况进行捕获并处理的方法。异常处理使用try关键字来尝试执行可能会出现异常的代码段，当在代码段的执行过程中有异常发生时，系统会抛出相应类型的异常，由紧随其后的catch关键字对异常进行捕获，并交由相应类型的异常处理分支对其进行恰当的处理，比如结束正在执行的操作、清理不再需要的资源等，从而尽可能地挽回用户的损失。在C++中，异常处理的语法格式如下：
```
// 用try开始异常处理语句
try
{
    // 包含可能发生异常的语句
}
catch(异常类型 [形参名])     // 捕获特定类型的异常
{
    // 对此类型异常进行处理
}
catch(异常类型 [形参名])     // 捕获特定类型的异常
{
    // 对此类型异常进行处理
}
// 可以有多个catch语句并列，捕获不同类型的异常
catch(...)    // 如果省略具体的异常类型用“...”表示，则表示捕获所有类型的异常
{
    // 对所有类型的异常进行处理
}
```
当我们认为某段代码可能会出现异常情况并需要对其进行处理时，我们可以把这段代码放入try关键字后面的代码块中。在程序执行try语句块中的语句（包括其中调用的函数）时，如果遇到异常情况真的发生，就可以使用throw关键字抛出一个相应类型的异常，表示某种异常情况的发生，需要后面的catch语句捕获并对其进行处理。用throw关键字抛出一个异常的语法格式如下：

throw 异常表达式;

其中，异常表达式就是要抛出的异常，它可以是表示异常类型的错误代码，或者是含有异常相关信息的某个对象，总之，它的意义是为异常处理提供相应的辅助信息。例如：
```
// 除法函数
double Divide( int a, int b )
{
    if( 0 == b )
        throw "不能使用0作为除数";

    return (double)a/b;
}
```
在这个除法函数中，当检测到除数为0时，它就用throw关键字抛出一个异常提前结束这个函数，跳过后面的除法运算避免错误的发生。这里throw关键字抛出的异常是一个字符串，它描述了这个异常发生的原因，便于程序员对其进行处理。当然，还可以抛出专门的异常对象，只要这个异常对象类型是事先定义好的并能够给后面的异常处理提供足够的信息即可。

当try语句块中抛出某个类型的异常后，该异常会被紧跟其后的相应类型的catch语句捕获并对其进行处理。catch语句可以带有一个形式参数，它的类型就是catch语句要捕获的异常类型，也就是说，异常被某个catch语句捕获的条件就是该异常的类型与catch语句的异常类型相匹配。当throw关键字抛出的异常被某个catch语句捕获时，throw关键字后的异常表达式会被当成实际参数传递给catch语句中的形式参数，进而catch语句可以根据这个参数提供的信息对异常进行具体的处理。当有多种类型的异常需要捕获时，可以将多个catch语句并列。如果省略catch关键字后面的形式参数而使用“…”代替，则表示catch语句会捕获所有类型的异常。

当try语句块中抛出异常并被某个catch分支捕获后，异常处理会把程序的执行从异常发生的地点转移到捕获这个异常的catch分支语句，开始对异常进行具体的处理。例如：
```
// 开始异常处理语句
try
{
	cout<<"请输入被除数与除数："<<endl;
	int a,b;   // 被除数与除数
	cin>>a>>b; // 接收用户输入

	// 进行除法运算，当b为0时会抛出异常
	double fRes = Divide( a, b );

	cout<<a<<"/"<<b<<" = "<<fRes<<endl;  // 输出结果
}
// 捕获try语句块中所抛出的字符串类型异常
catch( char* pMsg )
{
    // 对异常进行处理
    // 这里仅仅是输出错误信息
    cout<<"程序运行发生异常："<<pMsg<<endl;
}
```
在这段代码中，我们想用Divide()函数来完成一个除法运算。但是这个函数在除数为0的情况下会发生异常，为了程序结果的正确同时给用户一个很好的使用体验，我们将除法运算放到一个try语句块中来执行。这样，当异常发生时，也就是用户输入的除数为0时，Divide()函数就会抛出一个描述了错误信息的字符串类型的异常。在try语句块之后的catch语句会捕获到这个字符串类型异常并对其进行处理。有了异常处理，即使用户不小心输入的除数为0，程序也不会直接给出一个错误的结果，而是提示用户错误的发生及其原因，帮助用户改正。有了这样的用户体验，自然再不会被用户骂作笨蛋。当然，这里对异常的处理仅仅是将这个错误信息输出报告给用户而已，在实际应用中，异常处理往往要比这复杂，比如要进行资源的清理、记录错误日志等。

总之，使用异常处理这“亡羊补牢”之术，可以在错误发生之后对错误所造成的损失尽量进行补救，让用户的损失减到最小，也让程序更加健壮，让程序员少挨一点骂。

## 异常的函数接口声明
为了加强程序的可读性，方便函数的使用者知道所使用的函数可能会抛出的异常类型以便对其进行针对性的处理，可以在函数的声明中列出这个函数可能抛出的所有异常类型。其语法格式非常简单，只需要在函数声明之后用throw关键字加一个括号，括号中列出这个函数可能抛出的异常类型，如果有多个类型的异常，可以用逗号间隔。

例如，Divide()函数可能会抛出字符串类型和浮点数类型的类型，则可以将其定义如下：
```
// 可能抛出char*和double类型的异常
double Divide( int a, int b ) throw ( const char*, double )
{
    // …
}
```
在函数接口中用throw关键字列出的异常类型，是函数的使用者和定义者之间关于这个函数所可能抛出异常的一种约定。作为函数的使用者，这意味着我们只需要捕获并处理函数声明中所列出类型的异常就可以了；而作为函数的定义者，则有义务保证这个函数只会抛出函数声明的异常类型列表中所列类型的异常。如果函数抛出了其他类型的异常，有的编译器会在编译时给出警告信息。而在运行时，这个未事先说明的异常会导致程序崩溃。

如果在函数的声明中没有包括异常的接口声明，则此函数可以抛出任何类型的异常。例如：
```
// 可以抛出任何类型的异常

double Divide( int a, int b );
```
相反，如果一个函数不会抛出异常，那么我们可以将函数声明中throw关键字之后的异常类型列表留空，或者是用noexcept关键字对函数进行修饰，表示这个函数不会抛出任何类型的异常，函数的使用者无需将其放到try语句块中来执行。例如：
```
// 不会抛出任何类型的异常

double Divide( int a, int b ) throw();
double sqrt(double a) noexcept;  
```
虽然我们用noexcept关键字修饰一个函数，表示这个函数不会抛出异常。但世事难料，如果一个经过noexcept修饰的函数确实在执行的时候抛出了异常，那么程序会通过调用terminate()函数来结束自己的执行。这样做可能会留下很多后遗症，例如，它无法保证对象的析构函数的正常调用，也无法保证栈的自动释放等。但是，在可以预见异常极少发生的情况下，将函数用noexcept修饰却是一种简单而直接，却非常有效的异常处理机制，它可以简化异常处理从而在一定程度上提高程序的执行效率。

从以上内容可以看到，异常的函数接口声明形式非常灵活，既可以指定特定的异常类型，也可以不指定任何特定类型，甚至还可以指定函数不抛出任何类型的异常。合理地使用这些形式，可以让函数的定义者更加清晰明确地表达这个函数可能抛出的异常，从而使得函数的使用者可以更有针对性地捕获这些异常并进行处理，让程序更加健壮。


最佳实践：在什么时候使用异常？


既然异常处理的使用可以让程序更加健壮，那么异常的使用是不是越多越好呢？当然不是！所谓“异常”，顾名思义，就是不正常，这也决定了它只应该在极少数情况下才会使用。异常的使用，虽然使得程序变得更加健壮，但它也同时会带来程序性能的损失。如果使用过度，往往会得不偿失。所以，使用异常处理的基本原则就是——健壮性和性能之间的平衡——

l 只对偶然的、极少发生的不正常情况，比如内存申请失败、硬件读写错误等，使用异常进行错误处理；

l 而对于大量的、重复的、可预见的程序错误，比如打开文件失败、在循环结构中出现的错误等，则应该根据执行结果使用条件判断进行错误处理。