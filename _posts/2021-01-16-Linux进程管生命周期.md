---
layout: post
categories: [Linux]
description: none
keywords: Linux
---
# Linux进程管理生命周期

## 进程控制块 PCB 与 task_struct
进程是资源封装管理的单位，资源指占用的内存，文件系统，信号及处理方法。线程是调度的单位，进程的区别是资源，资源是隔离的，进程把资源描述清楚就可以了

Process Control Block(PCB) 进程控制块, 在不同操作系统中用于描述进程，在 Linux 的 PCB 就是用 task_struct 来描述。

描述来 task_struct 的部分成员
```
mm 内存资源: 进程的内存
fs 文件系统资源: 根路径和当前路径指针
files 文件系统资源: 进程打开的文件，文件描述符数组
signal 信号资源： 不同进程可以针对同一信号挂不同的处理方法
pid 属性资源： 描述进程的属性, 进程的 PID 是有限的
```
当前路经是在fs_struct中的：
```
struct fs_struct {
        int users;
        spinlock_t lock;
        seqcount_t seq;
        int umask;
        int in_exec;
        struct path root, pwd;
};
```
files进程打开的文件描述符fd_array：
```
/*
 * Open file table structure
 */
struct files_struct {
  /*
   * read mostly part
   */
        atomic_t count;
        struct fdtable __rcu *fdt;
        struct fdtable fdtab;
  /*
   * written part on a separate cache line in SMP
   */
        spinlock_t file_lock ____cacheline_aligned_in_smp;
        int next_fd;
        unsigned long close_on_exec_init[1];
        unsigned long open_fds_init[1];
        struct file __rcu * fd_array[NR_OPEN_DEFAULT];
};
```
PID 的数量：
```
$ cat /proc/sys/kernel/pid_max
32768
```
fork 炸弹：
```
:(){:|： & }； ：
# : 函数名为冒号
# () 函数参数定义
# {} 函数定义
# ：调用自己
# |：递归调用自己
# & 后台执行
# ; 函数结束
# : 调用函数
```
查看用户的 PID 限制：
```
$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 15225
max locked memory       (kbytes, -l) 16384
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 15225       ##<<<<<
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

PID 数量限制导致安卓的一键root

安卓的 2.2.1 之前的版本被发现一个漏洞，很容易就被一键 root，安卓的调试软件 adb 刚开始时有 root 权限，之后 adb 调用 api setuid(shell) 把自己从 root用户降为 shell 用户。谷歌的工程师在调用时没有检查 setuid 的返回值，即默认 setuid 总是可以成功。黑客们利用 uid 数量有限制的属性，将 shell 用户内的pid 进程全部用完，这样调用 setuid 时是无法成功的，但因为没有检查返回值，导致 adb 调用 setuid(shell) 后没有降权成功，还是有 root 权限。这就是 Android著名的提权漏洞： rageagainstthecage。2.2 之后的安卓版本修复了此漏洞，方法是检查 setuid 的返回值。

linux 的 pid 与 tgid

一个进程 fork 出子进程后，从 linux 内核的角度看，对应的 pid 肯定不一样。但是为了符合 POSIX 的标准要求， POSIX 要求规定同一个父进程 fork 出的子进程，调用 getpid 返回的 pid 的号必须是一样的，我们用 top 命令查看进

程可以看到 fork 出的子进程与父进程的 Pid 号是一样的。 linux 实现的原理就是通过增加一个 tgid 来实现父子进程调用 getpid 时返回值都一样的效果。

Linux 进程 task_struct 的三种数据结构

task_struct 与 task_struct 之间的关系是什么？

在 linux 代码中会涉及各种对 task_struct 的引用关系，比如调度算法中会将task_struct 挂在链表上，父子进程的关系用树来描述， CFS 调度算法会用到红黑树，通过 pid 查找进程则是用 hash 表的结构。可以通过 pstree 命令进行查看，父进程回收子进程，父对子的监控。

## Linux 进程的生命周期
Linux 进程的生命周期状态图

进程运行时的 3 个基本状态:

操作系统包括实时系统对应进程一般都有 3 个状态，进程在有 CPU 时对应运行态，无 CPU 时对应就绪态和睡眠态。就绪态指所有资源都准备好，只要有 CPU 就可以运行了。睡眠指有资源还未准备好，比如读串口数据时，数据还未发送。此时有 CPU 也无法运行，需要等资源准备好后变成就绪态，然后得到 CPU 后才能变成运行态，其转换关系。

Linux 进程扩展的 6 个状态:

僵尸态： 子进程退出后，所有资源都消失了，只剩下 task_struct，父进程在 wait 函数中可以得到子进程的死亡原因。在 wait 之前子进程的状态就是僵尸态。
深度睡眠： 等待资源到位后才醒过来
浅度睡眠: 等待资源到位或收到信号后都会醒过来
暂停： stop 状态是被外部命令作业控制等强制进程进入的状态。
就绪： 未占用 CPU，等待调度算法调度到运行态的进程
运行： 占有 CPU，正在运行的线程。
僵尸态

僵尸是什么?
资源释放了， task_struct 还在，父进程可以查到子进程的死因
子进程死了之后，linux 会自动回收资源

## 进程的内存泄露
什么是内存泄露？

内存泄露指随着时间的增长，进程的内存使用呈现线性增长的情况，指的是进程一直在运行，运行中申请了内存，但使用完后并没有释放，运行期间每次都申请内存而不释放导致系统内存越来越少的情况。这里要理解内存泄露的原因不可能是进程死了，内存没释放。因为进程死了之后就变成僵尸， Linux会自动将进程中申请的资源全部释放，只留下 task_struct 让父进程 wait 来查看状态。不可能再占用内存。

如何观察内存泄漏？

痛多多点检测法，多点采样，可以看到内存是的图像是震荡向上的。没内存泄漏的

内存是震荡收敛的一个图形

僵尸示例：

参看 process_codes/day1/life_period.c 代码

waitpid 可以清除僵尸进程，如果没有走到 wait 一直处于僵尸状态，处于僵尸状态的进程是无法 kill 掉的, 直接杀死父进程可以回收处于僵尸态的子进程

暂停状态

暂停状态是进程在运行过程中，通过外部 bash 命令强制让进程进入的状态。通过这种方法可以指定进程的 CPU 占用率。后面我们通常用 cgroup 的方法来实现，这里仅作了解。

如何进入停止态？ ctrl + z 进入停止状态，fg/bg可以调控前台/后台运行
```
# #作业控制的命令
# ctrl + z, fg/bg
$ cpulimit
$ cpulimit -l 20 -p 10111
# 限制 pid 为 10111 程序的 CPU 使用率不超过 20%
```

Linux 进程状态的联系和区别:

就绪 VS 运行 linux 的调度算法只管理 就绪和运行态 中的进程，只对应中的就绪和占有状态的进程，这两个状态都称为 task_running。

深度睡眠 VS 浅度睡眠 深度睡眠只有资源到位才醒，收到信号也不醒，浅度睡眠资源到位或收到信号都会醒,睡眠 VS 暂停 睡眠是代码中未得到资源主动进入的状态，暂停是程序外部强制进程进入的状态。

fork

fork 返回值， 父进程返回子进程的 PID, 子进程返回 0

## Linux进程六种状态
进程概念：
1）正在执行的程序

2）正在计算机上执行的程序实例

3）能分配处理器并由处理器执行的实体

进程的两个基本元素是程序代码和代码相关联的数据集。Linux是一个多用户，多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，而每个进程会有不同的状态。这就可以引入‘进程状态’，进程在内存中因策会略或调度需求，会处于各种状态。

## Linux下的进程状态：
```
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};
```
### Linux进程状态：R (TASK_RUNNING)，可执行状态:

只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。

很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。

### Linux进程状态：S (TASK_INTERRUPTIBLE)，可中断的睡眠状态:

处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。

通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。

### Linux进程状态：D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态:

与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。

绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见《linux内核异步中断浅析》）在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。

linux系统中也存在容易捕捉的TASK_UNINTERRUPTIBLE状态。执行vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用exit或exec（参见《神奇的vfork》）。

通过下面的代码就能得到处于TASK_UNINTERRUPTIBLE状态的进程：
```
#include   void main() { 

 if (!vfork()) sleep(100); 

 } 
```
编译运行，然后ps一下：kouu@kouu-one:~/test$ ps -ax | grep a\.out 4371 pts/0 D+ 0:00 ./a.out 4372 pts/0 S+ 0:00 ./a.out 4374 pts/1 S+ 0:00 grep a.out 然后我们可以试验一下TASK_UNINTERRUPTIBLE状态的威力。不管kill还是kill -9，这个TASK_UNINTERRUPTIBLE状态的父进程依然屹立不倒。

### Linux进程状态：T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态:

向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。

当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。

而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。

### Linux进程状态：Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程:

进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。

当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。

父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。

子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。

通过下面的代码能够制造一个EXIT_ZOMBIE状态的进程：
```
#include   void main() {  if (fork())  while(1) sleep(100);  } 
```
编译运行，然后ps一下：kouu@kouu-one:~/test$ ps -ax | grep a\.out 10410 pts/0 S+ 0:00 ./a.out 10411 pts/0 Z+ 0:00 [a.out] 10413 pts/1 S+ 0:00 grep a.out 只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程“收尸”？当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。1号进程，pid为1的进程，又称init进程。

linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：

1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；
2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；
init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。

### Linux进程状态：X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁：

而进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程（进程？线程？参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。）

此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。

## 进程的初始状态

进程是通过fork系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过kernel_thread函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。）

那么既然调用进程处于TASK_RUNNING状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于TASK_RUNNING状态。

另外，在系统调用调用clone和内核函数kernel_thread也接受CLONE_STOPPED选项，从而将子进程的初始状态置为 TASK_STOPPED。

## 进程状态变迁

进程自创建以后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从TASK_RUNNING状态变为非TASK_RUNNING状态、或者从非TASK_RUNNING状态变为TASK_RUNNING状态。

也就是说，如果给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNING状态），然后再响应SIGKILL信号而退出（变为TASK_DEAD状态）。并不会从TASK_INTERRUPTIBLE状态直接退出。

进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。

而进程从TASK_RUNNING状态变为非TASK_RUNNING状态，则有两种途径：

1、响应信号而进入TASK_STOPED状态、或TASK_DEAD状态；
2、执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。
显然，这两种情况都只能发生在进程正在CPU上执行的情况下。

## 状态切换

进程在运行中不断的改变运行状态；

1）就绪状态

当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。

2）执行（Running）状态

当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态

3） 阻塞(Blocked)状态

正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。

就绪–>执行

处在就绪状态的进程，当调度器为其分配了处理机后，就变成了执行状态。

执行–>就绪

执行状态的进程在其执行过程中，时间片跑完了不得不让出处理机，于是从执行变成就绪状态。

执行–>阻塞

正在执行的进程等待某种事件而无法继续执行时，便从执行状态变成阻塞状态。

阻塞–>就绪

处在阻塞状态的进程，如果等待的时间发生，则从阻塞状态转变成就绪状态。













