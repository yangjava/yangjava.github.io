---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL源码词法解析
词法分析（lexical analysis）是计算机科学中将字符序列转换为单词（Token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（Lexical analyzer，简称Lexer），也叫扫描器（Scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。词法分析阶段是编译过程的第一个阶段，是编译的基础。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用Lex等工具自动生成,lex可以参考Lex与 YACC 详解。词法分析是编译程序的第一个阶段且是必要阶段；词法分析的核心任务是扫描、识别单词且对识别出的单词给出定性、定长的处理；实现词法分析程序的常用途径:自动生成,手工生成

## MySQL词法解析
在 MySQL 数据库中，客户端向服务器发送过来SQL语句后，服务器首先要进行词法分析，而后进行语法分析，语义分析，构造执行树，生成执行计划。词法分析是第一阶段，然而Mysql并没有使用lex来实现词法分析，但是语法分析却用了yacc，

而yacc需要词法分析函数yylex，故在sql_yacc.cc文件最前面我们可以看到如下的宏定义:
```
/* Substitute the variable and function names.  */
#define yyparse         MYSQLparse
#define yylex           MYSQLlex
```

## 源码分析
MYSQLlex就是MYSQL自己的词法分析程序。在sql_lex.cc源文件中，我们可以在该函数处打断点，得到函数调用堆栈。


MYSQLlex 函数负责进行词法解析。lex_one_token 用来解析单个 token，简单来说，词法分析就是把一个完整的SQL 语句打碎成一个个的单词。

例如一个 sql 语句：
```
select * from bank;
```
它会打碎成4 个符号，每个符号是什么类型，从哪里开始到哪里结束。

## 词法解析状态机
词法解析状态机是在词法解析的扫描阶段执行的过程。状态机的主要用途就是解析token时的执行过程，比如MY_LEX_IDENT状态机会循环匹配字符后，解析字符并返回对应的token。

| 对应状态机                          | 备注                               |
|--------------------------------|----------------------------------|
| MY_LEX_START                   | 开始解析token                        |
| MY_LEX_CHAR                    | 解析单个字符例如*、:、;                    |
| MY_LEX_IDENT                   | 解析字符串，匹配关键词，例如“table”、“select” 等 |
| MY_LEX_IDENT_SEP               | 找到字符’.’                          |
| MY_LEX_IDENT_START             | 从’.'开始解析token                    |
| MY_LEX_REAL	                   | 不完全实数                            |
| MY_LEX_HEX_NUMBER              | hex字符串                           |
| MY_LEX_BIN_NUMBER              | bin字符串                           |
| MY_LEX_CMP_OP                  | 不完全比较运算符                         |
| MY_LEX_LONG_CMP_OP             | 不完全比较运算符                         |
| MY_LEX_STRING                  | 字符串                              |
| MY_LEX_COMMENT                 | 注释                               |
| MY_LEX_END                     | 结束                               |
| MY_LEX_NUMBER_IDENT            | 数字                               |
| MY_LEX_INT_OR_REAL             | 完全整数或不完全实数                       |
| MY_LEX_NUMBER_IDENT            | 数字                               |
| MY_LEX_REAL_OR_POINT           | 解析.返回不完全实数，或者字符’.’               |
| MY_LEX_BOOL                    | 布尔                               |
| MY_LEX_EOL                     | 如果是eof，则设置状态end结束                |
| MY_LEX_LONG_COMMENT	           | 长注释                              |
| MY_LEX_END_LONG_COMMENT        | 注释结束                             |
| MY_LEX_SEMICOLON               | 分隔符;                             |
| MY_LEX_SET_VAR                 | 检查:=                             |
| MY_LEX_USER_END                | 结束’@’                            |
| MY_LEX_HOSTNAME                | 解析hostname                       |
| MY_LEX_SKIP                    | 空格                               |
| MY_LEX_USER_VARIABLE_DELIMITER | 引号字符                             |
| MY_LEX_SYSTEM_VAR              | 例如解析user@hostname，解析到@           |
| MY_LEX_IDENT_OR_KEYWORD        | 判断返回字符串状态或者键盘键值                  |
| MY_LEX_IDENT_OR_HEX	           | hex-数字                           |
| MY_LEX_IDENT_OR_BIN            | bin-数字                           |
| MY_LEX_IDENT_OR_NCHAR          | 判断返回字符状态，或字符串状态                  |
| MY_LEX_STRING_OR_DELIMITER     | 判断返回字符串状态或者空格字符状态                |

## state_map 介绍
state_map是验证状态机的关键步骤，初始化该过程主要在/mysql-8.0.20/mysys/sql_chars.cc文件的init_state_maps方法中，方法实现如下:
```
bool init_state_maps(CHARSET_INFO *cs) {
  uint i;
  uchar *ident_map;
  enum my_lex_states *state_map = nullptr;

  lex_state_maps_st *lex_state_maps = (lex_state_maps_st *)my_once_alloc(
      sizeof(lex_state_maps_st), MYF(MY_WME));

  if (lex_state_maps == nullptr) return true;  // 空指针 OOM

  cs->state_maps = lex_state_maps;
  state_map = lex_state_maps->main_map;

  if (!(cs->ident_map = ident_map = (uchar *)my_once_alloc(256, MYF(MY_WME))))
    return true;  // OOM

  hint_lex_init_maps(cs, lex_state_maps->hint_map);

  /* 填充状态以获得更快的解析器 */
  for (i = 0; i < 256; i++) {
    if (my_isalpha(cs, i))
      state_map[i] = MY_LEX_IDENT;      // 字符串状态机
    else if (my_isdigit(cs, i))
      state_map[i] = MY_LEX_NUMBER_IDENT;
    else if (my_ismb1st(cs, i))
      /* To get whether it's a possible leading byte for a charset. */
      state_map[i] = MY_LEX_IDENT;
    else if (my_isspace(cs, i))
      state_map[i] = MY_LEX_SKIP;      // 空格状态机
    else
      state_map[i] = MY_LEX_CHAR;     // 字符状态机
  }
  state_map[(uchar)'_'] = state_map[(uchar)'$'] = MY_LEX_IDENT;
  state_map[(uchar)'\''] = MY_LEX_STRING;
  state_map[(uchar)'.'] = MY_LEX_REAL_OR_POINT;
  state_map[(uchar)'>'] = state_map[(uchar)'='] = state_map[(uchar)'!'] =
      MY_LEX_CMP_OP;         // 操作符匹配状态机
  state_map[(uchar)'<'] = MY_LEX_LONG_CMP_OP;
  state_map[(uchar)'&'] = state_map[(uchar)'|'] = MY_LEX_BOOL;
  state_map[(uchar)'#'] = MY_LEX_COMMENT;
  state_map[(uchar)';'] = MY_LEX_SEMICOLON;
  state_map[(uchar)':'] = MY_LEX_SET_VAR;
  state_map[0] = MY_LEX_EOL;       // 结束标志状态机
  state_map[(uchar)'/'] = MY_LEX_LONG_COMMENT;
  state_map[(uchar)'*'] = MY_LEX_END_LONG_COMMENT;   // *字符匹配状态机
  state_map[(uchar)'@'] = MY_LEX_USER_END;   // @字符匹配状态机
  state_map[(uchar)'`'] = MY_LEX_USER_VARIABLE_DELIMITER;
  state_map[(uchar)'"'] = MY_LEX_STRING_OR_DELIMITER;

  /*
    创建第二个映射以加快查找标识符的速度
  */
  for (i = 0; i < 256; i++) {
    ident_map[i] = (uchar)(state_map[i] == MY_LEX_IDENT ||
                           state_map[i] == MY_LEX_NUMBER_IDENT);
  }

  /* Special handling of hex and binary strings */
  state_map[(uchar)'x'] = state_map[(uchar)'X'] = MY_LEX_IDENT_OR_HEX;
  state_map[(uchar)'b'] = state_map[(uchar)'B'] = MY_LEX_IDENT_OR_BIN;
  state_map[(uchar)'n'] = state_map[(uchar)'N'] = MY_LEX_IDENT_OR_NCHAR;

  return false;
}
```
先来看这个for循环，256应该是256个字符了，每个字符的处理应该如下规则：如果是字母，则state = MY_LEX_IDENT；如果是数字，则state = MY_LEX_NUMBER_IDENT，如果是空格，则state = MY_LEX_SKIP，剩下的全为MY_LEX_CHAR。　 
 
for循环之后，又对一些特殊字符进行了处理，由于我们的语句“select @@version_comment limit 1”中有个特殊字符@，这个字符的state进行了特殊处理，为MY_LEX_USER_END。

代码中能快速匹配状态机，就是因为初始化好了一堆的状态机map，根据字符可以匹配不同的状态机。状态机的宏在mysql-8.0.20/include/sql_chars.h文件中。	
```
enum MY_ATTRIBUTE((__packed__)) my_lex_states {
  MY_LEX_START,
  MY_LEX_CHAR,
  MY_LEX_IDENT,
  MY_LEX_IDENT_SEP,
  MY_LEX_IDENT_START,
  MY_LEX_REAL,
  MY_LEX_HEX_NUMBER,
  MY_LEX_BIN_NUMBER,
  MY_LEX_CMP_OP,
  MY_LEX_LONG_CMP_OP,
  MY_LEX_STRING,
  MY_LEX_COMMENT,
  MY_LEX_END,
  MY_LEX_NUMBER_IDENT,
  MY_LEX_INT_OR_REAL,
  MY_LEX_REAL_OR_POINT,
  MY_LEX_BOOL,
  MY_LEX_EOL,
  MY_LEX_LONG_COMMENT,
  MY_LEX_END_LONG_COMMENT,
  MY_LEX_SEMICOLON,
  MY_LEX_SET_VAR,
  MY_LEX_USER_END,
  MY_LEX_HOSTNAME,
  MY_LEX_SKIP,
  MY_LEX_USER_VARIABLE_DELIMITER,
  MY_LEX_SYSTEM_VAR,
  MY_LEX_IDENT_OR_KEYWORD,
  MY_LEX_IDENT_OR_HEX,
  MY_LEX_IDENT_OR_BIN,
  MY_LEX_IDENT_OR_NCHAR,
  MY_LEX_STRING_OR_DELIMITER
};
```	
	
```text
static int lex_one_token(Lexer_yystype *yylval, THD *thd) {
uchar c = 0;
bool comment_closed;
int tokval, result_state;
uint length;
enum my_lex_states state;
Lex_input_stream *lip = &thd->m_parser_state->m_lip;   // 获取输入流信息
const CHARSET_INFO *cs = thd->charset();    // 获取字符集
const my_lex_states *state_map = cs->state_maps->main_map;   // 获取状态
const uchar *ident_map = cs->ident_map;      // 字符串分割符号

lip->yylval = yylval;  // The global state

lip->start_token();    // 初始化token 字符串
state = lip->next_state;    // 获得下一个状态
lip->next_state = MY_LEX_START;   // 设置下一个状态
for (;;) {         // 循环解析状态机
switch (state) {
case MY_LEX_START:  // Start of token
// Skip starting whitespace
while (state_map[c = lip->yyPeek()] == MY_LEX_SKIP) {  // 判断是否为空格
if (c == '\n') lip->yylineno++;

          lip->yySkip();  // 处理空格
        }

        /* Start of real token */
        lip->restart_token();   // 设置 m_tok_start 和 m_cpp_token_start
        c = lip->yyGet();       // 获得单个字符，并且设置m_cpp_str, 并且 m_ptr 移位
        state = state_map[c];   // 如果是字符串，返回 MY_LEX_IDENT 状态
        break;
        //......
      case MY_LEX_IDENT:    // 解析字符串关键字, 比如select、 tables 等
        const char *start;
        if (use_mb(cs)) {
          result_state = IDENT_QUOTED;
          switch (my_mbcharlen(cs, lip->yyGetLast())) {
            case 1:
              break;
            case 0:
              if (my_mbmaxlenlen(cs) < 2) break;
              [[fallthrough]];
            default:
              int l =
                  my_ismbchar(cs, lip->get_ptr() - 1, lip->get_end_of_query());
              if (l == 0) {
                state = MY_LEX_CHAR;
                continue;
              }
              lip->skip_binary(l - 1);
          }
          while (ident_map[c = lip->yyGet()]) {    // 循环获取字符串
            switch (my_mbcharlen(cs, c)) {
              case 1:
                break;
              case 0:
                if (my_mbmaxlenlen(cs) < 2) break;
                [[fallthrough]];
              default:
                int l;
                if ((l = my_ismbchar(cs, lip->get_ptr() - 1,
                                     lip->get_end_of_query())) == 0)
                  break;
                lip->skip_binary(l - 1);
            }
          }
        } else {
          for (result_state = c; ident_map[c = lip->yyGet()]; result_state |= c)
            ;
          /* If there were non-ASCII characters, mark that we must convert */
          result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;
        }
        length = lip->yyLength();
        start = lip->get_ptr();
        if (lip->ignore_space) {
          /*
            If we find a space then this can't be an identifier. We notice this
            below by checking start != lex->ptr.
          */
          for (; state_map[c] == MY_LEX_SKIP; c = lip->yyGet()) {
            if (c == '\n') lip->yylineno++;
          }
        }
        if (start == lip->get_ptr() && c == '.' && ident_map[lip->yyPeek()])
          lip->next_state = MY_LEX_IDENT_SEP;
        else {  // '(' must follow directly if function
          lip->yyUnget();
          if ((tokval = find_keyword(lip, length, c == '('))) {      // 查找token
            lip->next_state = MY_LEX_START;  // Allow signed numbers
            return (tokval);                 // Was keyword    // 返回token
          }
          lip->yySkip();  // next state does a unget
        }
        yylval->lex_str = get_token(lip, 0, length);
        //......
        return (result_state);  // IDENT or IDENT_QUOTED
        //......
       case MY_LEX_EOL:     // \0 结束符
          if (lip->eof()) {
          lip->yyUnget();  // Reject the last '\0'
          lip->set_echo(false);
          lip->yySkip();
          lip->set_echo(true);
          /* Unbalanced comments with a missing '*' '/' are a syntax error */
          if (lip->in_comment != NO_COMMENT) return (ABORT_SYM);
          lip->next_state = MY_LEX_END;  // Mark for next loop  设置下一个状态机为 MY_LEX_END
          return (END_OF_INPUT);   // 返回token
        }
```

## 源码调试跟踪
Mysql会调用MYSQLlex方法进行词法解析、MYSQLlex中会调用lex_one_token进行单个token解析.我们通过 gdb 进行调试，跟一下源码。在 lex_one_token 函数处打断点，启动客户端，执行sql select * from bank;	

根据上图我们得知第一个状态机为MY_LEX_START，执行状态机进入switch后，会通过yyPeek方法获取一个字符如下图。来判断这个字符是否为空格，不是空格后，通过“state = state_map[c];” 返回一个状态机。判断时通过state_map解析

由于获取单个字符是s，s对应state_map中的状态机是MY_LEX_IDENT，MY_LEX_IDENT状态机会去匹配对应的关键词返回token。第一个匹配的关键词就是select。

通过find_keyword方法可以匹配对应的token。第一次匹配“select”后我们得到一个token(748),748这个token对应SELECT_SYM，可以在/mysql-8.0.20/sql/sql_yacc.h文件中查找到。此时m_ptr参数值为“ * from t1”,该参数由返回前调用lip->yyUnget()进行左移。lip->next_state的状态再次设置为MY_LEX_START	

当我们再次调用lex_one_token时，处理MY_LEX_START状态机时，会过滤调一个空格字符。继续执行获取，获取到“*”字符，又会将状态机设置为MY_LEX_END_LONG_COMMENT,然后执行状态机会设置为MY_LEX_CHAR，返回时下一次的状态设置成了MY_LEX_START。最后返回一个token(42)，其实这个42是ASCII到“*”。此时m_ptr参数值为“ from t1”。再次执行MY_LEX_START过程，会设置状态机为MY_LEX_IDENT，执行MY_LEX_IDENT状态机后会返回token(452),可以在/mysql-8.0.28/sql/sql_yacc.h文件中查找到。对应FROM。再次执行后会返回状态机IDENT_QUOTED,最终返回状态机MY_LEX_EOL，最终返回MY_LEX_END结束	
	
	



































































































































































