---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL记录数字的存储方式


## 问题来源
如果我们查看show egnine innodb查看锁记录的时候往往会看到Innodb的数字使用类似 80000001的形式显示如下：
```
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 1; hex 31; asc 1;;
 1: len 1; hex 31; asc 1;;
 2: len 1; hex 80; asc  ;;
 3: len 8; hex 8000000000000001; asc         ;;
```
这里是一个有符号的bigint的显示。本文就来说一下这个值是这么计算出来的。本文以4字节的int为例。

## 源码部分
关于转换的部分主要集中在函数row_mysql_store_col_in_innobase_format中，我们来看一下数字的转换代码如下：
```
if (type == DATA_INT) {
        /* Store integer data in Innobase in a big-endian format,
        sign bit negated if the data is a signed integer. In MySQL,
        integers are stored in a little-endian format. */

        byte*   p = buf + col_len; //p指针指向buf的 最高地址， 反向获取数据 得到大端 buffer是

        for (;;) {
            p--;
            *p = *mysql_data; //转大端 
            if (p == buf) { //如果存储完成 
                break;
            }
            mysql_data++;
        }

        if (!(dtype->prtype & DATA_UNSIGNED)) {//如果为有符号类型

            *buf ^= 128;
        }

        ptr = buf; //PTR指向 buffer低地址
        buf += col_len;//buf指向 buffer的高地址
    } 
...
dfield_set_data(dfield, ptr, col_len); //存入dtuple中，里面很简单就是取void* 存进去进行了。
```
这里的关键部分就是对于有*buf ^= 128;这部分，实际上就是转换为大端后的最低位做一个异或操作。
最终操作为函数page_cur_tuple_insert会将这个dtuple插入到实际的数据文件其中有一个函数为rec_convert_dtuple_to_rec_comp，会获得最终的物理记录，其中的代码memcpy(end, dfield_get_data(field), len);可以看到实际存入物理记录的就是这里的转换后的值。

## 实例解析
1. 有符号

正数：以数字5为例子，其4字节的表示方法为0x05 0x00 0x00 0x00，这里还是小端形式为MySQL层传入的值。Innodb转换方式如下：

从高地址开始取，转换为大端形式，转换后为
0x00 0x00 0x00 0x05
如果为有符号类型转换为大端后的最低位做一个异或操，转换为
0x80 0x00 0x00 0x05
负数：以数字-5为例子，其4字节的表示方法为0xfb 0xff 0xff 0xff（补码），这里还是小端形式为MySQL层传入的值。Innodb转换方式如下：

从高地址开始取，转换为大端，转换后为
0xff 0xff 0xff 0xfb
如果为有符号类型转换为大端后的最低位做一个异或操，转换为
0x7f 0xff 0xff 0xfb

2. 无符号
这个比较简单，直接原始值大端输出即可，不做最后的异或操作。

## 测试
我们为了测试就建立一个表如下：
```
create table testint(id int primary key);
insert into testint values(5),(-5);
```
然后使用innblock和bcview查看二进制文件中存储的方式。

转换如下：
80000005 实际记录5
000000014224 trx id
bd000000230110 roll ptr

我们可以发现我们的分析是正确，确实物理文件中也是这样存储的。





