---
layout: post
categories: [DataStructure]
description: none
keywords: DataStructure
---
# 树进阶

## 二叉树（Binary Tree）
二叉树是n(n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。

特点
- 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。
- 左子树和右子树是有顺序的，次序不能任意颠倒。
- 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

### 斜树
所有的结点只有左子树的二叉树叫做左斜树。所有结点只有右子树的二叉树叫做右斜树。

### 满二叉树（Full Binary Tree）
在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

特点：
- 叶子只能出现在最下一层。出现在其它层就不可能达成平衡。
- 非叶子结点的度一定是2。
- 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

## 完全二叉树（Complete Binary Tree）
所有叶子结点都在最后一层或倒数第二层。

最后一层的叶子结点在左边连续，倒数第二节的叶子结点在右侧连续。

## 平衡二叉树（AVL，Balanced Binary Tree）
也叫 AVL 树。 它是一颗空树或左右两个子树的高度差的绝对值不超过1。 左右两个子树均为平衡二叉树。

AVL树是最先发明的自平衡二叉查找树算法。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O（log n）。

通过自平衡操作（即旋转）构建两个子树高度差不超过1的平衡二叉树。

## 二叉搜索树（BST，Binary Search Tree）
也叫二叉查找树、二叉排序树。

若子树不空，则子树上所有节点的值均小于或等于根节点的值。

若右子树不空，则右子树所有节点的值均大于或等于根节点的值。(左右是镜像的，所以，这里看你怎么用左右了。)

左、右子树也分别为二叉排序树，或是一颗空树。

## 红黑树（Red Black Tree）
每个节点都带有颜色属性（颜色为红或黑）的平衡二叉查找树。

节点是红色或黑色。

根节点是黑色。

所有叶子结点都是黑色。

每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）。

从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

红黑树，是一种自平衡二叉查找树, 通过对任何一条从根到叶子的路径上各个节点着色的方式的限制,红黑树确保从根到叶子节点的最长路径不会是最短路径的两倍，用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决。

使用场景：

红黑树多用于搜索,插入,删除操作多的情况下

红黑树应用比较广泛：

1.广泛用在C++的STL中。map和set都是用红黑树实现的。

2.著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。

3.epoll在内核中的实现，用红黑树管理事件块

4.nginx中，用红黑树管理timer等

红黑树的性能：

红黑树的查询性能略微逊色于AVL树，因为比AVL树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较，但是，红黑树在插入和删除上完爆AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多。

红黑树和平衡二叉树区别如下：

(1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。

(2) 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。


## B 树（ B- 树 ）
B-tree（多路搜索树，并不是二叉的）是一种常见的数据结构。使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。按照翻译，B 通常认为是Balance的简称。这个数据结构一般用于数据库的索引，综合效率较高。

## B- 树
B-树 就是指 B树 ，也是一种用于查找的平衡树，但是它不是二叉树，B树可以拥有多于2个子节点，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。这种数据结构常被应用在数据库和文件系统的实作上。

定义任意非叶子结点最多只有M个儿子；且M>2。

根结点的儿子数为[2, M]。

除根结点以外的非叶子结点的儿子数为[M/2, M]。

每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）。

非叶子结点的关键字个数=指向儿子的指针个数-1。

非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]。

非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树。

所有叶子结点位于同一层。

## B+ 树
通常在多数节点在次级存储比如硬盘中的时候出现。通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了。

B+树 是 B树 的变体，也是一种多路搜索树。

其定义基本与B-树相同，除了：

非叶子结点的子树指针与关键字个数相同。

非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）。

为所有叶子结点增加一个链指针。

所有关键字都在叶子结点出现。

特性：

所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的。

不可能在非叶子结点命中。

非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。

更适合文件索引系统。














