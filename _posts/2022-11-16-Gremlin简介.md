---
layout: post
categories: [Gremlin]
description: none
keywords: Gremlin
---
# Gremlin简介
Gremlin语言是图数据库最主流的查询语言，是Apache TinkerPop框架下规范的图语言，相当于SQL之于关系型数据库。

## TinkerPop & Gremlin
TinkerPop 是一个图计算框架，用来进行实时的事务型处理，和批量的图分析，包含了一系列以 Gremlin 引擎为核心的子项目和模块。

Gremlin 是 ThinkPop3 框架下的图查询语言，支持非常多的开发语言，例如 Python、JavaScript、Groovy、Scala、Go。Gremlin是一种函数式数据流语言，可以使得用户使用简洁的方式表述复杂的属性图（property graph）的遍历或查询。每个Gremlin遍历由一系列步骤（可能存在嵌套）组成，每一步都在数据流（data stream）上执行一个原子操作。

目前我们主要用的Gremlin 语言是是 Groovy，语句类似这样：
```
// 查询andy到jack四跳以内的最短路径
g.V("andy")
.repeat(both().simplePath()).until(hasId("target_v_id")
.and().loops().is(lte(4))).hasId("jack")
.path().limit(1)
```
每一条 Gremlin 语句会被转换成一个脚本对象，交给具体的脚本引擎去执行，如上面的Gremlin-Groovy查询，涉及到的模块有：
- gremlin-core
定义了Gremlin 语句下的查询规范，由具体的图数据库实现(eg. PathProcessorStrategy.java)；；
- gremlin-groovy
基于 jsr223 实现的 groovy 脚本引擎(eg. GremlinGroovyScriptEngine.java)；
- gremlin-server
提供了 RESTFul 和 WebSocket 两种 Gremlin 查询能力(eg. GremlinServer.java)；

Gremlin还有其他的一些模块，如gremlin-console、gremlin-jsr223等，需要的可以研究一下。框架型代码和工程代码（如 mybatis、nginx 等）的风格还是不一样的，一些好的设计模式值得好好研究。

## Gremlin查询
Gremlin是 Apache TinkerPop 框架下的图遍历语言。Gremlin是一种函数式数据流语言，可以使得用户使用简洁的方式表述复杂的属性图（property graph）的遍历或查询。每个Gremlin遍历由一系列步骤（可能存在嵌套）组成，每一步都在数据流（data stream）上执行一个原子操作。

Gremlin 语言包括三个基本的操作：
- map-step：对数据流中的对象进行转换；
- filter-step：对数据流中的对象就行过滤；
- sideEffect-step：对数据流进行计算统计；

## 图基本概念
- 图Graph：指关系图。比如：同学及朋友关系图、银行转账图等。
- 顶点Vertex：一般指实体。比如：人、账户等。
- 边Edge：一般指关系。比如：朋友关系、转账动作等。
- 属性Property：顶点或边可以包含属性，比如：人的姓名、人的年龄、转账的时间。

Gremlin是一种用于描述属性图中行走的语言。图形遍历分两个步骤进行。
## 遍历源（TraversalSource）
开始节点选择(Start node selection)。所有遍历都从数据库中选择一组节点开始，这些节点充当图中行走的起点。Gremlin中的遍历是从TraversalSource开始的。 GraphTraversalSource提供了两种遍历方法。
- GraphTraversalSource.V（Object … ids）：从图形的顶点开始遍历（如果未提供id，则为所有顶点）。
- GraphTraversalSource.E（Object … ids）：从图形的边缘开始遍历（如果未提供id，则为所有边）。

## 图遍历（GraphTraversal）
走图(Walking the graph)。从上一步中选择的节点开始，遍历会沿着图形的边行进，以根据节点和边的属性和类型到达相邻的节点。遍历的最终目标是确定遍历可以到达的所有节点。您可以将图遍历视为子图描述，必须执行该子图描述才能返回节点。

V()和E()的返回类型是GraphTraversal。 GraphTraversal维护许多返回GraphTraversal的方法。GraphTraversal支持功能组合。 GraphTraversal的每种方法都称为一个步骤(step)，并且每个步骤都以五种常规方式之一调制(modulates)前一步骤的结果。
- map：将传入的遍历对象转换为另一个对象`（S→E）`。
- flatMap：将传入的遍历对象转换为其他对象的迭代器`（S\subseteq E^*S⊆E∗）`。
- filter：允许或禁止遍历器进行下一步`（S→S∪∅）`。
- sideEffect：允许遍历器保持不变，但在过程中产生一些计算上的副作用`（S↬S）`。
- branch：拆分遍历器并将其发送到遍历中的任意位置`（S→{S1→E^*，…，S_n→E^*S1→E∗，…，Sn→E∗}→E*）`。

GraphTraversal中几乎每个步骤都从MapStep，FlatMapStep，FilterStep，SideEffectStep或BranchStep扩展得到。



## 图基本操作
- V()
查询顶点，一般作为图查询的第1步，后面可以续接的语句种类繁多。
```
// 查询图中所有的顶点
// 注意：g 代表的是整个图
// 一切查询都是以图开始
g.V()
```
- E()
查询边，一般作为图查询的第1步，后面可以续接的语句种类繁多。
```
// 查询图中所有的边
g.E()
```
- id()
获取顶点、边的id。
```
// 查询所有顶点的id
g.V().id()
// 类似的，通过g.E().id()查询所有边的id。
```
- label()
获取顶点、边的label。
```
// 查询所有顶点的label
g.V().label()
```
- properties()
获取顶点、边的属性。
```
// 查询所有顶点的属性
g.V().properties()
// 类似的，通过g.E().properties()查询所有边的属性。
```
此外 properties()还可以和 key()、value()搭配使用，以获取属性的名称或值。
```
// 查询所有顶点的属性名称
g.V().properties().key()
```
- valueMap()
获取顶点、边的属性， valueMap()与 properties()不同的地方是：它们返回的结构不一样，后者将所有的属性扁平化到一个大列表里面，一个元素代表一个属性；前者保持一个顶点或一条边的属性作为一组，每一组由若干属性的键值对组成。
```
// 查询所有顶点的属性
g.V().valueMap()
```
- values()
获取顶点、边的属性值。
```
// 查询所有顶点的属性值
// 效果等同于：
// g.V().properties().value()
g.V().values()
```

## 边遍历概念
边遍历是指通过顶点来访问与其有关联边的邻接顶点（或者仅访问邻接边），边遍历是图数据库与图计算的核心。

顶点为基准的Steps：
- out(label): 
根据指定的EdgeLabel来访问顶点的OUT方向邻接点（可以是零个EdgeLabel，代表所有类型边；也可以一个或多个EdgeLabel，代表任意给定EdgeLabel的边，下同）
```
// 先查询图中所有的顶点
// 然后访问顶点的OUT方向邻接点
// 注意：out()的基准必须是顶点
g.V().out()
```
- in(label): 
根据指定的EdgeLabel来访问顶点的IN方向邻接点
- both(label): 
根据指定的EdgeLabel来访问顶点的双向邻接点
- outE(label): 
根据指定的EdgeLabel来访问顶点的OUT方向邻接边
- inE(label): 
根据指定的EdgeLabel来访问顶点的IN方向邻接边
- bothE(label): 
根据指定的EdgeLabel来访问顶点的双向邻接边

边为基准的Steps（如上图中的边“knows”）：
- outV()
访问边的出顶点（注意：这里是以边为基准，上述Step均以顶点为基准），出顶点是指边的起始顶点
- inV()
访问边的入顶点，入顶点是指边的目标顶点，也就是箭头指向的顶点
- bothV()
访问边的双向顶点
- otherV()
访问边的伙伴顶点，即相对于基准顶点而言的另一端的顶点

## has条件过滤
在众多Gremlin的语句中，有一大类是filter类型，顾名思义，就是对输入的对象进行条件判断，只有满足过滤条件的对象才可以通过filter进入下一步。

has语句是filter类型语句的代表，能够以顶点和边的属性作为过滤条件，决定哪些对象可以通过。has语句包括很多变种：
- hasLabel(labels…)
满足一个label就可以通过
- hasId(ids…)
满足一个ID就可以通过
- has(key, value)
有“key=value”property的通过
- has(label, key, value)
有“key=value”且label的通过
- has(key, predicate)
有key且对应的value满足predicate
- hasKey(keys…)
properties包含所有的key才能通过
- hasValue(values…)
properties包含所有的value才能通过
- has(key)
有这个属性的通过
- hasNot(key)
没有这个属性的通过
- has(key, traversal)
Remove the traverser if its object does not yield a result through the traversal off the property value

## 循环操作说明
循环操作是指多次执行某一部分语句，用于语句需要重复运行的场景，比如“查找朋友的朋友的朋友”，可以直接使用循环操作来完成即“查找3层朋友”，下面对具体的循环相关的Step进行说明：

- repeat()
指定要重复执行的语句，如repeat(out('friend'))
- times()
指定要重复执行的次数，如执行3次repeat(out('friend')).times(3)
- until()
指定循环终止的条件，如一直找到某个名字的朋友为止repeat(out('friend')).until(has('name','xiaofang'))
- emit()
指定循环语句的执行过程中收集数据的条件，每一步的结果只要符合条件则被收集，不指定条件时收集所有结果
- loops()
当前循环的次数，可用于控制最大循环次数等，如最多执行3次repeat(out('friend')).until(loops().is(3))

## 数据分组与去重说明
Gremlin支持对数据进行分组和去重。

数据分组是指：从某个维度上对拥有相同点的数据进行分组，比如根据年龄分组、根据出生省份分组等。

数据去重是指：去除结果集中相同的元素，或者去除在某个维度上具有相同点的数据，比如根据年龄选出一些代表，每个年龄最多只能有一个人。

- group()
对结果集进行分组，可通过by(property)来指定根据什么维度进行分组，可称维度为分组键；如果不指定维度则以元素id作为分组键，相当于重复的元素被分为一组。每一组由分组键+组内元素列表构成。如果有需要也可对每一组的元素列表进行reduce操作，依然使用by()语句，如by(count())对组内元素计数。
- groupCount()
对结果集进行分组，并统计每一组的元素个数。每一组由分组键+组内元素数量构成。
- dedup()
去除结果集中相同的元素，可通过by(property)来指定根据什么维度进行去重。
- by()
语义上一般指“根据什么维度”，与上述语句配合使用，如group().by()、dedup().by()等。也可与其它语句配合，如前面讲到的排序order().by()及路径path().by()等。

## 结果聚集与展开说明
Gremlin在路径游走的时候，可以将某一步的所有结果收集到一个集合里面（我们称之为结果聚集），以备在后续步骤中使用；此外还可在需要的时候将聚集的结果展开。

- aggregate()
聚集路径中指定步骤的所有结果，通过aggregate(label)对任意步骤打上标签，在此之前的步骤的结果均会被收集到此标签所代表的集合中（但并不会影响路径的游走），可配合by及cap一起使用，通过cap(label)来获取该结果集合，此外还可通过select(label)或without(label)等其它方式读取。
- store()
类似aggregate()，只是以Lazy的方式来收集。
- unfold()
将集合展开平铺，路径将扩张。
- fold()
将多个元素折叠为一个集合，路径将收缩。

## 路径选取与过滤说明
Gremlin支持从走过的路径里选取部分数据作为结果，并且可以在选取时进行条件过滤。

- as()+select()
对路径中结果进行选取，首先通过as(label)对任意步骤打上标签，然后使用select(label)来选取若干历史步骤的结果作为新结果。此外还可通过select().by(property)来指定根据什么维度进行选取。
- as()+where()
以条件匹配的方式进行路径结果选取，只有符合条件的路径才能被选取出来。
- as()+match()
以模式匹配的方式进行路径结果选取，只有符合模式的路径才能被选取出来。
- as()+dedup()
根据路径中的若干步骤的结果进行去重，只有首次出现的路径段才能被选取出来。

## 










