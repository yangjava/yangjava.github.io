---
layout: post
categories: [Gremlin]
description: none
keywords: Gremlin
---
# Gremlin简介
Gremlin语言是图数据库最主流的查询语言，是Apache TinkerPop框架下规范的图语言，相当于SQL之于关系型数据库。

## TinkerPop & Gremlin
TinkerPop 是一个图计算框架，用来进行实时的事务型处理，和批量的图分析，包含了一系列以 Gremlin 引擎为核心的子项目和模块。

Gremlin 是 ThinkPop3 框架下的图查询语言，支持非常多的开发语言，例如 Python、JavaScript、Groovy、Scala、Go。Gremlin是一种函数式数据流语言，可以使得用户使用简洁的方式表述复杂的属性图（property graph）的遍历或查询。每个Gremlin遍历由一系列步骤（可能存在嵌套）组成，每一步都在数据流（data stream）上执行一个原子操作。

目前我们主要用的Gremlin 语言是是 Groovy，语句类似这样：
```
// 查询andy到jack四跳以内的最短路径
g.V("andy")
.repeat(both().simplePath()).until(hasId("target_v_id")
.and().loops().is(lte(4))).hasId("jack")
.path().limit(1)
```
每一条 Gremlin 语句会被转换成一个脚本对象，交给具体的脚本引擎去执行，如上面的Gremlin-Groovy查询，涉及到的模块有：
- gremlin-core
定义了Gremlin 语句下的查询规范，由具体的图数据库实现(eg. PathProcessorStrategy.java)；；
- gremlin-groovy
基于 jsr223 实现的 groovy 脚本引擎(eg. GremlinGroovyScriptEngine.java)；
- gremlin-server
提供了 RESTFul 和 WebSocket 两种 Gremlin 查询能力(eg. GremlinServer.java)；

Gremlin还有其他的一些模块，如gremlin-console、gremlin-jsr223等，需要的可以研究一下。框架型代码和工程代码（如 mybatis、nginx 等）的风格还是不一样的，一些好的设计模式值得好好研究。

## Gremlin查询
Gremlin是 Apache TinkerPop 框架下的图遍历语言。Gremlin是一种函数式数据流语言，可以使得用户使用简洁的方式表述复杂的属性图（property graph）的遍历或查询。每个Gremlin遍历由一系列步骤（可能存在嵌套）组成，每一步都在数据流（data stream）上执行一个原子操作。

Gremlin 语言包括三个基本的操作：
- map-step：对数据流中的对象进行转换；
- filter-step：对数据流中的对象就行过滤；
- sideEffect-step：对数据流进行计算统计；

## 图基本概念
- 图Graph：指关系图。比如：同学及朋友关系图、银行转账图等。
- 顶点Vertex：一般指实体。比如：人、账户等。
- 边Edge：一般指关系。比如：朋友关系、转账动作等。
- 属性Property：顶点或边可以包含属性，比如：人的姓名、人的年龄、转账的时间。

Gremlin是一种用于描述属性图中行走的语言。图形遍历分两个步骤进行。
## 遍历源（TraversalSource）
开始节点选择(Start node selection)。所有遍历都从数据库中选择一组节点开始，这些节点充当图中行走的起点。Gremlin中的遍历是从TraversalSource开始的。 GraphTraversalSource提供了两种遍历方法。
- GraphTraversalSource.V（Object … ids）：从图形的顶点开始遍历（如果未提供id，则为所有顶点）。
- GraphTraversalSource.E（Object … ids）：从图形的边缘开始遍历（如果未提供id，则为所有边）。

## 图遍历（GraphTraversal）
走图(Walking the graph)。从上一步中选择的节点开始，遍历会沿着图形的边行进，以根据节点和边的属性和类型到达相邻的节点。遍历的最终目标是确定遍历可以到达的所有节点。您可以将图遍历视为子图描述，必须执行该子图描述才能返回节点。

V()和E()的返回类型是GraphTraversal。 GraphTraversal维护许多返回GraphTraversal的方法。GraphTraversal支持功能组合。 GraphTraversal的每种方法都称为一个步骤(step)，并且每个步骤都以五种常规方式之一调制(modulates)前一步骤的结果。
- map：将传入的遍历对象转换为另一个对象`（S→E）`。
- flatMap：将传入的遍历对象转换为其他对象的迭代器`（S\subseteq E^*S⊆E∗）`。
- filter：允许或禁止遍历器进行下一步`（S→S∪∅）`。
- sideEffect：允许遍历器保持不变，但在过程中产生一些计算上的副作用`（S↬S）`。
- branch：拆分遍历器并将其发送到遍历中的任意位置`（S→{S1→E^*，…，S_n→E^*S1→E∗，…，Sn→E∗}→E*）`。

GraphTraversal中几乎每个步骤都从MapStep，FlatMapStep，FilterStep，SideEffectStep或BranchStep扩展得到。

所有的 DSL 语句从 g 开始，最常见的查询是流式查询，V()代表所有的点，E()代表所有的边
## 图基本操作
- V()
查询所有顶点，一般作为图查询的第1步，一般需要后带过滤条件。尤其数据量大时，不建议使用不带过滤条件的g.V()查询。
```
// 查询图中所有的顶点，注意：g 代表的是整个图，一切查询都是以图开始
g.V()
// 输出点的详细信息：ID、点label、类型、属性集合。
```

- E()
查询所有顶点，一般作为图查询的第1步，一般需要后带过滤条件。尤其数据量大时，不建议使用不带过滤条件的g.E()查询。
```
// 查询图中所有的边
g.E()
// 输出边的详细信息：ID、边label、类型、源点（outV）、源点label、目标点（inV）、目标点label、属性集合。
```

- V(ids)/E(ids)
V(ids)/E(ids): 根据id查询顶点、边
```
// 根据id查询顶点
g.V('3:Gremlin', '2:TinkerPop')
// 根据id查询边
g.E('S2:TinkerPop>4>>S3:Gremlin')
```

- id()
获取顶点、边的id。
```
// 查询所有顶点的id：注意fold()步骤使用后结果输出
g.V().id()
// 查询所有边的id：注意fold()步骤使用后结果输出
g.E().id()
// Gremlin Step是作用在上一步产生的结果集上，如果上一步的结果是多个元素，那么这里id()将返回多个元素的id。
// fold()是把前一步产生的结果以集合的形式折叠起来。
```

- label()
获取顶点、边的label。
```
// 查询所有顶点的label
g.V().label()
// dedup() 去重，不去重的话返回结果是g.V()返回的结果数量，即每个顶点都输出其label
g.V().label().dedup()
```

- properties()
获取顶点、边的属性。
```
// 查询所有顶点的属性
g.V().properties()
// 类似的，通过g.E().properties()查询所有边的属性。
// 按照每个顶点依次返回每个属性，即一个顶点的一个属性返回一行。一个顶点多个属性，每个属性都返回一行。
```
此外 properties()还可以和 key()、value()搭配使用，以获取属性的名称或值。
```
// 查询所有顶点的属性名称
g.V().properties().key()

```

- valueMap()
获取顶点、边的属性， valueMap()与 properties()不同的地方是：它们返回的结构不一样，后者将所有的属性扁平化到一个大列表里面，一个元素代表一个属性；前者保持一个顶点或一条边的属性作为一组，每一组由若干属性的键值对组成。
```
// 查询所有顶点的属性
g.V().valueMap()
// g.V().valueMap().with(WithOptions.tokens)与g.V().valueMap(true)返回结果一样，推荐使用这种方式
g.V().valueMap().with(WithOptions.tokens)
// g.V().valueMap(true)与g.V().valueMap()的区别是：是否返回顶点的id和label， 前者返回顶点的id和label
g.V().valueMap(true)
// 每个顶点返回一行，所有属性在一个集合里 不返回属性的ID值 类似的，通过g.E().valueMap()查询所有边的属性
// 查询所有顶点的name属性值
g.V().valueMap('name')
```

- values()
获取顶点、边的属性值。
```
// 查询所有顶点的属性值
// 效果等同于：
// g.V().properties().value()
g.V().values()
```

- 查询所有点的数量
```
g.V().count()
```

- 查询所有边的数量
```
g.E().count()
```


## 边遍历概念
边遍历是指通过顶点来访问与其有关联边的邻接顶点（或者仅访问邻接边），边遍历是图数据库与图计算的核心。

顶点为基准的Steps：
- out(label): 
根据指定的EdgeLabel来访问顶点的OUT方向邻接点（可以是零个EdgeLabel，代表所有类型边；也可以一个或多个EdgeLabel，代表任意给定EdgeLabel的边，下同）
```
// 先查询图中所有的顶点
// 然后访问顶点的OUT方向邻接点
// 注意：out()的基准必须是顶点
g.V().out()
```

- in(label): 
根据指定的EdgeLabel来访问顶点的IN方向邻接点

- both(label): 
根据指定的EdgeLabel来访问顶点的双向邻接点

- outE(label): 
根据指定的EdgeLabel来访问顶点的OUT方向邻接边

- inE(label): 
根据指定的EdgeLabel来访问顶点的IN方向邻接边

- bothE(label): 
根据指定的EdgeLabel来访问顶点的双向邻接边

边为基准的Steps：
- outV()
访问边的出顶点（注意：这里是以边为基准，上述Step均以顶点为基准），出顶点是指边的起始顶点

- inV()
访问边的入顶点，入顶点是指边的目标顶点，也就是箭头指向的顶点

- bothV()
访问边的双向顶点

- otherV()
访问边的伙伴顶点，即相对于基准顶点而言的另一端的顶点

通用解释：
① out(string...)：根据给定的边标签来沿外向游走到相邻的那些顶点
② in(string...)：根据给定的边标签来沿内向游走到相邻的那些顶点
③ both(string...)：根据给定的边标签来双向游走到相邻的那些顶点
④ outE(string...)：根据给定的边标签来沿外向游走到相邻的那些边
⑤ inE(string...)：根据给定的边标签来沿内向游走到相邻的那些边
⑥ bothE(string...)：根据给定的边标签来双向游走到相邻的那些边
⑦ outV()：游走到外向顶点
⑧ inV()：游走到内向顶点
⑨ bothV()：游走双向定点
⑩ otherV()：游走到边的其他顶点，这些顶点不包含此顶点从哪移动来的那些顶点

## has条件过滤
在众多Gremlin的语句中，有一大类是filter类型，顾名思义，就是对输入的对象进行条件判断，只有满足过滤条件的对象才可以通过filter进入下一步。

has语句是filter类型语句的代表，能够以顶点和边的属性作为过滤条件，决定哪些对象可以通过。has语句包括很多变种：
- hasLabel(labels…)
满足一个label就可以通过
- hasId(ids…)
满足一个ID就可以通过
- has(key, value)
有“key=value”property的通过
- has(label, key, value)
有“key=value”且label的通过
- has(key, predicate)
有key且对应的value满足predicate
- hasKey(keys…)
properties包含所有的key才能通过
- hasValue(values…)
properties包含所有的value才能通过
- has(key)
有这个属性的通过
- hasNot(key)
没有这个属性的通过
- has(key, traversal)
Remove the traverser if its object does not yield a result through the traversal off the property value

## 循环操作说明
循环操作是指多次执行某一部分语句，用于语句需要重复运行的场景，比如“查找朋友的朋友的朋友”，可以直接使用循环操作来完成即“查找3层朋友”，下面对具体的循环相关的Step进行说明：

- repeat()
指定要重复执行的语句，如repeat(out('friend'))
- times()
指定要重复执行的次数，如执行3次repeat(out('friend')).times(3)
- until()
指定循环终止的条件，如一直找到某个名字的朋友为止repeat(out('friend')).until(has('name','xiaofang'))
- emit()
指定循环语句的执行过程中收集数据的条件，每一步的结果只要符合条件则被收集，不指定条件时收集所有结果
- loops()
当前循环的次数，可用于控制最大循环次数等，如最多执行3次repeat(out('friend')).until(loops().is(3))

## 数据分组与去重说明
Gremlin支持对数据进行分组和去重。

数据分组是指：从某个维度上对拥有相同点的数据进行分组，比如根据年龄分组、根据出生省份分组等。

数据去重是指：去除结果集中相同的元素，或者去除在某个维度上具有相同点的数据，比如根据年龄选出一些代表，每个年龄最多只能有一个人。

- group()
对结果集进行分组，可通过by(property)来指定根据什么维度进行分组，可称维度为分组键；如果不指定维度则以元素id作为分组键，相当于重复的元素被分为一组。每一组由分组键+组内元素列表构成。如果有需要也可对每一组的元素列表进行reduce操作，依然使用by()语句，如by(count())对组内元素计数。
- groupCount()
对结果集进行分组，并统计每一组的元素个数。每一组由分组键+组内元素数量构成。
- dedup()
去除结果集中相同的元素，可通过by(property)来指定根据什么维度进行去重。
- by()
语义上一般指“根据什么维度”，与上述语句配合使用，如group().by()、dedup().by()等。也可与其它语句配合，如前面讲到的排序order().by()及路径path().by()等。

## 结果聚集与展开说明
Gremlin在路径游走的时候，可以将某一步的所有结果收集到一个集合里面（我们称之为结果聚集），以备在后续步骤中使用；此外还可在需要的时候将聚集的结果展开。

- aggregate()
聚集路径中指定步骤的所有结果，通过aggregate(label)对任意步骤打上标签，在此之前的步骤的结果均会被收集到此标签所代表的集合中（但并不会影响路径的游走），可配合by及cap一起使用，通过cap(label)来获取该结果集合，此外还可通过select(label)或without(label)等其它方式读取。
- store()
类似aggregate()，只是以Lazy的方式来收集。
- unfold()
将集合展开平铺，路径将扩张。
- fold()
将多个元素折叠为一个集合，路径将收缩。

## 路径选取与过滤说明
Gremlin支持从走过的路径里选取部分数据作为结果，并且可以在选取时进行条件过滤。

- as()+select()
对路径中结果进行选取，首先通过as(label)对任意步骤打上标签，然后使用select(label)来选取若干历史步骤的结果作为新结果。此外还可通过select().by(property)来指定根据什么维度进行选取。
- as()+where()
以条件匹配的方式进行路径结果选取，只有符合条件的路径才能被选取出来。
- as()+match()
以模式匹配的方式进行路径结果选取，只有符合模式的路径才能被选取出来。
- as()+dedup()
根据路径中的若干步骤的结果进行去重，只有首次出现的路径段才能被选取出来。

## 插入数据
- 添加 Label 为学生的点，同时添加属性和值
```
g.addV(‘学生').property(id, '小明').property('name', '小明').property('age', 21)

g.addV('student') . property(id, '小红'). property('name', '小红').property('age', 20)
// 如果指定 id，id 不能使用‘’，属性需要将 key 引起来
```

- 再加入另外一类点课程
```
g.addV(‘课程') .property(id, '程序设计语言'). property('名称’,'程序设计语言')

g.addV(‘课程') .property(id, '数据结构'). property('名称’,'数据结构')
```

- 添加边
```
a.addE(‘认识').from(V(‘小明')).to(V(‘小红')).property('时间','20191001')
// 从 id 为小明的点出发到 id 为小红的点，小明小红认识时间是在2019年10月1号

a.addE(‘必修').from(V('小明')).to(V('程序设计语言')).property('分数’,90)
小明必修的程序设计语言分数为90
```

## 修改数据
- 更新属性值
```
g.V(‘小明').has('age').property('age',20)    //确保必须有 age 这个属性，然后将年龄这个属性值更新为20
```

- 插入属性值
```
g.V('小明').hasNot('age').property("age',20)    //确保没有 age 这个属性，然后插入age=20
```

- 插入或更新属性值
```
g.V(‘小明').property('age' ,20)  //直接拿出小明这个点，如果有 age 属性就更新，如果没有就插入
```

## 删除数据
- 删除顶点
```
g.V('testV-id').drop()按照顶点的 id 拿出点，然后删除
```

- 删除边
```
g.E('testE-id').drop()    拿出  id 为 testE 的点然后删除边
```

- 删除指定的属性
```
g.V('testV-id').properties('age','name').drop()   先拿出该点，中间可以传多个属性，例如 age，name，然后删除这些指定的属性
```

## 实战
- 导入数据
```
g.io(’/path’).read().iterate()
```

- 清空数据
```
g.V().drop()
```

- 随机顶点
```
g.V().sample()
```

- K度查询
```
g.V(‘id’).repeat(bothE().otherV().simplePath().dedup()).times(3)
```

- K度查询保存中间点
```
g.V(‘id’).store(‘x’).repeat(bothE().otherV().simplePath().dedup().aggregate(‘x’)).times(3).cap(‘x’)
```

- 连通图
```
g.V(‘id’).repeat(bothE().subgraph(‘s’).otherV().simplePath().dedup()).until(bothE().count().is(0)).cap(‘s’)
```

- 连通数
```
subGraph=g.V(‘id’).repeat(bothE().subgraph(‘s’).otherV().simplePath().dedup()).until(bothE().count().is(0)).cap(‘s’).next();sg=traversal().withEmbedded(subGraph);sg.V().count()
```

- 最短路径
```
g.V(‘id1’).store(‘s’).repeat(bothE().otherV().where(without(‘s’)).aggregate(‘s’)).until(hasId(‘id2’)).limit(1).path()
```

- 新增顶点和边
```
g.addV(‘label1’).property(id,‘id1’).addV(‘label2’).property(id,‘id2’).addE(‘elabel’).property(id,‘id3’).from(__.V(‘id1’)).to(__.V(‘id2’))
```

- 新增边
```
g.addE(‘label1’).property(id,‘id1’).from(g.V(‘v1’).next()).to(g.V(‘v2’).next()).iterate();g.addE(‘label2’).property(id,‘id2’).from(g.V(‘v1’).next()).to(g.V(‘v2’).next()).iterate();
```











