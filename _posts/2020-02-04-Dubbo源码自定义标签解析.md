---
layout: post
categories: [Dubbo]
description: none
keywords: Dubbo
---
# Dubbo源码自定义标签解析
Dubbo框架会集成Spring的能力，在以XML方式配置信息时，会用自定义的处理器DubboNamespaceHandler和解析器DubboBeanDefinitionParser对XML进行解析，生成对应的Bean对象和Config对象。

## 
我们从dubbo标签的解析开始分析源码：

DubboNamespaceHandler：
```
public void init() {
    registerBeanDefinitionParser("application", new DubboBeanDefinitionParser(ApplicationConfig.class, true));
    registerBeanDefinitionParser("module", new DubboBeanDefinitionParser(ModuleConfig.class, true));
    registerBeanDefinitionParser("registry", new DubboBeanDefinitionParser(RegistryConfig.class, true));
    registerBeanDefinitionParser("monitor", new DubboBeanDefinitionParser(MonitorConfig.class, true));
    registerBeanDefinitionParser("provider", new DubboBeanDefinitionParser(ProviderConfig.class, true));
    registerBeanDefinitionParser("consumer", new DubboBeanDefinitionParser(ConsumerConfig.class, true));
    registerBeanDefinitionParser("protocol", new DubboBeanDefinitionParser(ProtocolConfig.class, true));
    registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));
    registerBeanDefinitionParser("reference", new DubboBeanDefinitionParser(ReferenceBean.class, false));
    registerBeanDefinitionParser("annotation", new DubboBeanDefinitionParser(AnnotationBean.class, true));
}
```
我们看到，dubbo的各个标签都是通过DubboBeanDefinitionParser来解析的，我们来分析解析的过程：

### init()方法解析：
重写Spring NamespaceHandler的init()方法， 在解析XML中的命名空间url时，如xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"，会调用init()方法，

调用的地方org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver#resolve

### registerBeanDefinitionParser()方法解析：
重写Spring NamespaceHandlerSupport#registerBeanDefinitionParser()方法。将元素名，如"application"与对应的解析器按键值对存储起来 Map<String, BeanDefinitionParser> parsers

注册以后当前对象DubboNamespaceHandler从NamespaceHandlerSupport继承的私有成员变量parsers就有相关值了

DubboBeanDefinitionParser：
```
public BeanDefinition parse(Element element, ParserContext parserContext) {
    /* 解析 */
    return parse(element, parserContext, beanClass, required);
}
```

主要成员变量分析
```
private final Class<?> beanClass; // Bean对应的Class类（即Config的Class类）
private final boolean required;   // 是否必须（即Config类的id是否必须）
```

DubboBeanDefinitionParser：
```java
public class DubboBeanDefinitionParser {
    private static BeanDefinition parse(Element element, ParserContext parserContext, Class<?> beanClass, boolean required) {
        RootBeanDefinition beanDefinition = new RootBeanDefinition(); //创建spring的Bean实例
        beanDefinition.setBeanClass(beanClass); // 根据构造方法传入的类型设置beanClass
        beanDefinition.setLazyInit(false); //设置是否延迟初始化，false：在spring容器启动时，就会创建Bean实例
        String id = element.getAttribute("id"); //解析属性id的值
        // 如果id属性为空，并且构造方法传入的required为true
        if ((id == null || id.length() == 0) && required) {
            // 生成的beanName默认为name属性值
            String generatedBeanName = element.getAttribute("name");
            // 如果name属性为空
            if (generatedBeanName == null || generatedBeanName.length() == 0) {
                if (ProtocolConfig.class.equals(beanClass)) {
                    // 如果解析的是<dubbo:protocol/>标签，设置beanName为dubbo
                    generatedBeanName = "dubbo";
                } else {
                    // 否则beanName赋值为interface属性值
                    generatedBeanName = element.getAttribute("interface");
                }
            }
            // bean的名称如：class org.apache.dubbo.config.ApplicationConfig
            if (generatedBeanName == null || generatedBeanName.length() == 0) {
                // 如果beanName还是为空，则将其设置为beanClass的名称
                generatedBeanName = beanClass.getName();
            }
            id = generatedBeanName; // 将beanName赋值给id
            int counter = 2;
            // 循环判断如果当前Spring上下文中包含当前id，则将id拼接递增数字后缀
            // 若bean已存在，则加上计数标识，直到没有重复的id为止
            while (parserContext.getRegistry().containsBeanDefinition(id)) {
                // count++的值从2开始递增，变量count在前，count++就是加之前的值
                id = generatedBeanName + (counter++);
            }
        }
        if (id != null && id.length() > 0) {
            // 如果到这里判断如果当前Spring上下文中包含当前bean id，则抛出bean id冲突的异常
            if (parserContext.getRegistry().containsBeanDefinition(id)) {
                throw new IllegalStateException("Duplicate spring bean id " + id);
            }
            // 注册BeanDefinition
            parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);
            // 添加id属性值
            beanDefinition.getPropertyValues().addPropertyValue("id", id);
        }
        // 对指定的bean进行处理，如ProtocolConfig、ServiceBean、ProviderConfig、ConsumerConfig等
        // <dubbo:protocol/>标签
        if (ProtocolConfig.class.equals(beanClass)) {
            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {
                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);
                PropertyValue property = definition.getPropertyValues().getPropertyValue("protocol");
                // 遍历所有的BeanDefinition，判断是否有protocol属性
                if (property != null) {
                    Object value = property.getValue();
                    if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {
                        // 如果有并且是ProtocolConfig类型则为其添加对当前bean id的依赖
                        definition.getPropertyValues().addPropertyValue("protocol", new RuntimeBeanReference(id));
                    }
                }
            }
            // <dubbo:service/>标签
        } else if (ServiceBean.class.equals(beanClass)) {
            // 获取class属性 //在<dubbo:service/>中设置class属性时进入
            String className = element.getAttribute("class");
            if (className != null && className.length() > 0) {
                // 构建配置的class的BeanDefinition
                RootBeanDefinition classDefinition = new RootBeanDefinition();
                // 设置beanClass
                classDefinition.setBeanClass(ReflectUtils.forName(className));
                classDefinition.setLazyInit(false);
                /* 解析<property/>子标签 */
                parseProperties(element.getChildNodes(), classDefinition);
                // 添加ServiceBean ref属性的依赖
                // 此处的bean实例，会在bean的名称后面加上Impl，如：org.apache.dubbo.demo.DemoService + "Impl"，对应的实现类是org.apache.dubbo.demo.DemoServiceImpl
                beanDefinition.getPropertyValues().addPropertyValue("ref", new BeanDefinitionHolder(classDefinition, id + "Impl"));
            }
            // <dubbo:provider/>标签
            // 对<dubbo:provider> 中的嵌套<dubbo:service> 元素进行解析
        } else if (ProviderConfig.class.equals(beanClass)) {
            /* 解析嵌套的元素 */
            parseNested(element, parserContext, ServiceBean.class, true, "service", "provider", id, beanDefinition);
            // <dubbo:consumer/>标签
            // 对<dubbo:consumer> 中的嵌套<dubbo:reference> 元素进行解析
        } else if (ConsumerConfig.class.equals(beanClass)) {
            /* 解析嵌套的元素 */
            parseNested(element, parserContext, ReferenceBean.class, false, "reference", "consumer", id, beanDefinition);
        }
        Set<String> props = new HashSet<String>();
        ManagedMap parameters = null;
        // 遍历beanClass的方法
        for (Method setter : beanClass.getMethods()) {
            String name = setter.getName();
            // 判断是否是public的有参数的setter方法
            if (name.length() > 3 && name.startsWith("set")
                    && Modifier.isPublic(setter.getModifiers())
                    && setter.getParameterTypes().length == 1) {
                Class<?> type = setter.getParameterTypes()[0];
                // 将setter驼峰命名去掉set后转成-连接的命名，如setApplicationContext --> application-context
                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), "-");
                props.add(property);
                Method getter = null;
                try {
                    // 获取对应属性的getter方法
                    getter = beanClass.getMethod("get" + name.substring(3), new Class<?>[0]);
                } catch (NoSuchMethodException e) {
                    try {
                        // boolean类型的属性的getter方法可能以is开头
                        getter = beanClass.getMethod("is" + name.substring(3), new Class<?>[0]);
                    } catch (NoSuchMethodException e2) {
                    }
                }
                // 如果没有getter方法或者getter方法不是public修饰符或者setter方法的参数类型与getter方法的返回值类型不同，直接忽略
                if (getter == null
                        || !Modifier.isPublic(getter.getModifiers())
                        || !type.equals(getter.getReturnType())) {
                    continue;
                }
                if ("parameters".equals(property)) {
                    /* parameters属性解析 */
                    parameters = parseParameters(element.getChildNodes(), beanDefinition);
                } else if ("methods".equals(property)) {
                    /* methods属性解析 */
                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);
                } else if ("arguments".equals(property)) {
                    /* arguments属性解析 */
                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);
                } else {
                    // 获取元素中的对应属性值
                    String value = element.getAttribute(property);
                    if (value != null) {
                        value = value.trim();
                        if (value.length() > 0) {
                            // registry属性设置为N/A
                            if ("registry".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {
                                RegistryConfig registryConfig = new RegistryConfig();
                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);
                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);
                            } else if ("registry".equals(property) && value.indexOf(',') != -1) {
                                /* 多值registry设置 */
                                parseMultiRef("registries", value, beanDefinition, parserContext);
                            } else if ("provider".equals(property) && value.indexOf(',') != -1) {
                                /* 多值provider设置 */
                                parseMultiRef("providers", value, beanDefinition, parserContext);
                            } else if ("protocol".equals(property) && value.indexOf(',') != -1) {
                                /* 多值protocol设置 */
                                parseMultiRef("protocols", value, beanDefinition, parserContext);
                            } else {
                                Object reference;
                                // 判断方法的参数是否是基本类型，包括包装类型
                                if (isPrimitive(type)) {
                                    if ("async".equals(property) && "false".equals(value)
                                            || "timeout".equals(property) && "0".equals(value)
                                            || "delay".equals(property) && "0".equals(value)
                                            || "version".equals(property) && "0.0.0".equals(value)
                                            || "stat".equals(property) && "-1".equals(value)
                                            || "reliable".equals(property) && "false".equals(value)) {
                                        // 向后兼容旧版本的xsd中的默认值
                                        value = null;
                                    }
                                    reference = value;
                                    // protocol属性
                                } else if ("protocol".equals(property)
                                        && ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)
                                        && (!parserContext.getRegistry().containsBeanDefinition(value)
                                        || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) {
                                    if ("dubbo:provider".equals(element.getTagName())) {
                                        logger.warn("Recommended replace <dubbo:provider protocol=\"" + value + "\" ... /> to <dubbo:protocol name=\"" + value + "\" ... />");
                                    }
                                    ProtocolConfig protocol = new ProtocolConfig();
                                    protocol.setName(value);
                                    reference = protocol;
                                    // onreturn属性
                                } else if ("onreturn".equals(property)) {
                                    int index = value.lastIndexOf(".");
                                    String returnRef = value.substring(0, index);
                                    String returnMethod = value.substring(index + 1);
                                    reference = new RuntimeBeanReference(returnRef);
                                    // 添加onreturnMethod属性值
                                    beanDefinition.getPropertyValues().addPropertyValue("onreturnMethod", returnMethod);
                                    // onthrow属性
                                } else if ("onthrow".equals(property)) {
                                    int index = value.lastIndexOf(".");
                                    String throwRef = value.substring(0, index);
                                    String throwMethod = value.substring(index + 1);
                                    reference = new RuntimeBeanReference(throwRef);
                                    // 添加onthrowMethod属性值
                                    beanDefinition.getPropertyValues().addPropertyValue("onthrowMethod", throwMethod);
                                } else {
                                    // 校验ref属性依赖的bean必须是单例的
                                    if ("ref".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {
                                        BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);
                                        if (!refBean.isSingleton()) {
                                            throw new IllegalStateException("The exported service ref " + value + " must be singleton! Please set the " + value + " bean scope to singleton, eg: <bean id=\"" + value + "\" scope=\"singleton\" ...>");
                                        }
                                    }
                                    reference = new RuntimeBeanReference(value);
                                }
                                // 为相关属性添加依赖
                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);
                            }
                        }
                    }
                }
            }
        }
        // 排除掉上面解析过的，剩余的属性添加到parameters属性中
        NamedNodeMap attributes = element.getAttributes();
        int len = attributes.getLength();
        for (int i = 0; i < len; i++) {
            Node node = attributes.item(i);
            String name = node.getLocalName();
            if (!props.contains(name)) {
                if (parameters == null) {
                    parameters = new ManagedMap();
                }
                String value = node.getNodeValue();
                parameters.put(name, new TypedStringValue(value, String.class));
            }
        }
        if (parameters != null) {
            beanDefinition.getPropertyValues().addPropertyValue("parameters", parameters);
        }
        return beanDefinition;
    }

}
```
代码中的RootBeanDefinition时Spring的Bean，可以作为其他BeanDefinition的父BeanDefinition，也可以单独作为BeanDefinition，但是不能作为其他BeanDefinition的子BeanDefinition。

代码中的NamedNodeMap代表一个节点的无序列表，可以通过它们的名称进行访问。

## 解析内嵌元素
```
private static void parseNested(Element element, ParserContext parserContext, Class<?> beanClass, boolean required, String tag, String property, String ref, BeanDefinition beanDefinition) {
    NodeList nodeList = element.getChildNodes(); //获取子节点列表
    if (nodeList == null) {
        return;
    }
    boolean first = true;
    for (int i = 0; i < nodeList.getLength(); i++) { //可以有多个内嵌节点
        Node node = nodeList.item(i);
        if (!(node instanceof Element)) {
            continue;
        }
        if (tag.equals(node.getNodeName()) //带上命名空间的节点名称，如dubbo:service（按指定的tag查找Node）
                || tag.equals(node.getLocalName())) { //去掉命名空间的名称，如service
            if (first) { //有多个元素时，如<dubbo:service>，只有第一个元素才处理default值
                first = false; //处理好第一个元素后，更改该标志
                String isDefault = resolveAttribute(element, "default", parserContext); // default: 是否为缺省协议，用于多协议
                if (StringUtils.isEmpty(isDefault)) { //处理默认属性default
                    beanDefinition.getPropertyValues().addPropertyValue("default", "false");
                }
            }
            // 内部嵌套的元素，按单个元素解析的方式依次解析
            BeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required); //获取嵌套元素对应的Bean，如<dubbo:provider>中<dubbo:service>
            if (subDefinition != null && StringUtils.isNotEmpty(ref)) { //依赖的bean用RuntimeBeanReference表示
                subDefinition.getPropertyValues().addPropertyValue(property, new RuntimeBeanReference(ref));
            }
        }
    }
}
```
BeanDefinition：在Spring中，Bean的解析阶段，会把xml配制中的标签解析成Spring中的BeanDefinition对象

RuntimeBeanReference：如果一个bean依赖其它的bean，比如dubbo:service中ref，那么被依赖的bean就用RuntimeBeanReference表示（因为解析阶段，还没有依赖的bean的实例，等解析以后存在实例时，再根据RuntimeBeanReference关联）

## 解析元素属性值
```
private static void parseProperties(NodeList nodeList, RootBeanDefinition beanDefinition, ParserContext parserContext) {
    if (nodeList == null) {
        return;
    }
    for (int i = 0; i < nodeList.getLength(); i++) { //NodeList: 提供了有序节点的抽象节点的集合
        if (!(nodeList.item(i) instanceof Element)) {
            continue;
        }
        Element element = (Element) nodeList.item(i);
        if ("property".equals(element.getNodeName()) //只对属性节点处理<property>
                || "property".equals(element.getLocalName())) {
            String name = resolveAttribute(element, "name", parserContext); //解析<property>中的name属性
            if (StringUtils.isNotEmpty(name)) {
                String value = resolveAttribute(element, "value", parserContext);
                String ref = resolveAttribute(element, "ref", parserContext);
                if (StringUtils.isNotEmpty(value)) { //解析基本属性
                    beanDefinition.getPropertyValues().addPropertyValue(name, value); //属性值列表beanDefinition.getPropertyValues()， 对应<property>的值
                } else if (StringUtils.isNotEmpty(ref)) { //解析含有引用的属性，创建对应的bean
                    beanDefinition.getPropertyValues().addPropertyValue(name, new RuntimeBeanReference(ref));
                } else {
                    throw new UnsupportedOperationException("Unsupported <property name=\"" + name + "\"> sub tag, Only supported <property name=\"" + name + "\" ref=\"...\" /> or <property name=\"" + name + "\" value=\"...\" />");
                }
            }
        }
    }
}
```

## 解析参数标签
```
private static ManagedMap parseParameters(NodeList nodeList, RootBeanDefinition beanDefinition, ParserContext parserContext) {
    if (nodeList == null) { //NodeList表示一个有顺序的节点列表
        return null;
    }
    ManagedMap parameters = null; //托管的Map，用来保存map的值
    for (int i = 0; i < nodeList.getLength(); i++) { //可以有多个元素，如：<dubbo:parameter>
        if (!(nodeList.item(i) instanceof Element)) { //若元素不是Element实例，则不处理
            continue;
        }
        Element element = (Element) nodeList.item(i);
        if ("parameter".equals(element.getNodeName())
                || "parameter".equals(element.getLocalName())) { //只处理<dubbo:parameter/>
            if (parameters == null) {
                parameters = new ManagedMap();
            }
            String key = resolveAttribute(element, "key", parserContext); //解析<dubbo:parameter> 元素中的key
            String value = resolveAttribute(element, "value", parserContext); //解析<dubbo:parameter> 元素中的value
            boolean hide = "true".equals(resolveAttribute(element, "hide", parserContext));
            if (hide) { //是否隐藏，若需要隐藏，加上前缀
                key = HIDE_KEY_PREFIX + key;
            }
            parameters.put(key, new TypedStringValue(value, String.class)); //多个 <dubbo:parameter>时，若key重复，value值会被覆盖（TypedStringValue：存储了string值，已经要转换的目标类型，类型转换由bean工厂处理）
        }
    }
    return parameters; //此处没有直接添加到bean的属性中，而是在DubboBeanDefinitionParser#parse方法的最后添加的
}
```

## 问题点答疑
DubboBeanUtils#registerCommonBeans功能用途是什么？

解答：用来注册含有基本功能的bean，如DubboBootstrapApplicationListener、ReferenceAnnotationBeanPostProcessor等等 会打印出"The Infrastructure bean definition"日志

是怎样加载到自定义的DubboNamespaceHandler的？

解答：当Spring读取XML时，遇到非Spring定义XML元素时，就会查找spring.schemas和spring.handlers，在spring.handlers中配置了DubboNamespaceHandler处理器。



























