---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++多线程Linux Linux线程实现

## 线程的基础
进程是资源管理的最小单位，线程是程序执行最小单位。
每个进程有自己的数据段，代码段和堆栈段。线程通常叫做轻型的进程，它包含独立的栈和CPU寄存器状态，线程是进程的一条执行路径，每个线程共享其所属进程的所有资源，包括打开的文件，内存页面，信号标识及动态分配的内存等
因为线程和进程比起来很小，所有相对来说，线程花费更少的CPU资源
在操作系统设计上，从进程演化出线程，最主要的目的就是更好地支持多处理器，并且减少进程上下文切换的开销。

## 进程和线程的关系
线程和进程的关系：线程是属于进程的，线程运行在进程空间内，同时进程所产生的线程共享同一用户内存空间，并当进程退出时该进程所产生的线程都会被强制退出并清除。一个进程至少需要一个线程作为它的指令执行体（一般也称为主线程），进程管理着资源（比如CPU，内存，文件等等），并把线程分配到某个CPU上执行。

一般一个进程在最开始的时候是有一个线程，这个线程称为主控线程（主线程），同时可以通过主线程去创建多个线程，这种线程称为子线程。

## 线程分类了解
线程按照其调度者可分为用户级线程和内核级线程两种
用户级线程：主要解决的是上下午切换的问题，其调度过程由用户决定
内核级线程：由内核调度机制实现
现在大多数操作系统都采用用户级线程和内核级线程并存的方法
用户级线程要绑定内核级线程运行，一个进程中的内核级线程会分配到固定的时间片，用户线级程分配的时间片以内核级线程为准。
默认情况下用户级线程和内核线程是一对一，也可以多对一，这样实时性就会比较差。
当CPU分配给线程的时间片用完后但线程没有执行完毕，此时线程会从运行状态返回到就绪状态，将CPU让给其它线程使用。

## Linux线程实现
以下线程均为用户级线程，在Linux中，一般采用Pthread线程库实现线程的访问与控制，由POSIX提出，具有良好的可移植性。
Linux线程程序编译需要在gcc上链接库Pthread -Lpthread

## 线程标识
每个进程内部的不同线程都有自己的唯一表示（ID）
线程标识只在它所属的进程环境中有效。
线程标识是pthread_t数据类型
```
#include <pthread.h>
//对比两个线程是否相等 相等返回非零，否则返回零  参数是两个线程标识
int pthread_equal(pthread_t,pthread_t)
//获取调用线程的线程ID
pthread_t pthread_self(void)
//调用
pthread_t th1;
pthread_t th2;
th2= th1.pthread_self();//返回线程ID
```