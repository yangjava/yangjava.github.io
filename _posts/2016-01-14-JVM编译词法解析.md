---
layout: post
categories: [JVM]
description: none
keywords: JVM
---
# JVM编译词法解析
编译的第一步是词法解析，那么究竟什么是词法解析呢？在Java语言中，关键字相信大家都非常熟悉，所谓关键字指的就是Java API内部预定义的一些字符集合（如public、private、class等）。那么词法解析要做的事情就是将Java源码中的关键字和标示符等内容转换为符合Java语法规范的Token序列，然后按照指定的顺序规则进行匹配校验，这就是词法解析步骤。

## 调用compile()方法执行编译
在正式开始讲解javac的编译步骤之前，大家首先找到com.sun.tools.javac.main.Main类，该类中提供了一个对外完全透明的字节码编译方法compile()，这样一来开发人员便可以直接在程序中调用该方法将目标源文件编译为字节码文件。

如下所示：
```
public static void main(String[] args) {
        com.sun.tools.javac.main.Main compiler = new com.sun.tools.javac.main.
            Main("javac");
        /* 调用compile()方法执行编译 */
        compiler.compile(new String[] { "d:/Test01.java" });
    }
```
上述代码示例中，compile()方法会将目标源文件中的Java代码编译为字节码。其中compile()的方法参数是一个字符串数组，这也就意味着开发人员不仅可以编译单个Java源文件，还可以在数组中添加多个源文件路径，统一调用compile()方法执行批量编译。如下所示：
```
 /* 调用compile()方法执行批量编译 */
    compiler.compile(new String[] { "d:/Test01.java", "d:/Test02.java",
        "d:/Test03.java" });
```
不论是编译单个Java源文件还是执行批量编译，compile()方法的输出目标都会与源文件一样保持在同级目录下。也就是说，当对源文件进行成功编译后，会在同级目录下生成与源文件名称对应的字节码文件。

在此大家需要注意，compile()方法本身其实并不具备执行编译的能力，而是在运行时由它负责调用其他的编译方法最终完成字节码编译。不过了解compile()方法则是弄清楚javac编译步骤的前提。如下所示：
```
 public int compile(String[] args) {
        // 创建上下文
        Context context = new Context();
        // 上下文中放入JavacFileManager
        javacFileManager.preRegister(context);
            // can't create it until Log has been set up
        // 执行编译
        int result = compile(args, context);
        // 上面创建了一个新的上下文，
            // 所以jfm必须是JavacFileManager
        if (fileManager instanceof javacFileManager) {
            // A fresh context was created above, so jfm must be a javacFileManager
            ((javacFileManager)fileManager).close();
                }
        return result;
    }
```

### 进入JavacFileManager.preRegister(context);
```
public static void preRegister(Context context) {
		//创建一个JavacFileManager对象放入context容器
		//并通过构造方法继续对context容器进行设置
        context.put(JavaFileManager.class,
                (Factory<JavaFileManager>)c -> new JavacFileManager(c, true, null));
                //Factory<JavaFileManager>用于延迟加载
    }
```

### 进入JavacFileManager构造方法
```
public JavacFileManager(Context context, boolean register, Charset charset) {
        super(charset);
        if (register)
        //将context中对应的元素进行覆盖，消除前面延迟加载的影响
            context.put(JavaFileManager.class, this);
        //对本类进行设置，这部分内容我留到后面再提，因为如果输入为空
        //JavacFileManager类根本不会被赋值，也根本不会调用这个方法
        //其次，我们需要先讲解后面的代码，才能讲清楚这一段
        setContext(context);
    }
```
回到上文，进入compile(args, context);

### 后序会达到这个Main类的下面这个方法，核心代码如下：
```
 public Result compile(String[] args,
                          String[] classNames,
                          Context context,
                          List<JavaFileObject> fileObjects,
                          Iterable<? extends Processor> processors)
{
     // 检测到语法不对，就返回代表错误的码Result.CMDERR
    if (args.length == 0
                    && (classNames == null || classNames.length == 0)
                    && fileObjects.isEmpty()) {
                Option.HELP.process(optionHelper, "-help");
                return Result.CMDERR;
            }
    Collection<File> files;    
    // 得到要命令行中要编译的文件集合   
    files = processArgs(CommandLine.parse(args), classNames);
    fileManager = context.get(JavaFileManager.class);

    if (!files.isEmpty()) {
        // add filenames to fileObjects
        comp = JavaCompiler.instance(context);
        List<JavaFileObject> otherFiles = List.nil();
        JavacFileManager dfm = (JavacFileManager)fileManager;
        for (JavaFileObject fo : dfm.getJavaFileObjectsFromFiles(files))
            otherFiles = otherFiles.prepend(fo);
        for (JavaFileObject fo : otherFiles)
            fileObjects = fileObjects.prepend(fo);
    }
    JavaCompiler comp = null;
    
    comp = JavaCompiler.instance(context);
    
    comp.compile(fileObjects,
              classnames.toList(),
              processors);
}
```

接下来，会走入关键类com/sun/tools/javac/main/JavaCompiler.java，方法主要看compile和compile2:
```
public void compile(List<JavaFileObject> sourceFileObjects,
                        List<String> classnames,
                        Iterable<? extends Processor> processors)
{
// 初始化插入式注解处理器
initProcessAnnotations(processors);

            // These method calls must be chained to avoid memory leaks
            delegateCompiler =
                // 2.注解处理执行
                processAnnotations(
                    // 1.1 parseFiles:词法分析和语法分析
                    // 1.2 输入到符号表
                    enterTrees(stopIfError(CompileState.PARSE, parseFiles(sourceFileObjects))),
                    classnames);
            // 3.分析及字节码class文件生成
            delegateCompiler.compile2();
}
```