---
layout: post
categories: [JVM]
description: none
keywords: JVM
---
# 元数据区
Universe的初始化时会完成表示元空间的Metaspace的初始化，顺着Metaspace::global_initialize()方法的实现来学习Metaspace相关类的实现和调用关系。

## Metaspace
Metaspace的定义位于hotspot src/share/vm/memory/metaspace.hpp中，Metaspace表示用来给Klass等元数据分配内存的一个内存空间，通常称为元空间，每个ClassLoader实例包括启动类加载器都会创建一个对应的Metaspace实例，每个Metaspace实例都有一个SpaceManager实例，通过SpaceManager完成内存分配与管理。

Metaspace定义的属性如下：
- static size_t _compressed_class_space_size;  //compressed class对应的Metaspace大小
- static size_t _first_chunk_word_size;  //第一个NonClassType类型的MetaChunk的大小
- static size_t _first_class_chunk_word_size; //第一个ClassType类型的MetaChunk的大小
- static size_t _commit_alignment;  //commit内存的粒度
- static size_t _reserve_alignment;  //reserve内存的粒度
- SpaceManager* _vsm;  //NonClassType类型的元数据对应的SpaceManager
- SpaceManager* _class_vsm; //ClassType类型的元数据对应的SpaceManager
- static VirtualSpaceList* _space_list;  // NonClassType类型的元数据对应的VirtualSpaceList
- static VirtualSpaceList* _class_space_list; // ClassType类型的元数据对应的VirtualSpaceList
- static ChunkManager* _chunk_manager_metadata;   //NonClassType类型的元数据对应的ChunkManager
- static ChunkManager* _chunk_manager_class;  // ClassType类型的元数据对应的ChunkManager
- static const MetaspaceTracer* _tracer; //打印日志使用
- AllocRecord * _alloc_record_head;  //AllocRecord链表的头部元素
- AllocRecord * _alloc_record_tail; //AllocRecord链表的尾部元素
注意上述 ClassType类型的ChunkManager和VirtualSpaceList具体是指开启UseCompressedClassPointers下用来存储Class等元数据的元空间。

```
// Metaspace的定义位于hotspot src/share/vm/memory/metaspace.hpp中，Metaspace表示用来给Klass等元数据分配内存的一个内存空间，通常称为元空间，
// 每个ClassLoader实例包括启动类加载器都会创建一个对应的Metaspace实例，每个Metaspace实例都有一个SpaceManager实例，通过SpaceManager完成内存分配与管理。

class Metaspace : public CHeapObj<mtClass> {
  // 第一个NonClassType类型的MetaChunk的大小
  static size_t _first_chunk_word_size;
  // 第一个ClassType类型的MetaChunk的大小
  static size_t _first_class_chunk_word_size;

  // commit内存的粒度
  static size_t _commit_alignment;
  // reserve内存的粒度
  static size_t _reserve_alignment;

  // NonClassType类型的元数据对应的SpaceManager 
  SpaceManager* _vsm;
  SpaceManager* vsm() const { return _vsm; }

  // ClassType类型的元数据对应的SpaceManager
  SpaceManager* _class_vsm;
  SpaceManager* class_vsm() const { return _class_vsm; }

  // Allocate space for metadata of type mdtype. This is space
  // within a Metachunk and is used by
  //   allocate(ClassLoaderData*, size_t, bool, MetadataType, TRAPS)
  MetaWord* allocate(size_t word_size, MetadataType mdtype);

  // Virtual Space lists for both classes and other metadata
  // NonClassType类型的元数据对应的VirtualSpaceList
  static VirtualSpaceList* _space_list;
  // ClassType类型的元数据对应的VirtualSpaceList
  static VirtualSpaceList* _class_space_list;

  // NonClassType类型的元数据对应的ChunkManager
  static ChunkManager* _chunk_manager_metadata;
  // ClassType类型的元数据对应的ChunkManager
  static ChunkManager* _chunk_manager_class;
}
```
## ergo_initialize / global_initialize / post_initialize
ergo_initialize、global_initialize、post_initialize这三个方法都是Metaspace的初始化方法，ergo_initialize用于初始化Metaspace的各种参数，如MetaspaceSize，MaxMetaspaceSize，MinMetaspaceExpansion等；global_initialize方法用于初始化_first_chunk_word_size，_space_list，_chunk_manager_metadata等静态属性；post_initialize就调用MetaspaceGC::post_initialize方法。

三个的源码实现如下，其中DumpSharedSpaces表示将共享的Metaspace空间dump到一个文件中，给其他JVM使用，默认为false；UseCompressedOops和UseCompressedClassPointers表示使用压缩的oop指针和Klass指针，64位下默认为true；UseSharedSpaces表示使用基于文件的共享Metaspace，即不同的JVM进程通过将Metaspace映射到同一个文件实现Metaspace共享，默认为false。
```
void Metaspace::ergo_initialize() {
  if (DumpSharedSpaces) {
    // Using large pages when dumping the shared archive is currently not implemented.
    FLAG_SET_ERGO(bool, UseLargePagesInMetaspace, false);
  }
 
  size_t page_size = os::vm_page_size();
  if (UseLargePages && UseLargePagesInMetaspace) {
    page_size = os::large_page_size();
  }
 
  //初始化参数
  _commit_alignment  = page_size;
  _reserve_alignment = MAX2(page_size, (size_t)os::vm_allocation_granularity());
 
  MaxMetaspaceSize = align_size_down_bounded(MaxMetaspaceSize, _reserve_alignment);
 
  if (MetaspaceSize > MaxMetaspaceSize) {
    MetaspaceSize = MaxMetaspaceSize;
  }
 
  MetaspaceSize = align_size_down_bounded(MetaspaceSize, _commit_alignment);
 
  assert(MetaspaceSize <= MaxMetaspaceSize, "MetaspaceSize should be limited by MaxMetaspaceSize");
 
  if (MetaspaceSize < 256*K) {
    vm_exit_during_initialization("Too small initial Metaspace size");
  }
 
  MinMetaspaceExpansion = align_size_down_bounded(MinMetaspaceExpansion, _commit_alignment);
  MaxMetaspaceExpansion = align_size_down_bounded(MaxMetaspaceExpansion, _commit_alignment);
 
  CompressedClassSpaceSize = align_size_down_bounded(CompressedClassSpaceSize, _reserve_alignment);
  set_compressed_class_space_size(CompressedClassSpaceSize);
 
  //VIRTUALSPACEMULTIPLIER的值是2
  uintx min_metaspace_sz =
      VIRTUALSPACEMULTIPLIER * InitialBootClassLoaderMetaspaceSize;
  if (UseCompressedClassPointers) {
    if ((min_metaspace_sz + CompressedClassSpaceSize) >  MaxMetaspaceSize) {
      if (min_metaspace_sz >= MaxMetaspaceSize) {
        vm_exit_during_initialization("MaxMetaspaceSize is too small.");
      } else {
        FLAG_SET_ERGO(uintx, CompressedClassSpaceSize,
                      MaxMetaspaceSize - min_metaspace_sz);
      }
    }
  } else if (min_metaspace_sz >= MaxMetaspaceSize) {
    FLAG_SET_ERGO(uintx, InitialBootClassLoaderMetaspaceSize,
                  min_metaspace_sz);
  }
 
}
 
 static void set_compressed_class_space_size(size_t size) {
    _compressed_class_space_size = size;
  }
 
 
void Metaspace::global_initialize() {
  MetaspaceGC::initialize();
 
  // Initialize the alignment for shared spaces.
  int max_alignment = os::vm_allocation_granularity();
  size_t cds_total = 0;
 
  MetaspaceShared::set_max_alignment(max_alignment);
  //DumpSharedSpaces默认为false
  if (DumpSharedSpaces) {
#if INCLUDE_CDS
    MetaspaceShared::estimate_regions_size();
 
    SharedReadOnlySize  = align_size_up(SharedReadOnlySize,  max_alignment);
    SharedReadWriteSize = align_size_up(SharedReadWriteSize, max_alignment);
    SharedMiscDataSize  = align_size_up(SharedMiscDataSize,  max_alignment);
    SharedMiscCodeSize  = align_size_up(SharedMiscCodeSize,  max_alignment);
 
    // the min_misc_code_size estimate is based on MetaspaceShared::generate_vtable_methods()
    uintx min_misc_code_size = align_size_up(
      (MetaspaceShared::num_virtuals * MetaspaceShared::vtbl_list_size) *
        (sizeof(void*) + MetaspaceShared::vtbl_method_size) + MetaspaceShared::vtbl_common_code_size,
          max_alignment);
 
    if (SharedMiscCodeSize < min_misc_code_size) {
      report_out_of_shared_space(SharedMiscCode);
    }
 
    cds_total = FileMapInfo::shared_spaces_size();
    cds_total = align_size_up(cds_total, _reserve_alignment);
    _space_list = new VirtualSpaceList(cds_total/wordSize);
    _chunk_manager_metadata = new ChunkManager(SpecializedChunk, SmallChunk, MediumChunk);
 
    if (!_space_list->initialization_succeeded()) {
      vm_exit_during_initialization("Unable to dump shared archive.", NULL);
    }
 
#ifdef _LP64
    if (cds_total + compressed_class_space_size() > UnscaledClassSpaceMax) {
      vm_exit_during_initialization("Unable to dump shared archive.",
          err_msg("Size of archive (" SIZE_FORMAT ") + compressed class space ("
                  SIZE_FORMAT ") == total (" SIZE_FORMAT ") is larger than compressed "
                  "klass limit: " SIZE_FORMAT, cds_total, compressed_class_space_size(),
                  cds_total + compressed_class_space_size(), UnscaledClassSpaceMax));
    }
 
    assert(UseCompressedOops && UseCompressedClassPointers,
      "UseCompressedOops and UseCompressedClassPointers must be set");
    Universe::set_narrow_klass_base((address)_space_list->current_virtual_space()->bottom());
    if (TraceMetavirtualspaceAllocation && Verbose) {
      gclog_or_tty->print_cr("Setting_narrow_klass_base to Address: " PTR_FORMAT,
                             _space_list->current_virtual_space()->bottom());
    }
 
    Universe::set_narrow_klass_shift(0);
#endif // _LP64
#endif // INCLUDE_CDS
  } else {
#if INCLUDE_CDS
    // If using shared space, open the file that contains the shared space
    // and map in the memory before initializing the rest of metaspace (so
    // the addresses don't conflict)
    address cds_address = NULL;
    //UseSharedSpaces默认是false
    if (UseSharedSpaces) {
      FileMapInfo* mapinfo = new FileMapInfo();
      if (mapinfo->initialize() && MetaspaceShared::map_shared_spaces(mapinfo)) {
        cds_total = FileMapInfo::shared_spaces_size();
        cds_address = (address)mapinfo->region_base(0);
      } else {
        assert(!mapinfo->is_open() && !UseSharedSpaces,
               "archive file not closed or shared spaces not disabled.");
      }
    }
#endif // INCLUDE_CDS
#ifdef _LP64
    //UseCompressedClassPointers为false，DumpSharedSpaces为true时，返回true，64位下默认返回true
    if (using_class_space()) {
      if (UseSharedSpaces) {
#if INCLUDE_CDS
        char* cds_end = (char*)(cds_address + cds_total);
        cds_end = (char *)align_ptr_up(cds_end, _reserve_alignment);
        allocate_metaspace_compressed_klass_ptrs(cds_end, cds_address);
#endif
      } else {
        //以堆内存的终止地址作为起始地址申请内存，避免堆内存与Metaspace的内存地址冲突
        char* base = (char*)align_ptr_up(Universe::heap()->reserved_region().end(), _reserve_alignment);
        allocate_metaspace_compressed_klass_ptrs(base, 0);
      }
    }
#endif // _LP64
 
    //计算_first_chunk_word_size和_first_class_chunk_word_size
    _first_chunk_word_size = InitialBootClassLoaderMetaspaceSize / BytesPerWord;
    _first_chunk_word_size = align_word_size_up(_first_chunk_word_size);
    _first_class_chunk_word_size = MIN2((size_t)MediumChunk*6,
                                       (CompressedClassSpaceSize/BytesPerWord)*2);
    _first_class_chunk_word_size = align_word_size_up(_first_class_chunk_word_size);
 
    //VIRTUALSPACEMULTIPLIER的取值是2，初始化_space_list和_chunk_manager_metadata
    size_t word_size = VIRTUALSPACEMULTIPLIER * _first_chunk_word_size;
    word_size = align_size_up(word_size, Metaspace::reserve_alignment_words());
    _space_list = new VirtualSpaceList(word_size);
    _chunk_manager_metadata = new ChunkManager(SpecializedChunk, SmallChunk, MediumChunk);
    
    //_space_list初始化失败
    if (!_space_list->initialization_succeeded()) {
      vm_exit_during_initialization("Unable to setup metadata virtual space list.", NULL);
    }
  }
 
  _tracer = new MetaspaceTracer();
}
 
 // Return TRUE only if UseCompressedClassPointers is True and DumpSharedSpaces is False.
  static bool using_class_space() {
    return NOT_LP64(false) LP64_ONLY(UseCompressedClassPointers && !DumpSharedSpaces);
  }
 
 
// Try to allocate the metaspace at the requested addr.
void Metaspace::allocate_metaspace_compressed_klass_ptrs(char* requested_addr, address cds_base) {
  //校验参数
  assert(using_class_space(), "called improperly");
  assert(UseCompressedClassPointers, "Only use with CompressedKlassPtrs");
  assert(compressed_class_space_size() < KlassEncodingMetaspaceMax,
         "Metaspace size is too big");
  assert_is_ptr_aligned(requested_addr, _reserve_alignment);
  assert_is_ptr_aligned(cds_base, _reserve_alignment);
  assert_is_size_aligned(compressed_class_space_size(), _reserve_alignment);
 
  //尝试在指定起始地址处申请一段连续的内存空间
  bool large_pages = false;
  ReservedSpace metaspace_rs = ReservedSpace(compressed_class_space_size(),
                                             _reserve_alignment,
                                             large_pages,
                                             requested_addr, 0);
  if (!metaspace_rs.is_reserved()) {
#if INCLUDE_CDS
    if (UseSharedSpaces) {
      size_t increment = align_size_up(1*G, _reserve_alignment);
      char *addr = requested_addr;
      while (!metaspace_rs.is_reserved() && (addr + increment > addr) &&
             can_use_cds_with_metaspace_addr(addr + increment, cds_base)) {
        addr = addr + increment;
        metaspace_rs = ReservedSpace(compressed_class_space_size(),
                                     _reserve_alignment, large_pages, addr, 0);
      }
    }
#endif
    // 忽略起始地址，尝试重新申请，分配失败抛出异常
    if (!metaspace_rs.is_reserved()) {
      metaspace_rs = ReservedSpace(compressed_class_space_size(),
                                   _reserve_alignment, large_pages);
      if (!metaspace_rs.is_reserved()) {
        vm_exit_during_initialization(err_msg("Could not allocate metaspace: %d bytes",
                                              compressed_class_space_size()));
      }
    }
  }
 
  // If we got here then the metaspace got allocated.
  MemTracker::record_virtual_memory_type((address)metaspace_rs.base(), mtClass);
 
#if INCLUDE_CDS
  if (UseSharedSpaces && !can_use_cds_with_metaspace_addr(metaspace_rs.base(), cds_base)) {
    FileMapInfo::stop_sharing_and_unmap(
        "Could not allocate metaspace at a compatible address");
  }
#endif
  //重置narrow_klass_base和narrow_klass_shift
  set_narrow_klass_base_and_shift((address)metaspace_rs.base(),
                                  UseSharedSpaces ? (address)cds_base : 0);
  initialize_class_space(metaspace_rs);
  
  //打印日志
  if (PrintCompressedOopsMode || (PrintMiscellaneous && Verbose)) {
      print_compressed_class_space(gclog_or_tty, requested_addr);
  }
}
 
void Metaspace::set_narrow_klass_base_and_shift(address metaspace_base, address cds_base) {
  address lower_base;
  address higher_address;
#if INCLUDE_CDS
  if (UseSharedSpaces) {
    higher_address = MAX2((address)(cds_base + FileMapInfo::shared_spaces_size()),
                          (address)(metaspace_base + compressed_class_space_size()));
    lower_base = MIN2(metaspace_base, cds_base);
  } else
#endif
  {
    //lower_base是起始地址，higher_address是终止地址
    higher_address = metaspace_base + compressed_class_space_size();
    lower_base = metaspace_base;
 
    uint64_t klass_encoding_max = UnscaledClassSpaceMax << LogKlassAlignmentInBytes;
    // If compressed class space fits in lower 32G, we don't need a base.
    if (higher_address <= (address)klass_encoding_max) {
      lower_base = 0; // effectively lower base is zero.
    }
  }
 
  Universe::set_narrow_klass_base(lower_base);
 
  if ((uint64_t)(higher_address - lower_base) <= UnscaledClassSpaceMax) {
    Universe::set_narrow_klass_shift(0);
  } else {
    assert(!UseSharedSpaces, "Cannot shift with UseSharedSpaces");
    Universe::set_narrow_klass_shift(LogKlassAlignmentInBytes);
  }
}
 
void Metaspace::initialize_class_space(ReservedSpace rs) {
  // 初始化_class_space_list和_chunk_manager_class
  assert(rs.size() >= CompressedClassSpaceSize,
         err_msg(SIZE_FORMAT " != " UINTX_FORMAT, rs.size(), CompressedClassSpaceSize));
  assert(using_class_space(), "Must be using class space");
  _class_space_list = new VirtualSpaceList(rs);
  _chunk_manager_class = new ChunkManager(ClassSpecializedChunk, ClassSmallChunk, ClassMediumChunk);
 
  if (!_class_space_list->initialization_succeeded()) {
    vm_exit_during_initialization("Failed to setup compressed class space virtual space list.");
  }
}
 
void Metaspace::post_initialize() {
  MetaspaceGC::post_initialize();
}
```
## 构造和析构函数
构造函数用于初始化_vsm和_class_vsm，分配第一个Chunk；析构函数用于释放_vsm和_class_vsm。

上述构造方法的调用方ClassLoaderData::initialize_shared_metaspaces()是初始化启动类加载器使用的Metaspace，ClassLoaderData::metaspace_non_null是初始化其他的非启动类加载器使用的Metaspace，属于惰性初始化。

析构方法是在ClassLoaderData被删除时调用的。两者的源码说明如下：
```
Metaspace::Metaspace(Mutex* lock, MetaspaceType type) {
  initialize(lock, type);
}
 
Metaspace::~Metaspace() {
  //释放SpaceManager
  delete _vsm;
  if (using_class_space()) {
    delete _class_vsm;
  }
}
 
void Metaspace::initialize(Mutex* lock, MetaspaceType type) {
  //校验space_list等初始化完成
  verify_global_initialization();
 
  //初始化_vsm和_class_vsm
  _vsm = new SpaceManager(NonClassType, lock);
  if (using_class_space()) {
    _class_vsm = new SpaceManager(ClassType, lock);
  }
  
  //获取锁
  MutexLockerEx cl(SpaceManager::expand_lock(), Mutex::_no_safepoint_check_flag);
 
  //初始化第一个Chunk
  initialize_first_chunk(type, NonClassType);
  if (using_class_space()) {
    initialize_first_chunk(type, ClassType);
  }
 
  _alloc_record_head = NULL;
  _alloc_record_tail = NULL;
}
 
void Metaspace::verify_global_initialization() {
  assert(space_list() != NULL, "Metadata VirtualSpaceList has not been initialized");
  assert(chunk_manager_metadata() != NULL, "Metadata ChunkManager has not been initialized");
 
  if (using_class_space()) {
    assert(class_space_list() != NULL, "Class VirtualSpaceList has not been initialized");
    assert(chunk_manager_class() != NULL, "Class ChunkManager has not been initialized");
  }
}
 
void Metaspace::initialize_first_chunk(MetaspaceType type, MetadataType mdtype) {
  Metachunk* chunk = get_initialization_chunk(type, mdtype);
  if (chunk != NULL) {
    //chunk分配成功，将其添加到SpaceManager中，将其作为当前使用的Chunk
    get_space_manager(mdtype)->add_chunk(chunk, true);
  }
}
 
Metachunk* Metaspace::get_initialization_chunk(MetaspaceType type, MetadataType mdtype) {
  //获取初始Chunk的大小
  size_t chunk_word_size = get_space_manager(mdtype)->get_initial_chunk_size(type);
 
  //从ChunkManager管理的空闲Chunk中分配一个满足大小的chunk
  Metachunk* chunk = get_chunk_manager(mdtype)->chunk_freelist_allocate(chunk_word_size);
 
  if (chunk == NULL) {
    //查找失败从VirtualSpaceList中分配一个新的Chunk
    chunk = get_space_list(mdtype)->get_new_chunk(chunk_word_size,
                                                  get_space_manager(mdtype)->medium_chunk_bunch());
  }
 
  if (DumpSharedSpaces && chunk == NULL) {
    //记录分配失败
    report_insufficient_metaspace(MetaspaceAux::committed_bytes() + chunk_word_size * BytesPerWord);
  }
 
  return chunk;
}
 
SpaceManager* get_space_manager(MetadataType mdtype) {
    assert(mdtype != MetadataTypeCount, "MetadaTypeCount can't be used as mdtype");
    return mdtype == ClassType ? class_vsm() : vsm();
  }
 
static ChunkManager* get_chunk_manager(MetadataType mdtype) {
    assert(mdtype != MetadataTypeCount, "MetadaTypeCount can't be used as mdtype");
    return mdtype == ClassType ? chunk_manager_class() : chunk_manager_metadata();
  }
 
 static VirtualSpaceList* get_space_list(MetadataType mdtype) {
    assert(mdtype != MetadataTypeCount, "MetadaTypeCount can't be used as mdtype");
    return mdtype == ClassType ? class_space_list() : space_list();
  }
```
## allocate / deallocate
allocate方法用于从Metaspace分配内存，与之对应的有个deallocate方法释放内存，将内存作为MetaBlock放入SpaceManager的放到block_freelists中重复利用。因为Metaspace分配的都是元数据，一般不会被释放，除非对应的ClassLoader被垃圾回收掉了，所以该方法很少被调用，当对应的ClassLoader会垃圾回收掉了，对应的Metaspace的SpaceManager使用的MetaChunk会被整体归还到ChunkManager中重新分配给其他的Metaspace。

从调用方可知上述类实例都会在Metaspace中分配内存。其源码实现如下：
```

MetaWord* Metaspace::allocate(ClassLoaderData* loader_data, size_t word_size,
                              bool read_only, MetaspaceObj::Type type, TRAPS) {
  if (HAS_PENDING_EXCEPTION) {
    //不能有未处理异常
    assert(false, "Should not allocate with exception pending");
    return NULL;  // caller does a CHECK_NULL too
  }
  //loader_data不能为空
  assert(loader_data != NULL, "Should never pass around a NULL loader_data. "
        "ClassLoaderData::the_null_class_loader_data() should have been used.");
 
  // DumpSharedSpaces默认为false
  if (DumpSharedSpaces) {
    assert(type > MetaspaceObj::UnknownType && type < MetaspaceObj::_number_of_types, "sanity");
    Metaspace* space = read_only ? loader_data->ro_metaspace() : loader_data->rw_metaspace();
    MetaWord* result = space->allocate(word_size, NonClassType);
    if (result == NULL) {
      report_out_of_shared_space(read_only ? SharedReadOnly : SharedReadWrite);
    }
    if (PrintSharedSpaces) {
      space->record_allocation(result, type, space->vsm()->get_raw_word_size(word_size));
    }
 
    // Zero initialize.
    Copy::fill_to_aligned_words((HeapWord*)result, word_size, 0);
 
    return result;
  }
 
  MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;
 
  //获取ClassLoaderData的_metaspace，然后分配内存
  MetaWord* result = loader_data->metaspace_non_null()->allocate(word_size, mdtype);
 
  if (result == NULL) {
    //报告分配事变
    tracer()->report_metaspace_allocation_failure(loader_data, word_size, type, mdtype);
    if (is_init_completed()) {
      //启动完成通过GC释放部分内存，然后尝试重新分配
      result = Universe::heap()->collector_policy()->satisfy_failed_metadata_allocation(
          loader_data, word_size, mdtype);
    }
  }
 
  if (result == NULL) {
    //报告分配失败，会对外抛出异常
    report_metadata_oome(loader_data, word_size, type, mdtype, CHECK_NULL);
  }
 
  //将分配的内存初始化成0
  Copy::fill_to_aligned_words((HeapWord*)result, word_size, 0);
 
  return result;
}
 
MetaWord* Metaspace::allocate(size_t word_size, MetadataType mdtype) {
  //通过SpaceManager分配内存
  if (is_class_space_allocation(mdtype)) {
    return  class_vsm()->allocate(word_size);
  } else {
    return  vsm()->allocate(word_size);
  }
}
 
void Metaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {
  //如果在安全点
  if (SafepointSynchronize::is_at_safepoint()) {
     //DumpSharedSpaces默认为false
    if (DumpSharedSpaces && PrintSharedSpaces) {
      record_deallocation(ptr, vsm()->get_raw_word_size(word_size));
    }
    //校验必须是VM Thread
    assert(Thread::current()->is_VM_thread(), "should be the VM thread");
    //获取锁
    MutexLockerEx ml(vsm()->lock(), Mutex::_no_safepoint_check_flag);
    //如果word_size过小则不处理
    if (word_size < TreeChunk<Metablock, FreeList<Metablock> >::min_size()) {
      // Dark matter.  Too small for dictionary.
      return;
    }
    //通过不同的SpaceManager释放，变成MetaBlock放到block_freelists中重复利用
    if (is_class && using_class_space()) {
      class_vsm()->deallocate(ptr, word_size);
    } else {
      vsm()->deallocate(ptr, word_size);
    }
  } else {
    MutexLockerEx ml(vsm()->lock(), Mutex::_no_safepoint_check_flag);
 
    if (word_size < TreeChunk<Metablock, FreeList<Metablock> >::min_size()) {
      // Dark matter.  Too small for dictionary.
      return;
    }
    if (is_class && using_class_space()) {
      class_vsm()->deallocate(ptr, word_size);
    } else {
      vsm()->deallocate(ptr, word_size);
    }
  }
}
```
## expand_and_allocate
expand_and_allocate方法用于GC结束后尝试扩展Metaspace的空间并从扩展后的Metaspace分配内存：
```
MetaWord* Metaspace::expand_and_allocate(size_t word_size, MetadataType mdtype) {
  //计算允许扩展的空间
  size_t delta_bytes = MetaspaceGC::delta_capacity_until_GC(word_size * BytesPerWord);
  assert(delta_bytes > 0, "Must be");
 
  size_t before = 0;
  size_t after = 0;
  bool can_retry = true;
  MetaWord* res;
  bool incremented;
 
  //扩展失败依然尝试分配内存，因为扩展失败可能是因为其他线程已经完成了扩展
  do {
    incremented = MetaspaceGC::inc_capacity_until_GC(delta_bytes, &after, &before, &can_retry);
    res = allocate(word_size, mdtype);
  } while (!incremented && res == NULL && can_retry);
 
  if (incremented) {
    //记录扩展成功
    tracer()->report_gc_threshold(before, after,
                                  MetaspaceGCThresholdUpdater::ExpandAndAllocate);
    if (PrintGCDetails && Verbose) {
      gclog_or_tty->print_cr("Increase capacity to GC from " SIZE_FORMAT
          " to " SIZE_FORMAT, before, after);
    }
  }
 
  return res;
}
 
MetaWord* Metaspace::allocate(size_t word_size, MetadataType mdtype) {
  if (is_class_space_allocation(mdtype)) {
    return  class_vsm()->allocate(word_size);
  } else {
    return  vsm()->allocate(word_size);
  }
}
```

## 数据结构
从Java8开始，JVM中的永久代被替换为了metaspace，本文将根据JVM源码对metaspace的初始化、分配内存、释放内存三个主要过程进行解析。

在metaspace中有如下一些概念，metaspace、classLoaderMetaspace、virtualSpace、metachunk、chunkManager、spaceManager、metablock。首先来看看各个数据结构中的内容，

metaspace
```
// hotspot/share/memory/metaspace.hpp
class Metaspace : public AllStatic {
  static metaspace::VirtualSpaceList* _space_list;
  static metaspace::VirtualSpaceList* _class_space_list;

  static metaspace::ChunkManager* _chunk_manager_metadata;
  static metaspace::ChunkManager* _chunk_manager_class;
}
```
Metaspace是一个只包含静态属性和静态方法的类，看上去更像是一个工具类。在里面重要包含了VirtualSpaceList和ChunkManager，不难看出VirtualSpaceList及ChunkManager是全局共享的。

## space_list和class_space_list的区别
这两者分别对应了一片内存区域，从名称中可以看出class_space_list是用来存储java中class的数据的。但事实上，不完全正确，只有当压缩指针生效的时候，class_space_list才会存在，否则class数据也同样会存储在space_list中。也就是说其实JVM的metaspace区域其实分为两块——Class区域和NonClass区域。

同理，chunk_manager_metadata对应了NonClass，chunk_manager_class对应了Class。

## classLoaderMetaspace
在Java中，每个ClassLoader实例(包括bootstrapClassLoader)都会在metaspace中拥有一块独立的区域，叫做classLoaderMetaspace。
classLoaderMetaspace的数据结构如下：
```
class ClassLoaderMetaspace : public CHeapObj<mtClass> {
  metaspace::SpaceManager* _vsm;
  metaspace::SpaceManager* _class_vsm;
}
```
每个ClassLoaderMetaspace实例都会有一个spaceManager(可能还有一个classSpaceManager)，用来处理ClassLoaderMetaspace的内存分配。

## classLoaderMetaspace类型
classLoaderMetaspace有些多种类型，分别对应了不同的ClassLoader
- StandardMetaspace 普通ClassLoader
- BootMetaspace BootstrapClassLoader
- AnonymousMetaspace 匿名ClassLoader
- ReflectionMetaspace 反射ClassLoader
不同类型的metaspace之间区别不大，主要在于他们创建的chunk大小的区别。

## virtualSpace
virtualSpace组成了为metaspace分配的空间，以链表形式共享给ClassLoaderMetaspace使用。数据结构如下：
```
class VirtualSpace {
  // Reserved area
  char* _low_boundary;
  char* _high_boundary;

  // Committed area
  char* _low;
  char* _high;
  
  // MPSS Support
  char* _lower_high;
  char* _middle_high;
  char* _upper_high;

  char* _lower_high_boundary;
  char* _middle_high_boundary;
  char* _upper_high_boundary;
}
```
在virtualSpace中划分为了上中下三个区域，如下图所示
```
-----------------  upper_high_boundary / high_boundary
| unused |      |
|--------|  上  |- upper_high
|  used  |      |
-----------------  middle_high_boundary
| unused |      |
|--------|  中  |- middle_high
|  used  |      |
-----------------  lower_high_boundary
| unused |      |
|--------|  下  |- lower_high
|  used  |      |
-----------------  low_boundary
```

## metachunk
metachunk是ClassLoaderMetaspace从VirtualSpace区域分配出来的内存，每个ClassLoaderMetaspace都会通过spaceManager持有一个metachunk列表，表明它所有持有的metaspace内存，同样的该classLoader的所有内存申请也全部是在chunk中进行。
在JVM中chunk从小到大分为了四种类型，以及其对应的chunk大小如下表，

| chunk类型	     | Class（单位：字）	 | NonClass（单位：字） |
|--------------|--------------|----------------|
| specialized	 | 128          | 128            |
| small        | 256          | 512            |
| medium       | 4K	          | 8K             |
| humongous    | 无固定大小	       | 无固定大小          |

## chunkManager
chunkManager用来那些已经释放了的chunk，用以重复使用，数据结构如下：
```
class ChunkManager : public CHeapObj<mtInternal> {
  ChunkList _free_chunks[NumberOfFreeLists];
  ChunkTreeDictionary _humongous_dictionary;
}
```
其中free_chunks[]用来存储special、small、medium三种类型的chunk，而humongous_dictionary用来存储humongous类型的chunk。前面三种是固定大小，因此直接使用数组存储，而humongous是无固定大小的，因此使用排序二叉树的形式存储。

## spaceManager
每个classLoaderMetaspace都对应一个NonClassSpaceManager和一个ClassSpaceManager，SpaceManager中存储了当前classLoaderMetaspace所使用的chunk的信息以及释放后用于重新使用的metablock列表。同时classLoaderMetaspace的内存分配最终也是由spaceManager来处理的。主要数据结构如下：
```
class SpaceManager : public CHeapObj<mtClass> {
  Metachunk* _chunk_list;
  Metachunk* _current_chunk;
  BlockFreelist* _block_freelists;
}
```
## metablock
metablock则是由metachunk中分配出来用于最终使用的内存。在spaceManager的BlockFreeList中存储了那些释放后可再次使用的block。

## 初始化过程
JVM metaspace初始化分为了metaspace和classLoaderMetaspace的初始化。我们依次来看这两者的初始化，

### metaspace初始化
metaspace的初始化分为三步，先是Arguments::apply_ergo()时调用Metaspace::ergo_initialize()，接着在universe_init()时调用Metaspace::global_initialize()，最后调用Metaspace::post_initialize()。这三步都是在JVM初始化的过程中执行。我们依次来看这三步初始化过程，

ergo_initialize
```
void Metaspace::ergo_initialize() {
  if (DumpSharedSpaces) {
    FLAG_SET_ERGO(bool, UseLargePagesInMetaspace, false);
  }

  size_t page_size = os::vm_page_size();
  if (UseLargePages && UseLargePagesInMetaspace) {
    page_size = os::large_page_size();
  }

  _commit_alignment  = page_size;
  _reserve_alignment = MAX2(page_size, (size_t)os::vm_allocation_granularity());
  
  MaxMetaspaceSize = align_down_bounded(MaxMetaspaceSize, _reserve_alignment);

  if (MetaspaceSize > MaxMetaspaceSize) {
    MetaspaceSize = MaxMetaspaceSize;
  }

  MetaspaceSize = align_down_bounded(MetaspaceSize, _commit_alignment);

  assert(MetaspaceSize <= MaxMetaspaceSize, "MetaspaceSize should be limited by MaxMetaspaceSize");

  MinMetaspaceExpansion = align_down_bounded(MinMetaspaceExpansion, _commit_alignment);
  MaxMetaspaceExpansion = align_down_bounded(MaxMetaspaceExpansion, _commit_alignment);

  CompressedClassSpaceSize = align_down_bounded(CompressedClassSpaceSize, _reserve_alignment);

  size_t min_metaspace_sz =
      VIRTUALSPACEMULTIPLIER * InitialBootClassLoaderMetaspaceSize;
  if (UseCompressedClassPointers) {
    if ((min_metaspace_sz + CompressedClassSpaceSize) >  MaxMetaspaceSize) {
      if (min_metaspace_sz >= MaxMetaspaceSize) {
        vm_exit_during_initialization("MaxMetaspaceSize is too small.");
      } else {
        FLAG_SET_ERGO(size_t, CompressedClassSpaceSize,
                      MaxMetaspaceSize - min_metaspace_sz);
      }
    }
  } else if (min_metaspace_sz >= MaxMetaspaceSize) {
    FLAG_SET_ERGO(size_t, InitialBootClassLoaderMetaspaceSize,
                  min_metaspace_sz);
  }

  set_compressed_class_space_size(CompressedClassSpaceSize);
}
```
在ergo初始化过程中主要是进行一些全局变量的设置，例如MaxMetaspaceSize、MinMetaspaceExpansion、MaxMetaspaceExpansion和CompressedClassSpaceSize。其中比较重要的就是MaxMetaspaceSize和CompressedClassSpaceSize，默认情况下CompressedClassSpaceSize的大小为1G（相见globals.hpp）。

### global_initialize
全局初始化主要是用来初始化VirtualSpaceList和ChunkManager。其中ClassVirtualSpaceList的首节点大小直接分配为CompressedClassSpaceSize（不考虑开启UseSharedSpaces模式的情况下）。而NonClassVirtualSpaceList的首节点大小则分配为4M*8/2（64位机器）或 2200K/4*2(32位机器)。源码中有很多关于对齐计算的源码，较为啰嗦，此处就不展示了。

### post_initialize
```
void Metaspace::post_initialize() {
  MetaspaceGC::post_initialize();
}
```
post初始化主要是用于MetaspaceGC的初始化。

## classLoaderMetaspace初始化
classLoaderMetaspace的初始化与metaspace的初始化不同，metaspace是在JVM启动的时候就已经初始化了，而classLoaderMetaspace的初始化则是当其对应的classLoader需要使用metaspace的时候才会进行初始化，代码如下:
```
ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
  ClassLoaderMetaspace* metaspace = OrderAccess::load_acquire(&_metaspace);
  if (metaspace == NULL) {
    MutexLockerEx ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);
    // Check if _metaspace got allocated while we were waiting for this lock.
    if ((metaspace = _metaspace) == NULL) {
      if (this == the_null_class_loader_data()) {
        assert (class_loader() == NULL, "Must be");
        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
      } else if (is_anonymous()) {
        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::AnonymousMetaspaceType);
      } else if (class_loader()->is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
      } else {
        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
      }
      OrderAccess::release_store(&_metaspace, metaspace);
    }
  }
  return metaspace;
}
```
在这段代码中我们可以看到四种ClassLoaderMetaspace类型分别与四种ClassLoader一一对应。

接下来是classLoaderMetaspace的初始化过程，
```
void ClassLoaderMetaspace::initialize(Mutex* lock, Metaspace::MetaspaceType type) {
  Metaspace::verify_global_initialization();

  DEBUG_ONLY(Atomic::inc(&g_internal_statistics.num_metaspace_births));

  _vsm = new SpaceManager(Metaspace::NonClassType, type, lock)
  if (Metaspace::using_class_space()) {
    _class_vsm = new SpaceManager(Metaspace::ClassType, type, lock);
  }

  MutexLockerEx cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);

  initialize_first_chunk(type, Metaspace::NonClassType);
  if (Metaspace::using_class_space()) {
    initialize_first_chunk(type, Metaspace::ClassType);
  }
}
```
在这段代码中我们可以看到初始化过程主要包含两个步骤，
- 创建NonClassSpaceManger(_vsm)和ClassSpaceManager(_class_vsm)
- 初始化第一个NonClassChunk和第一个ClassChunk
我们接下来重点关注一下第一个Chunk的初始化过程（简单期间，我们只关注NonClass类型的初始化，其实两者基本一样）。
```
// 代码已经过简单整理
void ClassLoaderMetaspace::initialize_first_chunk(Metaspace::MetaspaceType type, Metaspace::MetadataType mdtype) {
  size_t chunk_word_size = get_space_manager(mdtype)->get_initial_chunk_size(type);
  
  Metachunk* chunk = Metaspace::get_chunk_manager(mdtype)->chunk_freelist_allocate(chunk_word_size);

  if (chunk == NULL) {
    chunk = Metaspace::get_space_list(mdtype)->get_new_chunk(chunk_word_size,
                                                  get_space_manager(mdtype)->medium_chunk_bunch());
  }
  
  if (chunk != NULL) {
    get_space_manager(mdtype)->add_chunk(chunk, true);
  }
}
```
总体看来，初始化第一个chunk分为了三步：
- 从全局chunk_freelist中尝试分配一个chunk
- 从全局virtualSpaceList中创建一个新的chunk
- 将新的chunk添加到spaceManager中管理

不过在探究这三步之前，我们先来看看第一句代码，计算chunk大小，我们先来看看chunk大小如何计算，
```
enum ChunkSizes {    // in words.
  ClassSpecializedChunk = 128,
  SpecializedChunk = 128,
  ClassSmallChunk = 256,
  SmallChunk = 512,
  ClassMediumChunk = 4 * K,
  MediumChunk = 8 * K
};

size_t SpaceManager::adjust_initial_chunk_size(size_t requested, bool is_class_space) {
  size_t chunk_sizes[] = {
      specialized_chunk_size(is_class_space),
      small_chunk_size(is_class_space),
      medium_chunk_size(is_class_space)
  };
  for (size_t i = 0; i < ARRAY_SIZE(chunk_sizes); i++) {
    if (requested <= chunk_sizes[i]) {
      return chunk_sizes[i];
    }
  }
  return requested;
}

size_t SpaceManager::get_initial_chunk_size(Metaspace::MetaspaceType type) const {
  size_t requested;

  if (is_class()) {
    switch (type) {
      case Metaspace::BootMetaspaceType:       requested = Metaspace::first_class_chunk_word_size(); break;
      case Metaspace::AnonymousMetaspaceType:  requested = ClassSpecializedChunk; break;
      case Metaspace::ReflectionMetaspaceType: requested = ClassSpecializedChunk; break;
      default:                                 requested = ClassSmallChunk; break;
    }
  } else {
    switch (type) {
      case Metaspace::BootMetaspaceType:       requested = Metaspace::first_chunk_word_size(); break;
      case Metaspace::AnonymousMetaspaceType:  requested = SpecializedChunk; break;
      case Metaspace::ReflectionMetaspaceType: requested = SpecializedChunk; break;
      default:                                 requested = SmallChunk; break;
    }
  }

  const size_t adjusted = adjust_initial_chunk_size(requested);

  assert(adjusted != 0, "Incorrect initial chunk size. Requested: "
         SIZE_FORMAT " adjusted: " SIZE_FORMAT, requested, adjusted);

  return adjusted;
}
```
在这里我们可以看到不同类型的classLoaderMetaspace之间的区别，它们的初始chunk大小是不一样的。同时，对于Class类和NonClass类型的Chunk，它们的specialized、small、medium三档的大小值也是完全不同的。

接下来，我们重点仍然放回第一个chunk的初始化过程，此处重点关注前两步，先是第一步——从全局chunk_freelist中尝试分配一个chunk。ChunkManager::chunk_freelist_allocate(size_t word_size)中主要调用了ChunkManager::free_chunks_get方法，我们来看看具体源码，
```
// 去除了校验代码&日志代码
Metachunk* ChunkManager::free_chunks_get(size_t word_size) {
  slow_locked_verify();

  Metachunk* chunk = NULL;
  bool we_did_split_a_chunk = false;

  if (list_index(word_size) != HumongousIndex) {

    ChunkList* free_list = find_free_chunks_list(word_size);

    chunk = free_list->head();

    if (chunk == NULL) {
      ChunkIndex target_chunk_index = get_chunk_type_by_size(word_size, is_class());
      Metachunk* larger_chunk = NULL;
      ChunkIndex larger_chunk_index = next_chunk_index(target_chunk_index);
      while (larger_chunk == NULL && larger_chunk_index < NumberOfFreeLists) {
        larger_chunk = free_chunks(larger_chunk_index)->head();
        if (larger_chunk == NULL) {
          larger_chunk_index = next_chunk_index(larger_chunk_index);
        }
      }

      if (larger_chunk != NULL) {
        chunk = split_chunk(word_size, larger_chunk);
        we_did_split_a_chunk = true;
      }
    }

    if (chunk == NULL) {
      return NULL;
    }

    free_list->remove_chunk(chunk)
  } else {
    chunk = humongous_dictionary()->get_chunk(word_size);

    if (chunk == NULL) {
      return NULL;
    }
  }
  chunk->set_next(NULL);
  chunk->set_prev(NULL);
  return chunk;
}
```
简单讲解一下这段代码，内存分配分为了两种情况

specialized、small、medium三种大小的chunk
humongous类型的chunk

其中specialized、small、medium三种类型的freeChunk分别对应了三个列表，而humongou类型的freeChunk由于其大小不固定，则使用排序二叉树来存储。
非humongou类型的chunk在分配过程中如果失败，会尝试将更大的chunk进行拆分。

接下来看从全局virtualSpaceList中创建一个新的chunk的过程，
```
Metachunk* VirtualSpaceList::get_new_chunk(size_t chunk_word_size, size_t suggested_commit_granularity) {
  
  Metachunk* next = current_virtual_space()->get_chunk_vs(chunk_word_size);
  if (next != NULL) {
    return next;
  }

  const size_t size_for_padding = largest_possible_padding_size_for_chunk(chunk_word_size, this->is_class());

  size_t min_word_size       = align_up(chunk_word_size + size_for_padding, Metaspace::commit_alignment_words());
  size_t preferred_word_size = align_up(suggested_commit_granularity, Metaspace::commit_alignment_words());
  if (min_word_size >= preferred_word_size) {
    preferred_word_size = min_word_size;
  }

  bool expanded = expand_by(min_word_size, preferred_word_size);
  if (expanded) {
    next = current_virtual_space()->get_chunk_vs(chunk_word_size);
  }

   return next;
}
```
整段代码可以整理为三步：

尝试从当前virtualSpace分配chunk
扩展virtualSpace
再次尝试从当前virtualSpace分配chunk
比较让人感到好奇的是第二步，扩展virtualSpace，
```
bool VirtualSpaceList::expand_by(size_t min_words, size_t preferred_words) {

  if (!MetaspaceGC::can_expand(min_words, this->is_class())) {
    return false;
  }

  size_t allowed_expansion_words = MetaspaceGC::allowed_expansion();
  if (allowed_expansion_words < min_words) {
    return false;
  }

  size_t max_expansion_words = MIN2(preferred_words, allowed_expansion_words);

  bool vs_expanded = expand_node_by(current_virtual_space(), min_words, max_expansion_words);
  if (vs_expanded) {
     return true;
  }
  
  retire_current_virtual_space();

  size_t grow_vs_words = MAX2((size_t)VirtualSpaceSize, preferred_words);
  grow_vs_words = align_up(grow_vs_words, Metaspace::reserve_alignment_words());

  if (create_new_virtual_space(grow_vs_words)) {
    if (current_virtual_space()->is_pre_committed()) {
      return true;
    }
    return expand_node_by(current_virtual_space(), min_words, max_expansion_words);
  }

  return false;
}
```
这一步主要包含几个核心步骤：
- 尝试扩展当前virtualSpace
- 当前virtualSpace不满足要求，则将当前virtualSpace退休。这一步会将当前virtualSpace的剩余空间回收到chunk_freelist
- 创建一个新的virtualSpace

整个classLoaderMetaspace的初始化过程可以总结为如下步骤：
- 创建SpaceManager
- 初始化ClassLoaderMetaspace第一个Chunk
从全局chunk_freelist中尝试分配一个chunk
从全局virtualSpaceList中创建一个新的chunk

从当前virtualSpace尝试分配
回收当前virtualSpace剩余空间，新建一个virtualSpace并尝试分配
初始化完成，将chunk添加到spaceManager中管理

## 分配内存
对于metaspace而言，除了初始化之外，还有两个最重要的功能——分配内存和释放内存。我们先来看分配内存，
```
static bool is_class_space_allocation(MetadataType mdType) {
  return mdType == ClassType && using_class_space();
}

MetaWord* ClassLoaderMetaspace::allocate(size_t word_size, Metaspace::MetadataType mdtype) {
  if (Metaspace::is_class_space_allocation(mdtype)) {
    return  class_vsm()->allocate(word_size);
  } else {
    return  vsm()->allocate(word_size);
  }
}
```
这段代码中，我们可以看到，只有元数据类型为Class类型以及使用压缩指针的时候才会使用Class空间，否则都是使用NonClass空间。

接下来，我们继续探究vsm()->allocate(word_size)方法，
```
MetaWord* SpaceManager::allocate(size_t word_size) {
  MutexLockerEx cl(lock(), Mutex::_no_safepoint_check_flag);
  size_t raw_word_size = get_allocation_word_size(word_size);
  BlockFreelist* fl =  block_freelists();
  MetaWord* p = NULL;

  if (fl != NULL && fl->total_size() > allocation_from_dictionary_limit) {
    p = fl->get_block(raw_word_size);
  }
  if (p == NULL) {
    p = allocate_work(raw_word_size);
  }

  return p;
}
```
在这一步与之前metaspace初始化chunk有些异曲同工之处，此处也是先尝试从block_freelists中进行分配，分配失败再尝试从chunk中进行分配，逻辑几乎与上文的chunk初始化一摸一样。

block_freelists同样也是分为了小的和大的，数据结构如下：
```
class BlockFreelist : public CHeapObj<mtClass> {
  BlockTreeDictionary* const _dictionary;
  SmallBlocks* _small_blocks;
}

class SmallBlocks : public CHeapObj<mtClass> {
  FreeList<Metablock> _small_lists[_small_block_max_size - _small_block_min_size];
}
```
在small_block_max_size到small_block_min_size范围内的block通过链表来存储，更大的block则使用排序二叉树来实现。
至于chunk分配内存也如出一辙，先尝试从当前chunk分配，分配失败再新建chunk进行分配。

## 释放内存
释放内存的代码则比较简单，即直接将需要释放的内存放回block_freelist中重新使用。
```
void SpaceManager::deallocate(MetaWord* p, size_t word_size) {
  size_t raw_word_size = get_allocation_word_size(word_size);
  if (block_freelists() == NULL) {
    _block_freelists = new BlockFreelist();
  }
  block_freelists()->return_block(p, raw_word_size);
}

void BlockFreelist::return_block(MetaWord* p, size_t word_size) {
  Metablock* free_chunk = ::new (p) Metablock(word_size);
  if (word_size < SmallBlocks::small_block_max_size()) {
    small_blocks()->return_block(free_chunk, word_size);
  } else {
  	dictionary()->return_chunk(free_chunk);
	}
}
```
至此，metaspace部分的初始化，内存分配，内存释放便已结束。

