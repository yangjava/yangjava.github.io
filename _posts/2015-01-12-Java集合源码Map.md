---
layout: post
categories: [Java]
description: none
keywords: Java
---
# Java集合源码Map
Map集合属于双列集合，该集合中的信息是key-value形式。

## 简介
Map集合是一种以键值对形式存储和操作数据的数据结构，建立了key-value之间的映射关系，常用于存储和处理复杂的数据。 同时Map也是一种双列集合接口，它有多个实现类，包括HashMap、TreeMap、LinkedHashMap等，最常用的是HashMap类。

其中，HashMap是按哈希算法来实现存取键对象的，这是我们开发时最常用的Map子类，而TreeMap类则可以对键对象进行排序。

Map集合中的每个元素，都包含了一个键(key)和一个值(value)，key和value组成了键-值的映射表，我们称其为键值对。键用于唯一标识一个元素，值用于存储该元素的数据，一般情况下，这个key和value可以是任何引用类型的数据。其中，键key是无序、无下标、不重复的，最多只能有一个key为null。值value是无序、无下标、可重复的，可以有多个value为null。

并且这个key和value之间是单向的一对一关系，即通过指定的key，总能找到唯一的、确定的value。当我们想从Map中取出数据时，只要给出指定的key，就能取出对应的value。

## 特点
根据上面我们对Map概念的讲解，把Map的主要特点给大家总结如下：
- Map 和 List 不同，Map是一种双列集合；
- Map 存储的是 key-value 的映射关系；
- Map 不保证顺序 。在遍历时，遍历的顺序不一定是 put() 时放入的 key 的顺序，也不一定是 key 的排序顺序。

## 实现方式
在Java中，Map集合的实现方式主要有两种：基于哈希表和基于树结构。接下来给大家简单介绍一下基于这两种结构的Map集合。

### 基于哈希表的Map集合
基于哈希表的Map，其底层是基于哈希表作为数据结构的集合，主要的实现类是HashMap。

在HashMap中，每个元素都包含一个键和一个值。当我们在添加元素时，HashMap会根据键的哈希值计算出对应的桶(Bucket)，并将元素存储到该桶中。如果不同的键具有相同的哈希值，就会出现哈希冲突，此时HashMap会使用链表或红黑树等数据结构来解决冲突。基于哈希表的Map集合具有快速的添加、删除和查找元素的特点，但元素的顺序是不确定的。

### 基于树结构的Map集合
基于树结构的Map集合，其底层是基于红黑树作为数据结构的集合，主要的实现类是TreeMap。在TreeMap中，每个元素也都包含一个键和一个值。我们在添加元素时，TreeMap会根据键的比较结果，将元素存储到正确的位置上，使得元素可以按照键的升序或降序排列。基于树结构的Map集合，具有快速查找和遍历元素的特点，但添加和删除元素的速度较慢。

## 常用方法
Map集合的使用和其他集合类似，主要包括添加、删除、获取、遍历元素等操作。

当我们调用put(K key, V value)方法时，会把key和value进行映射并放入Map。当调用V get(K key)时，可以通过key获取到对应的value；如果key不存在，则返回null。如果我们只是想查询某个key是否存在，可以调用containsKey(K key)方法。另外我们也可以通过 Map提供的keySet()方法，获取所有key组成的集合，进而遍历Map中所有的key-value对。

下表中就是Map里的一些常用方法，大家可以记一下，这些方法在Map的各实现子类中也都存在。
```
clear()	删除Map中所有的键-值对
isEmpty()	判断Map是否为空
size()	计算Map中键/值对的数量
put()	将键/值对添加到Map中
putAll()	将所有的键/值对添加到Map中
putIfAbsent()	如果Map中不存在指定的键，则将指定的键/值对插入到Map中。
remove()	删除Map中指定键key的映射关系
containsKey()	检查Map中是否存在指定key对应的映射关系。
containsValue()	检查Map中是否存在指定的 value对应的映射关系。
replace()	替换Map中指定key对应的value。
replaceAll()	将Map中所有的映射关系替换成给定函数执行的结果。
get()	获取指定 key 对应对 value
getOrDefault()	获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
forEach()	对Map中的每个映射执行指定的操作。
entrySet()	返回Map中所有的键值对
keySet()	返回Map中所有的key键
values()	返回Map中所有的value值
merge()	添加键值对到Map中
compute()	对Map中指定key的值进行重新计算
computeIfAbsent()	对Map中指定key的值进行重新计算，如果该key不存在，则添加到Map中
computeIfPresent()	当key存在该Map时，对Map中指定key的值进行重新计算
```

## 常用实现类
Java中有多个Map接口的实现类，接下来就给大家逐一简单介绍一下。

### HashMap
HashMap是Java中最常用的Map集合实现类，它基于哈希表实现，具有快速查找键值对的优点。 HashMap的存储方式是无序的，也就是说，遍历HashMap集合时，得到的键值对顺序是不确定的。

下面是创建HashMap集合的代码示例：
```
Map<String, Integer> hashMap = new HashMap<>();
```

### TreeMap
TreeMap是Java中另一个常用的Map集合实现类，它基于红黑树实现，具有自动排序键值对的优点。TreeMap的存储方式是有序的，也就是说，遍历TreeMap集合时得到的键值对，是按照键的自然顺序或指定比较器的顺序排序的。

下面是创建TreeMap集合的代码示例：
```
Map<String, Integer> treeMap = new TreeMap<>();
```

### LinkedHashMap
LinkedHashMap是Java中另一个Map集合实现类，它继承自HashMap，并保持了插入顺序。也就是说，遍历LinkedHashMap集合时，得到的键值对的顺序是按照插入顺序排序的。

下面是创建LinkedHashMap集合的代码示例：
```
Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
```

### Hashtable
Hashtable是Java中另一个Map集合实现类，它与HashMap非常相似，但Hashtable是线程安全的。Hashtable的存储方式是无序的，也就是说，遍历Hashtable集合时，得到的键值对的顺序是不确定的。

下面是创建Hashtable集合的代码示例：
```
Map<String, Integer> hashtable = new Hashtable<>();
```
需要注意的是，由于Hashtable是线程安全的，所以在多线程环境中使用Hashtable的性能可能会较低，现在一般是建议使用ConcurrentHashMap。

### ConcurrentHashMap
ConcurrentHashMap是Java中的另一个Map集合实现类，它与Hashtable非常相似，但是ConcurrentHashMap是线程安全的，并且性能更高。ConcurrentHashMap的存储方式是无序的，也就是说，遍历ConcurrentHashMap集合时，得到的键值对的顺序是不确定的。

下面是创建ConcurrentHashMap集合的代码示例：
```
Map<String, Integer> concurrentHashMap = new ConcurrentHashMap<>();
```
需要注意的是，虽然ConcurrentHashMap是线程安全的，但仍然需要注意多线程环境下的并发问题。

下面针对各个实现类的特点做一些说明：
### HashMap
- 它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。
- HashMap 最多只允许一条记录的键为null，允许多条记录的值为null。
- HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。
- 如果需要满足线程安全 ，可以用：Collections的synchronizedMap方法使HashMap具有线程安全的能力， 或者使用ConcurrentHashMap。

### Hashtable
Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是 线程安全 的。 这个是老古董，Hashtable 不建议在代码中使用 ，

不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。

为何不建议用呢？ 任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap。后者使用了 分段保护机制，也就是 分而治之的思想。

### LinkedHashMap
LinkedHashMap是HashMap的一个子类，其优点在于： 保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时， 先得到的记录肯定是先插入的 ，也可以在构造时带参数，按照访问次序排序。

### TreeMap
TreeMap实现SortedMap接口，能够把它保存的记录根据键排序， 默认是按键值的升序排序 ，也可以 指定排序的比较器 ，

当用Iterator遍历TreeMap时，得到的记录是排过序的。 如果使用 排序的映射 ，建议使用TreeMap。 在使用TreeMap时， key必须实现Comparable接口 , 或者在构造TreeMap传入自定义的Comparator，

否则会在运行时抛出java.lang.ClassCastException类型的异常。

注意：
对于上述四种Map类型的类，要求映射中的key是不可变的。 在创建内部的Entry后， key的哈希值不会被改变。为啥呢？

如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。
```
static class Node<K,V> implements Map.Entry<K,V> {  
        final int hash;  //key的哈希值不会被改变  
        final K key; // 映射中的key是不可变的  
        V value;  
        Node<K,V> next;  
```