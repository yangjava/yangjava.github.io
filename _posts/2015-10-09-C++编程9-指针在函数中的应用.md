---
layout: post
categories: [C++]
description: none
keywords: C++
---
# C++编程指南-指针在函数中的应用

## 指针在函数中的应用
指针因其在访问内存上的灵活性而出名，而函数的任务就是读写访问内存上的数据并进行处理。当指针跟函数搭配使用时，可以大大提高函数读写数据的灵活性，增加函数的威力。指针在函数中的应用主要包括两个方面：指针作为函数参数和指针作为函数的返回值。

## 指针作为函数参数
在大多数情况下，函数之间参数的传递，都是通过传值的方式来完成的。参数的传值传递需要对参数数据进行拷贝，如果要传递的数据比较大，比如要向函数传递一个数组或者一个大体积的对象，参数的拷贝过程则会耗费较多时间而降低函数的性能。这时，利用指针可以间接访问它所指向的数据的特性，以指向这些大体积参数数据的指针作为函数参数就可以很好地解决这个问题。在函数内部，通过作为参数传递进来的指针，我们可以间接地访问到函数外的原先需要传递的大体积参数数据。这样，我们就以传递一个4个字节的指针代替了传递成千上万字节的大体积数据，但却起到了同样的向函数内传递数据的效果，避免了大体积数据的拷贝过程，自然也就提高了函数性能。使用指针作为函数参数，不仅可以向函数内传入数据，还可以向函数的调用者传出数据。在函数内部，利用指向外部参数数据的指针，我们可以读取其中的数据，实现数据向函数内的传递。同时还可以通过在函数内部修改这些数据，把函数的结果传出给调用者。下面来看一个使用指针作为函数参数的实际例子：
```
// 计算数组中所有数据元数之和
// 其中，参数pArray 和nCount分别表示数组的首地址和数组元素的个数，
// 用于向函数传入一个数组，
// pSum指向用于保存结果数据的变量，用于从函数中传出计算结果
void SumArray(int* pArray, int nCount, int* pSum )
{
	// 参数有效性检查…
	int nRes = 0; // 结果数据
	// 循环遍历整个数组，计算所有数据元数的和
	for( int i = 0; i < nCount; ++i )
	{
		// 通过pArray指针访问它所指向的函数外的nArray数组，
		// 读取其中的数据并累加到nRes中，实现向函数内传入数据
		nRes += *pArray;
		pArray++; // 指针加运算，访问数组中的下一个元素
	}

	// 通过pSum指针访问它所指向的函数外的nArraySum变量
	// 将结果数据写入这个变量，实现向函数外传出数据
	*pSum = nRes;
}

int main()
{
	// 保存结果数据的变量
	int nArraySum = 0;
	// 需要统计的数组
	int nArray[5] = { 1, 2, 3, 4, 5 };
	// 使用数组的首地址nArray传入数组，
	// 使用指向变量nArraySum的指针来接收计算结果
	SumArray(nArray, 5, &nArraySum);
	// 运算结果已经保存在nArraySum中，直接输出运算结果
	cout<<"数组中所有数据之和是 :"<<nArraySum<<endl;

	return 0;
}
```
在主函数中，我们将数组nArray 的首地址和指向保存结果数据的变量nArraySum的地址作为实际参数传递给数组求和函数SumArray()。这样在SumArray()函数中，我们就可以通过传入的数组地址访问整个数组，完成传入数据的功能。在完成统计后，又可以利用pSum指针，将结果数据直接保存到它所指向的函数外用于保存结果数据的变量nArraySum中，完成传出数据的功能。利用指针作为函数参数传递数据的本质，就是在主调函数和被调函数中，通过指向同一内存地址的不同指针访问相同的内存区域，从而实现数据的传递和交换。图7-3展示了指针作为函数参数访问相同内存区域的过程。

## 指针作为函数返回值
我们可以把指针当作一种基本数据类型，除了可以用它定义变量、作为函数参数之外，自然也可以作为函数的返回值类型。跟函数的参数传递一样，函数的返回过程同样也涉及到返回数据的拷贝，当我们需要从函数内返回某个比较大体积的数据，或者是返回数据不能被拷贝时，就可以采用返回指向这个数据的指针来代替返回数据本身。例如，在单件模式的getInstace()函数中，因为需要返回的对象不能在返回过程中被复制，所以就用指针作为它的返回值，从函数内返回指向这个对象的指针来代替返回这个对象本身：
```
// 以SalarySys*指针作为返回值
static SalarySys* getInstance()
{
	if ( nullptr == m_pInstance )
	m_pInstance = new SalarySys();

	return m_pInstance;// 返回指向SalarySys对象的指针
}
```
这里需要特别注意的是，不能把一个指向函数内局部变量的指针作为返回值。这是因为函数内部定义的局部变量在函数结束后，其生命周期已经结束，内存会被自动释放，这时它的内存地址是无意义的。如果这时仍将指向这个地址的指针作为函数返回值返回给主调函数，并在主调函数中访问这个指针所指向的数据，将产生不可预料的结果。例如，如果前面的getInstance()函数是下面这个样子，虽然能够编译通过，但是在运行的时候却可能会产生非常严重的错误：
```
// 错误的getInstance()函数
static SalarySys* getInstance()
{
	if ( nullptr == m_pInstance )
	{
		// 定义一个局部变量sys
		SalarySys sys;
		m_pInstance = &sys; // 获得局部变量的指针
	}

	return m_pInstance;// 返回指向局部的sys对象的指针

}

int main()
{
	// …
	// 获得的指针指向getInstance()函数内的局部变量sys
	SalarySys* p = SalarySys::getInstance();
	// 局部变量sys已经被销毁，对它的访问是无意义的
	p->Input();

	//…
}
```
在主函数中，我们通过getInstance()函数获得的指针指向的是函数内部的一个局部对象sys，当函数调用结束后，这个对象就会被自动销毁。如果这时仍然通过这个指针试图访问这个已经被销毁的对象，其结果是不可预料的，有可能正确，也有可能错误。而这恰恰使得这个错误具有极大的隐蔽性，时而正确时而错误，很难被发现。而要消灭这个错误的最好方法就是，牢记下面的规则：以指针为返回值的函数可以返回用new全新申请的内存地址；可以返回全局变量的地址；可以返回静态变量的地址，但就是不可以返回局部变量的地址。