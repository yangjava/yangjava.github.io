---
layout: post
categories: [Dubbo]
description: none
keywords: Dubbo
---
# Dubbo服务发布暴露流程

## ServiceConfig#doExport
上面我们可以看到 Dubbo 的服务暴露是通过ServiceConfig#doExport 方法完成，其详细代码如下：
```java
  	protected synchronized void doExport() {
        if (unexported) {
            throw new IllegalStateException("Already unexported!");
        }
        // 1. 如果已经暴露则返回
        if (exported) {
            return;
        }
        exported = true;

        if (path == null || path.length() == 0) {
            path = interfaceName;
        }
         //2.  ProviderModel 表示服务提供者模型，此对象中存储了与服务提供者相关的信息。
    	// 比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel。
    	// ApplicationModel 持有所有的 ProviderModel。
        ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), ref, interfaceClass);
        // 分组 + 版本号 + 接口 是一个服务的唯一id
        ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);
        // 3. 继续进行服务发布
        doExportUrls();
    }
```
我们这里很显然可以看到，发布工作是在 ServiceConfig#doExportUrls 中完成，其实现如下：
```java
 	private void doExportUrls() {
 		// Dubbo 支持多协议 多注册中心
 		// 1. 解析出所有注册中心
        List<URL> registryURLs = loadRegistries(true);
        // 2. 遍历协议类型，进行服务发布
        for (ProtocolConfig protocolConfig : protocols) {
            doExportUrlsFor1Protocol(protocolConfig, registryURLs);
        }
    }
```
Dubbo 允许我们使用不同的协议导出服务，也允许我们向多个注册中心注册服务。因此 Dubbo 在 ServiceConfig#doExportUrls 方法中对多协议，多注册中心进行了支持，主要逻辑在下面两个方法：
- loadRegistries(true); ：加载所有注册中心，因为Dubbo允许多协议多注册中心的实现，所以这里会解析出所有的注册中心。
- doExportUrlsFor1Protocol(protocolConfig, registryURLs); ：上面解析出了所有的注册中心，现在开始遍历协议类型，对服务进行不同注册中心的不同协议的发布。

### loadRegistries(true);
该方法加载所有注册中心，将注册中心解析成 URL 返回。由于一个服务可以被注册到多个服务注册中心，这里加载所有的服务注册中心对象。

下面我们来看详细代码：
```java
	// org.apache.dubbo.config.AbstractInterfaceConfig#loadRegistries
   protected List<URL> loadRegistries(boolean provider) {
        // check && override if necessary
        List<URL> registryList = new ArrayList<URL>();
        // 如果注册中心的配置不为空
        if (registries != null && !registries.isEmpty()) {
        	// 遍历所有注册中心
            for (RegistryConfig config : registries) {
                String address = config.getAddress();
                // 如果注册中心地址为空，则设置为 0.0.0.0
                if (StringUtils.isEmpty(address)) {
                    address = Constants.ANYHOST_VALUE;
                }
                // 排除不可用的地址 （地址信息为 N/A）
                if (!RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {
                	// 参数会拼接到map 中，最后会将map 转换成url
                    Map<String, String> map = new HashMap<String, String>();
                    /************* 1. 参数解析，将参数添加到 Map 中 **************/
                    // 添加 ApplicationConfig 中的字段信息到 map 中
                    appendParameters(map, application);
                    // 添加 RegistryConfig 字段信息到 map 中
                    appendParameters(map, config);
                     // 添加 path、pid，protocol 等信息到 map 中
                     // 设置注册中心的 path 为 RegistryService
                    map.put("path", RegistryService.class.getName());
                    // 拼接运行时参数
                    appendRuntimeParameters(map);
                    // 设置默认协议类型为 dubbo
                    if (!map.containsKey("protocol")) {
                        map.put("protocol", "dubbo");
                    }
                    /************* 2. 根据 address 和 map 将信息转化为 URL **************/
                    // 根据协议类型将map转化成URL
                    // dubbo 协议如下格式: zookeeper://localhost:2181/org.apache.dubbo.registry.RegistryService?application=Api-provider&dubbo=2.0.2&pid=24736&release=2.7.0&timestamp=1615539839228
                    // 这里返回URL 列表，因为address 可能包含多个注册中心。address 被正则切割，每个地址对应一个URL
                    List<URL> urls = UrlUtils.parseURLs(address, map);
                     /************* 3. 对 URL 进行进一步处理 **************/
                    for (URL url : urls) {
                    	// 保存服务暴露使用的注册中心的协议
                        url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());
                        // 设置 url 协议为 registry，表示当前URL 用于配置注册中心
                        url = url.setProtocol(Constants.REGISTRY_PROTOCOL);
                        // 通过判断条件，决定是否添加 url 到 registryList 中
         				// 满足两个条件会往里添加：1、是服务提供者且需要想注册中心注册；2、不是提供者但订阅了注册中心
                        if ((provider && url.getParameter(Constants.REGISTER_KEY, true))
                                || (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {
                            registryList.add(url);
                        }
                    }
                }
            }
        }
        // 返回封装好的注册中心 URL
        return registryList;
    }
```
这一步的目的是筛选并生成注册中心的URL，其逻辑如下
- 参数解析：解析ApplicationConfig、RegistryConfig 中的配置，用于作为注册中心的配置。这里会通过 AbstractConfig#appendParameters 将参数解析并保存到 Map 中。
- Map 转换 ：经过解析后， Map 中保存的是注册中心相关的信息，这里会根据 address 和 map 将信息转化为 URL。
- 对 URL 进行进一步处理 ：这里将 URL的协议类型替换为 registry，并保存了原先协议类型。

### 参数解析
```java
        Map<String, String> map = new HashMap<String, String>();
        // 解析 ApplicationConfig 中的参数保存到 map 中
        appendParameters(map, application);
        // 解析 RegistryConfig  中配的配置保存到 Map 中
        appendParameters(map, config);
        // 设置 url 的 path 为 org.apache.dubbo.registry.RegistryService
        map.put("path", RegistryService.class.getName());
        // 添加运行时参数
        appendRuntimeParameters(map);
        // 填充 protocol
        if (!map.containsKey("protocol")) {
            map.put("protocol", "dubbo");
        }

```
其中 .AbstractConfig#appendParameters 方法会获取 config 中的所有 get 方法，如下：
```java
  protected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {
        if (config == null) {
            return;
        }
        // 反射获取方法
        Method[] methods = config.getClass().getMethods();
        for (Method method : methods) {
            try {
                String name = method.getName();
                // 判断是 get 方法
                if (ClassHelper.isGetter(method)) {
                	// 如果方法被 Parameter  注解修饰，则解析  Parameter  注解
                    Parameter parameter = method.getAnnotation(Parameter.class);
                    // 返回类型为 Object || (Parameter  注解不为空且被排除在为) 直接跳过
                    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {
                        continue;
                    }
                    // 如果 Parameter  不为空，则使用 Parameter 的key为作为属性名，否则从get 方法上解析属性名
                    String key;
                    if (parameter != null && parameter.key().length() > 0) {
                        key = parameter.key();
                    } else {
                        key = calculatePropertyFromGetter(name);
                    }
                    // 执行get 方法获取值
                    Object value = method.invoke(config);
                    String str = String.valueOf(value).trim();
                    // 如果返回值不为空则将其添加到Map中
                    if (value != null && str.length() > 0) {
                        if (parameter != null && parameter.escaped()) {
                            str = URL.encode(str);
                        }
                        if (parameter != null && parameter.append()) {
                            String pre = parameters.get(Constants.DEFAULT_KEY + "." + key);
                            if (pre != null && pre.length() > 0) {
                                str = pre + "," + str;
                            }
                            pre = parameters.get(key);
                            if (pre != null && pre.length() > 0) {
                                str = pre + "," + str;
                            }
                        }
                        if (prefix != null && prefix.length() > 0) {
                            key = prefix + "." + key;
                        }
                        parameters.put(key, str);
                    } else if (parameter != null && parameter.required()) {
                    	// Parameter  标记为必须但是值为空则抛出异常
                        throw new IllegalStateException(config.getClass().getSimpleName() + "." + key + " == null");
                    }
                } else if ("getParameters".equals(name)
                        && Modifier.isPublic(method.getModifiers())
                        && method.getParameterTypes().length == 0
                        && method.getReturnType() == Map.class) {
                     // 对 getParameters 方法的特殊处理，由于 getParameters 方法返回的是个 Map，所以这里需要将整个Map 添加
                    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);
                    if (map != null && map.size() > 0) {
                        String pre = (prefix != null && prefix.length() > 0 ? prefix + "." : "");
                        for (Map.Entry<String, String> entry : map.entrySet()) {
                            parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());
                        }
                    }
                }
            } catch (Exception e) {
                throw new IllegalStateException(e.getMessage(), e);
            }
        }
    }
```
### UrlUtils#parseURLs
我们在指定多注册中心时可能通过指定格式如下：
```java
    <dubbo:registry protocol="zookeeper" address="zookeeper://localhost:2181, zookeeper://localhost:2182"/>
```
在这里我们需要将 zookeeper://localhost:2181, zookeeper://localhost:2182 的地址进行解析，分别生成 URL，其实现如下：
```java
    public static List<URL> parseURLs(String address, Map<String, String> defaults) {
        if (address == null || address.length() == 0) {
            return null;
        }
        // 将注册中心地址分割，因为注册中心可能会存在多个
        String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address);
        if (addresses == null || addresses.length == 0) {
            return null; //here won't be empty
        }
        List<URL> registries = new ArrayList<URL>();
        for (String addr : addresses) {
        	// 解析出来的每个地址和 参数 转化为 URL 
            registries.add(parseURL(addr, defaults));
        }
        return registries;
    }
```
### 对 URL 进行进一步处理
经历上面几步之后，假设当前阶段解析的URL如下：
```java
zookeeper://localhost:2181/org.apache.dubbo.registry.RegistryService?application=spring-dubbo-provider&dubbo=2.0.2&pid=10404&release=2.7.0&timestamp=1628842310884
```
下面我们看一下是如何 对 URL 进行处理的：
```java
    for (URL url : urls) {
     	// 1. 保存服务暴露使用的注册中心的协议
         url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());
         // 2. 设置 url 协议为 registry，表示当前URL 用于配置注册中心
         url = url.setProtocol(Constants.REGISTRY_PROTOCOL);
         //  3. 通过判断条件，决定是否添加 url 到 registryList 中
         // 满足两个条件会往里添加：1、是服务提供者且需要想注册中心注册；2、不是提供者但订阅了注册中心
         if ((provider && url.getParameter(Constants.REGISTER_KEY, true))
                 || (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {
             registryList.add(url);
         }
     }
```
第一步 和 第二步执行结束后URL 为：
```java
registry://localhost:2181/org.apache.dubbo.registry.RegistryService?application=spring-dubbo-provider&dubbo=2.0.2&pid=10404&registry=zookeeper&release=2.7.0&timestamp=1628842310884
```
这里可以看到第一步和第二部的目的就是 将原始 URL 的协议类型从 zookeeper 替换成 registry，并且在URL 中添加 registry=zookeeper 用于保存注册中心的协议。

这么做的目的是为了让 RegistryProtocol 来处理服务。因为在后面的代码中Dubbo会通过 Protocol#export 方法来暴露服务。而由于 Dubbo SPI机制的存在，所以 Dubbo在加载一些 SPI 接口的时候，是根据参数或者属性判断的，对于 Protocol 接口，则是通过url.getProtocol 返回的协议类型判断加载哪个实现类，而这里的协议类型是 registry，则会加载 RegistryProtocol 来处理, 而 RegistryProtocol 可以通过 registry 属性得知注册中心的真正协议 。而对于多种多样的注册中心(如 zk，nacos，redis), RegistryProtocol 会根据注册中心的实际协议类型来选择合适的 Registry 实现类来完成操作。

其中 关于 Dubbo SPI ，以 Protocol 为例， Dubbo中存在 多个实现，如 RegistryProtocol 、DubboProtocol、InjvmProtocol 等，每个实现都有一个唯一的name，如 RegistryProtocol 为 registry， DubboProtocol 为 dubbo， InjvmProtocol 为 injvm。

Dubbo 会为每个 SPI 接口生成一个适配器，用根据URL的参数来选择使用哪个实现类。如 ：对于 Protocol，Protocol$Adaptive 是 Dubbo 自动生成的针对于 Protocol 接口的适配器。在调用 Protocol#export 会先调用 Protocol$Adaptive#export ，在这个方法中会根据 Url 的协议类型选择合适的 Protocol 来处理，这里协议类型为 registry， 则会选择 RegistryProtocol 来处理服务。





















