---
layout: post
categories: Redis
description: none
keywords: Redis
---
# Redis部署

## 单机部署
优点
- 架构简单，部署方便
- 高性价比：缓存使用时无需备用节点(单实例可用性可以用 supervisor 或 crontab 保证)，当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务
- 高性能

缺点
- 不保证数据的可靠性
- 在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务
- 高性能受限于单核CPU的处理能力(Redis是单线程机制)，CPU为主要瓶颈，所以适合操作命令简单，排序/计算较少场景

## 主从复制
在分布式架构设计中，Redis是一个非常流行的NoSQL数据库。它不仅具有高性能和可扩展性，而且支持主从复制模式来提高可用性和容错性。

Redis主从复制是指通过多个Redis实例之间的数据同步机制，将一个Redis实例的所有数据自动复制到另一个或多个Redis实例上。

在主从架构中，有一个主Redis服务器和一个或多个从Redis服务器。主Redis服务器负责写操作并将数据同步到从Redis服务器上。从Redis服务器只能进行读操作，不能进行写操作。

- 主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库
- 从数据库一般都是只读的，并且接收主数据库同步过来的数据
- 一个master可以拥有多个slave，但是一个slave只能对应一个master
- slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来
- master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务
- master挂了以后，不会在slave节点中重新选一个master

### 核心原理
Redis主从复制的核心原理是基于Redis的发布/订阅模式和命令传播机制。当主Redis服务器接收到写操作时，它会将写操作作为命令发送到与之相连的从Redis服务器。从Redis服务器接收到命令后，将执行相应的操作并同步更新到本地数据库。

当slave启动后，主动向master发送SYNC命令。master接受到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave收到快照文件和命令后加载快照文件和缓存的执行命令。复制初始化后，master每次收到的写命令都会同步发送给slave，保证主从数据一致性。

Redis主从复制的过程可以描述如下：
- 主Redis服务器将写操作作为命令发送给与之相连的从Redis服务器。
- 从Redis服务器接收到命令后，执行相应的操作并同步更新到本地数据库。
- 从Redis服务器向主Redis服务器发送ACK确认消息，表示数据已经成功同步。
- 主Redis服务器在接收到ACK确认消息后，将该命令标记为已执行。
- 重复以上步骤以实现数据的持续同步。

### Redis主从复制的优点
Redis主从复制具有以下优点：
- 提高可用性和容错性。当主Redis服务器出现故障时，从Redis服务器可以自动接管读写请求。
- 分担主服务器的负载压力。从Redis服务器可以处理读请求，减轻主Redis服务器的负载压力。
- 提高系统的扩展性。通过添加新的从Redis服务器来增加系统的容量。

缺点：
- 从上面可以看出，master节点在主从模式中唯一，若master挂掉，则redis无法对外提供写服务。

### 操作步骤
下面是Redis主从复制的实践代码和操作步骤：

- 步骤一：安装Redis
首先需要在主机和从机上都安装Redis。

- 步骤二：配置主Redis服务器
在主Redis服务器上，需要修改redis.conf文件中的配置项。示例如下：
```
port 6379  
bind 127.0.0.1  
daemonize yes  
pidfile "/var/run/redis_6379.pid"  
logfile "/var/log/redis_6379.log"  
save 900 1  
save 300 10  
save 60 10000  
dbfilename "dump.rdb"  
dir "/var/lib/redis"  
masterauth "password"  
requirepass "password"  
```
其中，要开启主从复制功能，需要设置slaveof属性。示例如下：
```
slaveof host port
```
其中，host是主Redis服务器的地址，port是主Redis服务器的端口号。

- 步骤三：配置从Redis服务器
在从Redis服务器上，需要修改redis.conf文件中的配置项。示例如下：
```
port 6380  
bind 127.0.0.1  
daemonize yes  
pidfile "/var/run/redis_6380.pid"  
logfile "/var/log/redis_6380.log"  
save 900 1  
save 300 10  
save 60 10000  
dbfilename "dump.rdb"  
dir "/var/lib/redis"  
masterauth "password"  
requirepass "password"  
slaveof host port  
```
其中，要开启从Redis服务器的复制功能，只需设置slaveof属性即可。同样，host是主Redis服务器的地址，port是主Redis服务器的端口号。

- 步骤四：测试主从复制
启动主Redis服务器和从Redis服务器。
在主Redis服务器上写入数据。
```
set key value
```
在从Redis服务器上读取数据，检查是否已成功同步。
```
get key
```
如果读取到了写入的数据，则说明主从复制已经正常工作。

## 哨兵模式
在分布式架构设计中，Redis是一个非常流行的NoSQL数据库。它不仅具有高性能和可扩展性，而且支持哨兵模式来提高可用性和容错性。

Redis哨兵模式是指通过多个Redis实例之间的“哨兵”协作机制，自动化地完成Redis实例的监控、故障转移与恢复，从而提高Redis的可用性和稳定性。

在哨兵架构中，有三种类型的进程：主Redis服务器，从Redis服务器，以及哨兵进程。

主Redis服务器负责写操作，并将数据同步到从Redis服务器上。

从Redis服务器只能进行读操作，不能进行写操作。

哨兵进程则负责监控主Redis服务器和从Redis服务器的状态，当发现主Redis服务器故障时，会自动将某个从Redis服务器升级为新的主Redis服务器，并通知所有其他从Redis服务器更新到新的主服务器上。这样就可以在主Redis服务器故障时实现自动的故障转移和恢复。

哨兵的作用就是监控redis集群的运行状况。特点如下：
- sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义
- 当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master
- 当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据
- sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群
- 多sentinel配置的时候，sentinel之间也会自动监控
- 当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心
- 一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis
- sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了

## 核心原理
Redis哨兵模式的核心原理是基于Redis的发布/订阅模式和命令传播机制。
- 每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令
- 如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线。
- 如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态
- 当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线
- 在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令
- 当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次
- 若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；
- 若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除

在Redis哨兵模式中，主Redis服务器会向所有哨兵进程发送心跳消息，并将自己的状态信息更新至哨兵进程所维护的状态信息列表中。当一个哨兵进程发现主Redis服务器故障时，它会尝试执行以下操作：
- 向其他哨兵进程请求同步最新的主从节点状态信息。
- 承认或撤销之前的升级请求。
- 选举出一个哨兵进程来负责升级从Redis服务器为新的主Redis服务器。
- 负责将所有从Redis服务器切换到新的主Redis服务器。
- 将故障的主Redis服务器排除在哨兵集群之外，等待其恢复后重新加入。

如果出现多个哨兵进程同时检测到主Redis服务器故障的情况，那么由投票机制产生的优先级较高的哨兵进程进行自动故障转移和恢复。

### Redis哨兵模式的优点
Redis哨兵模式具有以下优点：
- 提高可用性和容错性。当主Redis服务器出现故障时，可以自动实现故障转移和恢复，保证系统的稳定性。
- 分担主服务器的负载压力。从Redis服务器可以处理读请求，减轻主Redis服务器的负载压力。
- 提高系统的扩展性。通过添加新的哨兵进程来增加系统的容量。
- Redis哨兵模式的实践代码和操作步骤

### 注意点
当使用sentinel模式的时候，客户端就不要直接连接Redis，而是连接sentinel的ip和port，由sentinel来提供具体的可提供服务的Redis实现，这样当master节点挂掉以后，sentinel就会感知并将新的master节点提供给使用者。

### 操作步骤：
- 步骤一：安装Redis
首先需要在主机和从机上都安装Redis。

- 步骤二：配置Redis
在主Redis服务器和从Redis服务器上，需要修改redis.conf文件中的配置项。示例如下：
```
port 6379  
bind 127.0.0.1  
daemonize yes  
pidfile "/var/run/redis_6379.pid"  
logfile "/var/log/redis_6379.log"  
save 900 1  
save 300 10  
save 60 10000  
dbfilename "dump.rdb"  
dir "/var/lib/redis"  
requirepass "password"  
```
在哨兵进程所在的机器上，需要创建sentinel.conf文件，并增加如下配置项：
```
sentinel monitor mymaster host port quorum 2  
sentinel down-after-milliseconds mymaster 3000  
sentinel parallel-syncs mymaster 1  
sentinel failover-timeout mymaster 180000  
sentinel auth-pass mymaster password  
logfile "/var/log/redis-sentinel.log"  
pidfile "/var/run/redis-sentinel.pid"  
```
其中，mymaster指定了需要监控的主Redis服务器的名称，host和port则是该主Redis服务器的地址和端口号。

- 步骤三：启动Redis
首先启动主Redis服务器和从Redis服务器，然后启动哨兵进程。
```
$ redis-server /etc/redis/redis.conf  
$ redis-server /etc/redis/slave.conf  
$ redis-sentinel /etc/redis/sentinel.conf  
```

## 集群模式
Redis 是一款内存数据库，常用于缓存、消息队列等。随着业务的发展和数据的增长，单机 Redis 可能无法满足我们的需求，此时我们需要使用 Redis 集群模式。Redis 集群模式可以将多个 Redis 实例组成一个集群，提供更高的性能和可用性。

哨兵模式基本可以满足一般生产的需求，具备高可用性。但是当数据量过大到一台服务器存不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实力中，cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。

### 核心原理
cluster可以说是sentinal和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。

使用集群，只要将redis配置文件中的cluster-enable配置打开即可。每个集群中至少需要3个主数据库才能正常运行，新增节点非常方便。

Redis 集群模式是通过将多个 Redis 实例组成一个集群来提供高可用性和性能的解决方案。Redis 集群使用的是分布式哈希槽算法，通过对 key 进行哈希映射到不同的 Redis 实例上，实现了数据的分布式存储和负载均衡。

### Redis集群模式优点
- 多个redis节点网络互联，数据共享
- 所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用
- 支持在线增加、删除节点
- 客户端可以连接任何一个主节点进行读写

cluster集群缺点
- 不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上，
- 并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为

### 分布式哈希槽算法
在 Redis 集群中，数据被分为 16384 个哈希槽，每个哈希槽对应一个 Redis 实例。当我们向 Redis 写入数据时，Redis 会对 key 进行哈希，然后将哈希值与 16383 取模得到的值就是要存储的哈希槽。根据哈希槽与 Redis 实例的映射关系，Redis 就知道了要将数据存储在哪个实例上。

当我们从 Redis 读取数据时，Redis 需要先确定要查询的 key 对应的哈希槽，然后才能知道要从哪个实例中读取数据。如果集群中的某一个节点失效了，那么相应的哈希槽就无法提供服务了。此时，Redis 会将失效的节点上的哈希槽迁移到其他节点上，保证数据的高可用性。

Redis 中使用哈希槽算法来实现分布式存储。哈希槽算法的基本思想是将所有数据按照 key 进行哈希计算，得到一个哈希值，然后将这个哈希值对槽总数取模，最终将数据存储到对应的哈希槽中。

下面是 Redis 哈希槽算法的示意图：
```
                  +----------+  
                  |          |  
                  |          |  
                  |  节点 A  |  
       +----------+          +-----------+  
       |          |          |           |  
       |          |          |           |  
       |  哈希槽 1  | .......... |  哈希槽 16384 |  
       |          |          |           |  
       |          |          |           |  
       +----------+          +-----------+  
                  |          |  
                  |          |  
                  |  节点 B  |  
                  |          |  
                  |          |  
                  +----------+  
```
在 Redis 集群中，节点被分配了一个唯一的标识符，也就是节点 ID，它是一个40个字符长的十六进制字符串。Redis 的哈希槽被划分为 16384 个，每个槽都有一个唯一的编号，从 0 到 16383。

当有新的节点加入集群时，它会首先从某个已知节点（通常是集群中的主节点）获取关于集群拓扑结构的信息。然后它会计算自己所负责的哈希槽范围，并将这个信息发送给其他节点，让它们知道新节点的存在和负责的哈希槽。

当有客户端向集群中写入一个 key-value 对时，Redis 首先将 key 对应的哈希值计算出来，然后将它对 16384 取模，得到这个 key 应该存储在哪个哈希槽中。如果存储这个哈希槽的节点是本地节点，则直接在本地节点上处理这个命令；否则，Redis 会将这个命令转发给负责这个哈希槽的节点进行处理。

### Redis 集群架构
Redis 集群由多个 Redis 节点组成，每个节点包含一个主节点和多个从节点。主节点负责接收写入请求，从节点只负责接收读取请求。当主节点发生故障时，从节点可以自动接管主节点的工作，实现高可用性。

另外，为了保证 Redis 集群的性能和可用性，我们需要为集群配置哨兵节点。哨兵节点负责监控 Redis 节点的状态，并在需要时进行自动故障转移操作。

Redis 集群部署的原理示意图：
```
                                +-----------+  
                     +--------------> |  节点 A    |  
                     |                |           |  
          +----------+               |  IP:port  |  
          |          |               +-----------+  
          |  客户端   |  
  
          |          |  
          +----------+  
  
          |          |  
          |  Redis   |  
          |  集群    |  
          |          |  
  
          +----------+  
  
          |          |  
          |          |  
          |  ....    |  
          |          |  
          |          |  
  
          +----------+  
  
          |          |  
          |          |  
          |  节点 N   |  
          |          |  
          |          |  
          +----------+              +-----------+  
                     <--------------+ |  节点 B    |  
                                    |           |  
                                    |  IP:port  |  
                                    +-----------+  
```
Redis 集群采用分布式架构，将数据划分为多个节点进行存储和处理。每个节点都可以独立地工作，并接收来自其他节点的命令请求。Redis 集群中有三种类型的节点：主节点、从节点和哨兵节点。

每个主节点都负责一系列哈希槽（hash slot），其中每个哈希槽只被一个主节点负责。Redis 客户端向 Redis 集群发送命令时，首先通过哈希算法计算 key 的哈希值，然后将这个哈希值对应的哈希槽路由到负责这个哈希槽的主节点上。如果负责这个哈希槽的主节点不可用，那么客户端会自动重定向到负责同样哈希槽的从节点上。

每个主节点都有若干个从节点，用于实现数据的备份和故障恢复。当一个主节点宕机时，Redis 会通过哨兵节点选举出新的主节点，并将原来的从节点升级为新的主节点。此时，新的主节点会重新负责一系列哈希槽，并接收来自其他节点的请求。所有的从节点会在新的主节点上进行复制，以保证数据的一致性。

哨兵节点用于监控 Redis 集群的健康状况，以及发现、选举并维护主节点的状态。如果某个主节点宕机，哨兵节点会检测到这个事件，并选择一个从节点作为新的主节点。当旧的主节点恢复后，它会成为新的从节点加入 Redis 集群中。

### Redis 集群节点之间的通信
Redis 集群节点之间通过 Gossip 协议进行通信，Gossip 协议是一种基于分布式的信息传递协议，常用于解决分布式系统中的数据同步和故障转移等问题。

Redis 集群中每个节点都要与其他节点保持一定的连接，以便及时感知节点状态的变化。当某个节点状态发生变化（比如节点上线、离线或者主从切换），该节点会将新的状态信息以广播的形式发送给集群中的其他节点。其他节点收到信息后，会更新自己的状态，并继续广播给其他节点，直到整个集群中所有节点都得到了最新的状态信息。

### Redis 集群演示
下面我们来演示如何搭建 Redis 集群。

- 环境准备
首先，我们需要准备 6 台虚拟机，每台虚拟机上都需要安装 Java 和 Redis。其中，3 台虚拟机作为主机，另外 3 台虚拟机作为从机。

- 修改配置文件
修改主机的 Redis 配置文件 redis.conf，在文件末尾添加以下内容：
```
cluster-enabled yes  
cluster-config-file nodes.conf  
cluster-node-timeout 5000  
```
这段配置用于启用集群模式，并指定了存储集群信息的文件和节点失效的超时时间。

修改从机的 Redis 配置文件 redis.conf，在文件末尾添加以下内容：
```
slaveof <master-ip> <master-port>  
```
将 <master-ip> 和 <master-port> 替换为主机的 IP 地址和端口号，这段配置用于指定从机的主机。

- 启动集群
分别在每台虚拟机上启动 Redis 实例：
```
redis-server /path/to/redis.conf  
```
然后，在主机的某个 Redis 节点上执行以下命令，以创建 Redis 集群：
```
redis-cli --cluster create <node1-ip>:<node1-port> <node2-ip>:<node2-port> <node3-ip>:<node3-port> --cluster-replicas 1  
```
将 <nodeX-ip> 和 <nodeX-port> 替换为各个节点的 IP 地址和端口号，--cluster-replicas 参数表示每个主节点对应的从节点数量。

执行完命令后，Redis 集群就创建完成了。

- 使用集群
要使用 Redis 集群，我们需要使用 redis-cli 或者其他 Redis 客户端进行连接。连接方式与单机 Redis 相同，只不过需要使用 -c 参数来启用 Redis 集群模式，例如：
```
redis-cli -c -h <cluster-ip> -p <cluster-port>  
```
将 <cluster-ip> 和 <cluster-port> 替换为任意一个主机的 IP 地址和端口号即可。

Redis 集群模式是 Redis 的一个重要特性，可以帮助我们解决单机 Redis 承载能力不够、高可用性等问题。

## 代理模式
目前比较流行的代理框架如下 ：
- twemproxy：快速、轻量级memcached和redis代理，Twitter推特公司开发
- codis：redis集群代理解决方案，豌豆荚公司开发，需要修改redis源码
- predixy：高性能全特征redis代理，支持Redis Sentinel和Redis Cluster
- Redis-cerberus: Redis Cluster代理

## Twemproxy

### 工作机制
Twemproxy是一种代理分片机制，由Twitter开源。Twemproxy作为代理，可接受来自多个程序的访问，按照路由规则，转发给后台的各个Redis服务器，再原路返回。该方案很好的解决了单个Redis实例承载能力的问题。通过Twemproxy可以使用多台服务器来水平扩张redis服务，可以有效的避免单点故障问题。

###  缺点
Twemproxy本身也是单点（需要用Keepalived做高可用方案）

使用Twemproxy需要更多的硬件资源和在redis性能有一定的损失（twitter测试约20%）

### 不支持的命令
https://github.com/twitter/twemproxy/blob/master/notes/redis.md

### Codis
Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说，连接到 Codis Proxy 和连接原生的 RedisServer 没有明显的区别 (部分命令不支持），上层应用可以像使用单机的 Redis 一样使用，Codis 底层会处理请求的转发，不停机的数据迁移等工作，所有后边的一切事情，对于前面的客户端来说是透明的，可以简单的认为后边连接的是一个内存无限大的 Redis 服务。

### 工作机制
Codis包含如下组件
- Codis Proxy (codis-proxy)
- Codis Manager (codis-config)
- Codis Redis (codis-server)
- ZooKeeper
codis-proxy 是客户端连接的 Redis 代理服务, codis-proxy 本身实现了 Redis 协议, 表现得和一个原生的 Redis 没什么区别 (就像 Twemproxy), 对于一个业务来说, 可以部署多个 codis-proxy, codis-proxy 本身是无状态的。

codis-config 是 Codis 的管理工具, 支持包括, 添加/删除 Redis 节点, 添加/删除 Proxy 节点, 发起数据迁移等操作. codis-config 本身还自带了一个 http server, 会启动一个 dashboard, 用户可以直接在浏览器上观察 Codis 集群的运行状态。

codis-server 是 Codis 项目维护的一个 Redis 分支, 基于 2.8.13 开发, 加入了 slot 的支持和原子的数据迁移指令. Codis 上层的 codis-proxy 和 codis-config 只能和这个版本的 Redis 交互才能正常运行.

Codis 依赖 ZooKeeper 来存放数据路由表和 codis-proxy 节点的元信息, codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy。

Codis 支持按照 Namespace 区分不同的产品, 拥有不同的 product name 的产品, 各项配置都不会冲突。











































