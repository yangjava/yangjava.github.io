---
layout: post
categories: DataStructure
description: none
keywords: DataStructure
---
# 数组
数据结构的鼻祖——数组，作为数据结构中最基础的一个存储方式，是我们学习一切数据结构、算法的基石。大部分数据结构都可以用数组来实现。在每一门编程语言中，数组都是重要的数据结构，当然每种语言对数组的实现和处理也不相同，但是本质是都是用来存放数据的的结构。

## 数组(Array)
**要用就要提前想好的数据结构——数组**。要用就要提前想好？为什么？这其实是由数组的一个特点决定的，那就是对于数组这个数据结构，在用它之前必须提前想好它的长度；有了长度，才能知道该为这个存储结构开辟多少空间；而在决定了长度之后，不管我们最后往里面填充的数据够不够长，没有用到的空间也就都浪费了；如果我们想往这个数组中放入的数据超过了提前设定好的长度，那么是不可行的，因为空间只有这么大。

## 什么是数组
数组（Array），就是把有限个数据类型一样的元素按顺序放在一起，用一个变量命名，然后通过编号可以按顺序访问指定位置的元素的一个有序集合。 其实简单来说，就是为了方便而把这些元素放在一起。我们通过编号去获取每个元素，这个编号叫作下标或者索引（Index），一般的语言是从0开始的。

我们常说的数组一般指一维数组，当然还有多维数组，虽然多维数组并不常用。 多维的实现其实是数组的某些元素本身也是一个数组，这里以一个标准的二维数组为例进行介绍。其实，二维数组相当于每个元素的长度都一样的一个一维数组（也就是我们常说的数组）。可以想象一下矩阵，其实它和数学中的矩阵类似。

在很多弱语言中，并不要求每个元素的长度都一样，可以某些元素是数组（长度可以不一样），某些元素不是数组，甚至每个元素的数据类型都不同。这里讲的二维数组指的是标准的二维数组。 注：弱类型语言也叫作弱类型定义语言，简称弱语言。弱语言一般对语言的标准没有特别的要求。比如在JavaScript中用var声明变量，不会指定该变量是哪种类型。如果想更多地了解弱语言，则请参考JavaScript，该语言主要用于前端开发。强语言对编写规则比较有要求，所以不容易出现问题，很多开发工具都会帮助检查其基本规则。

## 数组的存储结构
在了解了什么是数组之后，我们来看下数组的存储结构。
首先我们来看下一维数组的存储结构
```text
        num[n]数组结构

num[0] num[1] ... num[n-1]
```
其实，我们先要确定一个值，也就是数组的长度；然后，系统会根据我们声明的数据类型开辟一些空间（当然，每种数据类型需要开辟的空间也不一样）。这时，这些空间就归这个变量所有了。一般在编程语言的实现中，这些空间会默认对我们声明的数据类型赋值，比如整型值是0，布尔值是false，等等。

所以有以下几种情况。
- 只声明了指定长度的空间，没有初始化值（以整型为例，所有值都会默认为0，如下图）。
```text
例如num[5]，默认值都是0
[0,0,0,0,0]
```
- 声明了指定长度的空间，初始化了部分值（以整型为例，未初始化的值都会默认为0，如下图）。
```text
例如num[5]，只初始化了前三个值，其余值自动初始化为0
[0,1,2,0,0]
```
- 声明了指定长度的空间，初始化了全部的值
```text
例如num[5]，初始化了全部的值
[1,2,3,4,5]
```

## 数组在编程语言中的初始化及操作




## 数组的特点
因为本身存储的方式，数组有如下特点。
- 定长
数组的长度是固定的，这是数组最重要的一个特点。
只要我们在声明时确定了数组的长度，在赋值时就算没有给数组的所有元素赋值，未赋值的元素也是有初始默认值的；而如果我们在赋值时发现数组的长度不够用，这时也没有什么好办法，因为数组的长度无法改变。要是想继续存放数据，就只能重新声明一个数组了。
- 按顺序访问
我们在访问一个数组中的某个元素时，必须从第1个元素开始按顺序访问，直到访问到指定位置的元素。 这里想说明一点，虽然我们在开发时可以直接通过下标访问指定位置的元素，但是实际上计算机在处理时也是按顺序访问的。

## 数组的适用场景
数组其实是一个非常简单的数据结构，用起来也比较简单。但是，数组是所有数据结构的基础，我们必须掌握好数组，才能更好地学习其他数据结构和算法。 数组适合在什么时候用，其实根据数组的特点我们就可以想到，由于数组的长度一般是固定的，所以在不会出现变化的业务上比较适合使用数组。

- 技能快捷键
不知道大家对RPG（ARPG）等类似的游戏了解多少，在这类游戏中会有一排快捷键技能格，比如F1～F9这样9个快捷键技能格，我们每个人可以把自己惯用的技能拖动到这些技能格上，这样就可以直接通过技能快捷键操控技能了。一般在这种设计中，一个游戏的快捷键格子会有固定的个数。于是，我们在程序里就可以通过数组来存储每个人的技能快捷键对应的技能（当然，肯定会通过一定的映射存到数据库之类的磁盘上）。

到这里，我们应该已经很清晰地认识到了数组的劣势，那就是在用之前必须提前确定数组的长度，而后不管我们的技能是否需要增加快捷键位，或者优酷首页从8+1变成了11+1，都会导致对程序进行一定的改动。这时我们就该认识一下数组的升级版——集合了。



## 数组的局限性
通过上面的代码，我们发现数组是能完成一个数据结构所有的功能的，而且实现起来也不难，那数据既然能完成所有的工作，我们实际应用中为啥不用它来进行所有的数据存储呢？那肯定是有原因呢。
数组的局限性分析：
- 插入快，对于无序数组，上面我们实现的数组就是无序的，即元素没有按照从大到小或者某个特定的顺序排列，只是按照插入的顺序排列。无序数组增加一个元素很简单，只需要在数组末尾添加元素即可，但是有序数组却不一定了，它需要在指定的位置插入。
- 查找慢，当然如果根据下标来查找是很快的。但是通常我们都是根据元素值来查找，给定一个元素值，对于无序数组，我们需要从数组第一个元素开始遍历，直到找到那个元素。有序数组通过特定的算法查找的速度会比无需数组快，后面我们会讲各种排序算法。
- 删除慢，根据元素值删除，我们要先找到该元素所处的位置，然后将元素后面的值整体向前面移动一个位置。也需要比较多的时间。
- 数组一旦创建后，大小就固定了，不能动态扩展数组的元素个数。如果初始化你给一个很大的数组大小，那会白白浪费内存空间，如果给小了，后面数据个数增加了又添加不进去了。

很显然，数组虽然插入快，但是查找和删除都比较慢，而且扩展性差，所以我们一般不会用数组来存储数据，那有没有什么数据结构插入、查找、删除都很快，而且还能动态扩展存储个数大小呢，答案是有的，但是这是建立在很复杂的算法基础上，后面我们也会详细讲解。

---------------
![数据结构-array](png\Java\数据结构-array.png)


### Java数组介绍

在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型(Object类型数组除外)。

**①、数组的声明**

**第一种方式：**

```
数据类型 []  数组名称 = new 数据类型[数组长度];
```

这里 [] 可以放在数组名称的前面，也可以放在数组名称的后面，我们推荐放在数组名称的前面，这样看上去 数据类型 [] 表示的很明显是一个数组类型，而放在数组名称后面，则不是那么直观。

**第二种方式：**

```
数据类型 [] 数组名称 = {数组元素1，数组元素2，......}
```

这种方式声明数组的同时直接给定了数组的元素，数组的大小由给定的数组元素个数决定。

```
//声明数组1,声明一个长度为3，只能存放int类型的数据
int [] myArray = new int[3];
//声明数组2,声明一个数组元素为 1,2,3的int类型数组
int [] myArray2 = {1,2,3};
```

**②、访问数组元素以及给数组元素赋值**

数组是存在下标索引的，通过下标可以获取指定位置的元素，数组小标是从0开始的，也就是说下标0对应的就是数组中第1个元素，可以很方便的对数组中的元素进行存取操作。

前面数组的声明第二种方式，我们在声明数组的同时，也进行了初始化赋值。

```
//声明数组,声明一个长度为3，只能存放int类型的数据
int [] myArray = new int[3];
//给myArray第一个元素赋值1
myArray[0] = 1;
//访问myArray的第一个元素
System.out.println(myArray[0]);
```

上面的myArray 数组，我们只能赋值三个元素，也就是下标从0到2，如果你访问 myArray[3] ，那么会报数组下标越界异常。

**③、数组遍历**

数组有个 length 属性，是记录数组的长度的，我们可以利用length属性来遍历数组。

```
//声明数组2,声明一个数组元素为 1,2,3的int类型数组
int [] myArray2 = {1,2,3};
for(int i = 0 ; i < myArray2.length ; i++){
    System.out.println(myArray2[i]);
}
```

### 用类封装数组实现数据结构

数据结构必须具有以下基本功能：

**①、如何插入一条新的数据项**

**②、如何寻找某一特定的数据项**

**③、如何删除某一特定的数据项**

**④、如何迭代的访问各个数据项，以便进行显示或其他操作**

而我们知道了数组的简单用法，现在用类的思想封装一个数组，实现上面的四个基本功能：

ps:假设操作人是不会添加重复元素的，这里没有考虑重复元素，如果添加重复元素了，后面的查找，删除，修改等操作只会对第一次出现的元素有效。

```
package com.demo.array;

public class MyArray {
    //定义一个数组
    private int [] intArray;
    //定义数组的实际有效长度
    private int elems;
    //定义数组的最大长度
    private int length;

    //默认构造一个长度为50的数组
    public MyArray(){
        elems = 0;
        length = 50;
        intArray = new int[length];
    }
    //构造函数，初始化一个长度为length 的数组
    public MyArray(int length){
        elems = 0;
        this.length = length;
        intArray = new int[length];
    }

    //获取数组的有效长度
    public int getSize(){
        return elems;
    }

    /**
     * 遍历显示元素
     */
    public void display(){
        for(int i = 0 ; i < elems ; i++){
            System.out.print(intArray[i]+" ");
        }
        System.out.println();
    }

    /**
     * 添加元素
     * @param value,假设操作人是不会添加重复元素的，如果有重复元素对于后面的操作都会有影响。
     * @return添加成功返回true,添加的元素超过范围了返回false
     */
    public boolean add(int value){
        if(elems == length){
            return false;
        }else{
            intArray[elems] = value;
            elems++;
        }
        return true;
    }

    /**
     * 根据下标获取元素
     * @param i
     * @return查找下标值在数组下标有效范围内，返回下标所表示的元素
     * 查找下标超出数组下标有效值，提示访问下标越界
     */
    public int get(int i){
        if(i<0 || i>elems){
            System.out.println("访问下标越界");
        }
        return intArray[i];
    }
    /**
     * 查找元素
     * @param searchValue
     * @return查找的元素如果存在则返回下标值，如果不存在，返回 -1
     */
    public int find(int searchValue){
        int i ;
        for(i = 0 ; i < elems ;i++){
            if(intArray[i] == searchValue){
                break;
            }
        }
        if(i == elems){
            return -1;
        }
        return i;
    }
    /**
     * 删除元素
     * @param value
     * @return如果要删除的值不存在，直接返回 false;否则返回true，删除成功
     */
    public boolean delete(int value){
        int k = find(value);
        if(k == -1){
            return false;
        }else{
            if(k == elems-1){
                elems--;
            }else{
                for(int i = k; i< elems-1 ; i++){
                    intArray[i] = intArray[i+1];

                }
                 elems--;
            }
            return true;
        }
    }
    /**
     * 修改数据
     * @param oldValue原值
     * @param newValue新值
     * @return修改成功返回true，修改失败返回false
     */
    public boolean modify(int oldValue,int newValue){
        int i = find(oldValue);
        if(i == -1){
            System.out.println("需要修改的数据不存在");
            return false;
        }else{
            intArray[i] = newValue;
            return true;
        }
    }

} 
```

**优点**

- 构建非常简单
- 能在 O(1) 的时间里根据数组的下标（index）查询某个元素

**缺点**

- 构建时必须分配一段连续的空间
- 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）
- 删除和添加某个元素时，同样需要耗费 O(n) 的时间

**基本操作**

- **insert**：在某个索引处插入元素
- **get**：读取某个索引处的元素
- **delete**：删除某个索引处的元素
- **size**：获取数组的长度



**案例一：翻转字符串“algorithm”**

![翻转字符串algorithm](png/Java/翻转字符串algorithm.gif)

**解法**：用两个指针，一个指向字符串的第一个字符 a，一个指向它的最后一个字符 m，然后互相交换。交换之后，两个指针向中央一步步地靠拢并相互交换字符，直到两个指针相遇。这是一种比较快速和直观的方法。

**案例二：给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。**

说明：你可以假设字符串只包含小写字母。

**解题思路**：字母异位词，也就是两个字符串中的相同字符的数量要对应相等。

- 可以利用两个长度都为 26 的字符数组来统计每个字符串中小写字母出现的次数，然后再对比是否相等
- 可以只利用一个长度为 26 的字符数组，将出现在字符串 s 里的字符个数加 1，而出现在字符串 t 里的字符个数减 1，最后判断每个小写字母的个数是否都为 0






