---
layout: post
categories: [Lucene]
description: none
keywords: Lucene
---
# Lucene源码索引目录
Directory及相关类负责文档索引的存储。

## 数据存储类Directory
org.apache.lucene.store

Directory即Lucene中对索引目录的一个抽象，体现到API上，它被设计为一个抽象类，类里面定义了一些抽象方法，如listAll列出目录下所有文件，deleteFile(String name) 根据文件名称删除索引文件，这个都是文件的基本操作

## org.apache.lucene.store.Directory
一个Directory对象是一系列统一的文件列表（a flat list of files）。文件可以在它们被创建的时候一次写入，一旦文件被创建，它再次打开后只能用于读取（read）或者删除（delete）操作。并且同时在读取和写入的时候允许随机访问（random access）。

在这里并不直接使用Java I/O API，但是更确切地说，所有I/O操作都是通过这个API处理的。这使得读写操作方式更统一起来，如基于内存的索引（RAM-based indices）的实现（即RAMDirectory）、通过JDBC存储在数据库中的索引、将一个索引存储为一个文件的实现（即FSDirectory）。

Directory的锁机制是一个LockFactory的实例实现的，可以通过调用Directory实例的setLockFactory()方法来更改。

## BaseDirectory
BaseDirectory是Directory的一个子类，这里面值得注意是在做IO的时候用到了LockFactory，一个锁工厂。这是典型的工厂模式自不必说。它的主要作用是防止读写Directory的并发。

下面是BaseDirectory的源码：
```
public abstract class BaseDirectory extends Directory {

volatile protected boolean isOpen = true;

protected LockFactory lockFactory;

/** Sole constructor. */
protected BaseDirectory() {
super();
}

@Override
public Lock makeLock(String name) {
return lockFactory.makeLock(name);
}

@Override
public void clearLock(String name) throws IOException {
if (lockFactory != null) {
lockFactory.clearLock(name);
}
}

@Override
public void setLockFactory(LockFactory lockFactory) throws IOException {
assert lockFactory != null;
this.lockFactory = lockFactory;
lockFactory.setLockPrefix(this.getLockID());
}

@Override
public LockFactory getLockFactory() {
return this.lockFactory;
}

@Override
protected final void ensureOpen() throws AlreadyClosedException {
if (!isOpen)
throw new AlreadyClosedException("this Directory is closed");
}

}
```
BaseDirectory基本上就做了一件事：就是管理锁工厂。

这里的lockFactory仍然是一个抽象类，由子类传入传入具体的lockFactory工厂实现来创建不同的Lock实例FSDirectory是针对文件系统的一个Directory实现，即使用这个Directory就可以把索引文件存储到我们的文件系统里了。

下面重点来说一下Directory相关的类：

Directory的直接子类就只有BaseDirectoy和FilterDirectory两个。

其中FilterDirectory的子类都是给Directory添加附加的功能：TrackingDirectoryWrapper是记录文件的写入或删除；NRTCachingDirectory是提供对RAMDirectory的缓存，达到近实时的效果(NRT：near real time)；RateLimitedDirecotyWrapper是通过IOContext来限制读写速率。这些都是装饰器模式的代表。

BaseDirectory的子类中，FileSwitchDirectory针对lucene的不同的索引文件使用不同的Directory；CompoundFileDirectory用于访问一个组合的数据流；RAMDirectory是常驻内存的Directory实现。FSDirectory是文件系统的Directory（FS：File System ），它的三种实现：SimpleFSDirectory,它的并发支持能力有限；NIOFSDirectory支持默认线程安全的多线程读取；MMapDirectory是通过内存映射读取的Directory。

## org.apache.lucene.store.FSDirectory
FSDirectory类直接实现Directory抽象类为一个包含文件的目录。目录锁的实现使用缺省的SimpleFSLockFactory，但是可以通过两种方式修改，即给getLockFactory()传入一个LockFactory实例，或者通过调用setLockFactory()方法明确制定LockFactory类。

目录将被缓存（cache）起来，对一个指定的符合规定的路径（canonical path）来说，同样的FSDirectory实例通常通过getDirectory()方法返回。这使得同步机制（synchronization）能对目录起作用。

FSDirectory下面又有3个子类，分别是SimpleFSDirectory，NIOFSDirectory，MMapDirectory：

- SimpleFSDirectory：它是基于文件系统的索引目录的一个简单实现，它在多线程环境下性能表现很差，不支持并发读写索引文件。
- NIOFSDirectory:顾名思义，它就是使用NIO里的FileChannel文件通道来解决并发读写索引文件的，但它在windows平台下有个致命的BUG，官方建议在windows平台下使用RAFDirectory来代替NIOFSDirectory。
  An FSDirectory implementation that uses java.nio's FileChannel's positional read, which allows multiple threads to read from the same file without synchronizing
  大意是一个利用了java nio中FileChannel的FSDirectory实现，允许无syschronized的对同一文件进行多线程读

- MMapDirectory:即基于内存映射的方式把文件load到内存来减少与IO的交互次数，从而提高IO性能，但这部分内存也存在隐患，因为JDK存在一个BUG，就是当IndexInput.close()时并不能有效的交还文件系统里索引文件的文件句柄，这就直接导致索引lock无法释放，一直直到GC回收这部分内存中潜在的对象时该句柄才会释放。由于文件句柄不能有效的立即释放，可能会导致你的硬盘空间得不到立即的释放，所以如果你的应用对于硬盘状况很敏感，这将是一个致命的定时炸蛋，放在心里就行，反正暂时这个BUG未解决。(现在硬盘这么廉价，多浪费点硬盘空间也没啥)不过在linux系统上，即使句柄没有释放，当你删除索引文件时会提示是否在delete on last close,当你close时候还是会删除成功的，但索引文件还是会文件系统上占硬盘空间，而在windows平台上你只会得到一个Error。

上面简单说了下各种FSDirectory的作用，下面简单说下各个Directory中比较重要的一些接口方法：

## org.apache.lucene.store.RAMDirectory
RAMDirectory类是一个驻留内存的（memory-resident）Directory抽象类的实现。目录锁的实现使用缺省的SingleInstanceLockFactory，但是可以通过setLockFactory()方法修改。

## org.apache.lucene.store.IndexInput
IndexInput类是一个为了从一个目录（Directory）中读取文件的抽象基类，是一个随机访问（random-access）的输入流（input stream），用于所有Lucene读取Index的操作。BufferedIndexInput是一个实现了带缓冲的IndexInput的基础实现。

## org.apache.lucene.store.IndexOutput
IndexOutput类是一个为了写入文件到一个目录（Directory）中的抽象基类，是一个随机访问（random-access）的输出流（output stream），用于所有Lucene写入Index的操作。BufferedIndexOutput是一个实现了带缓冲的IndexOutput的基础实现。RAMOuputStream是一个内存驻留（memory-resident）的IndexOutput的实现类。

## FSDirectory类里的open
FSDirectory类里的open方法是使用比较频繁的方法之一，其实内部就是根据用户的操作系统环境和使用的JDK来选择合适的Directory,

Constants.JRE_IS_64BIT即表示是否是64位的JDK,

MMapDirectory.UNMAP_SUPPORTED即表示是否支持Direct Buffer，什么叫Direct Buffer？其实Direct Buffer并不是直接分配在堆上的，Direct Buffer不受GC管理，即Direct Buffer是有操作系统来销毁的，但Direct Buffer上对象是由GC负责回收的，Direct Buffer读写之所以快，是因为减少数据拷贝到内核缓冲区的操作，但Direct Buffer是由操作系统负责销毁，所以代价也是很高的。那我们看看Lucene是如何判断是否支持Direct Buffer的？
```
/** 
   * <code>true</code>, if this platform supports unmapping mmapped files. 
   */  
  public static final boolean UNMAP_SUPPORTED;  
  static {  
    boolean v;  
    try {  
      Class.forName("sun.misc.Cleaner");  
      Class.forName("java.nio.DirectByteBuffer")  
        .getMethod("cleaner");  
      v = true;  
    } catch (Exception e) {  
      v = false;  
    }  
    UNMAP_SUPPORTED = v;  
  } 
```
其实就是判断JDK里是否有sun.misc.Cleaner这个类，以及Java.nio.DirectByteBuffer类是否有cleaner方法。 这两个类都是用于Direct buffer里对象清理工作的。

Oracle/Sun JDK 6中的HotSpot VM只会在年老代GC（full GC/major GC或者concurrent GC都算）的时候才会做reference processing，而在young GC/minor GC时不做。 也就是说，做full GC的话会做reference processing，进而能触发Cleaner对已死的DirectByteBuffer对象做清理工作。而如果很长一段时间里没做过GC或者只做了young GC的话则不会触发Cleaner的工作，那么就可能让本来已经死了的DirectByteBuffer关联的native memory得不到及时释放。

之所以要保证有上述两个类，就是确保DirectByteBuffer里的内存能得到释放以保证性能，这样你使用MMapDirectory才能体现它的优势又能避免它潜在的隐患。

还有一个比较重要的Directory就是RAMDirectory,就是内存索引目录，即把索引文件数据load到堆中，内部就是用new byte[1024]来缓存索引数据的，这适合于小量的索引文件，RAMDirectory设计之初就不是为百万级别的大数量的索引而设计的，因为它会在你的内存产生数以百万的byte[1024],从而导致频繁GC回收，影响性能，而且它在多线程并发环境下表现也很糟糕，官方建议是：大数据量的索引请使用MMapDirectory,RAMDirectory的使用场景是当你创建索引时可以先把少量的索引放入内存，再switch到FSDirectory flush到file system,利用内存减少与File System访问次数。

另外一个比较重要的Directory就是FileSwitchDirectory,它就是集NIODirectory与MMapDirectory优点与一身的Directory，NIODirectory是直接把文件放入heap buffer中，而MMapDirectory是把文件直接映射到Direct buffer,由于Heap buffer可使用量大而Direct buffer虽然读写速度快，但它受操作系统调度，开辟和销毁的代价太高，不宜过多使用，所以一般我们需要使用NIODirectory来读写比较大的索引文件，而用MMapDirectory来读写相对比较小的文件，两者结合互补你懂的。

一般我们使用FSDirectory.open由api自动帮我们来选择合适的Directory即可，特殊情况下可以使用FileSwitchDirectory结合下两种Directory的优点。

FSLockFactory获得的默认LockFactory是NativeFSLockFactory，该工厂可以获得文件锁NativeFSLock，后面如果分析到再来细看这方面代码。这里假设FSDirectory的open函数创建了一个NIOFSDirectory，NIOFSDirectory继承自FSDirectory，并且直接调用了其父类FSDirectory的构造函数，
```
  protected FSDirectory(Path path, LockFactory lockFactory) throws IOException {
    super(lockFactory);
    // If only read access is permitted, createDirectories fails even if the directory already exists.
    if (!Files.isDirectory(path)) {
      Files.createDirectories(path);  // create directory, if it doesn't exist
    }
    directory = path.toRealPath();
  }
```
FSDirectory的构造函数根据Path创建了一个目录或者文件，并且保存了对应的路径。FSDirectory继承自BaseDirectory，其构造函数只是简单保存了LockFactory，这里就不要往下看了。



































































