---
layout: post
categories: Redis
description: none
keywords: Redis
---
# Redis基础数据类型
Redis 不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
- 字符串（String）
- 哈希（Hash）
- 列表（List）
- 集合（Set）
- 有序集合（Sorted Set）
- 位图 ( Bitmaps )
- 基数统计 ( HyperLogLogs )
- 地理空间信息(Geo)
- 流（Stream）

## 字符串（String）
string 是Redis的最基本的数据类型，是简单的 key-value 类型，一个key 对应一个 value。value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。string 类型是二进制安全的，意思是 Redis 的 string 可以包含任何数据，比如图片或者序列化的对象，一个 redis 中字符串 value 最多可以是 512M。

### String命令
下面用表格来看一下String操作的相关命令：

在这之外，专门提两点：

- Redis的命令不区分大小写
- Redis的Key区分大小写

| **命令** | **描述**                                                     | **用法**                                              |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| SET      | （1）将字符串值Value关联到Key（2）Key已关联则覆盖，无视类型（3）原本Key带有生存时间TTL，那么TTL被清除 | SET key value [EX seconds] [PX milliseconds] [NX\|XX] |
| GET      | （1）返回key关联的字符串值（2）Key不存在返回nil（3）Key存储的不是字符串，返回错误，因为GET只用于处理字符串 | GET key                                               |
| MSET     | （1）同时设置一个或多个Key-Value键值对（2）某个给定Key已经存在，那么MSET新值会覆盖旧值（3）如果上面的覆盖不是希望的，那么使用MSETNX命令，所有Key都不存在才会进行覆盖（4）**MSET是一个原子性操作**，所有Key都会在同一时间被设置，不会存在有些更新有些没更新的情况 | MSET key value [key value ...]                        |
| MGET     | （1）返回一个或多个给定Key对应的Value（2）某个Key不存在那么这个Key返回nil | MGET key [key ...]                                    |
| SETEX    | （1）将Value关联到Key（2）设置Key生存时间为seconds，单位为秒（3）如果Key对应的Value已经存在，则覆盖旧值（4）SET也可以设置失效时间，但是不同在于SETNX是一个原子操作，即关联值与设置生存时间同一时间完成 | SETEX key seconds value                               |
| SETNX    | （1）将Key的值设置为Value，当且仅当Key不存在（2）若给定的Key已经存在，SEXNX不做任何动作 | SETNX key value                                       |

①、上面的 ttl 命令是返回 key 的剩余过期时间，单位为秒。

②、mset和mget这种批量处理命令，能够极大的提高操作效率。因为一次命令执行所需要的时间=1次网络传输时间+1次命令执行时间，n个命令耗时=n次网络传输时间+n次命令执行时间，而批量处理命令会将n次网络时间缩减为1次网络时间，也就是1次网络传输时间+n次命令处理时间。

但是需要注意的是，Redis是单线程的，如果一次批量处理命令过多，会造成Redis阻塞或网络拥塞（传输数据量大）。

③、setnx可以用于实现分布式锁，具体实现方式后面会介绍。

#### **INCR/DECR**命令

前面介绍的是基本的Key-Value操作，下面介绍一种特殊的Key-Value操作即INCR/DECR，可以利用Redis自动帮助我们对一个Key对应的Value进行加减，用表格看一下相关命令：

| **命令** | **描述**                                                     | **用法**             |
| -------- | ------------------------------------------------------------ | -------------------- |
| INCR     | （1）Key中存储的数字值+1，返回增加之后的值（2）Key不存在，那么Key的值被初始化为0再执行INCR（3）如果值包含错误类型或者字符串不能被表示为数字，那么返回错误（4）值限制在64位有符号数字表示之内，即-9223372036854775808~9223372036854775807 | INCR key             |
| DECR     | （1）Key中存储的数字值-1（2）其余同INCR                      | DECR key             |
| INCRBY   | （1）将key所存储的值加上增量返回增加之后的值（2）其余同INCR  | INCRBY key increment |
| DECRBY   | （1）将key所存储的值减去减量decrement（2）其余同INCR         | DECRBY key decrement |

INCR/DECR在实际工作中还是非常管用的，

#### **典型使用场景**

- 计数：由于Redis单线程的特点，我们不用考虑并发造成计数不准的问题，通过 incrby 命令，我们可以正确的得到我们想要的结果。
- 限制次数：比如登录次数校验，错误超过三次5分钟内就不让登录了，每次登录设置key自增一次，并设置该key的过期时间为5分钟后，每次登录检查一下该key的值来进行限制登录。
- 秒杀库存：由于Redis本身极高的读写性能，一些秒杀的场景库存增减可以基于Redis来做而不是直接操作DB

### List(列表)
list 列表，它是简单的字符串列表，链表（redis 使用双端链表实现的 List）。按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表。

列表有两个特点：

**一、有序**

**二、可以重复**

#### **List命令**

接着我们看一下Redis中的List，相关命令有：

| **命令**  | **描述**                                                     | **用法**                              |
| --------- | ------------------------------------------------------------ | ------------------------------------- |
| LPUSH     | （1）将一个或多个值value插入到列表key的表头（2）如果有多个value值，那么各个value值按从左到右的顺序依次插入表头（3）key不存在，一个空列表会被创建并执行LPUSH操作（4）key存在但不是列表类型，返回错误 | LPUSH key value [value ...]           |
| LPUSHX    | （1）将值value插入到列表key的表头，当且晋档key存在且为一个列表（2）key不存在时，LPUSHX命令什么都不做 | LPUSHX key value                      |
| LPOP      | （1）移除并返回列表key的头元素                               | LPOP key                              |
| LRANGE    | （1）返回列表key中指定区间内的元素，区间以偏移量start和stop指定（2）start和stop都以0位底（3）可使用负数下标，-1表示列表最后一个元素，-2表示列表倒数第二个元素，以此类推（4）start大于列表最大下标，返回空列表（5）stop大于列表最大下标，stop=列表最大下标 | LRANGE key start stop                 |
| LREM      | （1）根据count的值，移除列表中与value相等的元素（2）count>0表示从头到尾搜索，移除与value相等的元素，数量为count（3）count<0表示从从尾到头搜索，移除与value相等的元素，数量为count（4）count=0表示移除表中所有与value相等的元素 | LREM key count value                  |
| LSET      | （1）将列表key下标为index的元素值设为value（2）index参数超出范围，或对一个空列表进行LSET时，返回错误 | LSET key index value                  |
| LINDEX    | （1）返回列表key中，下标为index的元素                        | LINDEX key index                      |
| LINSERT   | （1）将值value插入列表key中，位于pivot前面或者后面（2）pivot不存在于列表key时，不执行任何操作（3）key不存在，不执行任何操作 | LINSERT key BEFORE\|AFTER pivot value |
| LLEN      | （1）返回列表key的长度（2）key不存在，返回0                  | LLEN key                              |
| LTRIM     | （1）对一个列表进行修剪，让列表只返回指定区间内的元素，不存在指定区间内的都将被移除 | LTRIM key start stop                  |
| RPOP      | （1）移除并返回列表key的尾元素                               | RPOP key                              |
| RPOPLPUSH | 在一个原子时间内，执行两个动作：（1）将列表source中最后一个元素弹出并返回给客户端（2）将source弹出的元素插入到列表desination，作为destination列表的头元素 | RPOPLPUSH source destination          |
| RPUSH     | （1）将一个或多个值value插入到列表key的表尾                  | RPUSH key value [value ...]           |
| RPUSHX    | （1）将value插入到列表key的表尾，当且仅当key存在并且是一个列表（2）key不存在，RPUSHX什么都不做 | RPUSHX key value                      |

理解Redis的List了，**操作List千万注意区分LPUSH、RPUSH两个命令，把数据添加到表头和把数据添加到表尾是完全不一样的两种结果**。

另外List还有BLPOP、BRPOP、BRPOPLPUSH三个命令没有说，它们是几个POP的阻塞版本，**即没有数据可以弹出的时候将阻塞客户端直到超时或者发现有可以弹出的元素为止**。

#### **典型使用场景**

- Stack(栈)：通过命令 lpush+lpop
- Queue（队列）：命令 lpush+rpop
- Capped Collection（有限集合）：命令 lpush+ltrim
- Message Queue（消息队列）：命令 lpush+brpop 消息队列，可以利用 List 的 *PUSH 操作，将任务存在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。
-  TimeLine：使用 List 结构，我们可以轻松地实现最新消息排行等功能（比如新浪微博的 TimeLine ）。例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。

### Hash(字典)

![Redis-Hash](png/Redis/Redis-Hash.png)

Hash 是一个键值对集合，是一个 string 类型的 key和 value 的映射表，key 还是key，但是value是一个键值对（key-value）。类比于 Java里面的 Map<String,Map<String,Object>> 集合。

#### Hash命令

接着我们用表格看一下Hash数据结构的相关命令：

| **命令** | **描述**                                                     | **用法**                                |
| -------- | ------------------------------------------------------------ | --------------------------------------- |
| HSET     | （1）将哈希表Key中的域field的值设为value（2）key不存在，一个新的Hash表被创建（3）field已经存在，旧的值被覆盖 | HSET key field value                    |
| HGET     | （1）返回哈希表key中给定域field的值                          | HGET key field                          |
| HDEL     | （1）删除哈希表key中的一个或多个指定域（2）不存在的域将被忽略 | HDEL key filed [field ...]              |
| HEXISTS  | （1）查看哈希表key中，给定域field是否存在，存在返回1，不存在返回0 | HEXISTS key field                       |
| HGETALL  | （1）返回哈希表key中，所有的域和值                           | HGETALL key                             |
| HINCRBY  | （1）为哈希表key中的域field加上增量increment（2）其余同INCR命令 | HINCRYBY key filed increment            |
| HKEYS    | （1）返回哈希表key中的所有域                                 | HKEYS key                               |
| HLEN     | （1）返回哈希表key中域的数量                                 | HLEN key                                |
| HMGET    | （1）返回哈希表key中，一个或多个给定域的值（2）如果给定的域不存在于哈希表，那么返回一个nil值 | HMGET key field [field ...]             |
| HMSET    | （1）同时将多个field-value对设置到哈希表key中（2）会覆盖哈希表中已存在的域（3）key不存在，那么一个空哈希表会被创建并执行HMSET操作 | HMSET key field value [field value ...] |
| HVALS    | （1）返回哈希表key中所有的域和值                             | HVALS key                               |

#### **典型使用场景**

- 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力
- 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源
- session：常见方案spring session + redis实现session共享

### Set(集合)
Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。

Redis 的 set 是 String 类型的无序集合。

相对于列表，集合也有两个特点：

**一、无序**

​       **二、不可重复**

#### Set命令

接着我们看一下SET数据结构的相关操作：

| **命令**    | **描述**                                                     | **用法**                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------- |
| SADD        | （1）将一个或多个member元素加入到key中，已存在在集合的member将被忽略（2）假如key不存在，则只创建一个只包含member元素做成员的集合（3）当key不是集合类型时，将返回一个错误 | SADD key number [member ...]          |
| SCARD       | （1）返回key对应的集合中的元素数量                           | SCARD key                             |
| SDIFF       | （1）返回一个集合的全部成员，该集合是第一个Key对应的集合和后面key对应的集合的差集 | SDIFF key [key ...]                   |
| SDIFFSTORE  | （1）和SDIFF类似，但结果保存到destination集合而不是简单返回结果集（2） destination如果已存在，则覆盖 | SDIFFSTORE destionation key [key ...] |
| SINTER      | （1）返回一个集合的全部成员，该集合是所有给定集合的交集（2）不存在的key被视为空集 | SINTER key [key ...]                  |
| SINTERSTORE | （1）和SINTER类似，但结果保存早destination集合而不是简单返回结果集（2）如果destination已存在，则覆盖（3）destination可以是key本身 | SINTERSTORE destination key [key ...] |
| SISMEMBER   | （1）判断member元素是否key的成员，0表示不是，1表示是         | SISMEMBER key member                  |
| SMEMBERS    | （1）返回集合key中的所有成员（2）不存在的key被视为空集       | SMEMBERS key                          |
| SMOVE       | （1）原子性地将member元素从source集合移动到destination集合（2）source集合中不包含member元素，SMOVE命令不执行任何操作，仅返回0（3）destination中已包含member元素，SMOVE命令只是简单做source集合的member元素移除 | SMOVE source desination member        |
| SPOP        | （1）移除并返回集合中的一个随机元素，如果count不指定那么随机返回一个随机元素（2）count为正数且小于集合元素数量，那么返回一个count个元素的数组且数组中的**元素各不相同**（3）count为正数且大于等于集合元素数量，那么返回整个集合（4）count为负数那么命令返回一个数组，数组中的**元素可能重复多次**，数量为count的绝对值 | SPOP key [count]                      |
| SRANDMEMBER | （1）如果count不指定，那么返回集合中的一个随机元素（2）count同上 | SRANDMEMBER key [count]               |
| SREM        | （1）移除集合key中的一个或多个member元素，不存在的member将被忽略 | SREM key member [member ...]          |
| SUNION      | （1）返回一个集合的全部成员，该集合是所有给定集合的并集（2）不存在的key被视为空集 | SUNION key [key ...]                  |
| SUNIONSTORE | （1）类似SUNION，但结果保存到destination集合而不是简单返回结果集（2）destination已存在，覆盖旧值（3）destination可以是key本身 | SUNION destination key [key ...]      |

#### **典型使用场景**

- 共同好友、二度好友。利用集合的交并集特性，比如在社交领域，我们可以很方便的求出多个用户的共同好友，共同感兴趣的领域等。比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。
- 利用唯一性，可以统计访问网站的所有独立 IP
- 好友推荐的时候，根据 tag 求交集，大于某个 threshold 就可以推荐
- 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人　
- 点赞，或点踩，收藏等，可以放到set中实现


### Sorted Set(有序集合)
有序集合（sorted set ），和上面的set 数据类型一样，也是 string 类型元素的集合，但是它是有序的。和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。

#### SortedSet命令

SortedSet顾名思义，即有序的Set，看下相关命令：

| **命令**         | **描述**                                                     | **用法**                                                  |
| ---------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| ZADD             | （1）将一个或多个member元素及其score值加入有序集key中（2）如果member已经是有序集的成员，那么更新member对应的score并重新插入member保证member在正确的位置上（3）score可以是整数值或双精度浮点数 | ZADD key score member [[score member] [score member] ...] |
| ZCARD            | （1）返回有序集key的元素个数                                 | ZCARD key                                                 |
| ZCOUNT           | （1） 返回有序集key中，score值>=min且<=max的成员的数量       | ZCOUNT key min max                                        |
| ZRANGE           | （1）返回有序集key中指定区间内的成员，成员位置按score从小到大排序（2）具有相同score值的成员按字典序排列（3）需要成员按score从大到小排列，使用ZREVRANGE命令（4）下标参数start和stop都以0为底，也可以用负数，-1表示最后一个成员，-2表示倒数第二个成员（5）可通过WITHSCORES选项让成员和它的score值一并返回 | ZRANGE key start stop [WITHSCORES]                        |
| ZRANK            | （1）返回有序集key中成员member的排名，有序集成员按score值从小到大排列（2）排名以0为底，即score最小的成员排名为0（3）ZREVRANK命令可将成员按score值从大到小排名 | ZRANK key number                                          |
| ZREM             | （1）移除有序集key中的一个或多个成员，不存在的成员将被忽略（2）当key存在但不是有序集时，返回错误 | ZREM key member [member ...]                              |
| ZREMRANGEBYRANK  | （1）移除有序集key中指定排名区间内的所有成员                 | ZREMRANGEBYRANK key start stop                            |
| ZREMRANGEBYSCORE | （1）移除有序集key中，所有score值>=min且<=max之间的成员      | ZREMRANGEBYSCORE key min max                              |

#### **典型使用场景**

- 带有权重的元素，比如一个游戏的用户得分排行榜。和set数据结构一样，zset也可以用于社交领域的相关业务，并且还可以利用zset 的有序特性，还可以做类似排行榜的业务。
- 比较复杂的数据结构，一般用到的场景不算太多
- 排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。