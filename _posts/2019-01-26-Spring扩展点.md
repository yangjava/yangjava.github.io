---
layout: post
categories: [Spring]
description: none
keywords: Spring
---
# Spring扩展点
spring容器启动时，会先解析BeanDefinition，然后生成BeanDefinition信息；再实例化生成bean对象，在这个过程中spring为我们提供了很多扩展点，来实现定制功能。

## 常用扩展点
IOC（控制反转） 和 AOP（面向切面编程）是spring的基石。除此之外，spring的扩展能力非常强。由于这个优势的存在，让spring拥有强大的包容能力，让很多第三方应用能够轻松投入spring的怀抱。比如：rocketmq、mybatis、redis等。

Spring中最常用的扩展点

- 自定义拦截器
- Spring容器对象获取
- 全局异常处理
- 类型转换器
- 导入配置
- 项目启动配置
- BeanDefinition的修改
- Bean前后初始化
- 初始化方法
- 容器关闭
- 自定义作用域

### 解析BeanDefinition阶段
- BeanFactoryPostProcessor：bean工厂后置处理器，可以用来注册bean定义
- BeanDefinitionRegistryPostProcessor: 可以用来注册、移除、修改bean定义
- ImportBeanDefinitionRegistrar：通过@Import注解导入，可以用来注册bean定义

### Bean的生命周期阶段
- BeanPostProcessor：在创建Bean的过程中可以对实例化前后、属性赋值、初始化前后进行干预
- Aware接口：比如BeanNameAware， BeanFactoryAware等等，在bean实例化过程中调用
- FactoryBean：自定义一个特殊工厂bean对象
- InitializingBean：在bean初始化时调用

### Spring容器启动完成阶段
- SmartInitializingSingleton：在容器启动完成时调用（getBean创建完bean时调用）
- LifecycleProcessor：在容器完成刷新时调用
- ApplicationContextEvent：发布容器刷新事件

### 推荐使用的扩展点
- ImportBeanDefinitionRegistrar：通过@Import注解导入来注册bean定义
- @PostConstruct：注解定义初始化方法
- FactoryBean：将具体相同逻辑的类通过工厂bean来创建代理对象
- ApplicationContextEvent：容器刷新事件
- LifecycleProcessor：容器生命周期处理类

### 扩展点执行顺序及示例代码
- 解析BeanDefinition阶段：HelloService，HelloService1通过bean工厂后置处理器进行注册BeanDefinition
- bean生命周期阶段：bean的后置处理器，加了判断，只有beanName是demoService时才处理
- 容器启动完成阶段：bean创建完成后会调用容器启动后的扩展点

## Spring所有扩展接口
Spring的核心思想就是容器，内部想要把自动装配玩的转，就必须要了解spring对于bean的构造生命周期以及各个扩展接口。当然业务代码也能合理利用这些扩展点写出更加漂亮的代码。这里总结了几乎Spring & Springboot所有的扩展接口，以及各个扩展点的使用场景。下面是一个bean在spring内部从被加载到最后初始化完成所有可扩展点的顺序调用图。
```
org.springframework.context.ApplicationContextInitializer#initialize
org.springframework.context.support.AbstractApplicationContext#refresh
org.springframework.context.support.AbstractApplicationContext#initPropertySources
org.springframework.context.support.AbstractApplicationContext#addBeanFactoryPostProcessor
org.springframework.context.support.AbstractApplicationContext#addApplicationListener
org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry

```

## Spring所有扩展接口详解

### ApplicationContextInitializer
整个spring容器在刷新之前初始化ConfigurableApplicationContext的回调接口，简单来说，就是在容器刷新之前调用此类的initialize方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。

```
public class TestApplicationContextInitializer implements ApplicationContextInitializer {      
    @Override      
    public void initialize(ConfigurableApplicationContext applicationContext) {      
        System.out.println("[ApplicationContextInitializer]");      
    }      
}  

```
这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：

在启动类中用springApplication.addInitializers(new TestApplicationContextInitializer())语句加入
```
@SpringBootApplication
public class SpringextendApplication {

    public static void main(String[] args) {
        SpringApplication springApplication = new SpringApplication(SpringextendApplication.class);
        springApplication.addInitializers(new TestApplicationContextInitializer());
        springApplication.run(args);
    }
}
```

配置文件配置
```
context.initializer.classes=com.example.demo.TestApplicationContextInitializer
```

Spring SPI扩展，在spring.factories中加入
```
org.springframework.context.ApplicationContextInitializer=com.example.demo.TestApplicationContextInitializer
```

### BeanDefinitionRegistryPostProcessor
这个接口在读取项目中的beanDefinition之后执行，提供一个补充的扩展点。使用场景：可以在这里动态注册自己的beanDefinition，可以加载classpath之外的bean
```
@Component
public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        System.out.println("[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry");
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory");
    }
}
```

### BeanFactoryPostProcessor
这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。
```
@Component
public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("[BeanFactoryPostProcessor]");
    }
}
```

### InstantiationAwareBeanPostProcessor
该接口继承了BeanPostProcess接口，区别如下：BeanPostProcess接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而InstantiationAwareBeanPostProcessor接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。

该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：实例化阶段和初始化阶段，，按调用顺序为：

- postProcessBeforeInstantiation：实例化bean之前，相当于new这个bean之前
- postProcessAfterInstantiation：实例化bean之后，相当于new这个bean之后
- postProcessPropertyValues：bean已经实例化完成，在属性注入时阶段触发，@Autowired,@Resource等注解原理基于此方法实现
- postProcessBeforeInitialization：初始化bean之前，相当于把bean注入spring上下文之前
- postProcessAfterInitialization：初始化bean之后，相当于把bean注入spring上下文之后

使用场景：，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。
```
@Component
public class TestInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("[TestInstantiationAwareBeanPostProcessor] before initialization " + beanName);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("[TestInstantiationAwareBeanPostProcessor] after initialization " + beanName);
        return bean;
    }

    @Override
    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
        System.out.println("[TestInstantiationAwareBeanPostProcessor] before instantiation " + beanName);
        return null;
    }

    @Override
    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        System.out.println("[TestInstantiationAwareBeanPostProcessor] after instantiation " + beanName);
        return true;
    }

    @Override
    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {
        System.out.println("[TestInstantiationAwareBeanPostProcessor] postProcessProperties " + beanName);
        return pvs;
    }

}
```

### SmartInstantiationAwareBeanPostProcessor
该扩展接口有3个触发点方法：

- predictBeanType：该触发点发生在postProcessBeforeInstantiation之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。
- determineCandidateConstructors：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。
- getEarlyBeanReference：该触发点发生在postProcessAfterInstantiation之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。

```
@Component
public class TestSmartInstantiationAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor {

    @Override
    public Class<?> predictBeanType(Class<?> beanClass, String beanName) throws BeansException {
        System.out.println("[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType " + beanName);
        return beanClass;
    }

    @Override
    public Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, String beanName) throws BeansException {
        System.out.println("[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors " + beanName);
        return null;
    }

    @Override
    public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
        System.out.println("[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference " + beanName);
        return bean;
    }
}
```

### BeanFactoryAware
这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为setBeanFactory，可以拿到BeanFactory这个属性。使用场景：你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。也或者可以把BeanFactory拿到进行缓存，日后使用
```
@Component
public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("[BeanFactoryPostProcessor] " + beanFactory.toString());
        // 下面这个有循环依赖问题
        // System.out.println("[TestBeanFactoryAware] " + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName());
    }
}

```

### ApplicationContextAwareProcessor
该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前。该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行扩展接口，来获取对应容器的变量。所以这里应该来说是有6个扩展点

EnvironmentAware：用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。

EmbeddedValueResolverAware：用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取，如果实现了这个Aware接口，把StringValueResolver缓存起来，通过这个类去获取String类型的变量，效果是一样的。

ResourceLoaderAware：用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。

ApplicationEventPublisherAware：用于获取ApplicationEventPublisher的一个扩展类，ApplicationEventPublisher可以用来发布事件，结合ApplicationListener来共同使用，下文在介绍ApplicationListener时会详细提到。这个对象也可以通过spring注入的方式来获得。

MessageSourceAware：用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。

ApplicationContextAware：用来获取ApplicationContext的一个扩展类，ApplicationContext应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时ApplicationContext也实现了BeanFactory，MessageSource，ApplicationEventPublisher等接口，也可以用来做相关接口的事情。

### BeanNameAware
这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是postProcessBeforeInitialization之前，这个类的触发点方法只有一个：setBeanName。使用场景：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。
```
@Component
public class NormalBeanA implements BeanNameAware {
    public NormalBeanA() {
        System.out.println("NormalBean constructor");
    }

    @Override
    public void setBeanName(String name) {
        System.out.println("[BeanNameAware] " + name);
    }
}
```

### @PostConstruct
这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了@PostConstruct，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在postProcessBeforeInitialization之后，InitializingBean.afterPropertiesSet之前。使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性


### InitializingBean
这个类也是用来初始化bean的。InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在postProcessAfterInitialization之前。使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。

### FactoryBean
Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<T>的形式

使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿ProxyFactoryBean的功能。
```
@Component
public class TestFactoryBean implements FactoryBean<TestFactoryBean.TestFactoryInnerBean> {

    @Override
    public TestFactoryBean.TestFactoryInnerBean getObject() throws Exception {
        System.out.println("[FactoryBean] getObject");
        return new TestFactoryBean.TestFactoryInnerBean();
    }

    @Override
    public Class<?> getObjectType() {
        return TestFactoryBean.TestFactoryInnerBean.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }

    public static class TestFactoryInnerBean{

    }
}
```

### SmartInitializingSingleton
这个接口中只有一个方法afterSingletonsInstantiated，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为postProcessAfterInitialization之后。使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。
```
@Component
public class TestSmartInitializingSingleton implements SmartInitializingSingleton {
    @Override
    public void afterSingletonsInstantiated() {
        System.out.println("[TestSmartInitializingSingleton]");
    }
}
```

### CommandLineRunner
这个接口也只有一个方法：run(String... args)，触发时机为整个项目启动完毕后，自动执行。如果有多个CommandLineRunner，可以利用@Order来进行排序。使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。
```
@Component
public class TestCommandLineRunner implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        System.out.println("[TestCommandLineRunner]");
    }
}
```

### DisposableBean
这个扩展点也只有一个方法：destroy()，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。

### ApplicationListener
准确的说，这个应该不算spring&springboot当中的一个扩展点，ApplicationListener可以监听某个事件的event，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。

接下来罗列下spring主要的内置事件：

- ContextRefreshedEvent
ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext接口中使用 refresh()方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。
- ContextStartedEvent
当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。
- ContextStoppedEvent
当使用 ConfigurableApplicationContext接口中的 stop()停止ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作
- ContextClosedEvent
当使用 ConfigurableApplicationContext接口中的 close()方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启
- RequestHandledEvent
这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件

## 常用扩展点详解

### 自定义拦截器
spring mvc拦截器与spring拦截器相比，它里面能够获取HttpServletRequest和HttpServletResponse等web对象实例。

spring mvc拦截器的顶层接口是：HandlerInterceptor，包含三个方法：
- preHandle目标方法执行前执行
- postHandle 目标方法执行后执行
- afterCompletion请求完成时执行

一般情况会用HandlerInterceptor接口的实现类HandlerInterceptorAdapter类。假如有权限认证、日志、统计的场景，可以使用该拦截器。

代码详情
首先继承HandlerInterceptorAdapter类定义拦截器
```
public class AuthInterceptor extends HandlerInterceptorAdapter {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        String requestUrl = request.getRequestURI();
        if (checkAuth(requestUrl)) {
            return true;
        }

        return false;
    }

    private boolean checkAuth(String requestUrl) {
        System.out.println("===权限校验===");
        return true;
    }
}
```
然后将该拦截器注册到spring容器
```
@Configuration
public class WebAuthConfig extends WebMvcConfigurerAdapter {
 
    @Bean
    public AuthInterceptor getAuthInterceptor() {
        return new AuthInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new AuthInterceptor());
    }
}

```
最后在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。

### 获取Spring容器对象
在我们日常开发中，除了通过@Autowired注解获取Bean外，有时候我们会经常需要从Spring容器中手动获取Bean，下面是几种手动获取Bean的方法

BeanFactoryAware接口
实现BeanFactoryAware接口，然后重写setBeanFactory方法，就能从该方法中获取到spring容器对象
```
@Service
public class PersonService implements BeanFactoryAware {
    private BeanFactory beanFactory;

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }

    public void add() {
        Person person = (Person) beanFactory.getBean("person");
    }
}
```

ApplicationContextAware接口
实现ApplicationContextAware接口，然后重写setApplicationContext方法，也能从该方法中获取到spring容器对象
```
@Service
public class PersonService2 implements ApplicationContextAware {
    private ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    public void add() {
        Person person = (Person) applicationContext.getBean("person");
    }
}
```
ApplicationListener接口
```
@Service
public class PersonService3 implements ApplicationListener<ContextRefreshedEvent> {
    private ApplicationContext applicationContext;
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        applicationContext = event.getApplicationContext();
    }

    public void add() {
        Person person = (Person) applicationContext.getBean("person");
    }
}
```

### 全局异常处理
我们在开发接口时，如果出现异常，为了给用户一个更友好的提示，必须在每一个接口处捕获异常，但是随着接口数量增加，代码量和可维护性也随之增加，因此全局异常捕获就派上用场了：RestControllerAdvice。只需在handleException方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（程序统一处理了）

```
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public String handleException(Exception e) {
        if (e instanceof ArithmeticException) {
            return "数据异常";
        }
        if (e instanceof Exception) {
            return "服务器内部异常";
        }
        retur null;
    }
}
```

### 类型转换器
spring目前支持3中类型转换器

Converter<S,T>：将 S 类型对象转为 T 类型对象

ConverterFactory<S, R>：将 S 类型对象转为 R 类型及子类对象

GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换

SpringMVC 中提供了一个接口org.springframework.core.convert.converter.Converter，这个接口用来将一种类型转换为另一种类型，调用后端接口的时候，http 传递的参数都是字符串类型的，但是后端却可以使用 Integer、Double 等其他类型来接收，这就是Converter实现的。Spring 内部也提供了很多默认的实现，用于各种类型转换
```
@FunctionalInterface
public interface Converter<S, T> {

 /**
  * 将source转换为目标T类型
  */
 @Nullable
 T convert(S source);
}
```

### 配置的导入
有时我们需要在某个配置类中引入另外一些类，被引入的类也加到spring容器中。这时可以使用@Import注解完成这个功能。通过源码会发现，引入的类支持三种不同类型，将普通类和@Configuration注解的配置类分开讲解，列了四种不同类型
- 普通类
- @Configuration注解
- ImportSelector接口类
- ImportBeanDefinitionRegistrar接口类

普通类
这种引入方式是最简单的，被引入的类会被实例化bean对象
```
public class A {
}

@Import(A.class)
@Configuration
public class TestConfiguration {
}
```
通过@Import注解引入A类，spring就能自动实例化A对象，然后在需要使用的地方通过@Autowired注解注入即可，不用加@Bean注解也能实例化bean

配置类
这种引入方式是最复杂的，因为@Configuration注解还支持多种组合注解，比如：

@Import

@ImportResource

@PropertySource等

通过@Import注解引入@Configuration注解的配置类，会把该配置类相关@Import、@ImportResource、@PropertySource等注解引入的类进行递归，一次性全部引入。
```
public class A {
}

public class B {
}

@Import(B.class)
@Configuration
public class AConfiguration {

    @Bean
    public A a() {
        return new A();
    }
}

@Import(AConfiguration.class)
@Configuration
public class TestConfiguration {
}
```

ImportSelector
这种引入方式需要实现ImportSelector接口，好处是selectImports方法返回的是数组，意味着可以同时引入多个类，还是非常方便的
```
public class AImportSelector implements ImportSelector {

private static final String CLASS_NAME = "com.sue.cache.service.test13.A";
    
 public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{CLASS_NAME};
    }
}

@Import(AImportSelector.class)
@Configuration
public class TestConfiguration {
}
```

ImportBeanDefinitionRegistrar
种引入方式需要实现ImportBeanDefinitionRegistrar接口，这种方式是最灵活的，能在registerBeanDefinitions方法中获取到BeanDefinitionRegistry容器注册对象，可以手动控制BeanDefinition的创建和注册。
```
public class AImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(A.class);
        registry.registerBeanDefinition("a", rootBeanDefinition);
    }
}

@Import(AImportBeanDefinitionRegistrar.class)
@Configuration
public class TestConfiguration {
}
```

### 项目启动时
有时候我们需要在项目启动时定制化一些附加功能，比如：加载一些系统参数、完成初始化、预热本地缓存等，该怎么办呢？好消息是springboot提供了：

CommandLineRunner

ApplicationRunner

这两个接口帮助我们实现以上需求。它们的用法很简单的，以ApplicationRunner接口为例：
```
@Component
public class TestRunner implements ApplicationRunner {

    @Autowired
    private LoadDataService loadDataService;

    public void run(ApplicationArguments args) throws Exception {
        loadDataService.load();
    }
}
```
实现ApplicationRunner接口，重写run方法，在该方法中实现自己定制化需求。如果项目中有多个类实现了ApplicationRunner接口，他们的执行顺序要怎么指定呢？答案是使用@Order(n)注解，n的值越小越先执行。当然也可以通过@Priority注解指定顺序。

### 修改BeanDefinition
Spring IOC在实例化Bean对象之前，需要先读取Bean的相关属性，保存到BeanDefinition对象中，然后通过BeanDefinition对象，实例化Bean对象。如果想修改BeanDefinition对象中的属性，该怎么办呢？我们可以实现BeanFactoryPostProcessor接口

在postProcessBeanFactory方法中，可以获取BeanDefinition的相关对象，并且修改该对象的属性
```
@Component
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
        DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
        beanDefinitionBuilder.addPropertyValue("id", 123);
        beanDefinitionBuilder.addPropertyValue("name", "shawn");
        defaultListableBeanFactory.registerBeanDefinition("user", beanDefinitionBuilder.getBeanDefinition());
    }
}
```

### 初始化Bean前后
有时候需要在初始化Bean前后，实现一些自己的逻辑。这时可以实现BeanPostProcessor接口，该接口目前有两个方法：

postProcessBeforeInitialization 该在初始化方法之前调用。

postProcessAfterInitialization 该方法再初始化方法之后调用。

如果spring中存在User对象，则将它的userName设置成：shawn666。其实，我们经常使用的注解，比如：@Autowired、@Value、@Resource、@PostConstruct等，是通过AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor实现的。
```
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof User) {
            ((User) bean).setUserName("shawn666");
        }
        return bean;
    }
}
```

### 初始化方法
spring中使用比较多的初始化bean的方法有：
- 使用@PostConstruct注解
- 实现InitializingBean接口

使用@PostConstruct注解
在需要初始化的方法上增加@PostConstruct注解，这样就有初始化的能力
```
@Service
public class AService {
    @PostConstruct
    public void init() {
        System.out.println("===初始化===");
    }
}
```

实现InitializingBean接口
实现InitializingBean接口，重写afterPropertiesSet方法，该方法中可以完成初始化功能
```
@Service
public class BService implements InitializingBean {

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("===初始化===");
    }
}
```

关闭容器前
有时候，我们需要在关闭spring容器前，做一些额外的工作，比如：关闭资源文件等。这时可以实现DisposableBean接口，并且重写它的destroy方法：
```
@Service
public class DService implements InitializingBean, DisposableBean {
 
    @Override
    public void destroy() throws Exception {
        System.out.println("DisposableBean destroy");
    }
 
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("InitializingBean afterPropertiesSet");
    }
}

```
这样spring容器销毁前，会调用该destroy方法，做一些额外的工作。通常情况下，我们会同时实现InitializingBean和DisposableBean接口，重写初始化方法和销毁方法。

### 自定义作用域
我们都知道spring默认支持的Scope只有两种：

singleton 单例，每次从spring容器中获取到的bean都是同一个对象。

prototype 多例，每次从spring容器中获取到的bean都是不同的对象。

spring web又对Scope进行了扩展，增加了：

**RequestScope **同一次请求从spring容器中获取到的bean都是同一个对象。

**SessionScope **同一个会话从spring容器中获取到的bean都是同一个对象。

即便如此，有些场景还是无法满足我们的要求。比如，我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？这就需要自定义Scope了。

第一步实现Scope接口
```
public class ThreadLocalScope implements Scope {
    private static final ThreadLocal THREAD_LOCAL_SCOPE = new ThreadLocal();

    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        Object value = THREAD_LOCAL_SCOPE.get();
        if (value != null) {
            return value;
        }

        Object object = objectFactory.getObject();
        THREAD_LOCAL_SCOPE.set(object);
        return object;
    }

    @Override
    public Object remove(String name) {
        THREAD_LOCAL_SCOPE.remove();
        return null;
    }

    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
    }

    @Override
    public Object resolveContextualObject(String key) {
        return null;
    }

    @Override
    public String getConversationId() {
        return null;
    }
}
```

第二步将新定义的Scope注入到spring容器中
```
@Component
public class ThreadLocalBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        beanFactory.registerScope("threadLocalScope", new ThreadLocalScope());
    }
}
```

第三步使用新定义的Scope
```
@Scope("threadLocalScope")
@Service
public class CService {
    public void add() {
    }
}
```








