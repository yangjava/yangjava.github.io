---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL数据结构THD

## 什么是THD
是非常非常不想说这个数据结构的，按照设计原则和设计思想，这个类就是个让人无语的。可存在，就有它的道理，绕是绕不过去的。

这个类在前面提到过，它是对线程描述的一个数据结构。MySql里用到线程的地方不少，那么理所当然的这个THD类用到的地方也不少。在前面分析网络操作的时候儿就看到这个类的身影，讲真，是不想分析这个类的，不是说这个类多难，是这个类承载的东西太多。本身线程自己的定义就承载了很多相关的信息，再在此基础上进行抽象封装的THD类，一定是更多，但是不分析，又绕不过去，就勉强为之一下。

## 数据结构定义和分析
在前面的"线程池和线程"中大概分析过这个类，今天再次深入的分析一下。
这个类给人的第一印象是太大了，成员太多了。从811行的定义到4374行的一个巨型类。一般在编程的建议中，一个类的大小一般建议不超过1000行，不过，看国外的开源代码，确实一个类几千行的有不少，所以请明白建议就是建议，干起活儿来，听不听就是两回事儿了。
```
/**
  @class THD
  For each client connection we create a separate thread with THD serving as
  a thread/connection descriptor
*/

class THD : public MDL_context_owner,
            public Query_arena,
            public Open_tables_state {
 private:
  inline bool is_stmt_prepare() const {
    assert(0);
    return Query_arena::is_stmt_prepare();
  }

  inline bool is_stmt_prepare_or_first_sp_execute() const {
    assert(0);
    return Query_arena::is_stmt_prepare_or_first_sp_execute();
  }

  inline bool is_stmt_prepare_or_first_stmt_execute() const {
    assert(0);
    return Query_arena::is_stmt_prepare_or_first_stmt_execute();
  }

  inline bool is_regular() const {
    assert(0);
    return Query_arena::is_regular();
  }
  ......

  public:
  Transactional_ddl_context m_transactional_ddl{this};
  bool m_inside_system_variable_global_update;

  public:
  PS_PARAM * bind_parameter_values;

  unsigned long bind_parameter_values_count;
}

```
在这个类的开头的注释上说明：每个客户端连接到服务器时都会创建一个单独的线程类（THD）对象为做对线程<=>连接(这二者相当于形成一个映射)的整体的描述。

这里对几个重要的分类进行简要说明一下：
- 1、继承关系上，三个类非常明显：
MDL_context_owner：抽象接口代码，用来实现MDL模块和THD以及服务端代码分离。主要有元数据锁的相关接口，含控制和信息通知等。
Query_arena：看它的元素定义Item * m_item_list，它内部一定维护着一个很大的列表 而Item又继承自Parse_tree_node，所以它内部一定维护着Query语句（存储过程）的相关解析后的元素，也就是抽象语法树的结节。
Open_tables_state：该类保存线程有关已打开和锁定的表的状态，同时维护了表的信息和和锁信息。其提供了压入和弹出两个状态接口函数来操作这两类状态。

- 2、其内部有几个嵌套类：
对嵌套类不了解的可以看一下《c++编程思想》，简单理解就是一个类内部的类，用于控制访问权限。
Attachable_trx：表示只读可附加事务的类，封装了解如何备份当前事务的状态，启动SE中的只读可附加事务，完成它，然后还原返回原始事务的状态。还用作的基类可读写可附加事务实现。
Attachable_trx_rw：Attachable_trx类派生的类允许在可附加事务中进行更新。
Query_plan：先用LOCK_query_plan锁定再进行EXPLAINable命令的查询计划。
Transaction_state：Attachable_trx的实用程序结构。

- 3、一般来说，线程必然离不开锁，所以此类一定有不少锁相关的类、函数和接口等。比如MDL_context、User_level_lock、Global_read_lock等。
- 4、日志处理相关，如Gtid、Log、Binlog。
- 5、相关上下文处理的类和接口如sp_rcontext、Resource_group_ctx、Security_context等。
- 6、事务相关如Transaction_ctx等上面提到的内部类。
- 7、相关数据的处理和分析类和接口，如Item_change_record、sql_digest_state：Current、sp_cache等。
- 8、相关其它数据结构及协议和语法语义的接口如通信的VIO、语法分析LEX、内部状态机Parser_state以及提到的内部类Query_plan。另外还有相关的协议处理如传统协议(Protocal_classic)，文本协议(Protocal_text)，二进制协议(Protocal_binary)。
- 9、其它辅助的相关对象如插件相关信息等。

官方文档的定义在：
https://dev.mysql.com/doc/dev/mysql-server/latest/classTHD.html

## 初始化
在前面分析过，初始化是在事件循环中展开的：
```
void connection_event_loop() {
  Connection_handler_manager * mgr =
      Connection_handler_manager::get_instance();
  while (!connection_events_loop_aborted()) {
    Channel_info * channel_info = m_listener->listen_for_connection_event();
    if (channel_info != nullptr) mgr->process_new_connection(channel_info);
  }
}

bool Per_thread_connection_handler::add_connection(Channel_info *channel_info) {
  int error = 0;
  my_thread_handle id;

  DBUG_TRACE;

  // Simulate thread creation for test case before we check thread cache
  DBUG_EXECUTE_IF("fail_thread_create", error = 1; goto handle_error;);

  if (!check_idle_thread_and_enqueue_connection(channel_info)) return false;

  channel_info->set_prior_thr_create_utime();
  error =
      mysql_thread_create(key_thread_one_connection, &id, &connection_attrib,
                          handle_connection, (void *)channel_info);
#ifndef NDEBUG
handle_error:
#endif  // !NDEBUG

  if (error) {
    connection_errors_internal++;
    if (!create_thd_err_log_throttle.log())
      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);
    channel_info->send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,
                                               true);
    Connection_handler_manager::dec_connection_count();
    return true;
  }

  Global_THD_manager::get_instance()->inc_thread_created();
  DBUG_PRINT("info", ("Thread created"));
  return false;
}

uint Per_thread_connection_handler::get_max_threads() const {
  return max_connections;
}


```
它想出了线程THD的初始化：
```
extern "C" {
static void * handle_connection(void * arg) {
 Global_THD_manager * thd_manager = Global_THD_manager::get_instance();
 Connection_handler_manager * handler_manager =
     Connection_handler_manager::get_instance();
 Channel_info * channel_info = static_cast<Channel_info * >(arg);
 bool pthread_reused MY_ATTRIBUTE((unused)) = false;

 if (my_thread_init()) {
   connection_errors_internal++;
   channel_info->send_error_and_close_channel(ER_OUT_OF_RESOURCES, 0, false);
   handler_manager->inc_aborted_connects();
   Connection_handler_manager::dec_connection_count();
   delete channel_info;
   my_thread_exit(nullptr);
   return nullptr;
 }

 for (;;) {
   //初始化
   THD * thd = init_new_thd(channel_info);
   if (thd == nullptr) {
     connection_errors_internal++;
     handler_manager->inc_aborted_connects();
     Connection_handler_manager::dec_connection_count();
     break;  // We are out of resources, no sense in continuing.
   }

#ifdef HAVE_PSI_THREAD_INTERFACE
   if (pthread_reused) {

     PSI_thread * psi = PSI_THREAD_CALL(new_thread)(key_thread_one_connection,
                                                   thd, thd->thread_id());
     PSI_THREAD_CALL(set_thread_os_id)(psi);
     PSI_THREAD_CALL(set_thread)(psi);
   }
#endif

#ifdef HAVE_PSI_THREAD_INTERFACE

   PSI_thread * psi = PSI_THREAD_CALL(get_thread)();

   thd->set_psi(psi);
#endif
   mysql_thread_set_psi_id(thd->thread_id());
   mysql_thread_set_psi_THD(thd);
   MYSQL_SOCKET socket = thd->get_protocol_classic()->get_vio()->mysql_socket;
   mysql_socket_set_thread_owner(socket);
   thd_manager->add_thd(thd);

   if (thd_prepare_connection(thd))
     handler_manager->inc_aborted_connects();
   else {
     while (thd_connection_alive(thd)) {
       if (do_command(thd)) break;
     }
     end_connection(thd);
   }
   close_connection(thd, 0, false, false);

   thd->get_stmt_da()->reset_diagnostics_area();
   thd->release_resources();

   // Clean up errors now, before possibly waiting for a new connection.
#if OPENSSL_VERSION_NUMBER < 0x10100000L
   ERR_remove_thread_state(0);
#endif  
   thd_manager->remove_thd(thd);
   Connection_handler_manager::dec_connection_count();

#ifdef HAVE_PSI_THREAD_INTERFACE

   thd->set_psi(nullptr);
   PSI_THREAD_CALL(delete_current_thread)();
#endif  

   delete thd;

   // Server is shutting down so end the pthread.
   if (connection_events_loop_aborted()) break;

   channel_info = Per_thread_connection_handler::block_until_new_connection();
   if (channel_info == nullptr) break;
   pthread_reused = true;
   if (connection_events_loop_aborted()) {
     // Close the channel and exit as server is undergoing shutdown.
     channel_info->send_error_and_close_channel(ER_SERVER_SHUTDOWN, 0, false);
     delete channel_info;
     channel_info = nullptr;
     Connection_handler_manager::dec_connection_count();
     break;
   }
 }

 my_thread_end();
 my_thread_exit(nullptr);
 return nullptr;
}
}

```
它又会调用初始化函数：
```
static THD *init_new_thd(Channel_info *channel_info) {
  THD * thd = channel_info->create_thd();
  if (thd == nullptr) {
    channel_info->send_error_and_close_channel(ER_OUT_OF_RESOURCES, 0, false);
    delete channel_info;
    return nullptr;
  }

  thd->set_new_thread_id();

  if (channel_info->get_prior_thr_create_utime() != 0) {

    ulonglong launch_time =
        thd->start_utime - channel_info->get_prior_thr_create_utime();
    if (launch_time >= slow_launch_time * 1000000ULL)
      Per_thread_connection_handler::slow_launch_threads++;
  }
  delete channel_info;


  thd_set_thread_stack(thd, (char *)&thd);
  thd->store_globals();

  return thd;
}
THD *Channel_info::create_thd() {
  DBUG_EXECUTE_IF("simulate_resource_failure", return nullptr;);

  Vio * vio_tmp = create_and_init_vio();
  if (vio_tmp == nullptr) return nullptr;

  THD * thd = new (std::nothrow) THD;
  if (thd == nullptr) {
    vio_delete(vio_tmp);
    return nullptr;
  }

  thd->get_protocol_classic()->init_net(vio_tmp);

  return thd;
}

```
应用
从PSI_THREAD_CALL这个宏可以看到下面的函数调用：
```
//pfs_thread_provider.h
#ifdef __cplusplus
class THD;
#endif /* __cplusplus */

/*
  Naming current apis as _vc (version 'current'),
  to avoid changing the names every time
  psi_thread_v<N> is replaced by psi_thread_v<N+1>.
*/

#define PSI_THREAD_CALL(M) pfs_##M##_vc

void pfs_register_thread_vc(const char *category, PSI_thread_info *info,
                            int count);

int pfs_spawn_thread_vc(PSI_thread_key key, my_thread_handle *thread,
                        const my_thread_attr_t *attr,
                        void *(*start_routine)(void *), void *arg);

PSI_thread *pfs_new_thread_vc(PSI_thread_key key, const void *identity,
                              ulonglong processlist_id);

void pfs_set_thread_id_vc(PSI_thread *thread, ulonglong processlist_id);

ulonglong pfs_get_current_thread_internal_id_vc();

ulonglong pfs_get_thread_internal_id_vc(PSI_thread *thread);

PSI_thread *pfs_get_thread_by_id_vc(ulonglong processlist_id);

#ifdef __cplusplus
void pfs_set_thread_THD_vc(PSI_thread *thread, THD *thd);
#endif /* __cplusplus */

void pfs_set_thread_os_id_vc(PSI_thread *thread);

PSI_thread *pfs_get_thread_vc(void);

void pfs_set_thread_user_vc(const char *user, int user_len);

void pfs_set_thread_account_vc(const char *user, int user_len, const char *host,
                               int host_len);

void pfs_set_thread_db_vc(const char *db, int db_len);

void pfs_set_thread_command_vc(int command);

void pfs_set_thread_start_time_vc(time_t start_time);

void pfs_set_thread_state_vc(const char *state);

void pfs_set_connection_type_vc(opaque_vio_type conn_type);

void pfs_set_thread_info_vc(const char *info, uint info_len);

int pfs_set_thread_resource_group_vc(const char *group_name, int group_name_len,
                                     void *user_data);

int pfs_set_thread_resource_group_by_id_vc(PSI_thread *thread,
                                           ulonglong thread_id,
                                           const char *group_name,
                                           int group_name_len, void *user_data);

void pfs_set_thread_vc(PSI_thread *thread);

void pfs_set_thread_peer_port_vc(PSI_thread *thread, uint port);

void pfs_aggregate_thread_status_vc(PSI_thread *thread);

void pfs_delete_current_thread_vc(void);

void pfs_delete_thread_vc(PSI_thread *thread);

int pfs_set_thread_connect_attrs_vc(const char *buffer, uint length,
                                    const void *from_cs);

void pfs_get_current_thread_event_id_vc(ulonglong *internal_thread_id,
                                        ulonglong *event_id);

void pfs_get_thread_event_id_vc(PSI_thread *thread,
                                ulonglong *internal_thread_id,
                                ulonglong *event_id);

int pfs_get_thread_system_attrs_vc(PSI_thread_attrs *thread_attrs);

int pfs_get_thread_system_attrs_by_id_vc(PSI_thread *thread,
                                         ulonglong thread_id,
                                         PSI_thread_attrs *thread_attrs);

int pfs_register_notification_vc(const PSI_notification *callbacks,
                                 bool with_ref_count);

int pfs_unregister_notification_vc(int handle);

void pfs_notify_session_connect_vc(PSI_thread *thread);

void pfs_notify_session_disconnect_vc(PSI_thread *thread);

void pfs_notify_session_change_user_vc(PSI_thread *thread);

#endif /* WITH_LOCK_ORDER */
#endif /* MYSQL_DYNAMIC_PLUGIN */
#endif /* MYSQL_SERVER || PFS_DIRECT_CALL */
#endif /* HAVE_PSI_THREAD_INTERFACE */

#endif


```

然后看一下：
```
void Global_THD_manager::add_thd(THD *thd) {
  DBUG_PRINT("info", ("Global_THD_manager::add_thd %p", thd));
  // Should have an assigned ID before adding to the list.
  assert(thd->thread_id() != reserved_thread_id);
  const int partition = thd_partition(thd->thread_id());
  MUTEX_LOCK(lock_list, &LOCK_thd_list[partition]);
  // Technically it is not supported to compare pointers, but it works.
  std::pair<THD_array::iterator, bool> insert_result =
      thd_list[partition].insert_unique(thd);
  if (insert_result.second) ++atomic_global_thd_count;
  // Adding the same THD twice is an error.
  assert(insert_result.second);
}

```
它会开始：
```
bool do_command(THD *thd) {
  bool return_value;
  int rc;
  NET *net = nullptr;
  enum enum_server_command command;
  COM_DATA com_data;
  DBUG_TRACE;
  assert(thd->is_classic_protocol());

  /*
    indicator of uninitialized lex => normal flow of errors handling
    (see my_message_sql)
  */
  thd->lex->set_current_query_block(nullptr);

  /*
    XXX: this code is here only to clear possible errors of init_connect.
    Consider moving to prepare_new_connection_state() instead.
    That requires making sure the DA is cleared before non-parsing statements
    such as COM_QUIT.
  */
  thd->clear_error();  // Clear error message
  thd->get_stmt_da()->reset_diagnostics_area();

  /*
    This thread will do a blocking read from the client which
    will be interrupted when the next command is received from
    the client, the connection is closed or "net_wait_timeout"
    number of seconds has passed.
  */
  net = thd->get_protocol_classic()->get_net();
  my_net_set_read_timeout(net, thd->variables.net_wait_timeout);
  net_new_transaction(net);

  /*
    Synchronization point for testing of KILL_CONNECTION.
    This sync point can wait here, to simulate slow code execution
    between the last test of thd->killed and blocking in read().

    The goal of this test is to verify that a connection does not
    hang, if it is killed at this point of execution.
    (Bug#37780 - main.kill fails randomly)

    Note that the sync point wait itself will be terminated by a
    kill. In this case it consumes a condition broadcast, but does
    not change anything else. The consumed broadcast should not
    matter here, because the read/recv() below doesn't use it.
  */
  DEBUG_SYNC(thd, "before_do_command_net_read");

  /*
    Because of networking layer callbacks in place,
    this call will maintain the following instrumentation:
    - IDLE events
    - SOCKET events
    - STATEMENT events
    - STAGE events
    when reading a new network packet.
    In particular, a new instrumented statement is started.
    See init_net_server_extension()
  */
  thd->m_server_idle = true;
  rc = thd->get_protocol()->get_command(&com_data, &command);
  thd->m_server_idle = false;

  if (rc) {
#ifndef NDEBUG
    char desc[VIO_DESCRIPTION_SIZE];
    vio_description(net->vio, desc);
    DBUG_PRINT("info", ("Got error %d reading command from socket %s",
                        net->error, desc));
#endif  // NDEBUG
    /* Instrument this broken statement as "statement/com/error" */
    thd->m_statement_psi = MYSQL_REFINE_STATEMENT(
        thd->m_statement_psi, com_statement_info[COM_END].m_key);

    /* Check if we can continue without closing the connection */

    /* The error must be set. */
    assert(thd->is_error());
    thd->send_statement_status();

    /* Mark the statement completed. */
    MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());
    thd->m_statement_psi = nullptr;
    thd->m_digest = nullptr;

    if (rc < 0) {
      return_value = true;  // We have to close it.
      goto out;
    }
    net->error = NET_ERROR_UNSET;
    return_value = false;
    goto out;
  }

#ifndef NDEBUG
  char desc[VIO_DESCRIPTION_SIZE];
  vio_description(net->vio, desc);
  DBUG_PRINT("info", ("Command on %s = %d (%s)", desc, command,
                      command_name[command].str));
#endif  // NDEBUG
  DBUG_PRINT("info", ("packet: '%*.s'; command: %d",
                      (int)thd->get_protocol_classic()->get_packet_length(),
                      thd->get_protocol_classic()->get_raw_packet(), command));
  if (thd->get_protocol_classic()->bad_packet)
    assert(0);  // Should be caught earlier

  // Reclaim some memory
  thd->get_protocol_classic()->get_output_packet()->shrink(
      thd->variables.net_buffer_length);
  /* Restore read timeout value */
  my_net_set_read_timeout(net, thd->variables.net_read_timeout);

  DEBUG_SYNC(thd, "before_command_dispatch");

  return_value = dispatch_command(thd, &com_data, command);
  thd->get_protocol_classic()->get_output_packet()->shrink(
      thd->variables.net_buffer_length);

out:
  /* The statement instrumentation must be closed in all cases. */
  assert(thd->m_digest == nullptr);
  assert(thd->m_statement_psi == nullptr);
  return return_value;
}

```
这个老重要的开始就在这个线程的处理中展开了。

## 销毁
在end_connection后调用：
```
void close_connection(THD *thd, uint sql_errno, bool server_shutdown,
                      bool generate_event) {
  DBUG_TRACE;

  if (sql_errno) net_send_error(thd, sql_errno, ER_DEFAULT_NONCONST(sql_errno));
  thd->disconnect(server_shutdown);

  if (generate_event) {
    mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_CONNECTION_DISCONNECT),
                       sql_errno);
#ifdef HAVE_PSI_THREAD_INTERFACE
    PSI_THREAD_CALL(notify_session_disconnect)(thd->get_psi());
#endif  
  }

  thd->security_context()->logout();
}

```

在delete thd前调用：
```
void THD::release_resources() {
  assert(m_release_resources_done == false);

  Global_THD_manager::get_instance()->release_thread_id(m_thread_id);


  mysql_mutex_lock(&LOCK_thd_data);
  mysql_mutex_lock(&LOCK_query_plan);


  if (is_classic_protocol() && get_protocol_classic()->get_vio()) {
    vio_delete(get_protocol_classic()->get_vio());
    get_protocol_classic()->end_net();
  }


  assert(query_plan.get_modification_plan() == nullptr);
  mysql_mutex_unlock(&LOCK_query_plan);
  mysql_mutex_unlock(&LOCK_thd_data);
  mysql_mutex_lock(&LOCK_thd_query);
  mysql_mutex_unlock(&LOCK_thd_query);

  stmt_map.reset();  
  if (!cleanup_done) cleanup();

  mdl_context.destroy();
  ha_close_connection(this);


#if defined(ENABLED_DEBUG_SYNC)

  debug_sync_end_thread(this);
#endif  

  plugin_thdvar_cleanup(this, m_enable_plugins);

  assert(timer == nullptr);

  if (timer_cache) thd_timer_destroy(timer_cache);

  if (rli_fake) {
    rli_fake->end_info();
    delete rli_fake;
    rli_fake = nullptr;
  }
  mysql_audit_free_thd(this);

  if (current_thd == this) restore_globals();

  mysql_mutex_lock(&LOCK_status);

  add_to_status(&global_status_var, &status_var);
#ifdef HAVE_PSI_THREAD_INTERFACE

  if (m_psi != nullptr) {
    PSI_THREAD_CALL(aggregate_thread_status)(m_psi);
  }
#endif

  status_var_aggregated = true;

  mysql_mutex_unlock(&LOCK_status);

  m_release_resources_done = true;
}

```
再调用：
```
void Global_THD_manager::remove_thd(THD *thd) {
  DBUG_PRINT("info", ("Global_THD_manager::remove_thd %p", thd));
  const int partition = thd_partition(thd->thread_id());
  MUTEX_LOCK(lock_remove, &LOCK_thd_remove[partition]);
  MUTEX_LOCK(lock_list, &LOCK_thd_list[partition]);

  assert(unit_test || thd->release_resources_done());

  DBUG_EXECUTE_IF("sleep_after_lock_thread_count_before_delete_thd", sleep(5););

  const size_t num_erased = thd_list[partition].erase_unique(thd);
  if (num_erased == 1) --atomic_global_thd_count;
  // Removing a THD that was never added is an error.
  assert(1 == num_erased);
  mysql_cond_broadcast(&COND_thd_list[partition]);
}

my_thread_id Global_THD_manager::get_new_thread_id() {
  my_thread_id new_id;
  MUTEX_LOCK(lock, &LOCK_thread_ids);
  do {
    new_id = thread_id_counter++;
  } while (!thread_ids.insert_unique(new_id).second);
  return new_id;
}

```

其实在前面讲线程池时就提到过，线程其实不会被销毁是会被重用：
```
Channel_info *Per_thread_connection_handler::block_until_new_connection() {
  Channel_info * new_conn = nullptr;
  mysql_mutex_lock(&LOCK_thread_cache);
  if (blocked_pthread_count < max_blocked_pthreads && !shrink_cache) {

    DBUG_PRINT("info", ("Blocking pthread for reuse"));

    DBUG_POP();
    assert(!_db_is_pushed_());

    // Block pthread
    blocked_pthread_count++;
    while (!connection_events_loop_aborted() && !wake_pthread && !shrink_cache)
      mysql_cond_wait(&COND_thread_cache, &LOCK_thread_cache);
    blocked_pthread_count--;

    if (shrink_cache && blocked_pthread_count <= max_blocked_pthreads) {
      mysql_cond_signal(&COND_flush_thread_cache);
    }

    if (wake_pthread) {
      wake_pthread--;
      if (!waiting_channel_info_list->empty()) {
        new_conn = waiting_channel_info_list->front();
        waiting_channel_info_list->pop_front();
        DBUG_PRINT("info", ("waiting_channel_info_list->pop %p", new_conn));
      } else {
        assert(0);  // We should not get here.
      }
    }
  }
  mysql_mutex_unlock(&LOCK_thread_cache);
  return new_conn;
}

```
一个完整的流程就出来了，基本应用就是如此，但实际到具体的每个应用线程的位置还需要不断的看内部的代码。

## 线程类THD概述
对于每个客户端连接，我们使用THD作为线程/连接描述符创建一个单独的线程。

#include <sql_class.h>
```
//表示只读可连接事务的类，封装了有关如何备份当前事务的状态，如何在SE中启动只读可连接事务，将其完成，然后将其恢复为原始状态的知识。
class  	Attachable_trx
//从THD :: Attachable_trx类派生的类允许在可附加事务中进行更新。
class  	Attachable_trx_rw
//EXPLAINable命令的查询计划，在使用前应先用LOCK_query_plan锁定
class  	Query_plan
//Attachable_trx的实用程序结构
struct  	Transaction_state

```

公共类型
```
enum  	binlog_filter_state { BINLOG_FILTER_UNKNOWN, BINLOG_FILTER_CLEAR, BINLOG_FILTER_SET }
enum  	enum_reset_lex { RESET_LEX, DO_NOT_RESET_LEX }
enum  	Commit_error {
  CE_NONE = 0, CE_FLUSH_ERROR, CE_SYNC_ERROR, CE_COMMIT_ERROR,
  CE_ERROR_COUNT
}
enum  	killed_state {
  NOT_KILLED = 0, KILL_CONNECTION = ER_SERVER_SHUTDOWN, KILL_QUERY = ER_QUERY_INTERRUPTED, KILL_TIMEOUT = ER_QUERY_TIMEOUT,
  KILLED_NO_VALUE
}
enum  	enum_binlog_query_type { ROW_QUERY_TYPE, STMT_QUERY_TYPE, QUERY_TYPE_COUNT }
//SE GTID持久标识符类型
enum  	Se_GTID_flag : size_t {
  SE_GTID_PIN = 0, SE_GTID_CLEANUP, SE_GTID_PERSIST, SE_GTID_RESET_LOG,
  SE_GTID_MAX
}
using 	Se_GTID_flagset = std::bitset< SE_GTID_MAX

```
公共成员函数
```
dd::cache::Dictionary_client * 	dd_client () const
//该函数检查线程是否正在处理binlog的查询，这是mysqlbinlog自动生成的。 
bool 	is_binlog_applier () const
//当线程是binlog或从属应用程序时，它会分离与之关联的引擎ha_data并内存化其事实。
void 	rpl_detach_engine_ha_data ()
//当线程是binlog或从属应用程序时，它将重新附加与之关联的引擎ha_data并内存化该事实。
void 	rpl_reattach_engine_ha_data ()
bool 	rpl_unflag_detached_engine_ha_data () const
void 	reset_for_next_command ()
//清除当前查询的查询成本属性
void 	clear_current_query_costs ()
//设置当前查询的查询成本属性    
void 	save_current_query_costs ()
//锁定此THD的查询计划
void 	lock_query_plan ()
void 	unlock_query_plan ()
Security_context * 	security_context () const
void 	set_security_context (Security_context *sctx)
const Protocol * 	get_protocol () const
Protocol * 	get_protocol ()
SSL_handle 	get_ssl () const
//断言该协议为文本或二进制类型，然后将强制转换为Protocol_classic的m_protocol返回。  
const Protocol_classic * 	get_protocol_classic () const
Protocol_classic * 	get_protocol_classic ()
const LEX_CSTRING & 	catalog () const
void 	set_catalog (const LEX_CSTRING &catalog)
void 	enter_stage (const PSI_stage_info *stage, PSI_stage_info *old_stage, const char *calling_func, const char *calling_file, const unsigned int calling_line) SUPPRESS_TSAN
const char * 	get_proc_info () const
void 	set_admin_connection (bool admin)
bool 	is_admin_connection () const
//检索给定插槽的Ha_data
Ha_data * 	get_ha_data (int slot)
//将ha_data复制到提供的参数中。   
void 	backup_ha_data (Prealloced_array< Ha_data, PREALLOC_NUM_HA > *backup)
//从提供的备份副本中还原ha_data。
void 	restore_ha_data (const Prealloced_array< Ha_data, PREALLOC_NUM_HA > &backup)
void 	set_next_event_pos (const char *_filename, ulonglong _pos)
void 	clear_next_event_pos ()
int 	binlog_setup_trx_data ()  
//此函数将表映射写入二进制日志。
int 	binlog_write_table_map (TABLE *table, bool is_transactional, bool binlog_rows_query)
int 	binlog_write_row (TABLE *table, bool is_transactional, const uchar *new_data, const unsigned char *extra_row_info)
int 	binlog_delete_row (TABLE *table, bool is_transactional, const uchar *old_data, const unsigned char *extra_row_info)
int 	binlog_update_row (TABLE *table, bool is_transactional, const uchar *old_data, const uchar *new_data, const uchar *extra_row_info)
void 	set_server_id (uint32 sid)
template<class RowsEventT >
Rows_log_event * 	binlog_prepare_pending_rows_event (TABLE *table, uint32 serv_id, size_t needed, bool is_transactional, const unsigned char *extra_row_info, uint32 source_part_id=INT_MAX)
//此函数从通过参数is_transactional指定的缓存中检索未决的行事件。
Rows_log_event * 	binlog_get_pending_rows_event (bool is_transactional) const
int 	binlog_flush_pending_rows_event (bool stmt_end)
int 	binlog_flush_pending_rows_event (bool stmt_end, bool is_transactional)
//确定当前语句的二进制日志格式   
int 	is_current_stmt_binlog_format_row () const
//确定此会话当前是否禁用二进制日志记录
bool 	is_current_stmt_binlog_disabled () const
//确定此会话当前是否禁用二进制日志记录
bool 	is_current_stmt_binlog_log_slave_updates_disabled () const
//确定是否以行格式启用了二进制日志记录，并且是否为此会话启用了写集提取。
bool 	is_current_stmt_binlog_row_enabled_with_write_set_extraction () const
//告诉给定的optimizer_switch标志是否打开
bool 	optimizer_switch_flag (ulonglong flag) const
void 	reset_binlog_local_stmt_filter ()
void 	clear_binlog_local_stmt_filter ()
void 	set_binlog_local_stmt_filter ()
binlog_filter_state 	get_binlog_local_stmt_filter () const
void 	set_skip_readonly_check ()
bool 	is_cmd_skip_readonly () const
void 	reset_skip_readonly_check ()
//binlog_query（）用于引发警告的辅助方法。
void 	issue_unsafe_warnings ()
uint 	get_binlog_table_maps () const
void 	clear_binlog_table_maps ()
List< char > * 	get_binlog_accessed_db_names () const 
void 	add_to_binlog_accessed_dbs (const char *db)
Transaction_ctx * 	get_transaction ()
const Transaction_ctx * 	get_transaction () const
//更改THD对象中的Transaction_ctx实例
void 	set_transaction (Transaction_ctx *transaction_ctx)
void 	record_first_successful_insert_id_in_cur_stmt (ulonglong id_arg) 
ulonglong 	read_first_successful_insert_id_in_prev_stmt (void) 
void 	reset_first_successful_insert_id ()
void 	force_one_auto_inc_interval (ulonglong next_id)
longlong 	get_row_count_func () const
void 	set_row_count_func (longlong row_count_func) 
void 	set_user_connect (USER_CONN *uc) 
const USER_CONN * 	get_user_connect () const
void 	increment_user_connections_counter ()
void 	decrement_user_connections_counter ()
void 	increment_con_per_hour_counter ()
void 	increment_updates_counter ()
void 	increment_questions_counter ()
void 	time_out_user_resource_limits ()
ha_rows 	get_sent_row_count () const
ha_rows 	get_examined_row_count () const
void 	set_sent_row_count (ha_rows count)
void 	inc_sent_row_count (ha_rows count)
void 	inc_examined_row_count (ha_rows count)
void 	inc_status_created_tmp_disk_tables ()
void 	inc_status_created_tmp_tables ()
void 	inc_status_select_full_join ()
void 	inc_status_select_full_range_join ()
void 	inc_status_select_range ()
void 	inc_status_select_range_check ()
void 	inc_status_select_scan ()
void 	inc_status_sort_merge_passes ()
void 	inc_status_sort_range ()
void 	inc_status_sort_rows (ha_rows count)
void 	inc_status_sort_scan ()
void 	set_status_no_index_used ()
void 	set_status_no_good_index_used ()
//通过调用Global_THD_manager :: get_new_thread_id（）为m_thread_id分配一个值
void 	set_new_thread_id ()
my_thread_id 	thread_id () const
bool 	is_system_thread () const
bool 	is_dd_system_thread () const
bool 	is_initialize_system_thread () const
bool 	is_init_file_system_thread () const
bool 	is_bootstrap_system_thread () const
bool 	is_server_upgrade_thread () const
 	THD (bool enable_plugins=true)
	~THD () override
 //在析构THD之前释放大多数资源
void 	release_resources ()
bool 	release_resources_done () const
//初始化查询处理所需的内存根并为它预分配内存
void 	init_query_mem_roots ()
void 	cleanup_connection (void)
void 	cleanup_after_query ()
void 	store_globals ()
void 	restore_globals ()
void 	set_active_vio (Vio *vio)
void 	set_ssl (Vio *vio)
void 	clear_active_vio ()
//将活动克隆网络Vio设置为远程克隆
void 	set_clone_vio (Vio *vio)
//清除克隆网络Vio以进行远程克隆   
void 	clear_clone_vio () 
//检查克隆网络Vio是否处于活动状态
bool 	check_clone_vio ()
//关闭克隆vio（如果已激活）
void 	shutdown_clone_vio ()
enum_vio_type 	get_vio_type () const
void 	shutdown_active_vio ()
//唤醒线程。
void 	awake (THD::killed_state state_to_set)
//断开关联的通信端点。    
void 	disconnect (bool server_shutdown=false)
//记录当前查询。
int 	binlog_query (enum_binlog_query_type qtype, const char *query, size_t query_len, bool is_trans, bool direct, bool suppress_use, int errcode)
//输入条件等待    
void 	enter_cond (mysql_cond_t *cond, mysql_mutex_t *mutex, const PSI_stage_info *stage, PSI_stage_info *old_stage, const char *src_function, const char *src_file, int src_line) override
//结束条件等待
void 	exit_cond (const PSI_stage_info *stage, const char *src_function, const char *src_file, int src_line) override
//拥有者线程是否已被杀死？
int 	is_killed () const final
//在MDL子系统中，此仅用于DEBUG_SYNC。
THD * 	get_thd () override
//服务器内部的回调，用于解决锁定协议的特殊情况。
void 	notify_shared_lock (MDL_context_owner *ctx_in_use, bool needs_thr_lock_abort) override
//在获取密钥的排他锁之前，请从感兴趣的存储引擎通知/获取许可。
bool 	notify_hton_pre_acquire_exclusive (const MDL_key *mdl_key, bool *victimized) override
//通知感兴趣的存储引擎我们刚刚发布了密钥的排他锁。
void 	notify_hton_post_release_exclusive (const MDL_key *mdl_key) override
//为MDL_context的PRNG提供线程特定的随机种子。
uint 	get_rand_seed () const override
bool 	is_strict_mode () const
const CHARSET_INFO * 	collation ()
Time_zone * 	time_zone ()
time_t 	query_start_in_secs () const
timeval 	query_start_timeval_trunc (uint decimals)
void 	set_time ()
void 	set_time (const struct timeval *t)
void 	set_time_after_lock ()
bool 	is_fsp_truncate_mode () const
//评估当前时间，如果它超过了长时间查询时间设置，则将查询标记为慢速查询。
void 	update_slow_query_status ()
ulonglong 	found_rows () const
void 	update_previous_found_rows ()
//如果会话处于多语句事务模式，则返回true。
bool 	in_multi_stmt_transaction_mode () const
//如果会话处于多语句事务模式下，则为true
bool 	in_active_multi_stmt_transaction () const
bool 	fill_information_schema_tables () const
bool 	convert_string (LEX_STRING *to, const CHARSET_INFO *to_cs, const char *from, size_t from_length, const CHARSET_INFO *from_cs, bool report_error=false)
int 	send_explain_fields (Query_result *result)
//清除当前错误（如果有）。    
void 	clear_error ()
bool 	is_classic_protocol () const
//如果与客户端的连接断开，则返回false
bool 	is_connected () final
//将当前错误标记为致命错误。
void 	fatal_error ()
bool 	is_fatal_error () const
//如果错误堆栈中有错误，则为true
bool 	is_error () const
//返回当前语句的第一个诊断区域
Diagnostics_area * 	get_stmt_da ()
//返回当前语句的第一个诊断区域。
const Diagnostics_area * 	get_stmt_da () const
//返回当前语句的第二个“诊断区域”。
const Diagnostics_area * 	get_stacked_da () const
//返回用于分析的线程本地诊断区域。
Diagnostics_area * 	get_parser_da ()
//返回查询重写插件将使用的线程本地诊断区域。
Diagnostics_area * 	get_query_rewrite_plugin_da ()
//将给定的诊断区域推入堆栈顶部，使其成为新的第一个诊断区域。
void 	push_diagnostics_area (Diagnostics_area *da, bool copy_conditions=true)
//从诊断区域堆栈中弹出顶部DA
void 	pop_diagnostics_area ()
//将新协议插入协议栈的顶部，并使其成为该协议的当前协议。    
void 	push_protocol (Protocol *protocol) 
template<typename ProtocolClass >
void 	push_protocol (const std::unique_ptr< ProtocolClass > &protocol)
//弹出协议栈的顶部协议，并将前一个协议设置为当前协议。
void 	pop_protocol ()
const CHARSET_INFO * 	charset () const 
void 	update_charset ()
//将瞬态更改记录到另一个项目中指向某个项目的指针。 
void 	change_item_tree (Item **place, Item *new_value)
//请记住，该地点已使用new_value更新，因此可以通过rollback_item_tree_changes（）恢复该地点。
void 	nocheck_register_item_tree_change (Item **place, Item *new_value)
//恢复通过调用nocheck_register_item_tree_change（）设置的位置。
void 	rollback_item_tree_changes ()
void 	end_statement ()
void 	send_kill_message () const
void 	reset_n_backup_open_tables_state (Open_tables_backup *backup, uint add_state_flags)
void 	restore_backup_open_tables_state (Open_tables_backup *backup) 
void 	reset_sub_statement_state (Sub_statement_state *backup, uint new_state) 
void 	restore_sub_statement_state (Sub_statement_state *backup)
//启动只读的可附加事务
void 	begin_attachable_ro_transaction ()
//启动读写的可附加事务
void 	begin_attachable_rw_transaction ()
//结束可附加的事务
void 	end_attachable_transaction ()
bool 	is_attachable_ro_transaction_active () const
bool 	is_attachable_transaction_active () const
bool 	is_attachable_rw_transaction_active () const
void 	set_current_stmt_binlog_format_row_if_mixed ()
void 	set_current_stmt_binlog_format_row ()
void 	clear_current_stmt_binlog_format_row ()
void 	reset_current_stmt_binlog_format_row ()
//如果这是一个从属线程，则将variables.original_commit_timestamp复制到（（Slave_worker *）rli_slave）-> original_commit_timestamp。
void 	set_original_commit_timestamp_for_slave_thread ()
//返回@gtid_next_list的值：Gtid_set或NULL
Gtid_set * 	get_gtid_next_list ()
//返回@gtid_next_list的值：Gtid_set或NULL
const Gtid_set * 	get_gtid_next_list_const () const
//如果语句/事务缓存当前为空，则返回true，否则返回false。
bool 	is_binlog_cache_empty (bool is_transactional) const
//推迟释放拥有的GTID和SID，直到取消固定。
void 	pin_gtid ()
//取消固定并释放GTID和SID。
void 	unpin_gtid ()
bool 	is_one_phase_commit ()
//当Binlog重置操作开始时设置 
void 	set_log_reset ()
//在二进制日志重置期间刷新SE日志后清除。
void 	clear_log_reset ()
bool 	is_log_reset () const
//由SE设置，以保证GTID持久性。
void 	set_gtid_persisted_by_se ()
//保留GTID后，在交易结束时由SE重置。
void 	reset_gtid_persisted_by_se ()
bool 	se_persists_gtid () const
void 	clear_owned_gtids ()
bool 	owned_gtid_is_empty ()
const LEX_CSTRING & 	db () const
//设置当前数据库；使用C字符串的深层副本
bool 	set_db (const LEX_CSTRING &new_db)
//设置当前数据库；使用C字符串的浅表副本。更多...
void 	reset_db (const LEX_CSTRING &new_db)
bool 	copy_db_to (char const **p_db, size_t *p_db_length) const
bool 	copy_db_to (char **p_db, size_t *p_db_length) const
//返回 资源组上下文
resourcegroups::Resource_group_ctx * 	resource_group_ctx ()
//保存与此用户会话关联的性能架构线程检测。    
void 	set_psi (PSI_thread *psi)
//读取与此用户会话关联的性能架构线程检测。
PSI_thread * 	get_psi () const
const Internal_error_handler * 	get_internal_handler () const
//将内部错误处理程序添加到线程执行上下文 
void 	push_internal_handler (Internal_error_handler *handler)
//删除上次推送的错误处理程序
Internal_error_handler * 	pop_internal_handler ()
//引发异常条件
void 	raise_error (uint code)
//使用格式化的消息引发异常条件。
void 	raise_error_printf (uint code,...)
//提出完成条件（警告）。
void 	raise_warning (uint code)
//提出带有格式化消息的完成条件（警告）。
void 	raise_warning_printf (uint code,...)
//用固定的消息提出完成条件（注释）。
void 	raise_note (uint code)
//用格式化的消息提出完成条件（注释）。
void 	raise_note_printf (uint code,...)
void 	set_command (enum enum_server_command command)
enum enum_server_command 	get_command () const
//为了安全且受保护地访问查询字符串，应遵循以下规则：1：只有所有者（current_thd）可以设置查询字符串。 
void 	debug_assert_query_locked () const
const LEX_CSTRING & 	query () const
//当前查询以标准化形式。
const String 	normalized_query ()
//将查询设置为在性能表中显示
void 	set_query_for_display (const char *query_arg, size_t query_length_arg)
void 	reset_query_for_display (void)
//为thd-> m_query_string分配一个新值
void 	set_query (const char *query_arg, size_t query_length_arg)
void 	set_query (LEX_CSTRING query_arg)
void 	reset_query ()
//在THD上设置重写的查询（使用混淆的密码等）
void 	swap_rewritten_query (String &query_arg)
//从THD获取重写的查询（使用混淆的密码等）。
const String & 	rewritten_query () const
//重置thd-> m_rewrite_query。
void 	reset_rewritten_query ()
//设置一个新的查询id值
void 	set_query_id (query_id_t new_query_id)
//为open_tables分配一个新值。
void 	set_open_tables (TABLE *open_tables_arg)
//将新值分配给is_killable受LOCK_thd_data互斥锁保护
void 	set_is_killable (bool is_killable_arg)
void 	enter_locked_tables_mode (enum_locked_tables_mode mode_arg) 
//保留显式的LOCK TABLES或预锁定模式，并在MDL子系统中恢复事务标记的值。
void 	leave_locked_tables_mode ()
//确定用于该语句的日志记录格式，并根据需要发出错误或警告。 
int 	decide_logging_format (TABLE_LIST *tables)
//is_dml_gtid_compatible（）和is_ddl_gtid_compatible（）检查要处理的语句是否可以安全地获取GTID。
bool 	is_dml_gtid_compatible (bool some_transactional_table, bool some_non_transactional_table, bool non_transactional_tables_are_tmp)
bool 	is_ddl_gtid_compatible ()
void 	binlog_invoker ()
bool 	need_binlog_invoker () const
void 	get_definer (LEX_USER *definer)
void 	set_invoker (const LEX_STRING *user, const LEX_STRING *host)
LEX_CSTRING 	get_invoker_user () const
LEX_CSTRING 	get_invoker_host () const
bool 	has_invoker () const
//将事务标记为回滚并将错误标记为对子语句致命
void 	mark_transaction_to_rollback (bool all)
//初始化优化程序成本模型。
void 	init_cost_model ()
//检索此连接的优化程序成本模型。
const Cost_model_server * 	cost_model () const
void 	syntax_error ()
//将错误消息与行号和位置一起推入MySQL诊断区域。
void 	syntax_error (const char *format,...)
//将错误消息与行号和位置一起推入MySQL诊断区域。
void 	syntax_error (int mysql_errno,...)
void 	syntax_error_at (const YYLTYPE &location)
//将带有行和位置信息的语法错误消息推送到MySQL诊断区域。 
void 	syntax_error_at (const YYLTYPE &location, const char *format,...)
//将带有行和位置信息的语法错误消息推送到MySQL诊断区域。
void 	syntax_error_at (const YYLTYPE &location, int mysql_errno,...)
void 	vsyntax_error_at (const YYLTYPE &location, const char *format, va_list args)
//使用行号和位置将语法错误消息推送到MySQL诊断区域。
void 	vsyntax_error_at (const char *pos_in_lexer_raw_buffer, const char *format, va_list args)
//将名称和结果类型发送给客户端。 
bool 	send_result_metadata (const mem_root_deque< Item *> &list, uint flags)
//发送一个结果集行。
bool 	send_result_set_row (const mem_root_deque< Item *> &row_items)
void 	send_statement_status ()
//声明THD对象使用的所有内存。
void 	claim_memory_ownership (bool claim)
bool 	is_a_srv_session () const
void 	mark_as_srv_session ()
//返回thd所属的插件。
const st_plugin_int * 	get_plugin () const
//将插件ID设置为参数提供的值 
void 	set_plugin (const st_plugin_int *plugin)
uint 	get_tmp_table_seq_id ()
void 	set_tmp_table_seq_id (uint arg)
bool 	is_plugin_fake_ddl () const
void 	mark_plugin_fake_ddl (bool flag)
//设置waiting_for_disk_space标志。
void 	set_waiting_for_disk_space (bool waiting)
//返回当前的waiting_for_disk_space标志值
bool 	is_waiting_for_disk_space () const
//调用解析器将语句转换为解析树。
bool 	sql_parser ()
//在此会话中启用或禁用辅助存储引擎。
void 	set_secondary_engine_optimization (Secondary_engine_optimization state)
//辅助存储引擎可以用于此会话中的查询执行吗？ 
Secondary_engine_optimization 	secondary_engine_optimization () const
//检查此会话中的查询是否可以使用辅助存储引擎执行。
bool 	secondary_storage_engine_eligible () const
//返回会话的用户是否具有SYSTEM_USER特权
bool 	is_system_user ()
//为当前会话自动设置system_user标志
void 	set_system_user (bool system_user_flag)
//设置和获取事务position的功能
void 	set_trans_pos (const char *file, my_off_t pos)
void 	get_trans_pos (const char **file_var, my_off_t *pos_var) const
void 	get_trans_fixed_pos (const char **file_var, my_off_t *pos_var) const

```

公共属性
```
MDL_context 	mdl_context
enum enum_mark_columns 	mark_used_columns
//由Item :: check_column_privileges（）用来告知要检查的特权
ulong 	want_privilege
LEX * 	lex
Relay_log_info * 	rli_fake
Relay_log_info * 	rli_slave
bool 	tx_commit_pending
//仅用于服务器的附加网络工具。
NET_SERVER 	m_net_server_extension
//用户变量的字典
collation_unordered_map< std::string, unique_ptr_with_deleter< user_var_entry > > 	user_vars {system_charset_info, key_memory_user_var_entry}
struct rand_struct 	rand 
struct System_variables 	variables
struct System_status_var 	status_var 
struct System_status_var * 	initial_status_var 
bool 	status_var_aggregated
//所连接客户端的会话连接属性。
std::vector< char > 	m_connection_attributes
//当前查询的成本值
double 	m_current_query_cost
//当前查询部分计划
ulonglong 	m_current_query_partial_plans
THR_LOCK_INFO 	lock_info
//保护从其他线程访问的THD数据。
mysql_mutex_t 	LOCK_thd_data
//保护 THD::m_query_string
mysql_mutex_t 	LOCK_thd_query
//保护THD::variables
mysql_mutex_t 	LOCK_thd_sysvar
//当被x插件删除时，保护THD::m_protocol
mysql_mutex_t 	LOCK_thd_protocol
 	Protects THD::m_protocol when it gets removed in x plugin. More...
//这个连接的所有保护数据 
Prepared_statement_map 	stmt_map
const char * 	thread_stack
Security_context 	m_main_security_ctx
Security_context * 	m_security_ctx
List< Security_context > 	m_view_ctx_list
bool 	m_disable_password_validation
const char * 	proc_info
std::unique_ptr< Protocol_text > 	protocol_text
std::unique_ptr< Protocol_binary > 	protocol_binary
class THD::Query_plan 	query_plan
const char * 	where
ulong 	max_client_packet_length
collation_unordered_map< std::string, unique_ptr_my_free< TABLE_LIST > > 	handler_tables_hash
malloc_unordered_map< std::string, User_level_lock * > 	ull_hash
uint 	dbug_sentry
bool 	is_killable
// 互斥锁保护对current_mutex和current_cond的访问
mysql_mutex_t 	LOCK_current_cond
//与current_cond一起使用的互斥量
std::atomic< mysql_mutex_t * > 	current_mutex
//指向拥有THD的线程当前正在等待的条件变量的指针。
std::atomic< mysql_cond_t * > 	current_cond
//THR_LOCK.c子系统用于等待的条件变量。
mysql_cond_t 	COND_thr_lock
uint32 	unmasked_server_id
uint32 	server_id
uint32 	file_id
uint16 	peer_port
struct timeval 	start_time
struct timeval 	user_time
ulonglong 	start_utime
ulonglong 	utime_after_lock
//在未明确指定锁定的情况下，除INSERT之外，所有DML语句将使用的锁定类型。
thr_lock_type 	update_lock_default
// 如果未明确指定锁定，则用于INSERT语句的锁定类型。   
thr_lock_type 	insert_lock_default
uint 	in_sub_stmt
//由fill_status（）用于避免递归调用此函数时两次获取LOCK_status互斥锁 
uint 	fill_status_recursion_level
uint 	fill_variables_recursion_level
rpl_event_coordinates 	binlog_next_event_pos
uchar * 	binlog_row_event_extra_data
//保持活动计时器objec 
struct THD_timer_info * 	timer
//重置（取消）计时器后，使用timer_cache计时器缓存当前计时器对象以重复使用
struct THD_timer_info * 	timer_cache
Global_read_lock 	global_read_lock
Vio * 	active_vio = {nullptr}
Vio * 	clone_vio = {nullptr}
// 这用于在优化准备好的语句/存储过程期间跟踪项目的瞬时变化。
Item_change_list 	change_list
Query_arena * 	stmt_arena
table_map 	table_map_for_update
bool 	arg_of_last_insert_id_function
ulonglong 	first_successful_insert_id_in_prev_stmt
ulonglong 	first_successful_insert_id_in_prev_stmt_for_binlog
ulonglong 	first_successful_insert_id_in_cur_stmt
bool 	stmt_depends_on_first_successful_insert_id_in_prev_stmt
Discrete_intervals_list 	auto_inc_intervals_in_cur_stmt_for_binlog
Discrete_intervals_list 	auto_inc_intervals_forced
//存储FOUND_ROWS（）函数的结果 
ulonglong 	previous_found_rows
//动态，收集并在子查询中设置。更多...
ulonglong 	current_found_rows
bool 	is_operating_gtid_table_implicitly
bool 	is_operating_substatement_implicitly
ha_rows 	num_truncated_fields
const CHARSET_INFO * 	db_charset
std::unique_ptr< PROFILING > 	profiling
//当前阶段进度检测 
PSI_stage_progress * 	m_stage_progress_psi
// 当前语句摘要   
sql_digest_state * 	m_digest
//当前语句摘要令牌数组。
unsigned char * 	m_token_array
//顶级语句摘要
sql_digest_state 	m_digest_state
//当前语句工具    
PSI_statement_locker * 	m_statement_psi
//当前语句工具状态
PSI_statement_locker_state 	m_statement_state
//当前事务工具
PSI_transaction_locker * 	m_transaction_psi
//当前事务工具状态
PSI_transaction_locker_state 	m_transaction_state
//急速检测
PSI_idle_locker * 	m_idle_psi
//急速检测工具状态
PSI_idle_locker_state 	m_idle_state
//如果此连接的服务器代码为IDLE，则为True
bool 	m_server_idle
query_id_t 	query_id 
ulong 	col_access 
ulong 	statement_id_counter 
ulong 	rand_saved_seed1 
ulong 	rand_saved_seed2 
my_thread_t 	real_id 
uint 	tmp_table 
uint 	server_status 
uint 	open_options 
enum enum_thread_type 	system_thread 
enum_tx_isolation 	tx_isolation 
bool 	tx_read_only 
int 	tx_priority 
int 	thd_tx_priority
enum_check_fields 	check_for_truncated_fields
Prealloced_array< Binlog_user_var_event *, 2 > 	user_var_events
MEM_ROOT * 	user_var_events_alloc
//由MYSQL_BIN_LOG用于维护二进制日志组提交的提交队列 
THD * 	next_to_commit
//该成员用于将创建或更改使用TIMESTAMP列声明的表的查询标记为依赖于@ session.explicit_defaults_for_timestamp。    
bool 	binlog_need_explicit_defaults_ts
enum THD::Commit_error 	commit_error 
enum durability_properties 	durability_property 
std::atomic< killed_state > 	killed
//我们当前是否处于EXPLAIN ANALYZE查询的执行阶段。 
bool 	running_explain_analyze = false
//当在DD表上进行操作时，THD设置为终止免疫模式。
dd::DD_kill_immunizer * 	kill_immunizer
char 	scramble [SCRAMBLE_LENGTH+1] 
bool 	slave_thread 
uchar 	password
//由存储引擎设置，以请求回滚整个事务（可能跨越多个引擎）。
bool 	transaction_rollback_request
//如果我们处于子语句模式并且在离开子语句模式之前无法安全恢复当前错误，则为true。    
bool 	is_fatal_sub_stmt_error
bool 	query_start_usec_used 
bool 	rand_used 
bool 	time_zone_used 
bool 	in_lock_tables
//如果从库错误为true
bool 	is_slave_error
//如果在语句中使用某些线程特定的值，则设置。
bool 	thread_specific_used
//如果语句访问通过CREATE TEMPORARY TABLE创建的临时表，则设置
bool 	charset_is_system_charset
bool 	charset_is_collation_connection 
bool 	charset_is_character_set_filesystem 
bool 	enable_slow_log 
bool 	derived_tables_processing
bool 	parsing_system_view
//当前的SP运行时上下文 
sp_rcontext * 	sp_runtime_ctx
sp_cache * 	sp_proc_cache
sp_cache * 	sp_func_cache
//name_const（）替换的数量，请参见sp_head.cc:subst_spvars（）更多信息。 
uint 	query_name_consts

LOG_INFO * 	current_linfo 
union {
   bool   bool_value
   long   long_value 
   ulong   ulong_value 
   ulonglong   ulonglong_value 
   double   double_value 
} 	sys_var_tmp
 
struct {
   bool   do_union 
   bool   unioned_events 
   bool   unioned_events_trans 
   query_id_t   first_query_id 
} 	binlog_evt_union
//内核解析状态 
Parser_state * 	m_parser_state
Locked_tables_list 	locked_tables_list 
partition_info * 	work_part_info 
//此THD已使用的活动审核插件数组    
Plugin_array 	audit_class_plugins
//位数组，指示哪些审计类已经添加到当前正在使用的审计插件列表中。
Prealloced_array< unsigned long, 11 > 	audit_class_mask
bool 	m_enable_plugins 
bool 	m_audited 
//当前拥有事务的Gtid
Gtid 	owned_gtid
//为了方便起见，它包含存储在own_gtid中的GTID的SID组件 
rpl_sid 	owned_sid
//SE GTID持久性的标志
Se_GTID_flagset 	m_se_gtid_flags
Rpl_thd_context 	rpl_thd_ctx
bool 	skip_gtid_rollback
bool 	is_commit_in_middle_of_statement
bool 	has_gtid_consistency_violation 
thd_scheduler 	scheduler
//当前语句的优化器跟踪
Opt_trace_context 	opt_trace
Session_tracker 	session_tracker
Session_sysvar_resource_manager 	session_sysvar_res_mgr
//仅由主转储线程使用 
bool 	duplicate_slave_id
XID 	debug_binlog_xid_last 
Transactional_ddl_context 	m_transactional_ddl {this}
```

私有成员函数
```
bool 	is_stmt_prepare () const
bool 	is_stmt_prepare_or_first_sp_execute () const
bool 	is_stmt_prepare_or_first_stmt_execute () const
bool 	is_regular () const
void 	cleanup (void)
void 	init (void)
//是否处理一个SQL条件 
bool 	handle_condition (uint sql_errno, const char *sqlstate, Sql_condition::enum_severity_level *level, const char *msg)
//引发通用SQL条件 
Sql_condition * 	raise_condition (uint sql_errno, const char *sqlstate, Sql_condition::enum_severity_level level, const char *msg, bool fatal_error=false)
//在解析错误的情况下恢复会话状态 
void 	cleanup_after_parse_error ()
```

私有属性
```
//用于保存常规（未准备好的）查询的已解析树的lex
std::unique_ptr< LEX > 	main_lex
std::unique_ptr< dd::cache::Dictionary_client > 	m_dd_client
// 与该语句关联的查询
LEX_CSTRING 	m_query_string
String 	m_normalized_query
//当前选择的目录
LEX_CSTRING 	m_catalog
//当前（默认）数据库的名称
LEX_CSTRING 	m_db
//资源组上下文，指示当前资源组和在查询执行期间要切换到的资源组的名称。
resourcegroups::Resource_group_ctx 	m_resource_group_ctx
//在某些情况下，我们可能要修改查询
String 	m_rewritten_query
//保护查询计划（SELECT / UPDATE / DELETE）在另一个线程解释它的同时不被释放/更改。
mysql_mutex_t 	LOCK_query_plan
Protocol * 	m_protocol
// 附加到此连接的SSL数据
SSL_handle 	m_SSL = {nullptr}
unsigned int 	m_current_stage_key
//当前查询的类型：COM_STMT_PREPARE，COM_QUERY等。 
enum enum_server_command 	m_command
bool 	m_is_admin_conn
Prealloced_array< Ha_data, PREALLOC_NUM_HA > 	ha_data
bool 	skip_readonly_check
// 指示是否应丢弃当前语句，而不是将其写入binlog。
binlog_filter_state 	m_binlog_filter_state
//指示将记录当前语句的格式。
enum_binlog_format 	current_stmt_binlog_format
//Binlog警告状态的位字段
uint32 	binlog_unsafe_warning_flags
uint 	binlog_table_maps 
List< char > * 	binlog_accessed_db_names
NET 	net
String 	packet
std::unique_ptr< Transaction_ctx > 	m_transaction
Attachable_trx * 	m_attachable_trx
//存储ROW_COUNT（）函数的结果
longlong 	m_row_count_func
//我们实际发送给客户端的行数，包括ROLLUP等中的“合成”行
ha_rows 	m_sent_row_count
//语句读取和/或评估的行数。
ha_rows 	m_examined_row_count
USER_CONN * 	m_user_connect
//由于客户端协议，此计数器为32位
my_thread_id 	m_thread_id
//如果无法继续执行当前复合语句，则设置为true
bool 	m_is_fatal_error
bool 	m_release_resources_done
bool 	cleanup_done
// 此会话的性能架构线程检测
std::atomic< PSI_thread * > 	m_psi
//此线程的当前内部错误处理程序，或者为NULL
Internal_error_handler * 	m_internal_handler
//此内存根用于两个目的：
MEM_ROOT 	main_mem_root
Diagnostics_area 	main_da
Diagnostics_area 	m_parser_da
Diagnostics_area 	m_query_rewrite_plugin_da
Diagnostics_area * 	m_query_rewrite_plugin_da_ptr
Diagnostics_area * 	m_stmt_da
//如果在帐户管理语句中调用CURRENT_USER（）或在CREATE / ALTER SP，SF，Event，TRIGGER或VIEW语句中设置了默认定义器，则它将设置为TURE。
bool 	m_binlog_invoker
//它指向Query_log_event中的调用程序。
LEX_CSTRING 	m_invoker_user
LEX_CSTRING 	m_invoker_host
//服务器操作的优化器成本模型。 
Cost_model_server 	m_cost_model
//标记对象是否为Srv_session对象的一部分的变量，该对象聚合THD。
bool 	is_a_srv_session_thd
//存储它附加到的插件ID（如果有）
const st_plugin_int * 	m_plugin {nullptr}
//通过插件服务创建或删除插件本机表。
bool 	m_is_plugin_fake_ddl
//语句中创建的内部tmp表的顺序编号。
uint 	tmp_table_seq_id
bool 	waiting_for_disk_space = false
//该标志告诉辅助存储引擎是否可用于在此会话中执行查询。
Secondary_engine_optimization 	m_secondary_engine_optimization
//指示当前会话的用户是否具有SYSTEM_USER特权的标志。 
std::atomic< bool > 	m_is_system_user
//事务的二进制日志位置 
const char * 	m_trans_log_file
char * 	m_trans_fixed_log_file
my_off_t 	m_trans_end_pos
```
























































































































































