---
layout: post
categories: [Nacos]
description: none
keywords: Nacos
---
# Nacos实战
Nacos 是一种动态服务发现、配置和服务管理平台，可以轻松构建云原生应用。

## Nacos简介
Nacos 是一种动态服务发现、配置和服务管理平台，可以轻松构建云原生应用。Nacos 支持多种方式进行服务发现和配置管理，包括 DNS 和 HTTP 等。

Nacos 主要功能包括：
- 服务发现和注册
- 配置管理
- DNS 服务
- 消息服务

## Nacos概念
- Namespace
用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。如果不配置默认为：public
- Group
服务分组，不同的服务可以归类到同一分组。
- Service
服务提供的标识，通过该标识可以唯一确定其指代的服务。默认获取的${spring.application.name}作为服务名。
- Cluster
同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群。
- Instance
提供一个或多个服务的具有可访问网络地址（IP:Port）的进程。

## Nacos架构设计
Nacos是一个分布式的，支持服务发现、配置管理和服务治理的平台。其架构设计主要包含以下三部分：

- 注册中心（Naming Service）
用于服务的注册和发现。Nacos提供了REST和Java API接口，供开发者调用。
- 配置中心（Configuration Service）
用于动态配置服务。开发者可以使用Nacos的配置中心将配置信息注入到应用程序中。
- 控制台（Console）
用于管理和查看Nacos的服务和配置信息。

## 核心知识点
- 服务注册
Nacos Client 会通过发送REST请求的方式向 Nacos Server 注册自己的服务，提供自身的元数据，比如ip地址、端口等信息。Nacos Server接收到注册请求后，就会把这些元数据信息存储在一个 双层的内存Map 中。
- 服务发现
服务消费者（Nacos Client）在调用服务提供者的服务时，会发送一个REST请求给Nacos Server，获取上面注册的服务清单，并且缓存在Nacos Client本地，同时会在Nacos Client本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存 。
- 服务心跳
在服务注册后， Nacos Client 会维护一个 定时心跳 来持续通知 Nacos Server ，说明服务一直处于可用状态，防止被剔除。 默认5s发送一次心跳。
- 服务健康检查
Nacos Server 会开启一个 定时任务 用来检查注册服务实例的健康情况，对于 超过15s没有收到客户端心跳的实例会将它的healthy属性置为false (客户端服务发现时不会发现)，如果某个 实例超过30秒没有收到心跳，直接剔除该实例 ( 被剔除的实例如果恢复发送心跳则会重新注册 )。
- 服务同步
Nacos Server集群 之间会互相同步服务实例，用来保证服务信息的一致性 。

## Nacos实现技术和原理
Nacos的实现技术和原理主要包含以下几个方面：

- Spring Cloud和Spring Boot：Nacos使用Spring Cloud作为服务治理的核心组件，使用Spring Boot作为开发框架。Spring Cloud提供了对Eureka、Consul等服务治理组件的支持。
- Raft算法：Nacos使用了Raft算法作为分布式一致性算法。Raft算法保证了分布式环境下数据的一致性，并且可以容忍节点故障。
- 数据库：Nacos使用MySQL作为存储服务注册和配置信息的数据库。
- RPC框架：Nacos使用了gRPC作为远程过程调用框架。
- Spring Cloud Gateway：Nacos使用Spring Cloud Gateway作为网关，处理所有的服务请求。

## Nacos高性能实现原理
Nacos通过使用Raft算法来实现服务列表的同步和高并发访问。Raft算法是一种分布式一致性算法，能够保证在网络分区、服务器崩溃等异常情况下，系统仍能够保持强一致性。

Nacos中的每个节点都是一个Raft节点，节点之间通过Raft协议进行通信和协调。当有节点加入或离开集群时，Raft算法会自动进行选举，选出一个新的leader来负责更新服务列表，并将最新的服务列表同步给其他节点。同时，nacos使用了一些优化技术来提高同步效率和并发访问性能，包括：

- 快照技术：nacos会定期生成快照，将当前的服务列表状态保存下来，当节点重新加入集群时，可以快速恢复服务列表的状态，避免了重新同步的过程。
- 数据压缩：nacos使用了一些数据压缩算法来压缩服务列表数据，减少网络传输的数据量，提高同步效率。
- 前缀树：nacos中的服务列表使用了前缀树数据结构进行存储和管理，能够快速地进行服务的查找和匹配，提高了并发访问性能。

## 使用 Nacos

### 添加依赖
要在 Spring Cloud Alibaba 中使用 Nacos，需要添加以下 Maven 依赖：
```xml
    <properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <spring-cloud-alibaba.version>2.2.6.RELEASE</spring-cloud-alibaba.version>
</properties>

<dependencies>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
</dependencies>

<dependencyManagement>
<dependencies>
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-alibaba-dependencies</artifactId>
        <version>${spring-cloud-alibaba.version}</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
</dependencies>
</dependencyManagement>
```

### 使用Nacos作为服务注册
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```
### 配置 Nacos 服务器地址
在 application.properties 或 application.yml 中添加以下配置：
```yaml
server:  
  port: 8080  
  
spring:  
  application:  
    name: cloud-nacos-provider  
  
  cloud:  
    nacos:  
      discovery:  
        server-addr: localhost:8848  
```

### 注册服务
在 Spring Boot 应用程序中注册服务非常简单。只需要在启动类上添加 @EnableDiscoveryClient 注解即可：
```java
@SpringBootApplication
@EnableDiscoveryClient
public class DemoApplication {    
    public static void main(String[] args) {        
        SpringApplication.run(DemoApplication.class, args);    
    }
}
```

### 使用服务
在 Spring Boot 应用程序中使用 Nacos 服务非常简单。只需要在需要使用服务的类上添加 @Autowired 注解即可：
```java
@Service
public class DemoService {    
    
    @Autowired    
    private DiscoveryClient discoveryClient; 
    
    public void test() {        
        List<ServiceInstance> instances = discoveryClient.getInstances("demo-service");        
        for (ServiceInstance instance : instances) {            
            System.out.println(instance.getServiceId() + ": " + instance.getHost() + ":" + instance.getPort());        
        }    
    }
}
```

### 配置管理
Nacos 还支持配置管理，可以通过 Nacos 的控制台进行管理。要在 Spring Boot 应用程序中使用 Nacos 配置管理，需要添加以下 Maven 依赖：
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

然后，在 bootstrap.properties 或 bootstrap.yml 中添加以下配置：
```yaml

```
其中，server-addr 是 Nacos 服务器地址，namespace 是命名空间（可选），file-extension 是配置文件扩展名，group 是配置分组；


## 共享配置(shared-configs)和扩展配(extension-config)
常开发中，多个模块可能会有很多共用的配置，比如数据库连接信息，Redis 连接信息，RabbitMQ 连接信息，监控配置等等。那么此时，我们就希望可以加载多个配置，多个项目共享同一个配置之类等功能，Nacos Config 也确实支持。
- Nacos在配置路径spring.cloud.nacos.config.extension-config下，允许我们指定⼀个或多个额外配置。
- Nacos在配置路径spring.cloud.nacos.config.shared-configs下，允许我们指定⼀个或多个共享配置。

上述两类配置都⽀持三个属性：data-id、group(默认为字符串DEFAULT_GROUP)、refresh(默认为true)。

### 配置实例
```yaml
spring:
  application:
    name: nacos-config-multi
  main:
    allow-bean-definition-overriding: true
  cloud:
    nacos:
      username: ${nacos.username}
      password: ${nacos.password}
      config:
        server-addr: ${nacos.server-addr}
        namespace: ${nacos.namespace}
        # 用于共享的配置文件
        shared-configs:
          - data-id: common-mysql.yaml
            group: SPRING_CLOUD_EXAMPLE_GROUP

          - data-id: common-redis.yaml
            group: SPRING_CLOUD_EXAMPLE_GROUP

          - data-id: common-base.yaml
            group: SPRING_CLOUD_EXAMPLE_GROUP

        # 常规配置文件
        # 优先级大于 shared-configs，在 shared-configs 之后加载
        extension-configs:
          - data-id: nacos-config-advanced.yaml
            group: SPRING_CLOUD_EXAMPLE_GROUP
            refresh: true

          - data-id: nacos-config-base.yaml
            group: SPRING_CLOUD_EXAMPLE_GROUP
            refresh: true
```
参数解析：
- data-id : Data Id
- group：自定义 Data Id 所在的组，不明确配置的话，默认是 DEFAULT_GROUP。
- refresh: 控制该 Data Id 在配置变更时，是否支持应用中可动态刷新， 感知到最新的配置值。默认是不支持的。
注意：这里的Data ID后面是加.yaml后缀的，且不需要指定file-extension。

## 共享配置和扩展配置的区别
实际上，Nacos中并未对extension-configs和shared-configs的差别进⾏详细阐述。我们从他们的结构，看不出本质差别；除了优先级不同以外，也没有其他差别。那么，Nacos项⽬组为什么要引⼊两个类似的配置呢?我们可以从当初该功能的需求（issue）上找到其原始⽬的。

### Nacos对配置的默认理念
namespace区分环境：开发环境、测试环境、预发布环境、⽣产环境。
group区分不同应⽤：同⼀个环境内，不同应⽤的配置，通过group来区分。

### 主配置是应⽤专有的配置
因此，主配置应当在dataId上要区分，同时最好还要有group的区分，因为group区分应⽤（虽然dataId上区分了，不⽤设置group也能按应⽤单独加载）。

### 要在各应⽤之间共享⼀个配置，请使⽤上⾯的 shared-configs
因此按该理念，shared-configs指定的配置，本来应该是不指定group的，也就是应当归⼊DEFAULT_GROUP这个公共分组。

### 如果要在特定范围内（⽐如某个应⽤上）覆盖某个共享dataId上的特定属性，请使⽤ extension-config
⽐如，其他应⽤的数据库url，都是⼀个固定的url，使⽤shared-configs.dataId = mysql的共享配置。但其中有⼀个应⽤ddd-demo是特例，需要为该应⽤配置扩展属性来覆盖。
```yaml
spring:
 application:
   name: ddd-demo-service
 cloud:
   nacos:
     config:
       server-addr: nacos-2.nacos-headless.public.svc.cluster.local:8848
       namespace: ygjpro-test2
       group: ddd-demo
       ......
       shared-configs[3]:
         data-id: mysql.yaml
         refresh: true
       ......
       extension-configs[3]:
         data-id: mysql.yaml
         group: ddd-demo
         refresh: true
```

### 关于优先级
1、上述两类配置都是数组，对同种配置，数组元素对应的下标越⼤，优先级越⾼。也就是排在后⾯的相同配置，将覆盖排在前⾯的同名配置。

同为扩展配置，存在如下优先级关系：extension-configs[3] > extension-configs[2] > extension-configs[1] > extension-configs[0。

同为共享配置，存在如下优先级关系：shared-configs[3] > shared-configs[2] > shared-configs[1] > shared-configs[0]。

2、不同种类配置之间，优先级按顺序如下：主配置 > 扩展配置(extension-configs) > 共享配置(shared-configs)

## 使用Nacos作为配置中心如何使本地配置优先
在项目中使用了 SpringCloud 配置中心模式时远程配置的优先级默认高于本地配置，如果想要通过本地配置改变远程配置一定要在远程配置中做一下配置：
```
spring:
  cloud:
    config:
      # 如果本地配置优先级高，那么 override-none 设置为 true，包括系统环境变量、本地配置文件等配置
      override-none: true
      # 如果想要远程配置优先级高，那么 allow-override 设置为 false，如果想要本地配置优先级高那么 allow-override 设置为 true
      allow-override: true
      # 只有系统环境变量或者系统属性才能覆盖远程配置文件的配置，本地配置文件中配置优先级低于远程配置；注意本地配置文件不是系统属性
      override-system-properties: false
```
注意：一定要配置到远程配置中，否则不生效

## Nacos多人协作冲突
在使用nacos页面更改配置并发布的时候发现一个问题：

当两个人A和B都打开了某个配置的编辑页面，都进行了修改，然后点了发布，则会出现后点发布的B提交的配置生效，因为会覆盖前者A发布的版本，而此时如果没做比对或确认的话A就会没有察觉，从而导致可能的一些问题。

思路：在发布之前进行MD5比对！拿到源码，本地对逻辑进行变更，然后编译打包使用
```
@PostMapping
    @TpsControl(pointName = "ConfigPublish")
    @Secured(action = ActionTypes.WRITE, signType = SignType.CONFIG)
    public Boolean publishConfig(HttpServletRequest request, HttpServletResponse response,
            @RequestParam(value = "dataId") String dataId,
            @RequestParam(value = "group") String group,
            @RequestParam(value = "tenant", required = false, defaultValue = StringUtils.EMPTY) String tenant,
            @RequestParam(value = "content") String content, @RequestParam(value = "tag", required = false) String tag,
            @RequestParam(value = "appName", required = false) String appName,
            @RequestParam(value = "src_user", required = false) String srcUser,
            @RequestParam(value = "config_tags", required = false) String configTags,
            @RequestParam(value = "desc", required = false) String desc,
            @RequestParam(value = "use", required = false) String use,
            @RequestParam(value = "effect", required = false) String effect,
            @RequestParam(value = "type", required = false) String type,
            @RequestParam(value = "schema", required = false) String schema,
            @RequestParam(value = "md5", required = false) String md5) throws NacosException {
        
        // ... 代码省略
        configForm.setMd5(md5);

        // ... 代码省略
       
        return configOperationService.publishConfig(configForm, configRequestInfo, encryptedDataKey);
    }
```

```
public Boolean publishConfig(ConfigForm configForm, ConfigRequestInfo configRequestInfo, String encryptedDataKey)
            throws NacosException {
        
        // ... 代码省略

        ConfigInfo oldConfigInfo = configInfoPersistService.findConfigInfo(configInfo.getDataId(), configInfo.getGroup(),
                configInfo.getTenant());
        String oldConfigInfoMd5 = oldConfigInfo.getMd5();
        String curMd5 = configForm.getMd5();
        if (!StringUtils.equals(curMd5, oldConfigInfoMd5)) {
            // 传进来的上一版本md5和数据库里现在的md5不相等，表示在此之前其他用户已更新，不能直接覆盖
            throw new NacosApiException(HttpStatus.METHOD_NOT_ALLOWED.value(), ErrorCode.RESOURCE_CONFLICT, "已有其他用户更新了此配置，请先更新再修改发布！");
        }
        
        // ... 代码省略
        
        return true;
    }
```