---
layout: post
categories: DataStructure
description: none
keywords: DataStructure
---


## 平衡二叉树(AVL Tree)

二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。

**平衡二叉树全称叫做 `平衡二叉搜索（排序）树`，简称 AVL树**。高度为 `logN`。本质是一颗二叉查找树，AVL树的特性：

- 它是**一棵空树**或**左右两个子树的高度差**的绝对值不超过 `1`
- 左右两个子树也都是一棵平衡二叉树

如下图，根节点左边高度是3，因为左边最多有3条边；右边高度而2，相差1。根节点左边的节点50的左边是1条边，高度为1，右边有两条边，高度为2，相差1。

![AVLTree](png/Java/数据结构-AVLTree.png)

**效率总结**

- 查找：时间复杂度维持在`O(logN)`，不会出现最差情况
- 插入：插入操作时最多需要 `1` 次旋转，其时间复杂度在`O(logN)`左右
- 删除：删除时代价稍大，执行每个删除操作的时间复杂度需要`O(2logN)`
