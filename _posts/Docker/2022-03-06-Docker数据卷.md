---
layout: post
categories: Docker
description: none
keywords: Docker
---
# Docker数据卷
长风破浪会有时，直挂云帆济沧海。——李白《行路难》

Docker中的数据可以存储在类似于虚拟机磁盘的介质中，在Docker中称为数据卷（Data Volume）。类似我们平时使用的移动硬盘。数据卷可以用来存储Docker应用的数据，也可以用来在Docker容器间进行数据共享。数据卷呈现给Docker容器的形式就是一个目录，支持多个容器间共享，修改也不会影响镜像。使用Docker的数据卷，类似在系统中使用 mount 挂载一个文件系统。

## 为什么需要数据卷
这得从 docker 容器的文件系统说起。出于效率等一系列原因，docker 容器的文件系统在宿主机上存在的方式很复杂，这会带来下面几个问题：

* 不能在宿主机上很方便地访问容器中的文件。
* 无法在多个容器之间共享数据。
* 当容器删除时，容器中产生的数据将丢失。
为了解决这些问题，docker 引入了数据卷(volume) 机制。数据卷是存在于一个或多个容器中的特定文件或文件夹，这个文件或文件夹以独立于 docker 文件系统的形式存在于宿主机中。数据卷的最大特定是：其生存周期独立于容器的生存周期。

Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来， 那么当容器删除后，数据自然也就没有了。  
容器删除后，里面的数据将一同被删除，因此需要将容器内经常变动的数据存储在容器之外，这样删除容器之后数据依然存在。为了能保存数据在docker中我们使用数据卷。  
用户在使用 Docker 的过程中，往往需要能查看容器内应用产生的数据，或者需要把容器内的数据进行备份，甚至多个容器之间进行数据的共享，这必然涉及容器的数据管理操作。容器中管理数据主要有两种方式：数据卷(Data Volumes)，数据卷容器(Data Volume Containers)。

##  使用数据卷的最佳场景

数据卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：
数据卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷

* 在多个容器之间共享数据，多个容器可以同时以只读或者读写的方式挂载同一个数据卷，从而共享数据卷中的数据。
* 当宿主机不能保证一定存在某个目录或一些固定路径的文件时，使用数据卷可以规避这种限制带来的问题。
* 当你想把容器中的数据存储在宿主机之外的地方时，比如远程主机上或云存储上。
* 当你需要把容器数据在不同的宿主机之间备份、恢复或迁移时，数据卷是很好的选择。

Docker 提供三种方式将数据从宿主机挂载到容器中：

- **volumes**：由 Docker 管理的数据卷，是宿主机文件系统的一部分(/var/lib/docker/volumes)。是保存数据的最佳方式。
- **bind mounts**：将宿主机上的文件或目录挂载到容器中，通常在容器需要使用宿主机上的目录或文件时使用，比如搜集宿主机的信息、挂载宿主机上的 maven 仓库等。
- **tmpfs**：挂载存储在主机系统的内存中，而不会写入主机的文件系统。如果不希望将数据持久存储在任何位置，可以使用 tmpfs，同时避免写入容器可写层提高性能。这种方式使用比较少。

## 数据卷

数据卷是一个可供容器使用的特殊目录，它绕过文件系统，可以提供很多有用的特性：
* 数据卷可以在容器之间共享和重用。
* 对数据卷的更改会立即生效。
* 对数据卷的更新不会影响镜像。
* 数据卷会一直存在，直到没有容器使用。
数据卷的使用，类似于 linux 下对目录或文件进行 mount 操作。


### docker volume 子命令
docker 专门提供了 volume 子命令来操作数据卷：  

创建数据卷：**docker volume create <volume_name>**

列出所有的数据卷：**docker volume ls**  

显示数据卷的详细信息：**docker volume inspect <volume_name>**

删除所有未使用的 volumes，并且有 -f 选项：**docker volume prune **

删除一个或多个未使用的 volumes，并且有 -f 选项：**docker volume rm **

### 在容器内创建一个数据卷
在用 docker run 命令的时候，使用 -v 标记可以在容器内创建一个数据卷。多次使用 -v 标记可以创建多个数据卷。
下面的例子中我们使用 myimg/webapp 镜像创建一个 web 容器，并创建一个数据卷挂载到容器的 /webdata 目录。
```shell
$ sudo docker run -d -P –-name web -v /webdata myimg/webapp python app.py
```
         

① 管理卷



查看数据卷详细信息：**docker volume inspect <volume_name>**

创建的数据卷默认在宿主机的 /var/lib/docker/volumes/ 下

![img](https://img2018.cnblogs.com/blog/856154/201910/856154-20191006175104915-175131327.png)

② 创建容器时指定数据卷

\1) 通过 --mount 方式：**--mount src=<数据卷名称>,dst=<容器内的数据目录>，注意逗号之间不能有空格**

docker run -d --name nginx_1 --mount src=nginx_html,dst=/usr/share/nginx/html nginx

\2) 通过 -v 方式：**-v <数据卷名称>:<容器内的数据目录>**

docker run -d --name nginx_2 -v nginx_html:/usr/share/nginx/html nginx

以上两种方式，--mount 更加通用直观，-v 是老语法的方式。如果对应的数据卷不存在，将自动创建数据卷。如果挂载目标在容器中非空，则该目录现有内容会自动同步到数据卷中。

![img](https://img2018.cnblogs.com/blog/856154/201910/856154-20191006175210780-649821198.png)

③ 删除数据卷：**docker volume rm <volume_name>**

数据卷是独立于容器的生命周期的，删除容器是不会删除数据卷的，除非删除数据卷，删除数据卷之后数据也就丢失了。

如果数据卷正在被某个容器使用，将不能被删除，需要先删除使用此数据卷的所有容器之后才能删除数据卷。

![img](https://img2018.cnblogs.com/blog/856154/201910/856154-20191006173817305-2022720420.png)

④ Volume 特点及使用场景

- 多个容器可以同时挂载相同的卷，可用于多个运行容器之间共享数据。
- 当容器停止或被删除后，数据卷依然存在。当明确删除卷时，卷才会被删除。
- 可以将容器的数据存储在远程主机或其它存储上。
- 将数据从一台 docker 主机迁移到另一台主机时，先停止容器，然后备份卷的目录 /var/lib/docker/volumes



## Bind Mounts

① 创建容器时绑定数据卷

\1) 通过 --mount 方式：**--mount type=bind,src=<宿主机目录>,dst=<容器内的数据目录>，注意逗号之间不能有空格**

docker run -d --name nginx_1 --mount type=bind,src=/data/nginx/html,dst=/usr/share/nginx/html nginx

\2) 通过 -v 方式：**-v <宿主机目录>:\**<容器内的数据目录>\****

docker run -d --name nginx_2 -v /data/nginx/html:/usr/share/nginx/html nginx

以上两种方式，如果源文件/目录不存在，不会自动创建容器，会抛出错误。与 volume 方式相比，如果挂载目标在容器中非空，则该目录现有内容将被隐藏，可以理解成使用宿主机的目录覆盖了容器中的目录，新增的数据会同步。

![img](https://img2018.cnblogs.com/blog/856154/201910/856154-20191006174708341-358044453.png)

② Bind Mounts 特点及使用场景

- 从主机共享配置文件到容器。默认情况下，挂载主机 /etc/resolv.conf 到每个容器，提供 DNS 解析。
- 在 docker 主机上的开发环境和容器之间共享源代码。例如，可以将 maven target 目录挂载到容器中，每次在 docker 主机上构建maven项目时，容器都可以访问构建好的项目包。
- 当 docker 主机的文件或目
- 录结构保证与容器所需的绑定挂载一致时，例如容器中需要统计主机的一些信息，可以直接将主机的某些目录直接挂载给容器使用。