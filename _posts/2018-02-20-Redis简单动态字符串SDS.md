---
layout: post
categories: Redis
description: none
keywords: Redis
---
# Redis简单动态字符串SDS
SDS ，即 Simple Dynamic String，简单动态字符串。

Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamic string,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。

当Redis需要的不仅仅是一个字符串面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里，包含字符串值得键值对在底层都是由SDS来实现得。

客户端执行命令

set msg "hello world"

那么Redis将在数据库中创建一个新得键值对，其中

键值对得键是一个字符串对象，对象得底层实现是一个保存着字符串“msg”的SDS

键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS

又比如，客户端执行命令

rpush fruits “apple” “banana” “cherry”

那么Redis将在数据库中创建一个新的键值对，其中

键值对的键是一个字符串对象，对象底层实现是一个保存了字符串“fruits”的SDS

键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现:第一个SDS保存着字符串“apple”，第二个SDS保存着字符串“banana”，第三个SDS保存着字符串“cherry”

除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区：AOF模块zhong的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的。

## SDS的定义
在 sds.h 中，我们会看到以下结构：
```text
typedef char *sds;
```
可以看到，SDS 等同于 char * 类型。这是因为 SDS 需要和传统的 C 字符串保存兼容，因此将其类型设置为 char *。但是要注意的是，SDS 并不等同 char *

```C
struct sdshdr{
     //记录buf数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;
     //记录 buf 数组中未使用字节的数量
     int free;
     //字节数组，用于保存字符串
     char buf[];
}
```
我们看上面对于 SDS 数据类型的定义：
- len 保存了SDS保存字符串的长度
- buf[] 数组用来保存字符串的每个元素
- free j记录了 buf 数组中未使用的字节数量

结构如下图
```text   
  | sdshdr   |
  | free   0 |
  | len    5 |
  | buf      |  =》 ['R']['E']['D']['I']['S']['\0']
  
```

free 属性的值为0，表示这个SDS没有分配任何未使用空间

len 属性的值为5，表示这个SDS保存了一个五字节长的字符串

buf 属性是一个char类型的数组，最后一个字节保存了空字符“\0”

SDS遵循C字符串以空字符串结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里，并为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。

遵循空字符结尾的这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里的函数。

## SDS与C字符串区别

刚才我们说过 C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组的最后一个元素总是空字符'\0'。

这种简单的字符串表示方式，并不能满足 Redis 对字符串的安全性、效率以及功能上的要求。我们接下来对比一下 SDS 和 C 字符串之间的区别。

上面的定义相对于 C 语言对于字符串的定义，多出了 len 属性以及 free 属性。为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？

### 常数复杂度获取字符串长度
首先 C 字符串并不记录自身的长度信息，要是想获取 C 字符串长度，则必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到结尾标识符'\0'为止。复杂度为 O(N)。

而 SDS 不同，SDS 中的 len 属性记录了 SDS 本身的长度，所以获取 SDS 字符串长度的复杂度仅仅为 O(1)。

需要注意的是，设置和更新 SDS 长度的工作是由 SDS 的 API 在执行的时候自动完成的。

使用 SDS 将获取字符串长度从复杂度 O(N)降低到了 O(1)，确保了在 Redis 中获取字符串长度不会成为性能瓶颈。

通过 strlen key 命令可以获取 key 的字符串长度。

### 杜绝缓冲区溢出
除了获取字符串长度的复杂度高之外，C 字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出。

举个例子，在 string.h 中 strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾。
```C
char *strcat(char *dest, const char *src);
```
由于 C 字符串不记录自身长度，如果没有为 dest 分配足够多的内存来容下 src 字符串的所有内容的话，则会发生缓冲区溢出。

需要注意，如果内存中相邻 s1，s2 两个字符串，如果在修改 s1 字符串的时候没有分配足够的空间，可能会导致溢出到 s2 字符串所在的内存空间，导致 s2 字符串被篡改。

而 SDS 不同，SDS 的 空间分配策略 完全杜绝了发生缓冲区溢出的可能。在对 SDS 进行修改的时候，API 首先会检查是否满足所需的要求，如果不满足则会自动进行扩容，然后再进行修改。

举例：
```text   
  | sdshdr   |
  | free   0 |
  | len    5 |
  | buf      |  =》 ['R']['E']['D']['I']['S']['\0']
  
```
如上图，这时候我们执行
```C
sdscat(s," Cluster");
```
首先在拼接之前会进行检测当前 s 的长度是否足够，发现不足以拼接" Cluster"后，进行扩容，随后进行拼接，如下图所示。
```text   
  | sdshdr   |
  | free   13 |
  | len    13 |
  | buf      |  =》 ['R']['E']['D']['I']['S'][' ']['C']['l']['u']['s']['t']['e']['r']['\0']
  
```
需要注意：SDS 不仅仅进行了拼接操作，还另外分配了 13 字节的未使用空间，下面我们会了解 SDS 的空间分配策略。

### 减少修改字符串时带来的内存重分配次数

我们刚才说过，C 字符串是不记录字符串长度的，所以在增加或缩短一个字符串时，都要进行内存重分配操作。
- 如果执行的是增长字符串操作，比如 append，那么在操作前需要通过内存重分配策略来扩展底层数组的大小，如果忘记这一步，则会发生缓冲区溢出
- 如果执行的是缩短字符串操作，比如 trim，那么在执行这个操作后需要进行内存重分配来释放不再使用的空间，如果忘记这一步，则会发生内存泄漏

为了避免 C 字符串的这种缺陷，SDS 通过未使用空间 free 解除了字符串长度与底层数组长度之间的关联，在 SDS 中，buf 数组的长度并不一定是字符数量加一，还可能包含未使用字节。

通过未使用空间 free，SDS 实现了**空间预分配**和**惰性空间释放**两种优化策略。

#### 空间预分配

顾名思义，SDS 在进行扩展的时候，不仅仅会为 SDS 分配修改所必要的空间，还会为 SDS 分配额外的未使用空间。

空闲空间分配策略：
```text
len = free
```
通过这种预分配策略，SDS 将连续增长 N 次的字符串所需内存操作次数从必定 N 次减少到了最多 N 次。

#### 惰性空间释放

在进行缩短字符串操作时，SDS 并不会立即使用内存重分配来进行回收多余的空间，而是使用 free 进行记录，在后续如果进行增长操作的时候，就可能不需要再进行扩容。SDS 也提供了 API，来进行释放 SDS 未使用的空间。

### 二进制安全
我们知道 C 字符串末尾是空字符表示，在中间是不能包含空字符，否则会被认为是字符结尾。并且需要符合某种编码（比如 ASCII），导致 C 字符串只能保存文本数据，无法保存图片、视频等二进制数据。

SDS 的 API 都是二进制安全的，程序并不会对数据进行任何处理，写入时是什么样子，读取时候就是什么样子，而且在 SDS 中是可以包含空字符，因为 SDS 中是使用 len 来判断字符串是否结束。

但是为什么 SDS 末尾还是会有一个空字符？这是为了可以重用 <string.h> 中的部分函数，避免不必要的代码重复。

### 兼容部分 C 字符串函数

虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<string.h> 中的一部分函数。

一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。

**总结**

| C 字符串                                   | SDS                                    |
| ------------------------------------------ | -------------------------------------- |
| 获取字符串长度的复杂度为O（N)              | 获取字符串长度的复杂度为O(1)           |
| API 是不安全的，可能会造成缓冲区溢出       | API 是安全的，不会造成缓冲区溢出       |
| 修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多执行N次内存重分配 |
| 只能保存文本数据                           | 可以保存二进制数据和文本文数据         |
| 可以使用所有<String.h>库中的函数           | 可以使用一部分<string.h>库中的函数     |


## 最新的Redis实现
在 sds.h 中，我们会看到以下结构：
```text
typedef char *sds;
```
可以看到，SDS 等同于 char * 类型。这是因为 SDS 需要和传统的 C 字符串保存兼容，因此将其类型设置为 char *。但是要注意的是，SDS 并不等同 char *，它还包括一个 header 结构，共有 5 中类型的 header，源码如下：
```text
struct __attribute__ ((__packed__)) sdshdr5 { // 已弃用
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 { // 长度小于 2^8 的字符串类型
    uint8_t len;         // SDS 所保存的字符串长度
    uint8_t alloc;       // SDS 分配的长度
    unsigned char flags; // 标记位，占 1 字节，使用低 3 位存储 SDS 的 type，高 5 位不使用
    char buf[];          // 存储的真实字符串数据
};
struct __attribute__ ((__packed__)) sdshdr16 { // 长度小于 2^16 的字符串类型
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 { // 长度小于 2^32 的字符串类型
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 { // 长度小于 2^64 的字符串类型
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```
之所以会有 5 种类型的 header，是为了能让不同长度的字符串使用对应大小的 header，提高内存利用率。
一个 SDS 的完整结构，由内存地址上前后相邻的两部分组成：
header：包括字符串的长度（len），最大容量（alloc）和 flags（不包含 sdshdr5）。
- len： 记录 char buf [] 数组中已使用字节的数量，等于 SDS 保存字符串的长度，不包含结束标识符'\0'
- alloc：记录 char buf [] 数组申请的总字节数，不包含结束标识符'\0'
- flags：不同SDS 头类型，sds 会根据字符串实际的长度，选择不同的数据结构，节省内存空间，更好的提升内存效率。当前 sdshdr 结构分为 5 种子类型，分别为 sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64

buf[]：一个字符串数组。这个数组的长度等于最大容量加 1，存储着真正的字符串数据。
- buf：字节数组，用户保存字符串


## SDS 的空间扩展
关于 SDS 的空间扩展，源码如下：
```C
# sds.c/sdsMakeRoomFor()
...
newlen = (len+addlen); // SDS 最新长度
if (newlen < SDS_MAX_PREALLOC) // 预分配最大值 SDS_MAX_PREALLOC 在 sds.h 中定义，值为 1024*1024
    newlen *= 2;
else
    newlen += SDS_MAX_PREALLOC;
...
```
由源码可以看出，空间扩展分为两种情况：
- 新长度小于预分配最大值。此时，程序将直接为 SDS 新增最新长度大小的未使用空间。举个栗子，现有一个长度为 10 字节的字符串 s1，当给 s1 追加字符串 "redis"，那么，程序将除了分配足够 s1 使用的空间，还会为 s1 再分配最新长度大小的预使用空间。所以，s1 的实际长度就变为： 15 + 15 + 1 = 31 个字节。
- 新长度大于预分配最大值。此时，由于最新字符串较大，程序不会预分配这么多空间，只会给预分配最大值的空间。举个栗子，现有长度为 3M 的字符串 s2，当给 s1 追加一个 2M 大小的字符串，那么程序除了新增 2M 来存储新增的长度，还会为 s2 再分配 1M（SDS_MAX_PREALLOC）的预使用空间。所以，s2 的实际长度就变为：3M + 2M +1M + 1byte。
正是通过预分配的策略，Redis 减少了执行字符串增长操作所需的内存重分配次数，保证了 Redis 不会因字符串增长操作损耗性能。