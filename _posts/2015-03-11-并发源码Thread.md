---
layout: post
categories: [JUC]
description: none
keywords: JUC
---
# 并发源码Thread
在Java编程语言将线程抽象为Thread类，用Thread类来描述线程的概念，并拟定了优先级（priority）、守护线程（daemon Thread）、等相关的属性。

## Thread类
Thread类用于操作线程，是所以涉及到线程操作(如并发)的基础。
```java
/**
 * A <i>thread</i> is a thread of execution in a program. The Java
 * Virtual Machine allows an application to have multiple threads of
 * execution running concurrently.
 * <p>
 *     
 * **线程是一个进程/程序（Program）的一条执行路径，JVM虚拟机允许一个应用同时执行多个线程。**
 * 
 * Every thread has a priority. Threads with higher priority are
 * executed in preference to threads with lower priority. Each thread
 * may or may not also be marked as a daemon. When code running in
 * some thread creates a new <code>Thread</code> object, the new
 * thread has its priority initially set equal to the priority of the
 * creating thread, and is a daemon thread if and only if the
 * creating thread is a daemon.
 * <p>
 *     
 * 线程拥有一个优先级别（priority），优先级高的优先于优先级低的线程执行。一个线程可能是守护线程。
 *  当线程A在执行过程中创建了一个新的线程a，则：线程a默认拥有与线程A同样的优先级。当且仅当线程A是一个守护线程时，线程a才会成为守护线程。
 *     
 * When a Java Virtual Machine starts up, there is usually a single
 * non-daemon thread (which typically calls the method named
 * <code>main</code> of some designated class). The Java Virtual
 * Machine continues to execute threads until either of the following
 * occurs:
 * 
 * Java虚拟机一经启动，就会有一个非守护线程——对应于main方法开始执行。 JVM虚拟机结束执行多线程状态的两种情况：
 * 
 * <ul>
 * <li>The <code>exit</code> method of class <code>Runtime</code> has been
 *     called and the security manager has permitted the exit operation
 *     to take place.
 *     
 * (1)Runtime类的exit()方法被调用，并且，security manager管理器也允许退出操作被执行。    
 * <li>All threads that are not daemon threads have died, either by
 *     returning from the call to the <code>run</code> method or by
 *     throwing an exception that propagates beyond the <code>run</code>
 *     method.
 * </ul>
 * 
 *  (2)所有的非守护线程都已死亡，可以是run()方法正常执行结束，也可以是run()方法执行过程中抛出了异常，都会导致该线程结束执行。
 * <p>
 * There are two ways to create a new thread of execution. One is to
 * declare a class to be a subclass of <code>Thread</code>. This
 * subclass should override the <code>run</code> method of class
 * <code>Thread</code>. An instance of the subclass can then be
 * allocated and started. For example, a thread that computes primes
 * larger than a stated value could be written as follows:
 * 
 * 创建线程的两种方式 方式1：定义一个Thread类的子类SubThread，然后重写Thread类的run()方法，然后创建一个SubThread子类的实例，将其启动即可
 * <hr><blockquote><pre>
 *     class PrimeThread extends Thread {
 *         long minPrime;
 *         PrimeThread(long minPrime) {
 *             this.minPrime = minPrime;
 *         }
 *
 *         public void run() {
 *             // compute primes larger than minPrime
 *             &nbsp;.&nbsp;.&nbsp;.
 *         }
 *     }
 * </pre></blockquote><hr>
 * <p>
 * The following code would then create a thread and start it running:
 * <blockquote><pre>
 *     PrimeThread p = new PrimeThread(143);
 *     p.start();
 * </pre></blockquote>
 * <p>
 * The other way to create a thread is to declare a class that
 * implements the <code>Runnable</code> interface. That class then
 * implements the <code>run</code> method. An instance of the class can
 * then be allocated, passed as an argument when creating
 * <code>Thread</code>, and started. The same example in this other
 * style looks like the following:
 * 
 * 第二种方式是：创建一个Runnable接口的子类SunRunnable，然后实现run()方法。接着创建SunRunnable子类对象，将其作为参数传递给Thread类，将其启动即可。
 * <hr><blockquote><pre>
 *     class PrimeRun implements Runnable {
 *         long minPrime;
 *         PrimeRun(long minPrime) {
 *             this.minPrime = minPrime;
 *         }
 *
 *         public void run() {
 *             // compute primes larger than minPrime
 *             &nbsp;.&nbsp;.&nbsp;.
 *         }
 *     }
 * </pre></blockquote><hr>
 * <p>
 * The following code would then create a thread and start it running:
 * <blockquote><pre>
 *     PrimeRun p = new PrimeRun(143);
 *     new Thread(p).start();
 * </pre></blockquote>
 * <p>
 * Every thread has a name for identification purposes. More than
 * one thread may have the same name. If a name is not specified when
 * a thread is created, a new name is generated for it.
 * <p>
 * Unless otherwise noted, passing a {@code null} argument to a constructor
 * or method in this class will cause a {@link NullPointerException} to be
 * thrown.
 */
public
class Thread implements Runnable {
    
}
```




