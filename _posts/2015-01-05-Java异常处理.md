---
layout: post
categories: [Java]
description: none
keywords: Java
---
# Java异常处理
异常是在运行时程序代码序列中产生的一种异常情况、异常事件，如文件读写时找不到指定的路径、数据库操作时连接不到指定的数据库服务器等，此时程序无法继续运行，导致整个程序运行中断。

## Java中的异常类及分类
Java提供了一套完整的异常处理机制。 在Java中，一切的异常都秉承着面向对象的设计思想，所有的异常都以类和对象的形式存在。除了Java中已经提供的各种异常类外，用户也可以根据需要自定义异常类。

在程序实际的应用中，任何程序都可能存在问题，所以在程序的开发中对于错误的处理是极其重要的，而Java提供的异常处理机制就可以帮助用户很好地解决这些问题。

Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，此时系统（JVM）会自动实例化一个异常类对象，该对象中保存了具体的异常描述信息，调用这个对象的方法可以捕获到这个异常并进行处理。因此，在这里有必要先了解一下Throwable类。

Throwable类的4个构造方法如下：
```
Throwable()
Throwable(String message)
Throwable(String message, Throwable cause)
Throwable(Throwable cause)
```
Throwable类的方法如下：
```
Throwable  fillInStackTrace()
Throwable  getCause()
String  getLocalizedMessage()
String  getMessage()
StackTraceElement[]  getStackTrace()
Throwable  initCause(Throwable cause)
void  printStackTrace()
void  printStackTrace(PrintStream s)
void  printStackTrace(PrintWriter s)
void  setStackTrace(StackTraceElement[] stackTrace)
String  toString()
```

Throwable类有两个重要的子类：Error和Exception。

- Error类特指应用程序在运行期间发生的严重错误，如虚拟机内存用尽、堆栈溢出、动态链接失败等，对于这类错误导致的应用程序中断，程序无法预防和恢复。一般情况下，这种错误都是灾难性的，没有必要使用异常处理机制处理。
- Exception类是指一些可以被捕获且可能恢复的异常情况，如数组下标越界、数字被零除产生异常、输入/输出异常等。

Exception类又分为运行时异常和非运行时异常。RuntimeException及其子类都属于运行时异常，如数字被零除产生异常、数组下标越界异常等。除了运行时异常以外的Exception子类都是非运行时异常。所有继承自Error和RuntimeException类的异常为未检查异常，其他的异常为已检查异常。Java编译器要求Java程序必须处理已检查异常，而未检查异常、无法进行处理或是发生在程序运行时，编译器则没有硬性规定，建议开发者不处理未检查异常。

## Java异常处理机制
```java
public class ExcDemo01 {
     private String state = "正常状态";
     public String getState() {
          return state;
     }
     public void setState(String state) {
          this.state = state;
     }
     public static void main(String[] args) {
          System.out.println("<--程序开始-->");
          ExcDemo01 NullPointerCls = null;
          NullPointerCls.getState();
          System.out.println("<--程序结束-->");
     }
}
```
不难发现，这段程序代码中ExcDemo01类的NullPointerCls对象没有实例化。这段程序代码的运行结果如下：
```
<--程序开始-->
Exception in thread "main" java.lang.NullPointerException     at
example.code.exception.ExcDemo01.main(ExcDemo01.java:28)
```
从运行结果中可以得到以下信息：
- 出现了java.lang.NullPointerException，即通常说的空指针异常。
- 在ExcDemo01.java文件产生NullPointerCls.getState()的异常代码。
- 没有输出<--程序结束-->，说明程序中的异常没有得到处理从而导致异常终止。

上面的运行结果显然不是开发者所期望的。NullPointerException是一种运行时异常、一种未检查异常，不用显式地进行异常处理。但是至少说明如果不对异常进行处理，程序就会异常终止。

Java中有两种异常处理机制：捕获处理异常和声明抛出异常。与异常有关的关键字有try、catch、throw、throws和finally。通过try、catch、finally关键字实现捕获处理异常，通过throw、throws关键字声明抛出异常。

## 捕获处理异常
捕获处理异常是先用try选定监控异常的范围，每个try代码块可以伴随一个或多个catch代码块，用于处理try代码块中的方法可能抛出的异常。catch语句需要指明能够捕获处理的异常类型，这个类必须是Throwable的子类。捕获异常的顺序和catch语句的顺序有关，当捕获到一个异常时，剩下的catch语句就不再进行匹配。

在安排catch语句的顺序时，首先应该捕获最特殊的异常，然后逐渐一般化，也就是先安排子类，再安排父类。finally语句保证在控制流转到程序的其他部分之前，finally代码块中的程序都被执行。不管在try代码块中是否发生了异常事件，finally代码块中的语句都会被执行。

下面是Java异常处理程序的基本形式：
```
try{
//可能产生异常的代码
}
catch(异常类型1 异常对象){
//对异常类型1的处理
}
catch(异常类型2 异常对象){
//对异常类型2的处理
}
catch(异常类型3 异常对象){
//对异常类型3的处理
}
. . .      . . .
. . .      . . .
. . .      . . .
catch(异常类型n 异常对象){
//对异常类型n的处理
}
finally{
//总会执行的代码
}
```
下面是一个捕获处理异常的例子。
```java
public class ExcDemo02 {
          private static void loadClass(String className)
               throws ClassNotFoundException {
               Class.forName(className);
          }
          public static void doSth(String className) {
               System.out.println("<--调用loadClass()方法开始-->");
               try {
System.out.println("<--try的自述：在这里监控 可能出现异常的代码-->");
                    loadClass(className);
               } catch (ClassNotFoundException e) {
System.out.println("<--catch的自述：出现异常 在这里处理-->");
               } finally {
System.out.println("<--finally的自述： 不管是否出现异常，最后都要执行到这里-->");
               }
               System.out.println("<--调用loadClass()方法结束-->");
          }
     public static void main(String[] args) {
          System.out.println("<--调用doSth()方法开始-->");
          doSth("java.lang.exception");
          System.out.println("<--调用doSth()方法结束-->");
     }
}
```
这段程序代码的运行结果如下：
```
<--调用doSth()方法开始-->
<--调用loadClass()方法开始-->
<--try的自述：在这里监控可能出现异常的代码-->
<--catch的自述：出现异常在这里处理-->
<--finally的自述：不管是否出现异常，最后都要执行到这里-->
<--调用loadClass()方法结束-->
<--调用doSth()方法结束-->
```
从这段代码的运行结果中可以看出，doSth()方法捕获处理了loadClass()方法中出现的异常。

再看下面的例子。
```java
public class ExcDemo03 {
     private static void loadClass(String className)
               throws ClassNotFoundException {
          Class.forName(className);
     }
     public static void doSth(String className) {
          System.out.println("<--调用loadClass()方法开始-->");
          try {
               loadClass(className);
          } catch (ClassNotFoundException e) {
System.out.println("<--这里只处理 ClassNotFoundException-->");
          } catch (Exception e) {
               System.out.println("<-这里处理所有的异常->");
          } finally {
          }
          System.out.println("<--调用loadClass()方法结束-->");
     }
     public static void main(String[] args) {
          System.out.println("<--调用doSth()方法开始-->");
          doSth("java.lang.exception");
          System.out.println("<--调用doSth()方法结束-->");
     }
}
```
这段程序代码的运行结果如下：
```
<--调用doSth()方法开始-->
<--调用loadClass()方法开始-->
<--这里只处理ClassNotFoundException-->
<--调用loadClass()方法结束-->
<--调用doSth()方法结束-->
```
结果中为什么没有<-这里处理所有的异常->呢？这个例子正好说明了前面提到的：捕获异常的顺序和catch语句的顺序有关。当捕获到一个异常时，剩下的catch语句就不再进行匹配。为了加深对这个规则的理解和认识，再来看下面的例子：
```java
public class ExcDemo04 {
     private static void loadClass(String className)
               throws ClassNotFoundException {
          Class.forName(className);
     }
     public static void doSth(String className) {
          System.out.println("<--调用loadClass()方法开始-->");
          try {
               loadClass(className);
          } catch (Exception e) {
               System.out.println("<-这里处理所有的异常->");
          } catch (ClassNotFoundException e) {
System.out.println("<--这里只处理 ClassNotFoundException-->");
          } finally {
          }
          System.out.println("<--调用loadClass()方法结束-->");
     }
     public static void main(String[] args) {
          System.out.println("<--调用doSth()方法开始-->");
          doSth("java.lang.exception");
          System.out.println("<--调用doSth()方法结束-->");
     }
}

```
这个例子和上面的例子有什么区别呢？只是把两个catch块的顺序交换了一下。这个例子正好解释了：在安排catch语句的顺序时，首先应该捕获最特殊的异常，然后逐渐一般化，也就是一般先安排子类，再安排父类。如果用Eclipse 3.1作为开发工具编写这段代码，不用编译Eclipse 3.1就会自动指出，第2个catch块是在任何情况下都不可能被执行的。

一个try语句可以在另一个try块内部，也就是说，try块是可以被嵌套的。每次进入try块，try都会按其前后关系入栈，如果内部try块中的异常不能找到相应的catch块进行处理，就从栈中弹出并检查下一个try块对应的catch块是否与之匹配，直到找到匹配的为止，或者由于没有与之匹配的catch块而交由JVM处理。当然，如果交由JVM处理，程序就会异常终止。

看下面的例子：
```java
public class ExcDemo05 {
     private static void loadClass(String className)
               throws ClassNotFoundException {
          Class.forName(className);
     }
public static void doSth(String className) {
          try {
               try{
                    loadClass(className);
               }finally{
               }
          } catch (ClassNotFoundException e) {
               System.out.println("<--在这里处理内部的try块-->");
          } finally {
          }
     }
     public static void main(String[] args) {
          System.out.println("<--调用doSth()方法开始-->");
          doSth("java.lang.exception");
          System.out.println("<--调用doSth()方法结束-->");
     }
}
```
这段程序代码的运行结果如下：
```
<--调用doSth()方法开始-->
<--在这里处理内部的try块-->
<--调用doSth()方法结束-->
```

## 声明抛出异常
抛出异常也是生成异常对象的过程。异常或是由虚拟机生成，或是在程序中生成。在方法中，抛出异常对象是通过throw语句实现的。

如果方法中生成了一个异常，但是当这种方法不需要或不知道如何处理时，就应该声明抛出异常，使得异常对象可以从调用栈向上传播，直到有相应的方法捕获为止。因此，一旦出现异常就伴随着程序流程的跳转，但不建议用异常作为流程控制手段控制程序的流程。声明抛出异常是在方法声明中的throws子句中指明的。

下面是Java声明抛出异常程序的基本形式。
```
方法返回值类型 方法名(方法参数类型1 对象1，... … 方法参数类型n 对象n) throws
异常类型1，… …异常类型n{
. . .      . . .
. . .      . . .
. . .      . . .
throw异常类型1的对象
. . .      . . .
. . .      . . .
. . .      . . .
. . .      . . .
. . .      . . .
. . .      . . .
throw异常类型n的对象
}
```
回到前面的一个例子：
```java
public class ExcDemo02 {
     private static void loadClass(String className)
               throws ClassNotFoundException {
          Class.forName(className);
     }
     public static void doSth(String className) {
          System.out.println("<--调用loadClass()方法开始-->");
          try {
System.out.println("<--try的自述：在这里监控 可能出现异常的代码-->");
               loadClass(className);
          } catch (ClassNotFoundException e) {
System.out.println("<--catch的自述： 出现异常在这里处理-->");
          } finally {
System.out.println("<--finally的自述： 不管是否出现异常，最后都要执行到这里-->");
          }
          System.out.println("<--调用loadClass()方法结束-->");
     }
     public static void main(String[] args) {
          System.out.println("<--调用doSth()方法开始-->");
          doSth("java.lang.exception");
          System.out.println("<--调用doSth()方法结束-->");
     }
}
```
loadClass()方法后面的throws ClassNotFoundException，说明loadClass()方法没有捕获处理程序Class.forName（className）所引发异常，loadClass()方法使用throws关键字声明抛出了这个异常。调用loadClass()方法的doSth()方法使用try-catch-finally捕获处理了这个异常。而doSth()方法处理异常ClassNotFoundException的方式可以是将这个异常包装成更一般的Exception，然后抛出。

这样做也是有意义的：可能doSth()方法不希望调用它的方法知道具体发生了什么的异常，也可能是调用doSth()方法的方法根本不关心究竟发生了什么异常，所有的异常都同样对待。

请看下面的例子：
```java
public class ExcDemo05 {
     private static void loadClass(String className)
               throws ClassNotFoundException {
          Class.forName(className);
     }
     public static void doSth(String className) throws Exception {
          System.out.println("<--调用loadClass()方法开始-->");
          try {
               loadClass(className);
          } catch (ClassNotFoundException e) {
System.out.println("<--只向调用者声明可能出现 Exception异常并不告知具体是什么异常-->");
               throw new Exception();
          } finally {
          }
          System.out.println("<--调用loadClass()方法结束-->");
     }
     public static void main(String[] args) {
          System.out.println("<--调用doSth()方法开始-->");
          try {
               doSth("java.lang.exception");
          } catch (Exception e) {
               System.out.println("<--不管是什么异常，只要有异常 就这样处理-->");
          }
          System.out.println("<--调用doSth()方法结束-->");
     }
}
```
这段程序代码的运行结果如下：
```
<--调用doSth()方法开始-->
<--调用loadClass()方法开始-->
<--只向调用者声明可能出现Exception异常并不告知具体是什么异常-->
<--不管是什么异常，只要有异常就这样处理-->
<--调用doSth()方法结束-->
```
这段代码中，doSth()方法使用throw关键字抛出了异常。

## 自定义异常
Java还允许开发者定义自己的异常类，称为自定义异常。但需要遵守的规则是：自定义异常类必须是Throwable的子类，而更多情况下，自定义异常类都继承自Exception类。

下面的例子演示了如何编写自定义异常。
```java
import java.io.PrintStream;
import java.io.PrintWriter;
public class BuziException extends Exception {
     private static final long serialVersionUID = 1L;
     public synchronized Throwable fillInStackTrace() {
          System.out.println("<--添加自定义内容-->");
          return super.fillInStackTrace();
     }
     public Throwable getCause() {
          System.out.println("<--添加自定义内容-->");
          return super.getCause();
     }
     public String getLocalizedMessage() {
          System.out.println("<--添加自定义内容-->");
          return super.getLocalizedMessage();
     }
     public String getMessage() {
          System.out.println("<--添加自定义内容-->");
          return super.getMessage();
     }
     public StackTraceElement[] getStackTrace() {
          System.out.println("<--添加自定义内容-->");
          return super.getStackTrace();
     }
     public synchronized Throwable initCause(Throwable arg0) {
          System.out.println("<--添加自定义内容-->");
          return super.initCause(arg0);
     }
     public void printStackTrace() {
          System.out.println("<--添加自定义内容-->");
          super.printStackTrace();
     }
     public void printStackTrace(PrintStream arg0) {
          System.out.println("<--添加自定义内容-->");
          super.printStackTrace(arg0);
     }
     public void printStackTrace(PrintWriter arg0) {
          System.out.println("<--添加自定义内容-->");
          super.printStackTrace(arg0);
     }
     public void setStackTrace(StackTraceElement[] arg0) {
          System.out.println("<--添加自定义内容-->");
          super.setStackTrace(arg0);
     }
     public String toString() {
          System.out.println("<--添加自定义内容-->");
          return super.toString();
     }
}
```
上面示例定义了名为BuziException的异常类，继承自Exception，覆盖了Throwable类所有的方法。