---
layout: post
categories: JUC
description: none
keywords: JUC
---
# 并发编程线程池

## 线程池原理以及自定义线程池
自JDK1.5起，utils包提供了ExecutorService线程池的实现，主要目的是为了重复利用线程，提高系统效率。Thread是一个重量级的资源，创建、启动以及销毁都是比较耗费系统资源的，因此对线程的重复利用一种是非常好的程序设计习惯，加之系统中可创建的线程数量是有限的，线程数量和系统性能是一种抛物线的关系，也就是说当线程数量达到某个数值的时候，性能反倒会降低很多，因此对线程的管理，尤其是数量的控制更能直接决定程序的性能。

从原理入手，设计一个线程池，其目的并不是重复地发明轮子，而是为了帮助读者弄清楚一个线程池应该具备哪些功能，线程池的实现需要注意哪些细节。

## 线程池原理
所谓线程池，通俗的理解就是有一个池子，里面存放着已经创建好的线程，当有任务提交给线程池执行时，池子中的某个线程会主动执行该任务。如果池子中的线程数量不够应付数量众多的任务时，则需要自动扩充新的线程到池子中，但是该数量是有限的，就好比池塘的水界线一样。当任务比较少的时候，池子中的线程能够自动回收，释放资源。为了能够异步地提交任务和缓存未被处理的任务，需要有一个任务队列。

通过上面的描述可知，一个完整的线程池应该具备如下要素。
- 任务队列：用于缓存提交的任务。
- 线程数量管理功能：一个线程池必须能够很好地管理和控制线程数量，可通过如下三个参数来实现，比如创建线程池时初始的线程数量init；线程池自动扩充时最大的线程数量max；在线程池空闲时需要释放线程但是也要维护一定数量的活跃数量或者核心数量core。有了这三个参数，就能够很好地控制线程池中的线程数量，将其维护在一个合理的范围之内，三者之间的关系是init<=core<=max。
- 任务拒绝策略：如果线程数量已达到上限且任务队列已满，则需要有相应的拒绝策略来通知任务提交者。
- 线程工厂：主要用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等。
- QueueSize：任务队列主要存放提交的Runnable，但是为了防止内存溢出，需要有limit数量对其进行控制。
- Keepedalive时间：该时间主要决定线程各个重要参数自动维护的时间间隔。

## 线程池实现
实现一个比较简单的ThreadPool，虽然比较简单，但是该有的功能基本上都具备，对读者学习和掌握JUC中的ExecutorService也有一定的帮助。

### 线程池接口定义
ThreadPool主要定义了一个线程池应该具备的基本操作和方法，下面是ThreadPool接口定义的方法：
```java
public interface ThreadPool
{
    //提交任务到线程池
    void execute(Runnable runnable);

    //关闭线程池
    void shutdown();

    //获取线程池的初始化大小
    int getInitSize();

    //获取线程池最大的线程数
    int getMaxSize();

    //获取线程池的核心线程数量
    int getCoreSize();

    //获取线程池中用于缓存任务队列的大小
    int getQueueSize();

    //获取线程池中活跃线程的数量
    int getActiveCount();

    //查看线程池是否已经被shutdown
    boolean isShutdown();
}
```

RunanbleQueue主要用于存放提交的Runnable，该Runnable是一个BlockedQueue，并且有limit的限制
```java
//任务队列，主要用于缓存提交到线程池中的任务
public interface RunnableQueue
{
    //当有新的任务进来时首先会offer到队列中
    void offer(Runnable runnable);

    //工作线程通过take方法获取Runnable
    Runnable take();

    //获取任务队列中任务的数量
    int size();
}
```

ThreadFactory提供了创建线程的接口，以便于个性化地定制Thread，比如Thread应该被加到哪个Group中，优先级、线程名字以及是否为守护线程等
```java
//创建线程的工厂
@FunctionalInterface
public interface ThreadFactory
{
    // createThread（Runnable runnable）用于创建线程。
    Thread createThread(Runnable runnable);
}
```

DenyPolicy主要用于当Queue中的runnable达到了limit上限时，决定采用何种策略通知提交者。该接口中定义了三种默认的实现
```java
@FunctionalInterface
public interface DenyPolicy
{

    void reject(Runnable runnable, ThreadPool threadPool);

    //该拒绝策略会直接将任务丢弃
    class DiscardDenyPolicy implements DenyPolicy
    {

        @Override
        public void reject(Runnable runnable, ThreadPool threadPool)
        {
            //do nothing
        }
    }

    //该拒绝策略会向任务提交者抛出异常
    class AbortDenyPolicy implements DenyPolicy
    {

        @Override
        public void reject(Runnable runnable, ThreadPool threadPool)
        {
            throw new RunnableDenyException("The runnable " + runnable + " will be abort.");
        }
    }
    //该拒绝策略会使任务在提交者所在的线程中执行任务
    class RunnerDenyPolicy implements DenyPolicy
    {

        @Override
        public void reject(Runnable runnable, ThreadPool threadPool)
        {
            if (!threadPool.isShutdown())
            {
                runnable.run();
            }
        }
    }
}

```
void reject（Runnable runnable，ThreadPool threadPool）为拒绝方法。
- DiscardDenyPolicy策略会直接丢弃掉Runnable任务。
- AbortDenyPolicy策略会抛出RunnableDenyException异常。
- RunnerDenyPolicy策略，交给调用者的线程直接运行runnable，而不会被加入到线程池中。

RunnableDenyException是RuntimeException的子类，主要用于通知任务提交者，任务队列已无法再接收新的任务。
```java
public class RunnableDenyException extends RuntimeException
{

    public RunnableDenyException(String message)
    {
        super(message);
    }
}
```

InternalTask是Runnable的一个实现，主要用于线程池内部，该类会使用到RunnableQueue，然后不断地从queue中取出某个runnable，并运行runnable的run方法
```java
public class InternalTask implements Runnable
{
    private final RunnableQueue runnableQueue;

    private volatile boolean running = true;

    public InternalTask(RunnableQueue runnableQueue)
    {
        this.runnableQueue = runnableQueue;
    }

    @Override
    public void run()
    {
        //如果当前任务为running并且没有被中断，则其将不断地从queue中获取runnable，然后执行run方法
        while (running && !Thread.currentThread().isInterrupted())
        {
            try
            {
                Runnable task = runnableQueue.take();
                task.run();
            } catch (InterruptedException e)
            {
                running = false;
                break;
            }
        }
    }

    //停止当前任务，主要会在线程池的shutdown方法中使用
    public void stop()
    {
        this.running = false;
    }
}
```

### 线程池详细实现
LinkedRunnableQueue的示例代码
```java
import java.util.LinkedList;

public class LinkedRunnableQueue implements RunnableQueue
{
    //任务队列的最大容量，在构造时传入
    private final int limit;

    //若任务队列中的任务已经满了，则需要执行拒绝策略
    private final DenyPolicy denyPolicy;

    //存放任务的队列
    private final LinkedList<Runnable> runnableList = new LinkedList<>();

    private final ThreadPool threadPool;
    public LinkedRunnableQueue(int limit, DenyPolicy denyPolicy, ThreadPool threadPool)
    {
        this.limit = limit;
        this.denyPolicy = denyPolicy;
        this.threadPool = threadPool;
    }
}
```
在LinkedRunnableQueue中有几个重要的属性，第一个是limit，也就是Runnable队列的上限；当提交的Runnable数量达到limit上限时，则会调用DenyPolicy的reject方法；runnableList是一个双向循环列表，用于存放Runnable任务，示例代码如下：
```java
@Override
public void offer(Runnable runnable)
{
    synchronized (runnableList)
    {
        if (runnableList.size() >= limit)
        {
            //无法容纳新的任务时执行拒绝策略
            denyPolicy.reject(runnable, threadPool);
        } else
        {
            //将任务加入到队尾，并且唤醒阻塞中的线程
            runnableList.addLast(runnable);
            runnableList.notifyAll();
        }
    }
}
```
offer方法是一个同步方法，如果队列数量达到了上限，则会执行拒绝策略，否则会将runnable存放至队列中，同时唤醒take任务的线程：
```java
@Override
public Runnable take() throws InterruptedException
{
    synchronized (runnableList)
    {
        while (runnableList.isEmpty())
        {
            try
            {
                //如果任务队列中没有可执行任务，则当前线程将会挂起，进入runnableList关联的monitor waitset中等待唤醒（新的任务加入）
                runnableList.wait();
            } catch (InterruptedException e)
            {
                //被中断时需要将该异常抛出
                throw e;
            }
        }
        //从任务队列头部移除一个任务
        return runnableList.removeFirst();
    }
}
```

take方法也是同步方法，线程不断从队列中获取Runnable任务，当队列为空的时候工作线程会陷入阻塞，有可能在阻塞的过程中被中断，为了传递中断信号需要在catch语句块中将异常抛出以通知上游（InternalTask），示例代码如下：
```java
@Override
public int size()
{
    synchronized (runnableList)
    {
        //返回当前任务队列中的任务数
        return runnableList.size();
    }
}

```












