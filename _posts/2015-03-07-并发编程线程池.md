---
layout: post
categories: [JUC]
description: none
keywords: JUC
---
# 并发编程线程池

## 线程池ThreadPoolExecutor
线程池主要解决两个问题：一是当执行大量异步任务时线程池能够提供较好的性能。在不使用线程池时，每当需要执行异步任务时直接new一个线程来运行，而线程的创建和销毁是需要开销的。线程池里面的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。二是线程池提供了一种资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等。每个ThreadPoolExecutor也保留了一些基本的统计数据，比如当前线程池完成的任务数目等。

另外，线程池也提供了许多可调参数和可扩展性接口，以满足不同情境的需要，程序员可以使用更方便的Executors的工厂方法，比如newCachedThreadPool（线程池线程个数最多可达Integer.MAX_VALUE，线程自动回收）、newFixedThreadPool（固定大小的线程池）和newSingleThreadExecutor（单个线程）等来创建线程池，当然用户还可以自定义。

## 线程池原理以及自定义线程池
自JDK1.5起，utils包提供了ExecutorService线程池的实现，主要目的是为了重复利用线程，提高系统效率。Thread是一个重量级的资源，创建、启动以及销毁都是比较耗费系统资源的，因此对线程的重复利用一种是非常好的程序设计习惯，加之系统中可创建的线程数量是有限的，线程数量和系统性能是一种抛物线的关系，也就是说当线程数量达到某个数值的时候，性能反倒会降低很多，因此对线程的管理，尤其是数量的控制更能直接决定程序的性能。

从原理入手，设计一个线程池，其目的并不是重复地发明轮子，而是为了帮助读者弄清楚一个线程池应该具备哪些功能，线程池的实现需要注意哪些细节。

## 线程池原理
所谓线程池，通俗的理解就是有一个池子，里面存放着已经创建好的线程，当有任务提交给线程池执行时，池子中的某个线程会主动执行该任务。如果池子中的线程数量不够应付数量众多的任务时，则需要自动扩充新的线程到池子中，但是该数量是有限的，就好比池塘的水界线一样。当任务比较少的时候，池子中的线程能够自动回收，释放资源。为了能够异步地提交任务和缓存未被处理的任务，需要有一个任务队列。

通过上面的描述可知，一个完整的线程池应该具备如下要素。
- 任务队列：用于缓存提交的任务。
- 线程数量管理功能：一个线程池必须能够很好地管理和控制线程数量，可通过如下三个参数来实现，比如创建线程池时初始的线程数量init；线程池自动扩充时最大的线程数量max；在线程池空闲时需要释放线程但是也要维护一定数量的活跃数量或者核心数量core。有了这三个参数，就能够很好地控制线程池中的线程数量，将其维护在一个合理的范围之内，三者之间的关系是init<=core<=max。
- 任务拒绝策略：如果线程数量已达到上限且任务队列已满，则需要有相应的拒绝策略来通知任务提交者。
- 线程工厂：主要用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等。
- QueueSize：任务队列主要存放提交的Runnable，但是为了防止内存溢出，需要有limit数量对其进行控制。
- Keepedalive时间：该时间主要决定线程各个重要参数自动维护的时间间隔。

## 线程池实现
实现一个比较简单的ThreadPool，虽然比较简单，但是该有的功能基本上都具备，对读者学习和掌握JUC中的ExecutorService也有一定的帮助。

### 线程池接口定义
ThreadPool主要定义了一个线程池应该具备的基本操作和方法，下面是ThreadPool接口定义的方法：
```java
public interface ThreadPool
{
    //提交任务到线程池
    void execute(Runnable runnable);

    //关闭线程池
    void shutdown();

    //获取线程池的初始化大小
    int getInitSize();

    //获取线程池最大的线程数
    int getMaxSize();

    //获取线程池的核心线程数量
    int getCoreSize();

    //获取线程池中用于缓存任务队列的大小
    int getQueueSize();

    //获取线程池中活跃线程的数量
    int getActiveCount();

    //查看线程池是否已经被shutdown
    boolean isShutdown();
}
```

RunanbleQueue主要用于存放提交的Runnable，该Runnable是一个BlockedQueue，并且有limit的限制
```java
//任务队列，主要用于缓存提交到线程池中的任务
public interface RunnableQueue
{
    //当有新的任务进来时首先会offer到队列中
    void offer(Runnable runnable);

    //工作线程通过take方法获取Runnable
    Runnable take();

    //获取任务队列中任务的数量
    int size();
}
```

ThreadFactory提供了创建线程的接口，以便于个性化地定制Thread，比如Thread应该被加到哪个Group中，优先级、线程名字以及是否为守护线程等
```java
//创建线程的工厂
@FunctionalInterface
public interface ThreadFactory
{
    // createThread（Runnable runnable）用于创建线程。
    Thread createThread(Runnable runnable);
}
```

DenyPolicy主要用于当Queue中的runnable达到了limit上限时，决定采用何种策略通知提交者。该接口中定义了三种默认的实现
```java
@FunctionalInterface
public interface DenyPolicy
{

    void reject(Runnable runnable, ThreadPool threadPool);

    //该拒绝策略会直接将任务丢弃
    class DiscardDenyPolicy implements DenyPolicy
    {

        @Override
        public void reject(Runnable runnable, ThreadPool threadPool)
        {
            //do nothing
        }
    }

    //该拒绝策略会向任务提交者抛出异常
    class AbortDenyPolicy implements DenyPolicy
    {

        @Override
        public void reject(Runnable runnable, ThreadPool threadPool)
        {
            throw new RunnableDenyException("The runnable " + runnable + " will be abort.");
        }
    }
    //该拒绝策略会使任务在提交者所在的线程中执行任务
    class RunnerDenyPolicy implements DenyPolicy
    {

        @Override
        public void reject(Runnable runnable, ThreadPool threadPool)
        {
            if (!threadPool.isShutdown())
            {
                runnable.run();
            }
        }
    }
}

```
void reject（Runnable runnable，ThreadPool threadPool）为拒绝方法。
- DiscardDenyPolicy策略会直接丢弃掉Runnable任务。
- AbortDenyPolicy策略会抛出RunnableDenyException异常。
- RunnerDenyPolicy策略，交给调用者的线程直接运行runnable，而不会被加入到线程池中。

RunnableDenyException是RuntimeException的子类，主要用于通知任务提交者，任务队列已无法再接收新的任务。
```java
public class RunnableDenyException extends RuntimeException
{

    public RunnableDenyException(String message)
    {
        super(message);
    }
}
```

InternalTask是Runnable的一个实现，主要用于线程池内部，该类会使用到RunnableQueue，然后不断地从queue中取出某个runnable，并运行runnable的run方法
```java
public class InternalTask implements Runnable
{
    private final RunnableQueue runnableQueue;

    private volatile boolean running = true;

    public InternalTask(RunnableQueue runnableQueue)
    {
        this.runnableQueue = runnableQueue;
    }

    @Override
    public void run()
    {
        //如果当前任务为running并且没有被中断，则其将不断地从queue中获取runnable，然后执行run方法
        while (running && !Thread.currentThread().isInterrupted())
        {
            try
            {
                Runnable task = runnableQueue.take();
                task.run();
            } catch (InterruptedException e)
            {
                running = false;
                break;
            }
        }
    }

    //停止当前任务，主要会在线程池的shutdown方法中使用
    public void stop()
    {
        this.running = false;
    }
}
```

### 线程池详细实现
LinkedRunnableQueue的示例代码
```java
import java.util.LinkedList;

public class LinkedRunnableQueue implements RunnableQueue
{
    //任务队列的最大容量，在构造时传入
    private final int limit;

    //若任务队列中的任务已经满了，则需要执行拒绝策略
    private final DenyPolicy denyPolicy;

    //存放任务的队列
    private final LinkedList<Runnable> runnableList = new LinkedList<>();

    private final ThreadPool threadPool;
    public LinkedRunnableQueue(int limit, DenyPolicy denyPolicy, ThreadPool threadPool)
    {
        this.limit = limit;
        this.denyPolicy = denyPolicy;
        this.threadPool = threadPool;
    }
}
```
在LinkedRunnableQueue中有几个重要的属性，第一个是limit，也就是Runnable队列的上限；当提交的Runnable数量达到limit上限时，则会调用DenyPolicy的reject方法；runnableList是一个双向循环列表，用于存放Runnable任务，示例代码如下：
```
@Override
public void offer(Runnable runnable)
{
    synchronized (runnableList)
    {
        if (runnableList.size() >= limit)
        {
            //无法容纳新的任务时执行拒绝策略
            denyPolicy.reject(runnable, threadPool);
        } else
        {
            //将任务加入到队尾，并且唤醒阻塞中的线程
            runnableList.addLast(runnable);
            runnableList.notifyAll();
        }
    }
}
```
offer方法是一个同步方法，如果队列数量达到了上限，则会执行拒绝策略，否则会将runnable存放至队列中，同时唤醒take任务的线程：
```
@Override
public Runnable take() throws InterruptedException
{
    synchronized (runnableList)
    {
        while (runnableList.isEmpty())
        {
            try
            {
                //如果任务队列中没有可执行任务，则当前线程将会挂起，进入runnableList关联的monitor waitset中等待唤醒（新的任务加入）
                runnableList.wait();
            } catch (InterruptedException e)
            {
                //被中断时需要将该异常抛出
                throw e;
            }
        }
        //从任务队列头部移除一个任务
        return runnableList.removeFirst();
    }
}
```

take方法也是同步方法，线程不断从队列中获取Runnable任务，当队列为空的时候工作线程会陷入阻塞，有可能在阻塞的过程中被中断，为了传递中断信号需要在catch语句块中将异常抛出以通知上游（InternalTask），示例代码如下：
```
@Override
public int size()
{
    synchronized (runnableList)
    {
        //返回当前任务队列中的任务数
        return runnableList.size();
    }
}

```


# Java线程池(ThreadPoolExecutor)
创建Java线程需要给线程分配堆栈内存以及初始化内存，还需要进行系统调用，频繁地创建和销毁线程会大大降低系统的运行效率。出于线程管理的需要，线程池应运而生。线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。

## 什么是线程池

创建线程去处理业务，可能创建线程的时间比处理业务的时间还长一些，如果系统能够提前为我们创建好线程，我们需要的时候直接拿来使用，用完之后不是直接将其关闭，而是将其返回到线程中，给其他需要这使用，这样直接节省了创建和销毁的时间，提升了系统的性能。
简单的说，在使用了线程池之后，创建线程变成了从线程池中获取一个空闲的线程，然后使用，关闭线程变成了将线程归还到线程池。

## 为什么要有线程池

使用线程池的好处在于
- 降低资源消耗：线程池通常会维护一些线程（数量为 corePoolSize），这些线程被重复使用来执行不同的任务，任务完成后不会销毁。在待处理任务量很大的时候，通过对线程资源的复用，避免了线程的频繁创建与销毁，从而降低了系统资源消耗。
- 提高响应速度：由于线程池维护了一批 alive 状态的线程，当任务到达时，不需要再创建线程，而是直接由这些线程去执行任务，从而减少了任务的等待时间。
- 提高线程的可管理性：使用线程池可以对线程进行统一的分配，调优和监控。

## 线程池实现原理

当向线程池提交一个任务之后，线程池的处理流程如下：

1. 判断是否达到核心线程数，若未达到，则直接创建新的线程处理当前传入的任务，否则进入下个流程
2. 线程池中的工作队列是否已满，若未满，则将任务丢入工作队列中先存着等待处理，否则进入下个流程
3. 是否达到最大线程数，若未达到，则创建新的线程处理当前传入的任务，否则交给线程池中的饱和策略进行处理。

**举个例子，加深理解：**

咱们作为开发者，上面都有开发主管，主管下面带领几个小弟干活，CTO给主管授权说，你可以招聘5个小弟干活，新来任务，如果小弟还不到5个，立即去招聘一个来干这个新来的任务，当5个小弟都招来了，再来任务之后，将任务记录到一个表格中，表格中最多记录100个，小弟们会主动去表格中获取任务执行，如果5个小弟都在干活，并且表格中也记录满了，那你可以将小弟扩充到20个，如果20个小弟都在干活，并且存放任务的表也满了，产品经理再来任务后，是直接拒绝，还是让产品自己干，这个由你自己决定，小弟们都尽心尽力在干活，任务都被处理完了，突然公司业绩下滑，几个员工没事干，打酱油，为了节约成本，CTO主管把小弟控制到5人，其他15个人直接被干掉了。所以作为小弟们，别让自己闲着，多干活。

**原理:**  先找几个人干活，大家都忙于干活，任务太多可以排期，排期的任务太多了，再招一些人来干活，最后干活的和排期都达到上层领导要求的上限了，那需要采取一些其他策略进行处理了。对于长时间不干活的人，考虑将其开掉，节约资源和成本。

## JUC线程池架构

### ExecutorService
ExecutorService在Executor的基础上加入了线程池的生命周期管理，可以通过shutdown或者shutdownNow方法来关闭线程池。
ExecutorService支持提交Callable形式的任务，提交完Callable任务后拿到一个Future（代表一个异步任务执行的结果）。

```java
/**
 * An {@link Executor} that provides methods to manage termination and
 * methods that can produce a {@link Future} for tracking progress of
 * one or more asynchronous tasks.
 *
 * <p>An {@code ExecutorService} can be shut down, which will cause
 * it to reject new tasks.  Two different methods are provided for
 * shutting down an {@code ExecutorService}. The {@link #shutdown}
 * method will allow previously submitted tasks to execute before
 * terminating, while the {@link #shutdownNow} method prevents waiting
 * tasks from starting and attempts to stop currently executing tasks.
 * Upon termination, an executor has no tasks actively executing, no
 * tasks awaiting execution, and no new tasks can be submitted.  An
 * unused {@code ExecutorService} should be shut down to allow
 * reclamation of its resources.
 *
 * <p>Method {@code submit} extends base method {@link
 * Executor#execute(Runnable)} by creating and returning a {@link Future}
 * that can be used to cancel execution and/or wait for completion.
 * Methods {@code invokeAny} and {@code invokeAll} perform the most
 * commonly useful forms of bulk execution, executing a collection of
 * tasks and then waiting for at least one, or all, to
 * complete. (Class {@link ExecutorCompletionService} can be used to
 * write customized variants of these methods.)
 */
public interface ExecutorService extends Executor {
```

### AbstractExecutorService
抽象类，实现了ExecutorService

### ThreadPoolExecutor
线程池实现类，继承于AbstractExecutorService，JUC线程池的核心实现类

### ScheduledExecutorService
继承于ExecutorService。它是一个可以完成“延时”和“周期性”任务的调度线程池接口

### ScheduledThreadPoolExecutor
继承于ThreadPoolExecutor，实现了ExecutorService中延时执行和周期执行等抽象方法

### Executors
静态工厂类，它通过静态工厂方法返回ExecutorService、ScheduledExecutorService等线程池示例对象

ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系：

- ThreadPoolExecutor继承了AbstractExecutorService，AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。
- ExecutorService又是继承了Executor接口，Executor是顶层接口。

## 线程池的创建
Executors中提供了一系列静态方法创建线程池：

### newSingleThreadExecutor
newSingleThreadExecutor创建“单线程化线程池”。一个单线程的线程池。如果因异常结束，会再创建一个新的，保证按照提交顺序执行。
```java

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

public class NewSingleThreadExecutorDemo {

    public static void main(String[] args) {
        ExecutorService pool = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 3; i++) {
            pool.execute(new newSingleThreadExecutorRunnable());
            pool.submit(new newSingleThreadExecutorRunnable());
        }
        pool.shutdown();
    }

    static class newSingleThreadExecutorRunnable implements Runnable {

        static AtomicInteger taskNo = new AtomicInteger(1);

        private String taskName;

        public newSingleThreadExecutorRunnable() {
            taskName = "task-" + taskNo;
            taskNo.incrementAndGet();
        }

        @Override
        public void run() {
            System.out.println("task:" + taskName + " start...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("task:" + taskName + " end...");
        }
    }

}
```
特点：

- 单线程化的线程池中的任务是按照提交的次序顺序执行的
- 只有一个线程的线程池
- 池中的唯一线程的存活时间是无限的
- 当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其阻塞队列是无界的
- 适用场景：任务按照提交次序，一个任务一个任务地逐个执行的场景

### newFixedThreadPool
newFixedThreadPool创建“固定数量的线程池。创建固定大小的线程池。根据提交的任务逐个增加线程，直到最大值保持不变。如果因异常结束，会新创建一个线程补充。
```java

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

public class NewFixedThreadPoolDemo {


    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(2);
        for (int i = 0; i < 4; i++) {
            pool.execute(new NewFixedThreadPoolRunnable());
            pool.submit(new NewFixedThreadPoolRunnable());
        }
        pool.shutdown();
    }

    static class NewFixedThreadPoolRunnable implements Runnable {

        static AtomicInteger taskNo = new AtomicInteger(1);

        private String taskName;

        public NewFixedThreadPoolRunnable() {
            taskName = "task-" + taskNo;
            taskNo.incrementAndGet();
        }

        @Override
        public void run() {
            System.out.println("task:" + taskName + " start...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("task:" + taskName + " end...");
        }
    }
}
```
特点：
- 如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量
- 线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
- 在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）

适用场景：
- 需要任务长期执行的场景
- CPU密集型任务

缺点：
- 内部使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无限增大，使服务器资源迅速耗尽

### newCachedThreadPool
newCachedThreadPool创建“可缓存线程池” newCachedThreadPool：创建一个可缓存的线程池。会根据任务自动新增或回收线程。
```java

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

public class NewCachedThreadPoolDemo {

    public static void main(String[] args) {
        ExecutorService pool = Executors.newCachedThreadPool();
        for (int i = 0; i < 4; i++) {
            pool.execute(new NewCachedThreadPoolRunnable());
            pool.submit(new NewCachedThreadPoolRunnable());
        }
        pool.shutdown();
    }

    static class NewCachedThreadPoolRunnable implements Runnable {

        static AtomicInteger taskNo = new AtomicInteger(1);

        private String taskName;

        public NewCachedThreadPoolRunnable() {
            taskName = "task-" + taskNo;
            taskNo.incrementAndGet();
        }

        @Override
        public void run() {
            System.out.println("task:" + taskName + " start...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("task:" + taskName + " end...");
        }
    }
}
```
特点：
- 在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务
- 线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小
- 如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程

适用场景：
- 需要快速处理突发性强、耗时较短的任务场景，如Netty的NIO处理场景、REST API接口的瞬时削峰场景

缺点：
- 线程池没有最大线程数量限制，如果大量的异步任务执行目标实例同时提交，可能会因创建线程过多而导致资源耗尽

### newScheduledThreadPool
newScheduledThreadPool创建“可调度线程池”。支持定时以及周期性执行任务的需求。
```java

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class NewScheduledThreadPoolDemo {

    public static void main(String[] args) {
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);
        for (int i = 0; i < 4; i++) {
            pool.scheduleAtFixedRate(new NewScheduledThreadPoolRunnable(), 0, 500, TimeUnit.MILLISECONDS);

        }
        pool.shutdown();
    }

    static class NewScheduledThreadPoolRunnable implements Runnable {

        static AtomicInteger taskNo = new AtomicInteger(1);

        private String taskName;

        public NewScheduledThreadPoolRunnable() {
            taskName = "task-" + taskNo;
            taskNo.incrementAndGet();
        }

        @Override
        public void run() {
            System.out.println("task:" + taskName + " start...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("task:" + taskName + " end...");
        }
    }
}
```
Executors创建线程池的4种方法十分方便，但是构造器创建普通线程池、可调度线程池比较复杂，这些构造器会涉及大量的复杂参数，已经较少使用。

### newWorkStealingPool
JDK8新增，根据所需的并行层次来动态创建和关闭线程，通过使用多个队列减少竞争，底层使用ForkJoinPool来实现。优势在于可以充分利用多CPU，把一个任务拆分成多个“小任务”，放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。

## Executors创建线程池存在的问题
- 创建固定数量线程池的问题

```java
 public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```
阻塞队列无界，队列很大，很有可能导致JVM出现OOM（Out Of Memory）异常，即内存资源耗尽

- 创建单线程线程池的问题
```java
 public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```
问题和固定数量线程池一样，阻塞队列无界
- 创建缓存线程池的问题

```java
 public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }

```
问题存在于其最大线程数量不设限上。由于其maximumPoolSize的值为Integer.MAX_VALUE（非常大），可以认为可以无限创建线程，如果任务提交较多，就会造成大量的线程被启动，很有可能造成OOM异常，甚至导致CPU线程资源耗尽

- 创建可调度线程存在的问题
```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
 
 public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }

```
主要问题在于线程数不设上限

总结：
- newFixedThreadPool和newSingleThreadExecutor： 阻塞队列无界，会堆积大量任务导致OOM(内存耗尽)
- newCachedThreadPool和newScheduledThreadPool： 线程数量无上界，会导致创建大量的线程，从而导致OOM
- 建议直接使用线程池ThreadPoolExecutor的构造器






