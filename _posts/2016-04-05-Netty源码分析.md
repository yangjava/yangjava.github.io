---
layout: post
categories: Netty
description: none
keywords: Netty
---
# Netty源码分析


## ByteBuf和相关辅助类
当我们进行数据传输的时候，往往需要使用到缓冲区，常用的缓冲区就是JDK NIO类库提供的java.nio.Buffer。

定义：缓冲区Buffer在java nio中负责数据的存储，缓冲区Buffer本质就是数组，用于存储不同类型数据的数组，nio提供了一整套读写API。

Buffer更像一个容器，用于盛装数据，可以从数据源读取数据，放在Buffer里，也可以从Buffer中取出数据来用。缓冲，用于批量读写数据

Buffer是一个抽象类，基本数据类型都有实现类：XxxBuffer，比如ByteBuffer、CharBuffer、IntBuffer、DoubleBuffer等，最常用的是ByteBuffer、CharBuffer。

Java NIO中代表缓冲区的Buffer类是一个抽象类，对应于Java的主要数据类型，在NIO中有8种缓存区，分别如下：ByteBuffer，CharBuffer，DoubleBuffer，FloatBuffer，IntBuffer，LongBuffer，ShortBuffer，MappedByteBuffer；前7种 Buffer类型，覆盖了能在 IO中传输的所有的 Java基本数据类型，第8种类型MappedByteBuffer是专门用于内存映射的一种 ByteBuffer类型。
7种基础类型（Boolean除外）都有自己的缓冲区实现。对于NIO编程而言，我们主要使用的是ByteBuffer。从功能角度而言，ByteBuffer完全可以满足NIO编程的需要，但是由于NIO编程的复杂性，ByteBuffer也有其局限性，它的主要缺点如下。
- ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；
- ByteBuffer只有一个标识位置的指针position，读写的时候需要手工调用flip（）和rewind（）等，使用者必须小心谨慎地处理这些API，否则很容易导致程序处理失败；
- ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。

为了弥补这些不足，Netty提供了自己的ByteBuffer实现——ByteBuf，下面我们一起学习ByteBuf的原理和主要功能。

## Buffer类实战
NIO的Buffer的内部是一个内存块（数组），此类用来与普通的内存块（Java数组）不同的是：Buffer对象提供了一组比较有效的方法，用来进行写入和读取的交替访问；
注：Buffer类是一个非线程安全类；

Buffer中的4个概念：
- capacity     容量。表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。
- limit        界限。limit是一个下标（索引），limit及以后的数据既不能读，也不能写。第一个不应该读取的数据的索引，即位于 limit 后的数据不可读。缓冲区的限制不能为负，并且不能大于其容量。
- position     记录指针。记录当前读写到的位置。下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制
- mark         标记。读写的时候，可在某处做一个标记，调用reset()方法可将记录指针重置到此mark处。标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.
调用mark( )来设定mark=postion。调用reset( )设定position= mark。标记在设定前是未定义的(undefined)。

标记 、 位置 、 限制 、 容量遵守以下不变式： 0 <= mark <= position <= limit <= capacity
- 新建的buffer(容量为10)
位置被设为 0，mark 为空，而且容量和上界被设为 10，刚好经过缓冲区能够容纳的最后一个字节。 标记最初未定义。容量是固定的，但另外的三个属性可以在使用缓冲区时改变。

### 缓冲区的基本属性：
Buffer有分读模式和写模式，其实质是由limit值和position值决定的。这种模式没有特定的死规定。

### 缓冲区的数据操作
Buffer 所有子类提供了两个用于数据操作的方法：get() 与 put() 方法
```
获取 Buffer 中的数据
get() ：读取单个字节
get(byte[] dst)：批量读取多个字节到 dst 中
get(int index)：读取指定索引位置的字节(不会移动 position)
放入数据到 Buffer 中
put(byte b)：将给定单个字节写入缓冲区的当前位置
put(byte[] src)：将 src 中的字节写入缓冲区的当前位置
put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)
```

#### 创建Buffer对象
如果需要获取一个Buffer实例对象，并不是使用子类的构造器来创建一个实例对象，而是调用子类的allocate方法；
```
static  XxxBuffer  allocate(int  capacity)      //静态方法，返回该类对应的Buffer对象
```
实例如下
```
@Test
public void testAllocate() {
    IntBuffer intBuffer = null;
    intBuffer = IntBuffer.allocate(20);
    logger.info("------------after allocate------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());
}
```
例子中，IntBuffer是具体的Buffer子类，通过调用IntBuffer.allocate(20)，创建了一个Intbuffer实例对象，并且分配了 20 * 4个字节的内存空间；

一个缓冲区在新建后，处于写入的模式，position属性的值为 0，缓冲区的capacity容量值也是初始化时 allocate方法的参数值，而limit最大可写上限值也为的allocate方法的初始化参数值；

#### Buffer#put 写入缓冲区 
在调用allocate方法分配内存、返回了实例对象后，缓冲区实例对象处于写模式，可以写入对象，而如果要写入对象到 缓冲区，需要调用put方法；
```
 @Test
public void testPut() {
    IntBuffer intBuffer = IntBuffer.allocate(20);
    logger.info("------------after allocate------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    for (int i = 0; i < 5; i++) {
        intBuffer.put(i);
    }

    logger.info("------------after putTest------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());
}
```
从结果可以看到，写入了5个元素之后，缓冲区的position属性值变成了5（从下标0开始），所以指向了第6个可以进行写入的元素位置，而 limit最大可写上限、capacity最大容量两个属性的值，都没有发生变化；

往Buffer中放入数据，可使用put()往Buffer中放入数据，也可以从Channel中获取数据。
```
    //XxxBuffer有多个重载的put()方法，但只能放入该种类型的数据。
    charBuffer.put(char c);   //未指定index的，都是依次放置。一个萝卜一个坑，如果坑中有萝卜，就往后放。往坑中放萝卜时，记录指针会指向这个坑，放完后，记录指针会自动指向下一个坑。
    charBuffer.put(int index,char c);   //在指定的坑中放萝卜
    charBuffer.put(char[]  src);  //放在多个坑中，一个坑一个char
    charBuffer.put(String str);  //放在多个坑中，一坑一个char
    charBuffer.put(CharBuffer src);  //把其他CharBuffer中的所有萝卜都copy一份，放到这个CharBuffer中来，一坑一个char
```

#### Buffer#flip 翻转
flip翻转方法是Buffer类提供的一个模式转变的重要方法，它的作用就是将写入模式翻转成读取模式；
```
@Test
public void flipTest() {
    IntBuffer intBuffer = null;
    intBuffer = IntBuffer.allocate(20);
    logger.info("------------after allocate------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());


    for (int i = 0; i < 5; i++) {
        intBuffer.put(i);

    }

    logger.info("------------after putTest------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());


    intBuffer.flip();
    logger.info("------------after flipTest ------------------");

    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());
}
```
数据放置完毕后，调用flip()方法，此方法会将limit设置为position（记录指针）的值，并将position（记录指针）的值置为0。这就标明了可读写的数据区间。
说明：数据放置完毕后，position（记录指针）是指向最后一个萝卜后面的那个坑的。
```
charBuffer.flip();
```
现在，Buffer做好了输出数据的准备。

#### Buffer#get 从缓冲区读取
调用flip方法将缓冲区切换成读取模式之后，就可以开始从缓冲区中进行数据读取，通过调用get方法每次从position的位置读取一个数据，并且进行相应的缓冲区属性的调整；
```
@Test
public void getTest() {
    IntBuffer intBuffer = null;
    intBuffer = IntBuffer.allocate(20);
    logger.info("------------after allocate------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());


    for (int i = 0; i < 5; i++) {
        intBuffer.put(i);

    }

    logger.info("------------after putTest------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());


    intBuffer.flip();
    logger.info("------------after flipTest ------------------");

    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    for (int i = 0; i < 2; i++) {
        int j = intBuffer.get();
        logger.info("intBuffer[" + i + "]:" + j);
    }

    logger.info("------------after get 2 int ------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    for (int i = 0; i < 3; i++) {
        int j = intBuffer.get();
        logger.info("intBuffer[" + i + "]:" + j);
    }
    logger.info("------------after get 3 int ------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());
}
```
读取操作会改变可读位置position的属性值，而limit可读上限值并不会改变；在position值和limit的值相等时，表示所有数据读取完成，position指向了一个没有数据的元素位置，已经不能再读了，此时再读，会抛出BufferUnderflowException异常；
处于读取模式下，不能对缓冲区进行数据写入，需要调用Buffer#clear或Buffer#compact方法，即清空或压缩缓冲区，将缓冲区切换成写入模式，让缓冲区重新可写；

从Buffer中取出数据，并使用。
```
      charBuffer.get();   //取一个萝卜。从前往后取，只取一个。
      charBuffer.get(int index);   //取指定位置上的萝卜
      //这里的取是指取出副本，并不是真的把萝卜从坑里拿出来，萝卜还是在这个坑里，不会变。
```

### Buffer#rewind 倒带
已经读完的数据，如果需要再读一遍，可以调用rewind方法；
```
@Test
public void getTest() {
    IntBuffer intBuffer = null;
    intBuffer = IntBuffer.allocate(20);
    logger.info("------------after allocate------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());


    for (int i = 0; i < 5; i++) {
        intBuffer.put(i);

    }

    logger.info("------------after putTest------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());


    intBuffer.flip();
    logger.info("------------after flipTest ------------------");

    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    for (int i = 0; i < 2; i++) {
        int j = intBuffer.get();
        logger.info("intBuffer[" + i + "]:" + j);
    }

    logger.info("------------after get 2 int ------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    for (int i = 0; i < 3; i++) {
        int j = intBuffer.get();
        logger.info("intBuffer[" + i + "]:" + j);
    }
    logger.info("------------after get 3 int ------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    intBuffer.rewind();
    logger.info("------------after rewind ------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());
}
```
rewind方法，主要是调整了缓冲区的 position属性与 mark标记属性，调整规则如下：
position重置为 0，所以可以重读缓冲区中的所有数据； limit保持不变，数据量还是一样的，仍然表示能从缓冲区中读取的元素数量；
mark标记被清理，表示之前的临时位置不能再用了； 在调用rewind方法后，就可以再一次读取Buffer；

#### Buffer#mark和Buffer#reset
Buffer#mark方法和Buffer#reset方法是成套使用的，Buffer#mark方法将当前position的值保存起来，放在mark属性中，让mark属性记录这个临时位置，之后可以调用Buffer#reset方法将mark的值恢复到position中；
```
@Test
public void resetTest() {
    IntBuffer intBuffer = IntBuffer.allocate(20);
    logger.info("------------after allocate------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());


    for (int i = 0; i < 5; i++) {
        intBuffer.put(i);

    }

    logger.info("------------after putTest------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    intBuffer.flip();
    logger.info("------------after flipTest ------------------");

    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    for (int i = 0; i < 5; i++) {
        if (i == 2) {
            intBuffer.mark();
        }
        int j = intBuffer.get();
        logger.info("intBuffer[" + i + "]:" + j);

    }
    logger.info("------------after mark------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    intBuffer.reset();
    logger.info("------------after reset------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());
    for (int i = 2; i < 5; i++) {
        int j = intBuffer.get();
        logger.info("intBuffer[" + i + "]:" + j);
    }
}
```

#### Buffer#clear 清空缓冲区
当Buffer中的数据都用完了，不需要再保存时，就可以调用clear()清空这个Buffer，这样，每个坑都是空的了，又可以装入新的数据了。
```
charBuffer.clear();
```
在读取模式下，调用clear方法将缓冲区切换为写入模式；
```
@Test
public void clearTest() {
    IntBuffer intBuffer = IntBuffer.allocate(20);
    logger.info("------------after allocate------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());


    for (int i = 0; i < 5; i++) {
        intBuffer.put(i);

    }

    logger.info("------------after putTest------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    intBuffer.flip();
    logger.info("------------after flipTest ------------------");

    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    for (int i = 0; i < 5; i++) {
        if (i == 2) {
            intBuffer.mark();
        }
        int j = intBuffer.get();
        logger.info("intBuffer[" + i + "]:" + j);

    }
    logger.info("------------after mark------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());

    intBuffer.reset();
    logger.info("------------after reset------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());
    for (int i = 2; i < 5; i++) {
        int j = intBuffer.get();
        logger.info("intBuffer[" + i + "]:" + j);

    }

    intBuffer.clear();
    logger.info("------------after clear------------------");
    logger.info("position=" + intBuffer.position());
    logger.info("limit=" + intBuffer.limit());
    logger.info("capacity=" + intBuffer.capacity());
}
```
在缓冲区处于读取模式时，调用clear方法，缓冲区会被切换成写入模式，清空了position的值，其值被设置为0，并且limit值为最大容量（capacity）；

- hasRemaining()操作
该操作的作用是释放缓冲区时告诉您是否已经达到缓冲区的上界。
```
for (int i = 0; buffer.hasRemaining( ), i++) {
myByteArray [i] = buffer.get( ); 
}

int count = buffer.remaining( );
for (int i = 0; i < count, i++) {
	myByteArray [i] = buffer.get( ); 
}
```

- conpat()压缩操作
将从position位置开始往后的数据往前覆盖。position会移到末尾。他的作用是移除已经使用的数据

当使用compact之后，如果继续使用put的操作，会覆盖position之后的数据。

示例：
```
        //创建Buffer对象
        CharBuffer charBuffer=CharBuffer.allocate(10);

        //放入数据
        charBuffer.put("ABCD");

        //调整指针，准备好使用数据
        charBuffer.flip();

        //从Buffer中取出数据来使用
        System.out.println(charBuffer.get());  //A
        System.out.println(charBuffer.get(2));  //取第三个，C
        System.out.println(charBuffer.get());  //B

        //好啦，这批数据搞定了，不再用了，清空Buffer，准备好下次装入数据
        charBuffer.clear();

        //装入下一批数据
        charBuffer.put('A');

        //.........
```
观察上面的输出结果，调用get()获取值后，记录指针会自动指向下一个坑。调用get(int  index)获取值，记录指针并不会受到影响，还是在原来的位置。

Buffer类的其他常用方法：
- int  capacity()    //返回容量
- boolean   hasRemaining()    //判断是否还有元素可供处理（position、limit之间是否还有萝卜）
- int remaining()    //还有多少个元素未处理
- int  limit()     //返回limit的位置
- limit(int  newLimit)    //重新设置limit（以新Buffer的形式返回，但原Buffer的limit会改变）
- int position()   //返回当前记录指针的位置
- position(int  newPosition)    //重置position的位置
- mark()    //在当前position的位置做一个标记
- reset()   //转到标记处，即将position指向mark处
- rewind()   //将position重置为0，取消设置的mark，即从头开始。

通过 allocate() 创建的Buffer是普通Buffer。 ByteBuffer提供了 allocateDirect()  来创建直接Buffer，直接Buffer读取数据的效率很高，但创建成本很高，适合用于创建生存期较长的Buffer。一般情况用普通Buffer即可。

注意：只有ByteBuffer类能创建直接Buffer。

## 关于ByteBuffer在JVM内存与堆外外内存比较#
java.nio.ByteBuffer#allocate: 分配空间位于JVM中（也称JVM堆内存），分配空间需要从外界Java程序接收到外部传来的数据时，首先被系统内存获取，然后再由系统内存复制拷贝到JVM内存中供Java程序使用；

java.nio.ByteBuffer#allocateDirect：  分配的内存是系统内存（也称直接内存），无需复制； 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，某些情况下这部分内存也会被频繁地使用，而且也可能导致OutOfMemoryError异常出现；Java里用DirectByteBuffer可以分配一块直接内存(堆外内存)，元空间对应的内存也叫作直接内存，它们对应的都是机器的物理内存；

## Buffer源码分析
Buffer的子类会拥有一块内存，作为数据的读写缓冲区，但是读写缓冲区并没有定义在Buffer基类，而是定义在具体的子类中；

```
/*
* Buffer以上七大基本类型缓冲区类的基类，是个抽象类，定义了一些通用方法以及一些抽象方法。
* 具体方法都是final修饰的，不可被子类覆盖。
*/
public abstract class Buffer {
    // 在缓冲区中维护遍历和分割元素的拆分特征??
    static final int SPLITERATOR_CHARACTERISTICS =
        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;
 
    //标记当前的position 位置，用reset方法的话，可以把position设置为mark值位置。
	//如果mark=-1的话会reset失败。
    private int mark = -1;
    //游标，标记缓冲区下一个要读取或者写入的数组下标。
    private int position = 0;
    //表示缓冲区数组可以操作（读取、写入）的可用数据长度。
    private int limit;
    //缓冲区容量
    private int capacity;
 
	//以上四个属性符合 mark<=position<=limit<=capacity，不符合就会报错。
 
    // 只对直接缓冲区有用
    // 记录直接缓冲区的内存地址，用于提高JNI 的方法GetDirectBufferAddress的效率。
    //ByteBuffer才支持直接缓冲区，所以到后面关于ByteBuffer的会讲。
    long address;
 
    // 传入mark、position、limit、capacity值创建一个缓冲区的构造器
    //是个包内私有的构造器
    Buffer(int mark, int pos, int lim, int cap) { 
         //缓冲区容量小于0时抛出异常。
        if (cap < 0)
            throw new IllegalArgumentException("Negative capacity: " + cap);
 
		//根据传参设置缓冲区大小。
        this.capacity = cap;
        //设置limit
        limit(lim);
        //设置position
        position(pos);
        if (mark >= 0) {
            if (mark > pos)
                //mark大于pos并且mark大于等于0时会抛出异常
                throw new IllegalArgumentException("mark > position: ("
                                                   + mark + " > " + pos + ")");
            //设置mark
            this.mark = mark;
        }
    }
 
    /**
     * 返回缓冲区容量
     */
    public final int capacity() {
        return capacity;
    }
 
    /**
     * 返回缓冲区下一次要读取或者写入的数组下标
     */
    public final int position() {
        return position;
    }
 
    /**
     * 设置缓冲区的游标
     */
    public final Buffer position(int newPosition) {
        //要设置的position值不能大于limit值或者小于0，否则就抛出异常。
        if ((newPosition > limit) || (newPosition < 0))
            throw new IllegalArgumentException();
        //设置游标
        position = newPosition;
        //如果设置的新的游标值比mark值小，就重置mark值为-1.
        if (mark > position) mark = -1;
        return this;
    }
 
    /**
     *返回缓冲区的可用数据长度。
     */
    public final int limit() {
        return limit;
    }
 
    /**
     * 设置缓冲区的limit值，同时会保证position和mark值保证这几个值的关系符合规则。
     */
    public final Buffer limit(int newLimit) {
    	//对要设置的新limit进行检查，如果大于缓冲区容量或者小于0就抛出异常
        if ((newLimit > capacity) || (newLimit < 0))
            throw new IllegalArgumentException();
        //设置limit值
        limit = newLimit;
        //如果游标比可操作的最大数组下标还大的话，就把游标设置为limit
        if (position > limit) position = limit;
        //如果mark > limit，重置mark。
        if (mark > limit) mark = -1;
        return this;
    }
 
    /**
     * 标记当前position位置。
     */
    public final Buffer mark() {
        mark = position;
        return this;
    }
 
    /**
     * 把游标恢复到标记的位置
     */
    public final Buffer reset() {
        int m = mark;
        //标记小于0时抛出异常
        if (m < 0)
            throw new InvalidMarkException();
        //重置游标至标记处
        position = m;
        return this;
    }
 
    /**
     * 清空缓冲区，其实就设置游标为0，limit设置回capacity值，mark重置，数据还是存在的。
     */
    public final Buffer clear() {
        position = 0;
        limit = capacity;
        mark = -1;
        return this;
    }
 
    /**
     * 缓冲区创建时默认是写模式的，这个方法把缓冲区改为读模式。
     * 每次通过通道往存储设备中写数据都需要调用此方法把缓冲区设置为读模式。读取缓冲区的数据。
     * 最后详细讲解这个
     */
    public final Buffer flip() {
        //把limit设置为position
        limit = position;
        //将游标设置为0
        position = 0;
        //重置mark。
        mark = -1;
        return this;
    }
 
    /**
     * 重置游标，从新开始读、写数据。
     */
    public final Buffer rewind() {
        position = 0;
        mark = -1;
        return this;
    }
 
    /**
     * 读模式下，返回剩余可读的数据长度，写模式下，返回剩余可写的缓冲区长度。
     */
    public final int remaining() {
        return limit - position;
    }
 
    /**
     * 返回是否还有数据可读或者可写。
     */
    public final boolean hasRemaining() {
        return position < limit;
    }
 
    /**
     * 返回缓冲区是否只读，抽象方法，具体看实现类。
     */
    public abstract boolean isReadOnly();
   
    /**
     * 是否直接缓冲区，true为直接缓冲区
     */
    public abstract boolean isDirect();
 
 
    //分割线，上面是公共方法API，下面是包私有方法，我们不能调用的//
 
    /**
     * 读模式下游标往右移一位，也就是跳过一个数据。
     * 返回移动前的游标值。
     */
    final int nextGetIndex() {                          // package-private
    	//因为游标加一 所以要确保游标加一前要小于等于limit
        if (position >= limit)
        	//当前游标>=limit抛出异常
            throw new BufferUnderflowException();
        return position++;
    }
 
	/**
	* 读模式下游标往右移动n位。
	* 返回移动前的游标
	*/
    final int nextGetIndex(int nb) {                    // package-private
        if (limit - position < nb)
        	//判断加n后的游标是否大于limit，大于就抛出异常
            throw new BufferUnderflowException();
        int p = position;
        position += nb;
        //返回移动前的游标。
        return p;
    }
 
    /**
     * 写模式下游标往右移动1位。
	 * 返回移动前的游标
	 * 逻辑与上面的一样。
     */
    final int nextPutIndex() {                          // package-private
        if (position >= limit)
            throw new BufferOverflowException();
        return position++;
    }
 
     /**
     * 写模式下游标往右移动n位。
	 * 返回移动前的游标
	 * 逻辑与上面的一样。
     *
    final int nextPutIndex(int nb) {                    // package-private
        if (limit - position < nb)
            throw new BufferOverflowException();
        int p = position;
        position += nb;
        return p;
    }
    
    final int markValue() {                             // package-private
    	//返回标记的值
        return mark;
    }
    //把缓冲区置为不可用
    final void truncate() {                             // package-private
    	
    	//重置mark为-1
        mark = -1;
        //啥都置零
        position = 0;
        limit = 0;
        capacity = 0;
    }
    final void discardMark() {                          // package-private
        //重置游标-1
        mark = -1;
    } 
}
```
为了记录读写的状态和位置，Buffer类额外提供了一些重要的属性，如下：

### capacity
Buffer类的capacity属性，表示缓冲区中的最大数据容量；一旦写入的对象数量超过了capacity容量，缓冲区就满了，不能再写入，而且Buffer类的capacity属性一旦初始化，就不能更改，因为Buffer类的对象在初始化时，它会按照capacity分配内部数组的内存，在数组分配好内存之后，它的大小则不能更改，比如capacity为1024的IntBuffer，代表其一次可以存储1024个int类型的值；

注：capacity容量并不是指Buffer内部的内存块byte[]数组的字节数量，而是指能写入的数据对象最大限制量；如在ByteBuffer中内部的内存块存储在ByteBuffer#hb成员属性上，该数组的长度是可以扩容和压缩的；

### position
Buffer类的position属性，表示当前的位置，即被写入或者读取的元素索引；position属性的值与缓冲区的读写模式有关，在不同的模式下，position属性值的含义是不同的，在缓存区进行读写的模式改变时，position值会进行相应的调整；

#### 写模式下的position值变化规则
在写模式下，position值变化规则如下：
- 在刚进入到写入模式时position值为0，表示当前的写入位置为从头开始；
- 每当一个数据写到缓冲区后，position会向后移动到下一个可写的位置；
- 初始的position值为0，最大可写值为limit - 1，当position值达到limit时，缓冲区就已经无空间可写了；

#### 读模式下的position值变化规则
在读模式下，position的值变化规则如下：
- 当缓冲区刚开始进入到读取模式时，position会被重置为0；
- 当从缓冲区读取时，从position位置开始读；读取数据后，position向后移动到下一个可读的位置；
- 在读模式下，limit表示可以读上限；position的最大值，为最大可读上限limit，当position达到limit时，表明缓冲区已经无数据可读；

### Buffer的读写模式切换
当新建了一个缓冲区实例时，缓冲区处于写入模式，这时是可以写数据的；在数据写入完成后，如果要从缓冲区读取数据，这就要进行模式的切换，可以使用（即调用） flip翻转方法，将缓冲区变成读取模式；

从写入模式到读取模式的flip方法翻转过程中， position和limit属性值会进行调整，规则如下：
- limit属性被设置成写入模式时的position值，表示可以读取的最大数据位置；
- position由原来的写入位置，变成新的可读位置，即0的位置，表示可以从头开始读；

### limit
Buffer类的limit属性，表示还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读取缓冲区时)，limit属性值的含义与缓冲区的读写模式有关；
- 在写入模式下，limit属性值的含义为可以写入的数据最大上限；在刚进入到写入模式时， limit的值会被设置成缓冲区的capacity容量值，表示可以一直将缓冲区的容量写满；
- 在读取模式下，limit属性值的含义为最多能从缓冲区读取多少数据；

#### limit值在读写模式下的取值
当新创建的缓冲区时，Buffer处于写入模式，其position值为0，limit值为最大容量capacity；
往缓冲区写入数据，每写一个数据，position向后偏移一个位置，即position值加1；
当调用flip方法时，将缓冲区切换到读模式，将写入模式下的position的值设置成读模式下的limit的值，即写入模式下的position的值为读模式下的limit的值；

### mark
标记着当前position可读或可写的一个备份值，可供后续恢复时使用；

在缓冲区操作（读取或写）的过程中，可以将当前的position的值，临时存入mark属性中；在需要恢复的时候，可以再从mark中取出之前的值，恢复到positioin属性中，后续可以重新从position为重开始处理（读取或写）；

## ByteBuf的工作原理
首先，ByteBuf依然是个Byte数组的缓冲区，它的基本功能应该与JDK的ByteBuffer一致，提供以下几类基本功能。
- 7种Java基础类型、byte数组、ByteBuffer（ByteBuf）等的读写；
- 缓冲区自身的copy和slice等；
- 设置网络字节序；
- 构造缓冲区实例；
- 操作位置指针等方法。
由于JDK的ByteBuffer已经提供了这些基础能力的实现，因此，Netty ByteBuf的实现可以有两种策略。
- 参考JDK ByteBuffer的实现，增加额外的功能，解决原ByteBuffer的缺点；
- 聚合JDK ByteBuffer，通过Facade模式对其进行包装，可以减少自身的代码量，降低实现成本。
JDK ByteBuffer由于只有一个位置指针用于处理读写操作，因此每次读写的时候都需要额外调用flip（）和clear（）等方法，否则功能将出错

ByteBuf通过两个位置指针来协助缓冲区的读写操作，读操作使用readerIndex，写操作使用writerIndex。

readerIndex和writerIndex的取值一开始都是0，随着数据的写入writerIndex会增加，读取数据会使readerIndex增加，但是它不会超过writerIndex。在读取之后，0～readerIndex就被视为discard的，调用discardReadBytes方法，可以释放这部分空间，它的作用类似ByteBuffer的compact方法。ReaderIndex和writerIndex之间的数据是可读取的，等价于ByteBuffer position和limit之间的数据。WriterIndex和capacity之间的空间是可写的，等价于ByteBuffer limit和capacity之间的可用空间。

由于写操作不修改readerIndex指针，读操作不修改writerIndex指针，因此读写之间不再需要调整位置指针，这极大地简化了缓冲区的读写操作，避免了由于遗漏或者不熟悉flip（）操作导致的功能异常。

### ByteBuf是如何实现动态扩展的
通常情况下，当我们对ByteBuffer进行put操作的时候，如果缓冲区剩余可写空间不够，就会发生BufferOverflowException异常。为了避免发生这个问题，通常在进行put操作的时候会对剩余可用空间进行校验。如果剩余空间不足，需要重新创建一个新的ByteBuffer，并将之前的ByteBuffer复制到新创建的ByteBuffer中，最后释放老的ByteBuffer。

为了解决这个问题，ByteBuf对write操作进行了封装，由ByteBuf的write操作负责进行剩余可用空间的校验。如果可用缓冲区不足，ByteBuf会自动进行动态扩展。对于使用者而言，不需要关心底层的校验和扩展细节，只要不超过设置的最大缓冲区容量即可。当可用空间不足时，ByteBuf会帮助我们实现自动扩展，这极大地降低了ByteBuf的学习和使用成本，提升了开发效率。
```
@Override
public ByteBuf writeBytes(byte[] src) {
    writeBytes(src, 0, src.length);
    return this;
}

@Override
public ByteBuf writeBytes(byte[] src, int srcIndex, int length) {
    ensureAccessible();
    ensureWritable(length);
    setBytes(writerIndex, src, srcIndex, length);
    writerIndex += length;
    return this;
}

@Override
public ByteBuf ensureWritable(int minWritableBytes) {
    if (minWritableBytes < 0) {
        throw new IllegalArgumentException(String.format(
                "minWritableBytes: %d (expected: >= 0)", minWritableBytes));
    }

    if (minWritableBytes <= writableBytes()) {
        return this;
    }

    if (minWritableBytes > maxCapacity - writerIndex) {
        throw new IndexOutOfBoundsException(String.format(
                "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s",
                writerIndex, minWritableBytes, maxCapacity, this));
    }

    // 默认64     当前大小 <<= 1 翻倍
    int newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);

    // Adjust to the new capacity.
    capacity(newCapacity);
    return this;
}
```
通过源码分析，我们发现当进行write操作时，会对需要write的字节进行校验。如果可写的字节数小于需要写入的字节数，并且需要写入的字节数小于可写的最大字节数，就对缓冲区进行动态扩展。无论缓冲区是否进行了动态扩展，从功能角度看使用者并不感知，这样就简化了上层的应用。

由于NIO的Channel读写的参数都是ByteBuffer，因此，Netty的ByteBuf接口必须提供API，以方便地将ByteBuf转换成ByteBuffer，或者将ByteBuffer包装成ByteBuf。考虑到性能，应该尽量避免缓冲区的复制，内部实现的时候可以考虑聚合一个ByteBuffer的私有指针用来代表ByteBuffer。

扩容分析
- 调用writeBytes方法后，ByteBuf会修改writerIndex的指针大小，然后判断最小写入字节是否大于0，如果都没内容这不是在玩它么(*^▽^*)
- 接下来是最小写入字节小于或者等于剩余容量，那就返回当前的ByteBuf，也就不会扩容了，因为能装得下
- 接下来继续判断最小写入字节是否大于当前ByteBuf最大容量 - 已使用容量，如果最大容量都装不下说明这已经没法继续玩了，只能装这么多，扩容不了
- 最后就是扩容处理了，Netty的做法是默认64字节，小于阀值取64，大于取64 <<= 1，成倍递增

相比其它的JAVA对象，缓冲区的分配(包括动态扩容)与释放是一个耗时操作，因此需要尽可能的复用
```
@Override
public ByteBuf discardReadBytes() {
    ensureAccessible();
    if (readerIndex == 0) {
        return this;
    }

    if (readerIndex != writerIndex) {
        setBytes(0, this, readerIndex, writerIndex - readerIndex);
        writerIndex -= readerIndex;
        adjustMarkers(readerIndex);
        readerIndex = 0;
    } else {
        adjustMarkers(readerIndex);
        writerIndex = readerIndex = 0;
    }
    return this;
}
public final Buffer clear() {
    position = 0;
    limit = capacity;
    mark = -1;
    return this;
}
```

## ByteBuf的功能介绍

### readerIndex和writerIndex
Netty提供了两个指针变量用于支持顺序读取和写入操作：readerIndex用于标识读取索引，writerIndex用于标识写入索引。两个位置指针将ByteBuf缓冲区分割成三个区域。

调用ByteBuf的read操作时，从readerIndex处开始读取。readerIndex到writerIndex之间的空间为可读的字节缓冲区；从writerIndex到capacity之间为可写的字节缓冲区；0到readerIndex之间是已经读取过的缓冲区，可以调用discardReadBytes操作来重用这部分空间，以节约内存，防止ByteBuf的动态扩张。这在私有协议栈消息解码的时候非常有用，因为TCP底层可能粘包，几百个整包消息被TCP粘包后作为一个整包发送。这样，通过discardReadBytes操作可以重用之前已经解码过的缓冲区，从而防止接收缓冲区因为容量不足导致的扩张。但是，discardReadBytes操作是把双刃剑，不能滥用。

### Discardable bytes
相比于其他的Java对象，缓冲区的分配和释放是个耗时的操作，因此，我们需要尽量重用它们。由于缓冲区的动态扩张需要进行字节数组的复制，它是个耗时的操作，因此，为了最大程度地提升性能，往往需要尽最大努力提升缓冲区的重用率。

假如缓冲区包含了N个整包消息，每个消息的长度为L，消息的可写字节数为R。当读取M个整包消息后，如果不对ByteBuf做压缩或者discardReadBytes操作，则可写的缓冲区长度依然为R。如果调用discardReadBytes操作，则可写字节数会变为R=（R+M×L），之前已经读取的M个整包的空间会被重用。假如此时ByteBuf需要写入R+1个字节，则不需要动态扩张ByteBuf。

需要指出的是，调用discardReadBytes会发生字节数组的内存复制，所以，频繁调用将会导致性能下降，因此在调用它之前要确认你确实需要这样做，例如牺牲性能来换取更多的可用内存。

### Readable bytes和Writable bytes
可读空间段是数据实际存储的区域，以read或者skip开头的任何操作都将会从readerIndex开始读取或者跳过指定的数据，操作完成之后readerIndex增加了读取或者跳过的字节数长度。如果读取的字节数长度大于实际可读的字节数，则抛出IndexOutOfBoundsException。当新分配、包装或者复制一个新的ByteBuf对象时，它的readerIndex为0。

可写空间段是尚未被使用可以填充的空闲空间，任何以write开头的操作都会从writerIndex开始向空闲空间写入字节，操作完成之后writerIndex增加了写入的字节数长度。如果写入的字节数大于可写的字节数，则会抛出IndexOutOfBoundsException异常。新分配一个ByteBuf对象时，它的readerIndex为0。通过包装或者复制的方式创建一个新的ByteBuf对象时，它的writerIndex是ByteBuf的容量。

### Clear操作
正如JDK ByteBuffer的clear操作，它并不会清空缓冲区内容本身，例如填充为NUL（0x00）。它主要用来操作位置指针，例如position、limit和mark。对于ByteBuf，它也是用来操作readerIndex和writerIndex，将它们还原为初始分配值。

### Mark和Rest
当对缓冲区进行读操作时，由于某种原因，可能需要对之前的操作进行回滚。读操作并不会改变缓冲区的内容，回滚操作主要就是重新设置索引信息。

对于JDK的ByteBuffer，调用mark操作会将当前的位置指针备份到mark变量中，当调用rest操作之后，重新将指针的当前位置恢复为备份在mark中的值

### 查找操作
很多时候，需要从 ByteBuf 中查找某个字符，例如通过”\r\n”作为文本字符串的换行符，利用”NUL（0x00）”作为分隔符。

ByteBuf提供了多种查找方法用于满足不同的应用场景，详细分类如下。
- indexOf（int fromIndex，int toIndex，byte value）：从当前ByteBuf中定位出首次出现value的位置。起始索引为fromIndex，终点是toIndex。如果没有查找到则返回-1，否则返回第一条满足搜索条件的位置索引。
- bytesBefore（byte value）：从当前ByteBuf中定位出首次出现value的位置。起始索引为readerIndex，终点是writerIndex。如果没有查找到则返回-1，否则返回第一条满足搜索条件的位置索引。该方法不会修改readerIndex和writerIndex。
- bytesBefore（int length，byte value）：从当前ByteBuf中定位出首次出现value的位置。起始索引为readerIndex，终点是readerIndex+length。如果没有查找到则返回-1，否则返回第一条满足搜索条件的位置索引。如果length大于当前字节缓冲区的可读字节数，则抛出IndexOutOfBoundsException异常。
- bytesBefore（int index，int length，byte value）：从当前ByteBuf中定位出首次出现value的位置。起始索引为index，终点是index+length。如果没有查找到则返回-1，否则返回第一条满足搜索条件的位置索引。如果index+length大于当前字节缓冲区的容量，则抛出IndexOutOfBoundsException异常。
- forEachByte（ByteBufProcessor processor）：遍历当前ByteBuf的可读字节数组，与ByteBufProcessor设置的查找条件进行对比。如果满足条件，则返回位置索引，否则返回-1。
- forEachByte（int index，int length，ByteBufProcessor processor）：以index为起始位置，index+length为终止位置进行遍历，与ByteBufProcessor设置的查找条件进行对比。如果满足条件，则返回位置索引，否则返回-1。
- forEachByteDesc（ByteBufProcessor processor）：遍历当前ByteBuf的可读字节数组，与ByteBufProcessor设置的查找条件进行对比。如果满足条件，则返回位置索引，否则返回-1。注意对字节数组进行迭代的时候采用逆序的方式，也就是从writerIndex-1开始迭代，直到readerIndex。
- forEachByteDesc（int index，int length，ByteBufProcessor processor）：以index为起始位置，index+length为终止位置进行遍历，与ByteBufProcessor设置的查找条件进行对比。如果满足条件，则返回位置索引，否则返回-1。采用逆序查找的方式，从index+length-1开始，直到index。

### Derived buffers
类似于数据库的视图，ByteBuf提供了多个接口用于创建某个ByteBuf的视图或者复制ByteBuf，具体方法如下。
- duplicate：返回当前ByteBuf的复制对象，复制后返回的ByteBuf与操作的ByteBuf共享缓冲区内容，但是维护自己独立的读写索引。当修改复制后的ByteBuf内容后，之前原ByteBuf的内容也随之改变，双方持有的是同一个内容指针引用。
- copy：复制一个新的ByteBuf对象，它的内容和索引都是独立的，复制操作本身并不修改原ByteBuf的读写索引。
- copy（int index，int length）：从指定的索引开始复制，复制的字节长度为length，复制后的ByteBuf内容和读写索引都与之前的独立。
- slice：返回当前ByteBuf的可读子缓冲区，起始位置从readerIndex到writerIndex，返回后的ByteBuf与原ByteBuf共享内容，但是读写索引独立维护。该操作并不修改原ByteBuf的readerIndex和writerIndex。
- slice（int index，int length）：返回当前ByteBuf的可读子缓冲区，起始位置从index到index+length，返回后的ByteBuf与原ByteBuf共享内容，但是读写索引独立维护。该操作并不修改原ByteBuf的readerIndex和writerIndex。

### 转换成标准的ByteBuffer
我们知道，当通过NIO的SocketChannel进行网络读写时，操作的对象是JDK标准的java.nio.ByteBuffer，由于Netty统一使用ByteBuf替代JDK原生的java.nio.ByteBuffer，所以必须从接口层面支持两者的相互转换，下面就一起看下如何将ByteBuf转换成java.nio.ByteBuffer。

将ByteBuf转换成java.nio.ByteBuffer的方法有两个，详细说明如下。
- ByteBuffer nioBuffer（）：将当前ByteBuf可读的缓冲区转换成ByteBuffer，两者共享同一个缓冲区内容引用，对ByteBuffer的读写操作并不会修改原ByteBuf的读写索引。需要指出的是，返回后的ByteBuffer无法感知原ByteBuf的动态扩展操作。
- ByteBuffer nioBuffer（int index，int length）：将当前ByteBuf从index开始长度为length的缓冲区转换成ByteBuffer，两者共享同一个缓冲区内容引用，对ByteBuffer的读写操作并不会修改原ByteBuf的读写索引。需要指出的是，返回后的ByteBuffer无法感知原ByteBuf的动态扩展操作。

### ByteBuf的主要类继承关系
从内存分配的角度看，ByteBuf可以分为两类。
- 堆内存（HeapByteBuf）字节缓冲区：特点是内存的分配和回收速度快，可以被JVM自动回收；缺点就是如果进行Socket的I/O读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核Channel中，性能会有一定程度的下降。
= 直接内存（DirectByteBuf）字节缓冲区：非堆内存，它在堆外进行内存分配，相比于堆内存，它的分配和回收速度会慢一些，但是将它写入或者从Socket Channel中读取时，由于少了一次内存复制，速度比堆内存快。

正是因为各有利弊，所以Netty提供了多种ByteBuf供开发者使用，经验表明，ByteBuf的最佳实践是在I/O通信线程的读写缓冲区使用DirectByteBuf，后端业务消息的编解码模块使用HeapByteBuf，这样组合可以达到性能最优。

从内存回收角度看，ByteBuf也分为两类：基于对象池的ByteBuf和普通ByteBuf。两者的主要区别就是基于对象池的ByteBuf可以重用ByteBuf对象，它自己维护了一个内存池，可以循环利用创建的ByteBuf，提升内存的使用效率，降低由于高负载导致的频繁GC。测试表明使用内存池后的Netty在高负载、大并发的冲击下内存和GC更加平稳。

尽管推荐使用基于内存池的ByteBuf，但是内存池的管理和维护更加复杂，使用起来也需要更加谨慎，因此，Netty提供了灵活的策略供使用者来做选择。

## ByteBuf相关的辅助类功能介绍
### ByteBufHolder
ByteBufHolder是ByteBuf的容器，在Netty中，它非常有用。例如HTTP协议的请求消息和应答消息都可以携带消息体，这个消息体在NIO ByteBuffer中就是个ByteBuffer对象，在Netty中就是ByteBuf对象。由于不同的协议消息体可以包含不同的协议字段和功能，因此，需要对ByteBuf进行包装和抽象，不同的子类可以有不同的实现。

### ByteBufAllocator
ByteBufAllocator是字节缓冲区分配器，按照Netty的缓冲区实现不同，共有两种不同的分配器：基于内存池的字节缓冲区分配器和普通的字节缓冲区分配器。

### CompositeByteBuf
CompositeByteBuf允许将多个ByteBuf的实例组装到一起，形成一个统一的视图，有点类似于数据库将多个表的字段组装到一起统一用视图展示。

CompositeByteBuf在一些场景下非常有用，例如某个协议POJO对象包含两部分：消息头和消息体，它们都是ByteBuf对象。当需要对消息进行编码的时候需要进行整合，如果使用JDK的默认能力，有以下两种方式。
- 将某个ByteBuffer复制到另一个ByteBuffer中，或者创建一个新的ByteBuffer，将两者复制到新建的ByteBuffer中；
- 通过List或数组等容器，将消息头和消息体放到容器中进行统一维护和处理。

### ByteBufUtil
ByteBufUtil是一个非常有用的工具类，它提供了一系列静态方法用于操作ByteBuf对象。
其中最有用的方法就是对字符串的编码和解码，具体如下。
- encodeString（ByteBufAllocator alloc，CharBuffer src，Charset charset）：对需要编码的字符串src按照指定的字符集charset进行编码，利用指定的ByteBufAllocator生成一个新的ByteBuf；
- decodeString（ByteBuffer src，Charset charset）：使用指定的ByteBuffer和charset进行对ByteBuffer进行解码，获取解码后的字符串。

还有一个非常有用的方法就是hexDump，它能够将参数ByteBuf的内容以十六进制字符串的方式打印出来，用于输出日志或者打印码流，方便问题定位，提升系统的可维护性。

## Channel
JDK的NIO类库的一个重要组成部分，就是java.nio.SocketChannel和java.nio.ServerSocketChannel，它们用于非阻塞的I/O操作。 类似于NIO的Channel，Netty提供了自己的Channel和其子类实现，用于异步I/O操作和其他相关的操作。

io.netty.channel.Channel是Netty网络操作抽象类，它聚合了一组功能，包括但不限于网路的读、写，客户端发起连接，主动关闭连接，链路关闭，获取通信双方的网络地址等。它也包含了Netty框架相关的一些功能，包括获取该Chanel的EventLoop，获取缓冲分配器ByteBufAllocator和pipeline等。

## Channel的工作原理
Channel是Netty抽象出来的网络I/O读写相关的接口，为什么不使用JDK NIO 原生的Channel而要另起炉灶呢，主要原因如下。
- JDK的SocketChannel和ServerSocketChannel没有统一的Channel接口供业务开发者使用，对于用户而言，没有统一的操作视图，使用起来并不方便。
- JDK的SocketChannel和ServerSocketChannel的主要职责就是网络I/O操作，由于它们是SPI类接口，由具体的虚拟机厂家来提供，所以通过继承SPI功能类来扩展其功能的难度很大；直接实现ServerSocketChannel和SocketChannel抽象类，其工作量和重新开发一个新的Channel功能类是差不多的。
- Netty的Channel需要能够跟Netty的整体架构融合在一起，例如I/O模型、基于ChannelPipeline的定制模型，以及基于元数据描述配置化的TCP参数等，这些JDK的SocketChannel和ServerSocketChannel都没有提供，需要重新封装。
- 自定义的Channel，功能实现更加灵活。

基于上述4个原因，Netty重新设计了Channel接口，并且给予了很多不同的实现。它的设计原理比较简单，但是功能却比较繁杂，主要的设计理念如下。
- 在Channel接口层，采用Facade模式进行统一封装，将网络I/O操作、网络I/O相关联的其他操作封装起来，统一对外提供。
- Channel接口的定义尽量大而全，为SocketChannel和ServerSocketChannel提供统一的视图，由不同子类实现不同的功能，公共功能在抽象父类中实现，最大程度地实现功能和接口的重用。
- 具体实现采用聚合而非包含的方式，将相关的功能类聚合在Channel中，由Channel统一负责分配和调度，功能实现更加灵活。

## Channel的功能介绍
Channel网络I/O相关的方法定义
- Channel read（）：从当前的Channel中读取数据到第一个inbound缓冲区中，如果数据被成功读取，触发ChannelHandler.channelRead（ChannelHandlerContext，Object）事件。读取操作API调用完成之后，紧接着会触发ChannelHandler.channelReadComplete（Channel HandlerContext）事件，这样业务的ChannelHandler可以决定是否需要继续读取数据。如果已经有读操作请求被挂起，则后续的读操作会被忽略。
- ChannelFuture write（Object msg）：请求将当前的msg通过ChannelPipeline写入到目标Channel中。注意，write操作只是将消息存入到消息发送环形数组中，并没有真正被发送，只有调用flush操作才会被写入到Channel中，发送给对方。
- ChannelFuture write（Object msg，ChannelPromise promise）：功能与write（Object msg）相同，但是携带了ChannelPromise参数负责设置写入操作的结果。
- ChannelFuture writeAndFlush（Object msg，ChannelPromise promise）：与方法（3）功能类似，不同之处在于它会将消息写入Channel中发送，等价于单独调用write和flush操作的组合。
- ChannelFuture writeAndFlush（Object msg）：功能等同于方法（4），但是没有携带writeAndFlush（Object msg）参数。
- Channel flush（）：将之前写入到发送环形数组中的消息全部写入到目标Chanel中，发送给通信对方。
- ChannelFuture close（ChannelPromise promise）：主动关闭当前连接，通过Channel Promise设置操作结果并进行结果通知，无论操作是否成功，都可以通过ChannelPromise获取操作结果。该操作会级联触发ChannelPipeline中所有ChannelHandler的ChannelHandler.close（ChannelHandlerContext，ChannelPromise）事件。
- ChannelFuture disconnect（ChannelPromise promise）：请求断开与远程通信对端的连接并使用ChannelPromise来获取操作结果的通知消息。该方法会级联触发Channel Handler.disconnect（ChannelHandlerContext，ChannelPromise）事件。
- ChannelFuture connect（SocketAddress remoteAddress）：客户端使用指定的服务端地址remoteAddress发起连接请求，如果连接因为应答超时而失败，ChannelFuture中的操作结果就是ConnectTimeoutException异常；如果连接被拒绝，操作结果为ConnectException。该方法会级联触发ChannelHandler.connect（ChannelHandlerContext，SocketAddress，SocketAddress，ChannelPromise）事件。
- ChannelFuture connect（SocketAddress remoteAddress，SocketAddress localAddress）：与方法（9）功能类似，唯一不同的就是先绑定指定的本地地址localAddress，然后再连接服务端。
- ChannelFuture connect（SocketAddress remoteAddress，ChannelPromise promise）：与方法（9）功能类似，唯一不同的是携带了ChannelPromise参数用于写入操作结果。
- connect（SocketAddress remoteAddress，SocketAddress localAddress，ChannelPromise promise）：与方法（11）功能类似，唯一不同的就是绑定了本地地址。
- ChannelFuture bind（SocketAddress localAddress）：绑定指定的本地Socket地址localAddress，该方法会级联触发ChannelHandler.bind（ChannelHandlerContext，SocketAddress，ChannelPromise）事件。
- ChannelFuture bind（SocketAddress localAddress，ChannelPromise promise）：与方法（13）功能类似，多携带了了一个ChannelPromise用于写入操作结果。
- ChannelConfig config（）：获取当前Channel的配置信息，例如CONNECT_TIMEOUT_MILLIS。
- boolean isOpen（）：判断当前Channel是否已经打开。
- boolean isRegistered（）：判断当前Channel是否已经注册到EventLoop上。
- boolean isActive（）：判断当前Channel是否已经处于激活状态。
- ChannelMetadata metadata（）：获取当前Channel的元数据描述信息，包括TCP参数配置等。
- SocketAddress localAddress（）：获取当前Channel的本地绑定地址。
- SocketAddress remoteAddress（）：获取当前Channel通信的远程Socket地址。

他常用的API功能说明
- 第一个比较重要的方法是eventLoop（）。Channel需要注册到EventLoop的多路复用器上，用于处理I/O事件，通过eventLoop（）方法可以获取到Channel注册的EventLoop。EventLoop本质上就是处理网络读写事件的Reactor线程。在Netty中，它不仅仅用来处理网络事件，也可以用来执行定时任务和用户自定义NioTask等任务。
- 第二个比较常用的方法是metadata（）方法。熟悉TCP协议的读者可能知道，当创建Socket的时候需要指定TCP参数，例如接收和发送的TCP缓冲区大小、TCP的超时时间、是否重用地址等。在Netty中，每个Channel对应一个物理连接，每个连接都有自己的TCP参数配置。所以，Channel会聚合一个ChannelMetadata用来对TCP参数提供元数据描述信息，通过metadata（）方法就可以获取当前Channel的TCP参数配置。
- 第三个方法是parent（）。对于服务端Channel而言，它的父Channel为空；对于客户端Channel，它的父Channel就是创建它的ServerSocketChannel。
- 第四个方法是用户获取Channel标识的id（），它返回ChannelId对象，ChannelId是Channel的唯一标识，它的可能生成策略如下。
（1）机器的MAC地址（EUI-48或者EUI-64）等可以代表全局唯一的信息；
（2）当前的进程ID；
（3）当前系统时间的毫秒——System.currentTimeMillis（）；
（4）当前系统时间纳秒数——System.nanoTime（）；
（5）32位的随机整型数；
（6）32位自增的序列数。

## Channel源码分析