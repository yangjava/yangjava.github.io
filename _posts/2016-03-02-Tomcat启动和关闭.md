---
layout: post
categories: [Tomcat]
description: none
keywords: Tomcat
---
# Tomcat启动和关闭
Tomcat的启动和关闭批处理脚本放在安装目录的bin子目录里，其中不仅包含了Windows系统的bat文件，同时还包含了UNIX/Linux的shell文件。

## startup.bat
这里就以开发时常用的Windows系统为例讲解Tomcat的启动命令。

从文件命名上看，就知道startup.bat是一个启动批处理脚本，它的主要功能就是找到另一个批处理脚本catalina.bat，并且执行catalina.bat。所以，将整个startup.bat的内容分成两部分讲解。

startup.bat脚本的第一部分如下所示。
```shell
if "%OS%" == "Windows_NT" setlocal
set "CURRENT_DIR=%cd%"
if not "%CATALINA_HOME%" == "" goto gotHome  
set "CATALINA_HOME=%CURRENT_DIR%"  
if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome  
cd ..  
set "CATALINA_HOME=%cd%"  
cd "%CURRENT_DIR%"   
:gotHome
if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome  
echo The CATALINA_HOME environment variable is not defined correctly
echo This environment variable is needed to run this program
goto end
:okHome
set "EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat"   
if exist "%EXECUTABLE%" goto okExec   
goto end
:okExec
```
一开始先用if "%OS%" == "Windows_NT" setlocal判断系统是否为Windows_NT，如果是，则使用setlocal命令。此命令表示之后所有对环境变量的改变只限于该批处理文件。要还原原先的设置，可以执行endlocal，如果未显式执行，则会在批处理的最后自动隐式执行endlocal命令。

如果环境变量设置了CATALINA_HOME，则直接使用环境变量设置的值作为Tomcat安装目录。假如未设置环境变量CATALINA_HOME，则以当前目录作为CATALINA_HOME。此时，如果%CATALINA_HOME%\bin\catalina.bat存在，则批处理或命令行当前目录作为CATALINA_HOME。假如%CATALINA_HOME%\bin\catalina.bat不存在，则把当前目录的上一级目录作为CATALINA_HOME，然后再判断%CATALINA_HOME%\bin\catalina.bat是否存在。如果存在，则上一级目录就是CATALINA_HOME；否则，提示找不到CATALINA_HOME环境变量并结束执行。

确定了CATALINA_HOME的值即已经确定了catalina.bat。接下来接收参数，在启动时经常会附带一些命令参数。startup.bat通过以下程序完成对参数的收集。
```
set CMD_LINE_ARGS=
:setArgs
if ""%1""=="""" goto doneSetArgs     
set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1   //将参数组成一行，接在后面
shift
goto setArgs
:doneSetArgs
call "%EXECUTABLE%" start %CMD_LINE_ARGS%
:end
```
首先判断第一个参数是否为空，为空则表示没有参数，直接跳到doneSetArgs位置。如果第一个参数不为空，则把第一个参数赋给CMD_LINE_ARGS。shift命令的作用是把参数前移一位，这时%1代表的就是原来的第二个参数，shift然后又跳到setArgs位置，此时判断的是第二个参数，如果不为空，则把参数追加到CMD_LINE_ARGS后面。以此类推，把参数一个个前移，直到%1为空，则表示全部参数都已经收集完。

call "%EXECUTABLE%" start %CMD_LINE_ARGS%，这条命令以刚刚收集的所有参数CMD_LINE_ARGS作为参数，调用并执行catalina.bat批处理脚本。

## shutdown.bat
以下关闭脚本shutdown.bat的内容与启动脚本startup.bat的内容基本一样，其执行顺序也是先找到另一个批处理脚本catalina.bat的路径，然后执行catalina.bat。不同的是，执行catalina.bat时传入的参数不同，如启动时传入的参数为start，而关闭时传入的参数为stop，相关脚本为call "%EXECUTABLE%" stop %CMD_LINE_ARGS%。

```
set CMD_LINE_ARGS=
:setArgs
if ""%1""=="""" goto doneSetArgs
set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1
shift
goto setArgs
:doneSetArgs
call "%EXECUTABLE%" stop %CMD_LINE_ARGS%
:end
```

## catalina.bat
catalina.bat批处理脚本才是Tomcat服务器启动和关闭的核心脚本，它的最终目的是组合出一个最终的执行命令，组合时会涉及多个变量和组合逻辑。

第一部分脚本如下所示，它主要目的是在按Ctrl+C组合键终止程序时自动确认。当执行catalina.bat run命令时开始启动Tomcat，然后如果按Ctrl+C组合键则会终止进程，而且命令窗口还会输出“终止批处理操作吗(Y/N)?”让用户确认，而这里做的就是帮你自动输入Y。
```
1 if not ""%1"" == ""run"" goto mainEntry
2 if "%TEMP%" == "" goto mainEntry
3 if exist "%TEMP%\%～nx0.run" goto mainEntry
4 echo Y>"%TEMP%\%～nx0.run"
5 if not exist "%TEMP%\%～nx0.run" goto mainEntry
6 echo Y>"%TEMP%\%～nx0.Y"
7 call "%～f0" %* <"%TEMP%\%～nx0.Y"
8 set RETVAL=%ERRORLEVEL%
9 del /Q "%TEMP%\%～nx0.Y" >NUL 2>&1
10 exit /B %RETVAL%
11 :mainEntry
12 del /Q "%TEMP%\%～nx0.run" >NUL 2>&1
```
- 第1行中，如果%1（即第一个参数）不等于run，则直接跳到mainEntry，使用两个双引号是为了防止参数中带有空格。
- 第2行中，如果TEMP环境变量为空，则直接跳到mainEntry。
- 第3行中，如果TEMP环境变量目录下存在catalina.bat.run文件，则直接跳到mainEntry。
- 第4行把字母Y输入catalina.bat.run文件中。
- 第5行中，如果不存在catalina.bat.run文件，则跳到mainEntry。
- 第6行将字母Y输入到catalina.bat.Y文件中。
- 第7行以catalina.bat.Y作为输入执行当前批处理脚本，%*表示所有的参数。
- 第8行把上面执行后的%ERRORLEVEL%变量赋值给RETVAL，如果执行过程出现问题则赋予它非零值。
- 第9行删除catalina.bat.Y文件，并且不输出执行结果，另外，把标准错误输出STDERR重定向到标准输出STDOUT。
- 第10行退出当前批处理脚本，并把RETVAL变量作为返回值。

第二部分脚本主要用于设置CATALINA_HOME、CATALINA_BASE两个变量。
```
set "CURRENT_DIR=%cd%"
if not "%CATALINA_HOME%" == "" goto gotHome
set "CATALINA_HOME=%CURRENT_DIR%"
if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome
cd ..
set "CATALINA_HOME=%cd%"
cd "%CURRENT_DIR%"
:gotHome
if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome
goto end
:okHome
if not "%CATALINA_BASE%" == "" goto gotBase
set "CATALINA_BASE=%CATALINA_HOME%"
:gotBase
```
首先设置CATALINA_HOME环境变量，该部分的逻辑和startup.bat的一样，但这里为什么还要进行一次CATALINA_HOME环境变量的设置呢？简单地说，是为了支持用户直接运行catalina.bat，而非通过startup.bat运行。接着设置CATALINA_BASE环境变量，这里直接把CATALINA_HOME的值赋给它。

第三部分脚本主要用于尝试寻找setenv.bat和setclasspath.bat并执行它们，然后再将Tomcat的启动包bootstrap.jar和日志包tomcat-juli.jar添加到CLASSPATH环境变量下。
```
set CLASSPATH= 
if not exist "%CATALINA_BASE%\bin\setenv.bat" goto checkSetenvHome
call "%CATALINA_BASE%\bin\setenv.bat"
goto setenvDone
:checkSetenvHome
if exist "%CATALINA_HOME%\bin\setenv.bat" call "%CATALINA_HOME%\bin\setenv.bat"
:setenvDone
if exist "%CATALINA_HOME%\bin\setclasspath.bat" goto okSetclasspath
goto end
:okSetclasspath
call "%CATALINA_HOME%\bin\setclasspath.bat" %1
if errorlevel 1 goto end
if "%CLASSPATH%" == "" goto emptyClasspath
set "CLASSPATH=%CLASSPATH%;"
:emptyClasspath
set "CLASSPATH=%CLASSPATH%%CATALINA_HOME%\bin\bootstrap.jar"
if not "%CATALINA_TMPDIR%" == "" goto gotTmpdir
set "CATALINA_TMPDIR=%CATALINA_BASE%\temp"
:gotTmpdir
if not exist "%CATALINA_BASE%\bin\tomcat-juli.jar" goto juliClasspathHome
set "CLASSPATH=%CLASSPATH%;%CATALINA_BASE%\bin\tomcat-juli.jar"
goto juliClasspathDone
:juliClasspathHome
set "CLASSPATH=%CLASSPATH%;%CATALINA_HOME%\bin\tomcat-juli.jar"
:juliClasspathDone
```
这里的逻辑比较清晰。首先，把CLASSPATH设为空，判断%CATALINA_BASE%\bin目录下是否存在setenv.bat，如果存在则调用此批处理文件，否则判断%CATALINA_HOME%\bin目录下是否存在setenv.bat，如存在则执行。然后，继续判断是否存在%CATALINA_HOME%\ bin\setclasspath.bat文件，如果不存在则直接跳到结尾，这表明setclasspath.bat是必要的批处理脚本。接着，执行setclasspath.bat脚本，%1表示参数。if errorlevel 1 goto end表示执行到此处时如果错误值大于等于1，则直接跳到结尾，如果没有错误，则继续往下，判断环境变量%CLASSPATH%是否为空，不为空则把CLASSPATH设置为%CLASSPATH%并加上分号。此后把%CATALINA_HOME%\bin\bootstrap.jar加入到classpath中，这个包是Tomcat的核心包。接着，设置临时目录temp，追加tomcat-juli.jar包到classpath中，逻辑是先从%CATALINA_BASE%\bin目录下找，如果找不到，再去%CATALINA_HOME%\bin目录下找。tomcat-juli.jar这个包主要包含了Tomcat系统日志处理类。

第四部分是对日志配置的设置。
```
if not "%LOGGING_CONFIG%" == "" goto noJuliConfig
set LOGGING_CONFIG=-Dnop
if not exist "%CATALINA_BASE%\conf\logging.properties" goto noJuliConfig
set LOGGING_CONFIG=-Djava.util.logging.config.file="%CATALINA_BASE%\conf\logging.properties"
:noJuliConfig
set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG%
if not "%LOGGING_MANAGER%" == "" goto noJuliManager
set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
:noJuliManager
set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER%
```
Tomcat中的日志实现使用jdk自带的日志工具。其中主要有两项属性可以配置，分别为java.util.logging.config.file和java.util.logging.manager。

为了设置LOGGING_CONFIG，首先，要判断环境变量是否存在LOGGING_CONFIG，若存在，即直接使用，否则把LOGGING_CONFIG设为-Dnop。接着，判断是否存在%CATALINA_BASE%\conf\logging.properties，如果存在，则又把LOGGING_CONFIG设为-Djava.util.logging. config. file="%CATALINA_BASE%\conf\logging.properties"。

为了设置LOGGING_MANAGER，要判断环境变量是否存在LOGGING_MANAGER，若存在，即直接使用，否则把LOGGING_MANAGER设为-Djava.util.logging.manager=org.apache. juli. ClassLoaderLogManager。

第五部分是执行命令前一些参数的初始化。
```
set _EXECJAVA=%_RUNJAVA%
set MAINCLASS=org.apache.catalina.startup.Bootstrap
set ACTION=start
set SECURITY_POLICY_FILE=
set DEBUG_OPTS=
set JPDA=
if not ""%1"" == ""jpda"" goto noJpda
set JPDA=jpda
if not "%JPDA_TRANSPORT%" == "" goto gotJpdaTransport
set JPDA_TRANSPORT=dt_socket
:gotJpdaTransport
if not "%JPDA_ADDRESS%" == "" goto gotJpdaAddress
set JPDA_ADDRESS=8000
:gotJpdaAddress
if not "%JPDA_SUSPEND%" == "" goto gotJpdaSuspend
set JPDA_SUSPEND=n
:gotJpdaSuspend
if not "%JPDA_OPTS%" == "" goto gotJpdaOpts
set JPDA_OPTS=-agentlib:jdwp=transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,suspend=%JPDA_SUSPEND%
:gotJpdaOpts
shift
:noJpda
```
把%_RUNJAVA%变量赋给_EXECJAVA，%_RUNJAVA%变量在setclasspath.bat脚本中已经被设置为%JRE_HOME%\bin\java，设置MAINCLASS为Tomcat的启动类org.apache. catalina.startup.Bootstrap，设置ACTION为start，其他变量先不初始化。如果第一个参数为jpda，则把JPDA变量设为值jpda，jpda即是Java平台调试体系结构，它可以提供很方便的远程调试。如果JPDA_TRANSPORT变量为空，则把它设置为dt_socket。如果JPDA_ADDRESS变量为空，则把它设置为8000。如果JPDA_SUSPEND变量为空，则把它设置为n。如果JPDA_OPTS变量为空，则把它设置为-agentlib:jdwp=transport=%JPDA_TRANSPORT%, address= %JPDA_ADDRESS%, server=y,suspend=%JPDA_SUSPEND%。最后用了一个shift，把参数前移一位。这段脚本主要初始化JPDA启动命令项，把JDWP代理加载到应用程序的JVM中。

第六部分命令主要根据不同的参数跳转到不同的位置执行不同的命令，其实也组装一些参数，为下一步真正执行命令做准备。
```
if ""%1"" == ""debug"" goto doDebug
if ""%1"" == ""run"" goto doRun
if ""%1"" == ""start"" goto doStart
if ""%1"" == ""stop"" goto doStop
if ""%1"" == ""configtest"" goto doConfigTest
if ""%1"" == ""version"" goto doVersion
:doDebug
shift
set _EXECJAVA=%_RUNJDB%
set DEBUG_OPTS=-sourcepath "%CATALINA_HOME%\..\..\java"
if not ""%1"" == ""-security"" goto execCmd
shift
set "SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy"
goto execCmd
:doRun
shift
if not ""%1"" == ""-security"" goto execCmd
shift
set "SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy"
goto execCmd
:doStart
shift
if not "%OS%" == "Windows_NT" goto noTitle
if "%TITLE%" == "" set TITLE=Tomcat
set _EXECJAVA=start "%TITLE%" %_RUNJAVA%
goto gotTitle
:noTitle
set _EXECJAVA=start %_RUNJAVA%
:gotTitle
if not ""%1"" == ""-security"" goto execCmd
shift
set "SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy"
goto execCmd
:doStop
shift
set ACTION=stop
set CATALINA_OPTS=
goto execCmd
:doConfigTest
shift
set ACTION=configtest
set CATALINA_OPTS=
goto execCmd
:doVersion
%_EXECJAVA% -classpath "%CATALINA_HOME%\lib\catalina.jar" org.apache.catalina.util.ServerInfo
goto end
```
前面已经用shift把参数前移一位，此时%1表示的参数已经是下一个参数，分别按照debug、run、start、stop、configtest、version跳到doDebug、doRun、doStart、doStop、doConfigTest、doVersion标签的位置执行不同的操作。下面对这6个操作进行分析。

doDebug的逻辑如下。首先把参数前移一位，并设置_EXECJAVA变量赋为%_RUNJDB%，_RUNJDB变量在setclasspath批处理脚本中已经设置为%JAVA_HOME%\bin\jdb，然后，设置DEBUG_OPTS变量。接着，判断参数是否等于-security，即是否启动安全管理器，如果不启动，则直接跳到execCmd位置，否则把参数前移一位，并且设置SECURITY_POLICY_FILE变量为%CATALINA_BASE%\conf\catalina.policy。最后，跳到execCmd位置。

doRun的逻辑如下。首先，把参数前移一位，并判断是否使用安全管理器，如果不使用安全管理器，则直接跳到execCmd位置，否则参数前移一位。然后，设置SECURITY_POLICY_FILE变量。最后，跳到execCmd位置。

doStart的逻辑如下。首先，把参数前移一位，根据系统是不是Windows_NT系统设置命令窗口的标题，把TITLE变量设置为Tomcat字符串。然后，设置_EXECJAVA变量，如果有标题，则添加到启动命令中。接着，判断是否使用安全管理器，把参数前移一位并设置SECURITY_POLICY_FILE。最后跳到execCmd位置。

doStop、doConfigTest的逻辑差不多，都是把参数前移一位，分别设置ACTION变量为stop、configtest，清空CATALINA_OPTS变量，跳到execCmd位置。

doVersion其实就是显示服务器的信息，直接用%JRE_HOME%\bin目录下的Java执行%CATALINA_HOME%\lib\catalina.jar包的org.apache.catalina.util.ServerInfo类，即可输出服务器相关信息，然后结束命令。

第七部分属于命令真正执行的过程，它将前面所有脚本运行后组成一个最终的命令开始执行。
```
:execCmd
set CMD_LINE_ARGS=
:setArgs
if ""%1""=="""" goto doneSetArgs
set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1
shift
goto setArgs
:doneSetArgs
if not "%JPDA%" == "" goto doJpda
if not "%SECURITY_POLICY_FILE%" == "" goto doSecurity
%_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" -classpath "%CLASSPATH%" -Dcatalina.base="%CATALINA_BASE%" -Dcatalina.home="%CATALINA_HOME%" -Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION%
goto end
:doSecurity
%_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" -classpath "%CLASSPATH%" -Djava.security.manager -Djava.security.policy=="%SECURITY_POLICY_FILE%" -Dcatalina.base="%CATALINA_BASE%" -Dcatalina.home="%CATALINA_HOME%" -Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION%
goto end
:doJpda
if not "%SECURITY_POLICY_FILE%" == "" goto doSecurityJpda
%_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %JPDA_OPTS% %DEBUG_OPTS% -Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" -classpath "%CLASSPATH%" -Dcatalina.base="%CATALINA_BASE%" -Dcatalina.home="%CATALINA_HOME%" -Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION%
goto end
:doSecurityJpda
%_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %JPDA_OPTS% %DEBUG_OPTS% -Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" -classpath "%CLASSPATH%" -Djava.security.manager -Djava.security.policy=="%SECURITY_POLICY_FILE%" -Dcatalina.base="%CATALINA_BASE%" -Dcatalina.home="%CATALINA_HOME%" -Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION%
goto end
:end
```
首先，收集参数，这个在前面已经见过，这里不再赘述。接下来，根据参数的值执行不同的命令。主要是通过JPDA、SECURITY_POLICY_FILE两个变量进行判断，它们分别代表是否使用Java平台调试体系结构和安全管理器。

## setclasspath.bat
在catalina.bat批处理脚本中会调setclasspath.bat批处理脚本，setclasspath.bat的职责很简单，它只负责寻找、检查JAVA_HOME和JRE_HOME两个环境变量。其内容如下。
```
if ""%1"" == ""debug"" goto needJavaHome
if not "%JRE_HOME%" == "" goto gotJreHome
if not "%JAVA_HOME%" == "" goto gotJavaHome
goto exit
:needJavaHome
if "%JAVA_HOME%" == "" goto noJavaHome
if not exist "%JAVA_HOME%\bin\java.exe" goto noJavaHome
if not exist "%JAVA_HOME%\bin\javaw.exe" goto noJavaHome
if not exist "%JAVA_HOME%\bin\jdb.exe" goto noJavaHome
if not exist "%JAVA_HOME%\bin\javac.exe" goto noJavaHome
set "JRE_HOME=%JAVA_HOME%"
goto okJava
:noJavaHome
goto exit
:gotJavaHome
set "JRE_HOME=%JAVA_HOME%"
:gotJreHome
if not exist "%JRE_HOME%\bin\java.exe" goto noJreHome
if not exist "%JRE_HOME%\bin\javaw.exe" goto noJreHome
goto okJava
:noJreHome
goto exit
:okJava
if not "%JAVA_ENDORSED_DIRS%" == "" goto gotEndorseddir
set "JAVA_ENDORSED_DIRS=%CATALINA_HOME%\endorsed"
:gotEndorseddir
set _RUNJAVA="%JRE_HOME%\bin\java"
set _RUNJDB="%JAVA_HOME%\bin\jdb"
goto end
:exit
exit /b 1
:end
exit /b 0
```
首先，判断是否在debug模式下，此模式下必须要设置JAVA_HOME环境变量，即跳到needJavaHome位置。接着，分别判断JRE_HOME、JAVA_HOME两个环境变量，如果不为空，则分别跳到gotJreHome、gotJavaHome位置。needJavaHome做的事情包括检查JAVA_HOME环境变量是否为空，如果不为空，确认它的bin目录下是否存在java.exe、javaw.exe、jdb.exe、javac.exe等文件，这些文件都是运行时必要的执行文件。最后，把JAVA_HOME变量的值赋给JRE_HOME。这里有必要说明一下exit标签与end标签的不同，exit /b 1即退出当前命令窗口并返回值1，exit /b 0则退出当前命令窗口并返回0，0表示在这段脚本运行时没有出现错误。所以，如果一切运行正常，最终会得到JAVA_ENDORSED_DIRS="%CATALINA_HOME%\ endorsed"，_RUNJAVA="%JRE_HOME%\bin\java"，_RUNJDB="%JAVA_HOME%\bin\jdb"。

## Tomcat中的变量及属性
变量及属性的目的主要是将某些参数剥离出程序，以实现可配置性。在Tomcat中，启动时会涉及大量环境变量、JVM系统属性及Tomcat属性。环境变量在操作系统中配置，也可以在批处理中添加或修改环境变量，在Tomcat程序中可通过System.getenv(name)获取环境变量。JVM系统属性可以是JVM自带的属性，也可以在Java执行命令中通过-D参数配置，在Tomcat程序中可通过System.getProperty(name)获取JVM系统属性。而Tomcat属性主要通过catalina. properties配置文件配置，在Tomcat启动时会加载，Tomcat程序通过CatalinaProperties获取。

最底层的是操作系统的环境变量，假如我们在脚本catalina.bat中想获取它，可以通过%变量名%直接获取；假如在Tomcat中想获取它，则可以通过System.getevn(＂变量名＂）获取。假如我们想在脚本catalina.bat中启动Java时传入参数作为JVM系统属性，则可以附带-Dparam=value参数，而在Tomcat中则通过System.getproperty(＂param＂)获取该JVM系统属性值。除此之外，Tomcat自身配置文件catalina.properties则通过CatalinaProperties类获取。

## 下面介绍一些常见的变量和属性。

### 环境变量
- %JAVA_HOME% 表示JDK的安装目录。
- %CLASSPATH% JDK搜索class时优先搜索%CLASSPATH%指定的jar包。
- %PATH% 执行某命令时，如果在本地找不到此命令或文件，则会从%PATH%变量声明的目录中区查找。

### JVM系统变量
- user.dir 表示当前用户工作目录。
- java.io.tmpdir 表示系统默认的临时文件目录。不同操作系统的目录不同。
- java.home 表示Java安装目录。
- user.home 表示用户目录。
- java.vm.vendor 表示Java虚拟机实现供应商。
- java.runtime.version 表示Java运行时版本号。
- java.library.path 表示系统搜索库文件的路径。
- java.vendor 表示Java运行时环境供应商。
- java.ext.dirs 表示Java扩展包的目录。
- user.name 表示用户的账户名。
- package.definition 表示Java安全管理器需要检查的包。
- package.access 表示Java安全管理器需要检查访问权限的包。
- path.separator 表示多个文件路径之间的分隔符。
- file.encoding 表示默认JVM编码。
- os.version 表示操作系统的版本。
- catalina.home 配置Tomcat的安装目录。这个路径变量很重要，Tomcat中常用到。在执行Tomcat启动的批处理脚本中会附带-Dcatalina.home="%CATALINA_HOME%"，即启动Tomcat程序时会把catalina.home作为JVM系统变量。
- catalina.base 配置Tomcat的工作目录。这个目录容易与catalina.home混淆，工作目录与安装目录有什么区别呢？当我们想要运行多个Tomcat实例时，就可以创建多个工作目录，而使用同一个安装目录，达到了多个Tomcat实例重用Tomcat程序的目的。在执行Tomcat启动的批处理脚本中会附带-Dcatalina.base="%CATALINA_BASE %"，即启动Tomcat程序时会把catalina.base作为JVM系统变量。
- catalina.config 配置Tomcat配置文件catalina.properties的路径。
- org.apache.catalina.startup.EXIT_ON_INIT_FAILURE 配置启动初始化阶段遇到问题是否退出。
- tomcat.util.scan.DefaultJarScanner.jarsToSkip 配置此选项将使JarScanner扫描时会跳过这些包。
- org.apache.catalina.startup.ContextConfig.jarsToSkip 配置此选项避免扫描Servlet 3.0插件功能。
- org.apache.catalina.startup.TldConfig.jarsToSkip 配置此选项避免扫描TLD。
- org.apache.catalina.tribes.dns_lookups 配置是否在集群中尝试使用DNS查找主机。
- org.apache.catalina.connector.CoyoteAdapter.ALLOW_BACKSLASH 配置是否允许使用“\”符号作为路径分隔符。
- org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH 配置是否允许使用%2F和%5C作为路径分隔符。
- org.apache.catalina.core.ApplicationContext.GET_RESOURCE_REQUIRE_SLASH 配置是否传入ServletContext.getResource()或ServletContext.getResourceAsStream()的参数一定要以“/”开头。
- org.apache.tomcat.util.http.ServerCookie.ALLOW_EQUALS_IN_VALUE 配置Cookie中的值是否可以包含“=”符号。
- org.apache.catalina.session.StandardSession.ACTIVITY_CHECK 配置是否跟踪统计活跃的会话数。
- org.apache.catalina.authenticator.Constants.SSO_SESSION_COOKIE_NAME 配置单点登录的会话Cookie名字。
- jvmRoute 配置Engine默认的路由标识。
- org.apache.jasper.Constants.SERVICE_METHOD_NAME 配置JSP执行时调用的服务方法，默认是_jspService。
- org.apache.jasper.Constants.JSP_PACKAGE_NAME 配置编译的JSP页面的包名，默认为org.apache.jsp。
- org.apache.juli.formatter 配置日志框架的格式类。
- org.apache.juli.AsyncMaxRecordCount 配置异步方式下日志在内存中能保存的最大记录数。
- org.apache.juli.AsyncOverflowDropType 配置异步方式下到达日志记录内存限制时所采取的措施。
- org.apache.coyote.USE_CUSTOM_STATUS_MSG_IN_HEADER 配置是否在HTTP报文头部使用自定义状态。

### Tomcat属性
- package.access
此属性与Java安全管理器的权限配置有关，用于配置包的访问权限。它的值包含多个包路径，默认配置为package.access=sun., org.apache.catalina., org.apache.coyote., org.apache.tomcat., org. apache.jasper.。
- package.definition
此属性与Java安全管理器的权限配置相关，用于配置包的定义权限。默认配置为package.definition=sun.,java., org.apache.catalina., org.apache.coyote., org.apache.tomcat., org.apache. jasper.。
- common.loader
此属性用于配置Tomcat中用commonLoader类加载器加载的类库。配置的值可以使用特定的变量，例如$ {catalina.base}，Tomcat程序中会对其进行解析替换。默认配置为common. loader=$ {catalina.base}/lib, $ {catalina.base}/lib/­*.jar, $ {catalina.home}/lib, $ {catalina.home}/lib/­*.jar。
- server.loader
此属性用于配置Tomcat中用serverLoader类加载器加载的类库。默认配置为空。
- shared.loader
此属性用于配置Tomcat中用sharedLoader类加载器加载的类库。默认配置为空。















