---
layout: post
categories: [Gateway]
description: none
keywords: Gateway
---
# 网关Gateway源码8负载均衡

## 概述
先来总览一下所有GlobalFilter的顺序：

ReactiveLoadBalancerClientFilter会根据 lb:// 前缀过滤处理，做负载均衡，选择最终要调用的服务地址。

## ReactiveLoadBalancerClientFilter核心源码分析
```
public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
    // 获取请求url和前缀
    URI url = exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR);
    // 获取url scheme前缀
    String schemePrefix = exchange.getAttribute(GATEWAY_SCHEME_PREFIX_ATTR);
    // 1.如果请求url为空，或者不是lb开头，那直接跳过处理
    if (url == null
            || (!"lb".equals(url.getScheme()) && !"lb".equals(schemePrefix))) {
        return chain.filter(exchange);
    }
    // 2.添加原始请求url到exchange里的GATEWAY_ORIGINAL_REQUEST_URL_ATTR（LinkedHashSet）
    addOriginalRequestUrl(exchange, url);
    return choose(exchange).doOnNext(response -> {
        // 3.获取负载均衡器，一般这里就是RibbonLoadBalancerClient
        ServiceInstance retrievedInstance = response.getServer();
        URI uri = exchange.getRequest().getURI();
        // 判断获取到的负载均衡器是用http还是https
        String overrideScheme = retrievedInstance.isSecure() ? "https" : "http";
	// 假设请求url的scheme前缀不为空，这里的逻辑应该是有问题的
        // 如果schemePrefix不是lb，那早在第一步就结束了
        if (schemePrefix != null) {
            // 那么委托的负载均衡器请求也使用同样的scheme：lb
            overrideScheme = url.getScheme();
        }
        // 构造一个委托的负载均衡器
        DelegatingServiceInstance serviceInstance = new DelegatingServiceInstance(
            retrievedInstance, overrideScheme);
        // 由负载均衡器选出从多个提供服务的url里选出一个
        URI requestUrl = reconstructURI(serviceInstance, uri);
        // 然后把这个选出的url塞到ServerWebExchange里给其他过滤器用
        exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);
    }).then(chain.filter(exchange));
}
```
分析了ReactiveLoadBalancerClientFilter实现负载均衡的原理：通过构造一个LoadBalancerClient，委托它去选出一个服务url来调用，正好贴合了它的命名。它的前身是LoadBalancerClientFilter，已经被标记为过时，但内容上没有太大差别，应该是刚迁移没多久。今天的内容比较简单，spring-cloud-gateway也确实没剩多少可讲的了。