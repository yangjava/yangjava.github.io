---
layout: post
categories: [Neo4j]
description: none
keywords: Neo4j
---
# 图数据库查询语言Cypher
Cypher 是 Neo4j 提出的图查询语言，是一种声明式的图数据库查询语言。

## Cypher简介
Cypher 是 Neo4j 提出的图查询语言，是一种声明式的图数据库查询语言，它拥有精简的语法和强大的表现力，能够精准且高效地对图数据进行查询和更新。

它是一种受 SQL 启发的语言，用于使用 ASCII-Art 语法描述图中的可视模式。它允许声明想要从图数据库中选择、插入、更新或删除什么，而不需要精确地描述如何做到这一点。

通过 Cypher，用户可以构建表达性强且高效的查询，处理所需的创建、读取、更新和删除功能。

## Cypher 设计理念
Cypher 的设计理念是：无论是开发工程师，数据库管理员，还是运维工程师，甚至非技术人员都可以轻松读懂 Cypher。 这使得图数据库的使用者可以专注于自身业务需求，而不必花费很多时间去理解图数据库的底层实现原理。

### 人性化设计
Cypher 在语法设计上十分人性化，它提供了一个直观方式来匹配图中的节点和关系。例如想要查询一个一跳路径，（）代表节点，[] 代表关系，看起来就像两个点一条关系组成的一跳路径。
```
MATCH (n)-[r]-(m) RETURN *
```
### 博采众长
Cypher 集思广益，借鉴和吸收了已有数据库查询语言的习惯写法。例如 WHERE、ORDER BY、SKIP 和 LIMIT 就来源于关系数据库查询语言 SQL，例如可视化模式匹配的语法设计来源于 RDF 查询语言 SPARQL 等。

### 语句组合Cypher
类似于 SQL 语言，一条完整的查询可由多个语句（Clause）组合而成，每条语句的执行结果将保存为中间结果，并往下一条语句传递，值得一提的是，Cypher 执行采用火山模型（Vocalno），所以除了聚合（Eager）操作，当前语句完全执行完之前就会把部分已完成的结果往下一条语句传递。

## Cypher 事务操作
用户可以自行选择是否开启事务，对于一个事务内的 Cypher 更新操作来说，要不全部执行失败，要不全部执行成功。
- 若业务需求不需开启事务，执行 Cypher 会获得更佳的性能 。
- 若业务需求需开启事务，开启事务后，Cypher 执行就运行在该事务中，直到事务成功提交事务，执行造成的数据改动才会持久化到磁盘中去。

此外可以在一个事务中执行多个 Cypher 查询：通过 Bolt Driver 提供的 API 创建并开启一个事务；执行多个 Cypher 查询；提交并关闭这个事务。

## 图数据库基本使用
Cypher是Neo4J的声明式图形查询语言，允许用户不必编写图形结构的遍历代码，就可以对图形数据进行高效的查询。Cypher的设计目的类似SQL，适合于开发者以及在数据库上做点对点模式（ad-hoc）查询的专业操作人员。

其具备的能力包括： - 创建、更新、删除节点和关系 - 通过模式匹配来查询和修改节点和关系 - 管理索引和约束等。

Neo4j CQL
- 它是Neo4j图形数据库的查询语言。
- 它是一种声明性模式匹配语言
- 它遵循SQL语法。
- 它的语法是非常简单且人性化、可读的格式。

## Neo4j CQL命令
常用的Neo4j CQL命令
- CREATE
创建	创建节点，关系和属性
- MATCH
匹配	检索有关节点，关系和属性数据
- RETURN
返回	返回查询结果
- WHERE
哪里	提供条件过滤检索数据
- DELETE
删除	删除节点和关系
- REMOVE
移除	删除节点和关系的属性
- ORDER BY
以…排序
- SET
添加或更新标签

## Neo4j CQL 函数
以下是常用的Neo4j CQL函数：
- String
字符串	它们用于使用String字面量。
- Aggregation
聚合	它们用于对CQL查询结果执行一些聚合操作。
- Relationship
关系	他们用于获取关系的细节，如startnode，endnode等。

## Neo4j CQL数据类型
这些数据类型与Java语言类似。 它们用于定义节点或关系的属性 
- boolean	用于表示布尔文字：true，false。
- byte	用于表示8位整数。
- short	用于表示16位整数。
- int	用于表示32位整数。
- long	用于表示64位整数。
- float	I用于表示32位浮点数。
- double	用于表示64位浮点数。
- char	用于表示16位字符。
- String	用于表示字符串。

## neo4j命令实战

### 创建节点

格式：
```
create (Variable:Lable1:Lable2{Key1:Value1,Key2：Value2})
```
例如：
```
CREATE (n)  
CREATE (a),(b)
// 创建空节点

CREATE (n:Person)
CREATE (n:Person:Swedish)  ---(此为节点同时创建两个标签)
CREATE (n:西游:金箍棒{name:'如意金箍棒',title:'神兵'}) ---(举例)
// (注释:Person节点标签,Swedish节点标签 )

create (n:Person { name: 'Tom Hanks', born: 1956 }) return n;
//该结点标签为Preson（也就是这个结点的名字），结点有两个属性：name和born，属性所对的值分别为：‘Tom Hanks’和‘1956’.
```
关于return语句，创建结点后，没有return，界面上将不会出现创建的结点，只会显示有没有创建成功。

### 创建关系
语法结构：
```
StartNode-[Variable:RelationshipType{Key1:Value1,Key2:Value2}] -> EndNode
```
注：在创建关系的时候，需要指定关系类型。

- 创建没有任何属性的关系
```
match (a:Person),(b:Movie)
where a.name = 'Robert Zemeckis' AND b.title = 'Forrest Gump'  
//找到label分别为‘Person’和‘Movie’的两个结点，且a结点的属性name为'Robert Zemeckis'、b结点的属性
// name为'Forrest Gump'。找到后，用a表示Person这个结点，b表示Movie这个结点。
 
create (a)-[r:DIRECTED]->(b)
//创建a->b的一个关系，关系用变量r表示，DIRECTED表示关系的类型
 
return r;
//类似于可视化关系的意思
```

- 创建关系并设置关系的属性
```
match (a:Person),(b:Movie)
where a.name = 'Tom Hanks' AND b.title = 'Forrest Gump'
create (a)-[r:ACTED_IN { roles:['Forrest'] }]->(b)
return r;
```

### 查询结点
match：用于查询数据库；where：用于对查询语句进行约束。

- 查询整个数据库
```
match(n) return n;
```

- 查询born属性小于1955的结点
```
match(n) where n.born<1955 return n;
```

- 查询指定label的结点
```
match(n:movie) return n;
```

- 查询指定属性的结点
```
match(n{name:"Tom Thanks"}) return n;
```

### 查询关系
在Cypher中，关系分为三种：
- 符号"--"，表示有关系，忽略关系的类型和方向；
- 符号"-->"和"<--"表示有方向的关系。

- 查询跟指定结点有关系的结点
```
//查询所有跟Movie有关系的结点，并返回
match(n)--(m:Movie) 
return n;
```

- 查询有向关系的结点
```
match (n:Person { name: 'Tom Hanks' })-->(movie)
return n,movie;
```

- 获取关系类型
```
match (n:Person { name: 'Tom Hanks' })-[r]->(movie)
return r,type(r);
```

- 查询特定的关系类型
```
match (n:Person { name: 'Tom Hanks' })-[r:ACTED_IN{roles:['Forrest']}]->(movie)
return r,type(r);
```

### 更新图形
set：用于对更新结点的标签和实体的属性；

remove：用于移除实体的属性和结点的标签。

- 创建一个完整的Path
```
create p =(vic:Worker:Person{ name:'vic',title:"Developer" })-[:WORKS_AT]->(neo)<-[:WORKS_AT]-(michael:Worker:Person { name: 'Michael',title:"Manager" })
return p
```
neo结点没有任何属性，但是有一个ID值，可以通过ID值为neo结点设置属性和标签。

注意：由于Path是由节点和关系构成的，当路径中的关系或节点不存在时，Neo4j会自动创建。

- 通过ID为结点增加属性
```
match (n)
where id(n)=4
set n.name = 'neo'
return n;
```

- 通过ID为结点增加标签
```
match (n)
where id(n)=4
set n:Company
return n;
```

- 为关系增加属性
```
match (n)<-[r]-(m)
where id(n)=7 and id(m)=8
set r.team='Azure'
return r;
```

### Merge
通过merge匹配搜索结果
匹配模式：一个节点有Person标签，并且具有name属性；如果数据库不存在该模式，那么创建新的节点；如果存在该模式，那么绑定该节点；
```
merge (michael:Person { name: 'Michael Douglas' })
return michael;
```
merge 一个标签为：Person，属性name为：Michael Douglas的结点，因为数据库中没有该结点，所以创建一个满足上述条件的结点。即merge语句就相当于create和match语句。
```
merge (n:Person)
return n;
```
merge一个标签为：Person的结点，因为数据库中有标签为Person的结点，所以merge语句回返回所有标签为Person的结点。

- merge与on create
检查节点是否存在，如果不存在则创建它并设置属性。
```
merge (keanu:Person { name: 'Keanu Reeves' })
on create set keanu.created = timestamp()
return keanu.name, keanu.created
```

- merge与on match
匹配结点，并在找到的结点上设置属性。
```
merge (n:Person)
on match set n.found = TRUE , n.lastAccessed = timestamp()
return n,n.name, n.found, n.lastAccessed
```
该语句回匹配所有标签为Person的结点，并为这些结点设置found和lastAccessed两个属性。

- merge与on create、on match一起
```
merge (n:Person { name: 'Keanu Reeves' })
on create set n.created = timestamp()
on match set n.lastSeen = timestamp()
return n,n.name, n.created, n.lastSeen
```
相当于匹配一个标签为Person、name属性为Keanu Reeves的结点，然后为匹配到的结点的设置created、lastSeen这两个属性。

- merge与关系
```
match (n:Person)
merge (n)-[:WORKS_AT]->(m:Movie)
return n,m;
```
查找标签为Person的结点，merge (n)-[:WORKS_AT]->(m:Movie)，如果能找到标签为Person的结点指向标签为Movie的结点，且关系属性为WORKS_AT，就返回符合条件的path；否则创建。

- 与实体有关的函数

id()函数，返回结点或关系的ID
```
match (n:Company {name:'neo'})
return id(n);
```

```
match (n:Person {name:'vic'})-[r]->(m:Company)
return id(r);
```

type()函数，返回关系类型
```
match (n:Person {name:'vic'})-[r]->(m:Company)
return type(r);
```

label()函数，返回结点的标签
```
match (n:Person {name:'vic'})-[r]->(m:Company)
return labels(n);
```

### with的用法
把with后面结果集当成一个查询结果、在这个结果基础上再做where条件的筛选

比如下面这个语句：查询所有电影集、每个电影至少有8个以上的演员参演。
```
with o,count(r) as count_r，以这个为结果集、然后在此基础上筛选出count_r大于8的
```

### 查询节点多层关系语句
查询所有下级节点，包含c节点
```
MATCH (c:标签{键:"值"})-[r*0..]->(result) return result
```

查询所有下级节点，不包含c节点
```
MATCH (c:标签{键:"值"})-[r*1..]->(result) return result
```

遍历到第三层
```
MATCH (c:标签{键:"值"})-[r*3..]->(result) return result
```

向上遍历
```
MATCH (c:标签{键:"值"})<-[r*3..]-(result) return result
```
语法[r**0..2]是一个范围参数，用于指定距给定节点的最小和最大关系距离，关系类型为r。

### 查询两节点有效的路径
路径长度（5个节点之内），一般都会做限制，否则数据库一但内容过多就会卡死

- 所有路径（不准确）
最容易想到的就是这样写，但是结果是不准确的。
```
match p = (a)-[r*..5]-(b)
where a.name = '刘备' and b.name='刘禅'
return p
```

我们可以把每条路径中的节点名称抽取出来看看
```
match p = (a)-[r*..5]-(b)
where a.name = '刘备' and b.name='刘禅'
return extract(n in nodes(p)| n.name)
```
问题就是在一条路径(p)中，有重复人员的出现。那么解决方案就是，去掉路径(p)中有重复人员的路径(p)
```
// 相当于遍历nodes, 每得到一个node就在nodes中找一下他自己有几个，如果不等于1就不要了
and ALL( n1 in nodes(p) where size(filter(n2 in nodes(p) where id(n1) = id(n2)))=1 )
// 新版本neo4j 不支持fliter函数 用[]代替
and ALL( n1 in nodes(p) where size([n2 in nodes(p) where id(n1) = id(n2)])=1 )
```

最终方案
```
match p = (a)-[r*..5]-(b)
where a.name = '刘备' and b.name='刘禅'
and ALL( n1 in nodes(p) where size(filter(n2 in nodes(p) where id(n1) = id(n2)))=1 )
return p
 
// 新版
match p = (a)-[r*..5]-(b) 
where a.name = '刘备' and b.name='刘禅' 
and ALL( n1 in nodes(p) where size([n2 in nodes(p) where id(n1) = id(n2)])=1 ) 
return p
```





## 删除数据
如果数据库中的数据量并不大，节点数相对较少，我们可以通过命令行直接删除节点。此类操作起到清空数据库的效果，但是不会删除数据库

这里列举两种常用的删除数据的用法：
- 删除对应节点及其所有关系。也就是说，只要符合键值对 { property-name：value } 条件的节点都会被删除
```
match (n {<property-name>:<value>} ) detach delete (n)
```
示例：
```text
//创建节点
merge(t:Test{id:01,name:"hh"})
merge(t:test{id:02,name:"hh"})

//name为hh的两个节点及其关系都会删除
match (n{name:"hh"}) detach delete (n)
```
- 删除所有节点及其所有关系
此命令不用筛选条件，直接将数据库中的所有节点及关系全部删除
```
match (n) detach delete (n)
```
删除数据库
如果数据库中的数据量很大，节点数非常多，通过命令行删除会比较慢，那么我们可以通过物理方式直接删除数据库。 此类操作直接删除了数据库，数据当然都被清空了
首先，我们需要关闭 Neo4j 数据库的运行。然后找到 Neo4j 数据库的存放目录，也就是 <NEO4J_HOME>/data/ 。 如果忘记了 NEO4J_HOME 可以去环境变量中查看
- 3.x版
Neo4j 的 3.x 版本下有一个 databases 文件夹，进入这个文件夹，里面有一个 graph.db 的文件夹和一个 store_lock 文件。 这个 graph.db 文件夹就是我们当前使用的数据库，直接删除即可。
- 4.x版
Neo4j 的 4.x 版本下有一个 databases 文件夹和一个 transactions 文件夹，两个文件夹下都有 graph.db。 我们将这两个文件夹下的 graph.db 都删除即可。

## neo4j-在不复制字段的情况下创建节点并为其设置 ID
create (n:Entry) set n.id=1111

你看到的两个值是

id(n)Neo4j的内部节点标识符，这里12和
一个属性n.id，在这里1111。
你可以从 Cypher 中访问它们，取消上面显示的语法， MATCH (n:Entry) RETURN id(n), n.id产生：

id(n)	n.id
12	1111
你不能从 Cypher 更改内部 ID，它是在系统创建节点时分配的。我知道控制哪个节点获取哪个内部 ID 的唯一方法（你永远不必这样做，重新考虑你的软件设计！）是使用带有选项的Neo4j 管理导入工具--id-type=ACTUAL。但是，这仅适用于批量导入到以前为空的数据库中的节点。

## 建立索引
CREATE INDEX FOR (n:c) ON (n.id)

在 Neo4j 中，你可以使用以下命令来显示当前数据库中已经创建的索引：
```
CALL db.indexes();
```
这个命令会返回一个结果集，其中包含了数据库中所有的索引信息，包括索引的名称、标签、属性、类型等。你可以通过查看这些信息来了解当前数据库中的索引情况。

另外，你还可以使用下面的命令来查看节点或关系的索引信息：

查看节点的索引信息：
```text
CALL db.indexesForLabel('label');
```
查看关系的索引信息：
```
CALL db.relationshipTypes();
```
在上面的命令中，你需要将 label 替换为你要查询索引的节点标签。

在 Neo4j 中，可以使用 CREATE CONSTRAINT 语句创建唯一索引。以下是创建唯一索引的示例命令：

CREATE CONSTRAINT constraint_name ON (label_name:Label) ASSERT label_name.property_name IS UNIQUE;
在上面的命令中，你需要替换以下内容：

constraint_name：要创建的约束/索引的名称。
label_name：要应用索引的节点标签的名称。
property_name：要为其创建唯一索引的属性的名称。
例如，要在 Person 标签上为 name 属性创建唯一索引，可以使用以下命令：

CREATE CONSTRAINT unique_name_constraint ON (p:Person) ASSERT p.name IS UNIQUE;
执行该命令后，任何尝试创建具有相同 name 属性值的 Person 标签的节点都会引发约束违规错误。

需要注意的是，创建唯一索引可能需要一些时间，特别是在大型数据库上。此外，索引会影响写入性能，因为每次写入操作都需要维护索引。因此，需要权衡考虑何时使用唯一索引。

在 Neo4j 中使用 neo4j-admin 工具导入 CSV 文件时，可以通过指定一个包含列名信息的额外 CSV 文件来设置头信息。以下是基本步骤：

创建一个包含列名信息的 CSV 文件（例如 headers.csv），文件中的每一行应该只包含一个列名。
header1
header2
header3
...
使用 neo4j-admin 工具执行导入命令，并通过 --nodes 参数指定要导入的节点 CSV 文件，以及 --nodes-header 参数指定包含列名信息的 CSV 文件。
neo4j-admin import --nodes=/path/to/nodes.csv --nodes-header=/path/to/headers.csv --database=your_database_name
在上面的命令中，/path/to/nodes.csv 是要导入的节点 CSV 文件的路径，/path/to/headers.csv 是包含列名信息的 CSV 文件的路径，your_database_name 是你的数据库名称。

执行命令后，Neo4j 将使用指定的列名信息来操作 CSV 文件，并相应地创建节点。

请确保节点 CSV 文件中的列名与列名信息文件中的列名匹配，以便正确映射数据到节点属性。

## MATCH
MATCH 用于检索图数据库中的节点和关系。

- 获取图中所有节点
如果指定模式为不带类型的节点，返回结果则为图中的所有节点。示例如下：
```
MATCH (n)
RETURN n
//返回数据库中的所有节点
```

- 获取所有电影类型的节点
如果单节点模式（pattern）中节点带类型，返回结果为所有此类型的节点。示例如下：
```
MATCH (movie:电影)
RETURN movie
//返回数据库中的所有指定类型的节点
```

## OPTIONAL MATCH
OPTIONAL MATCH 和 MATCH 一样用于对图数据进行检索。两者的区别在于，对于找不到的匹配项 OPTIONAL MATCH 会用 null 代替。注意，与不加 OPTIOANAL 关键字时的查询做比较会更容易理解 OPTIONAL 关键字的作用。





























