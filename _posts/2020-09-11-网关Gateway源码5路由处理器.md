---
layout: post
categories: [Gateway]
description: none
keywords: Gateway
---
# 网关Gateway源码5路由处理器

## spring-cloud-gateway的请求路由过程
1. DispatcherHandler ：接收到请求后匹配 HandlerMapping ，此处会匹配到 RoutePredicateHandlerMapping ；
2. RoutePredicateHandlerMapping ：匹配 Route ；

3. FilteringWebHandler ：获取 Route 的 GatewayFilter 列表，创建 GatewayFilterChain 来处理请求。

## DispatcherHandler
请求分发处理器，是WebFlux的访问入口。看这似曾相识的样子，没错，对应到Spring MVC中，跟它承担类似作用的，就是DispatcherServlet。稍微提一点有趣的地方，在整个spring-cloud-gateway的工程下，还有两个子模块：
- spring-cloud-gateway-mvc
- spring-cloud-gateway-webflux

这两兄弟就是个对称的关系，类名都一毛一样：

spring-cloud-gateway-mvc 用于支持Spring 4.x的Spring MVC扩展
spring-cloud-gateway-webflux 用于支持Spring 5.x的Spring WebFlux扩展
分别对应了两种web的实现方式：

Spring MVC 构建于 Servlet API 之上，使用的是同步阻塞式 I/O 模型，什么是同步阻塞式 I/O 模型呢？就是说，每一个请求对应一个线程去处理；
Spring WebFlux 是一个异步非阻塞式的 Web 框架，它能够充分利用多核 CPU 的硬件资源去处理大量的并发请求。IO 密集型包括：磁盘IO密集型, 网络IO密集型，微服务网关就属于网络 IO 密集型，使用异步非阻塞式编程模型，能够显著地提升网关对下游服务转发的吞吐量。但WebFlux 并不能使接口的响应时间缩短，它仅仅能够提升吞吐量和伸缩性。
在两个工程的ProxyExchangeArgumentResolver类中，继承了同名接口HandlerMethodArgumentResolver，但分属于不同的包：

好了，延伸到此为止。所以DispatcherHander也和DispatcherServlet的请求处理流程类似：
```
public class DispatcherHandler implements WebHandler, ApplicationContextAware {
	private List<HandlerMapping> handlerMappings;
	private List<HandlerAdapter> handlerAdapters;
	private List<HandlerResultHandler> resultHandlers;

        // 1. 初始化时从BeanFactory分别拉取类型为：HandlerMapping、HandlerAdapter、HandlerResultHandler
        //    的所有Bean，填充到：handlerMappings、handlerAdapters、resultHandlers
	protected void initStrategies(ApplicationContext context) {
		Map<String, HandlerMapping> mappingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(
				context, HandlerMapping.class, true, false);

		ArrayList<HandlerMapping> mappings = new ArrayList<>(mappingBeans.values());
                // 对所有的HandlerMapping排序，实现按优先级选择HandlerMapping使用的关键
                // 因为HandlerMapping的作用是判断一个请求究竟适不适用于它所有对应的Handler
                // 最终是通过Handler去处理一个请求的，所以假设我们有一组HandlerMapping
                // 这时来了个请求，我们就先把HandlerMapping按getOrder()拿到的优先级排序
                // 然后依次做HandlerMapping.getHandler(request);
                // 如果这个过程是顺序的，或者说同步的，那么第一次有某个HandlerMapping
                // 拿到了Handler的话，说明它就是我们需要的Mr Right，方法可以直接返回这个了。
                // 其实在Spring MVC里 DispatcherServlet就是通过 for if != null return
                // 这样去顺序取HandlerMapping尝试获取Handler的。
                // 但是在Spring WebFlux里，Reactor编程将这个过程异步化了：
                // 通过concatMap()将所有的HandlerMapping异步getHandler(request);
                // 它不保证每个HandlerMapping执行getHandler的顺序，但保证最终得到的
                // 一组结果，是按原先HandlerMapping的顺序排好的，所以只用next()来获取
                // 第一个Handler，就得到了符合HandlerMapping优先级的Handler，得到了
                // 与同步执行同样的结果。假设HandlerMapping比较多，或者每个HandlerMapping
                // 执行getHandler()的时间比较久，那么异步是有优势的，它相当于是把这个过程
                // 并行化了。但也并非一定总有优势，要并行就需要分配多个线程去做任务，也涉及到
                // 最终结果的归并。多个线程会占用额外的cpu资源，与其他任务竞争时间片，CPU调度
                // 线程造成上下文切换消耗也增加了。并且每个getHandler的线程计算结果是需要维护
                // 对应的优先级的，因为最终合并结果需要保持不改变顺序。
		AnnotationAwareOrderComparator.sort(mappings);
		this.handlerMappings = Collections.unmodifiableList(mappings);

		Map<String, HandlerAdapter> adapterBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(
				context, HandlerAdapter.class, true, false);

		this.handlerAdapters = new ArrayList<>(adapterBeans.values());
		AnnotationAwareOrderComparator.sort(this.handlerAdapters);

		Map<String, HandlerResultHandler> beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(
				context, HandlerResultHandler.class, true, false);

		this.resultHandlers = new ArrayList<>(beans.values());
		AnnotationAwareOrderComparator.sort(this.resultHandlers);
	}

        // 2.遍历handlerMappings，获取对应的WebHandler
	@Override
	public Mono<Void> handle(ServerWebExchange exchange) {
		if (this.handlerMappings == null) {
			return createNotFoundError();
		}
		return Flux.fromIterable(this.handlerMappings)
                                // a.此处会匹配到RoutePredicateHandlerMapping
                                // b.RoutePredicateHandlerMapping匹配请求对应的 Route
                                // c.返回FilteringWebHandler
				.concatMap(mapping -> mapping.getHandler(exchange))
				.next()
				.switchIfEmpty(createNotFoundError())
                                // d.执行Handler
				.flatMap(handler -> invokeHandler(exchange, handler))
                                // e.处理result
				.flatMap(result -> handleResult(exchange, result));
	}

        // 3.执行Handler，得到HandlerResult
	private Mono<HandlerResult> invokeHandler(ServerWebExchange exchange, Object handler) {
		if (this.handlerAdapters != null) {
			for (HandlerAdapter handlerAdapter : this.handlerAdapters) {
				if (handlerAdapter.supports(handler)) {
					return handlerAdapter.handle(exchange, handler);
				}
			}
		}
		return Mono.error(new IllegalStateException("No HandlerAdapter: " + handler));
	}

        // 5.处理返回结果
	private Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {
		return getResultHandler(result).handleResult(exchange, result)
				.checkpoint("Handler " + result.getHandler() + " [DispatcherHandler]")
				.onErrorResume(ex ->
						result.applyExceptionHandler(ex).flatMap(exResult -> {
							String text = "Exception handler " + exResult.getHandler() +
									", error=\"" + ex.getMessage() + "\" [DispatcherHandler]";
							return getResultHandler(exResult).handleResult(exchange, exResult).checkpoint(text);
						}));
	}

        // 4.根据Result类型，获取处理返回结果的Handler
	private HandlerResultHandler getResultHandler(HandlerResult handlerResult) {
		if (this.resultHandlers != null) {
			for (HandlerResultHandler resultHandler : this.resultHandlers) {
				if (resultHandler.supports(handlerResult)) {
					return resultHandler;
				}
			}
		}
		throw new IllegalStateException("No HandlerResultHandler for " + handlerResult.getReturnValue());
	}
}
```

## RoutePredicateHandlerMapping
匹配 Route ，并返回处理 Route 的 FilteringWebHandler :
```
private final FilteringWebHandler webHandler;
private final RouteLocator routeLocator;
private final Integer managementPort;
private final ManagementPortType managementPortType;

public RoutePredicateHandlerMapping(FilteringWebHandler webHandler,
			RouteLocator routeLocator, GlobalCorsProperties globalCorsProperties,
			Environment environment) {
    this.webHandler = webHandler;
    this.routeLocator = routeLocator;
    this.managementPort = getPortProperty(environment, "management.server.");
    this.managementPortType = getManagementPortType(environment);
    // order设置为1的原因：
    // GatewayWebfluxEndpoint提供http api，不走网关。
    // 它通过 RequestMappingHandlerMapping 进行请求匹配处理。
    // RequestMappingHandlerMapping的order=0 ，
    // 需要排在 RoutePredicateHandlerMapping 前面。
    setOrder(1);
    setCorsConfigurations(globalCorsProperties.getCorsConfigurations());
}
```
DispatcherHandler在步骤2：handler()方法中，调用RoutePredicateHandlerMapping继承自AbstractPredicateHandlerMapping中的getHandler()方法：
```
public Mono<Object> getHandler(SeverWebExchange exchange) {
    // 调用到具体实现类重写的getHandlerInternal()方法
    // 所以此处实际调用了RoutePredicateHandlerMapping.getHandlerInternal()
    return getHandlerInternal(exchange).map(handler -> {
	ServerHttpRequest request = exchange.getRequest();
	if (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) {
	    CorsConfiguration config = (this.corsConfigurationSource != null ? this.corsConfigurationSource.getCorsConfiguration(exchange) : null);
	    CorsConfiguration handlerConfig = getCorsConfiguration(handler, exchange);
	    config = (config != null ? config.combine(handlerConfig) : handlerConfig);
	    if (!this.corsProcessor.process(config, exchange) || CorsUtils.isPreFlightRequest(request)) {
	        return REQUEST_HANDLED_HANDLER;
	    }
	}
	return handler;
    });
}
```
getHandlerInternal()的核心代码：
```
protected Mono<?> getHandlerInternal(ServerWebExchange exchange) {
    // 1.设置GATEWAY_HANDLER_MAPPER_ATTR为RoutePredicateHandlerMapping 
    exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());

    // 2.调用lookupRoute(ServerWebExchange)匹配Route 
    return lookupRoute(exchange)
	.flatMap((Function<Route, Mono<?>>) r -> {
	    exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);
                // 3.设置 GATEWAY_ROUTE_ATTR 为 匹配的 Route
		exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);
                // 4.返回 FilteringWebHandler
		return Mono.just(webHandler);
                // 5.匹配不到Route时返回Mono.empty()，即不返回处理器
                // 这样会导致在 DispatcherHandler#handle(ServerWebExchange)
                // 没有合适的Handler，返回Mono.error(HANDLER_NOT_FOUND_EXCEPTION) 
		}).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -> {
		    exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);
    })));
}
```
lookupRoute()的核心代码：
```
protected Mono<Route> lookupRoute(ServerWebExchange exchange) {
    return this.routeLocator.getRoutes()
        .concatMap(route -> Mono.just(route).filterWhen(r -> {
	    exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());
            // 1.顺序匹配每个Route
            return r.getPredicate().apply(exchange);
	})
        .next()
	.map(route -> {
            // 2.校验Route的合法性，目前是个空方法，
            // 可以通过继承RoutePredicateHandlerMapping重写，不过一般也用不到就是了
	    validateRoute(route, exchange);
	    return route;
	});
}
```