---
layout: post
categories: [MySQL]
description: none
keywords: MySQL
---
# MySQL数据存储

## 表空间文件组成结构
InnoDB存储引擎在存储设计上模仿了Oracle的存储结构，其数据是按照表空间进行管理的。新建一个数据库时，InnoDB存储引擎会初始化一个名为ibdata1的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS等。此外，还会存储用来保证数据完整性的回滚段数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了。

InnoDB存储引擎的设计很灵活，可以通过参数InnoDB_file_per_table来设置，使得每一个表都对应一个自己的独立表空间文件，而不是存储到公共的ibdata1文件中。独立的表空间文件只存储对应表的B+树数据、索引和插入缓冲等信息，其余信息还是存储在默认表空间中。

以一个单表文件（表空间文件）为切入点，来介绍这种文件的管理方式。现在已经知道，这个文件所存储的内容主要就是B+树（索引），一个表可以有多个索引，也就是在一个文件中，可以存储多个索引，而如果一个表没有索引的话，用来存储数据的被称为聚簇索引，也就是说这也是一个索引。最终的结论是，ibd文件存储的就是一个表的所有索引数据。

那问题来了，在ibd文件中，InnoDB是如何管理这几个B+树的呢？他们之间的组织关系是什么？在文件中是如何区分开的？一个B+树在文件中，又是如何组织的？每一个B+树管理单位是什么？每一个B+树节点，他们之间的父子、兄弟关系是如何体现的？这些正是这节想要说清楚的内容。

首先介绍一下一个B+树是如何构成的。InnoDB中的索引（B+树）是通过段、簇、页面构成的，下面分别来介绍。

## 段
段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树中非叶子节点（页面）的数据，叶子段用来管理（存储）B+树中叶子节点的数据。

也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个逻辑概念中申请的，在内节点分裂时申请新节点就从内节点段中申请，在叶子节点分裂申请新节点时就要从叶子段中申请了。一个索引，包括两个段，那么一个表的段的数目，就是索引的个数乘以2了。

更形象的解释是，ibd文件，就是由多个段组成的，没有任何其他空间是脱离了段的管理的。

## 簇
现在已经知道，一个索引是由两个段组织的，段是一个逻辑的概念，那段内部的组织结构是什么样的？InnoDB对此引入了簇的概念，在代码中被称为Extent。

簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但扩展的最小单位就是簇。簇的空间大小是固定的，一般是64个页面。

现在可以想象一下，一个索引，是由两个段组成，两个段之间的物理位置是没有关系的，而每个段是由多个簇组成，多个簇之间的物理位置也是没有关系的，具体位置要根据当时物理文件的使用情况而定，形象一些的表述

## 页面
现在已经知道段和簇的关系了，但簇的物理空间内部还需要继续被切分并高效管理。我们平常津津乐道的“页面”就是簇在细分之后的产物，它是簇的组成单位，也是段所管理的最小单位、数据库文件管理的最小单位，当然也是文件中空间分配的最小单位。

一个簇中可以包括多个页面（默认为64个页面），这个页面数通常被叫做“簇的大小”。这些页面都归这个簇管理，在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面出来使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用，依此类推。

更简单地说，表空间文件就是被划分成相等长度的块，每一个块就是一个页面，一个页面默认为16KB，上面已经说过，一个文件中没有任何空间是脱离了段的管理而存在的。那么，这里可以说，对于一个文件，没有任何空间不是以页面的形式而存在的。

## 段、簇、页面组织结构
上面已经提到，段是由多个簇组成，簇是由默认的64个页面组成的，但在具体实现上，它们是如何组织、如何实现的呢？下面就主要从InnoDB的源代码的角度来讨论它们的组织方式，同时讲述在组织这三层结构时，InnoDB是如何做到可扩展、高效的页面管理的。

一个表空间可以有多个文件，每个文件都有各自的编号，创建一个表空间时，至少有一个文件，这个文件被称为“0号文件”。上面已经提到，一个文件是被切割为等长（默认16KB）的块，这个块通常被称为页面，那么在“0号文件”的第一个页面（page_no为0）中，存储了这个表空间中所有段簇页管理的入口，那么在这个页面中，可存储的数据就是16KB，但通常都会有页面头信息会占用一些空间，真正的管理信息数据是从页面偏移为FIL_PAGE_DATA （38）的位置开始的，这个位置存储了表空间描述信息，描述信息中包括如下主要内容。
- FSP_SPACE_ID：当前表空间ID号，每一个表空间都有一个唯一的ID号，在创建时分配。在第6章中可以了解到，这个ID的分配会在ibdata文件的第0号文件的第7个页面中存储和管理，每分配一个新的表空间，这个值会加1，并将最新值写入这个页面相应的位置中。
- FSP_SIZE：当前表空间总的页面数，即一个表空间可以有多个文件。这个值表示表空间中所有文件按照页面（默认16KB）大小划分的页面数之和，在文件空间不足需要扩展时，这个值会被更新为扩展后的大小。
- FSP_FREE：表空间所有段中的簇都是由表空间统一管理的，这个地址是一个链表头指针，表空间中所有的空闲簇都以链表的形式存储在这个链表中。上面已经提到，表空间中空间扩展的最小单位就是簇，页面是属于簇的，所以，文件中所有游离出现的都是一个个的簇。新分配的或已经清空数据的簇，都会被挂在这个链表中。这个链表，相当于是一个表空间的簇池子，不用了的簇可以放到这里，某一个段要分配新的簇时就从这里取。
- FSP_FREE_FRAG：一个簇可以管理很多页面（默认值64个页），如果这个簇中已经有被使用（分配）的页面，这个簇就被称为半满簇，这个地址就是存储所有半满簇的链表头指针。这个链表和上面的FSP_FREE是类似的，只不过存储的簇的性质不同，FSP_FREE存储的是完全空闲的簇，而这个是只有部分页面是空闲的簇。
- FSP_FULL_FRAG：如果一个簇中的所有页面都已经被分配（使用）了，那么这个簇就被称为满簇，这个地址就是用来存储所有满簇的链表头指针。
- FSP_FRAG_N_USED：这个值表示上面的FSP_FREE_FRAG链表中，所有已经被使用过的页面数。在分配页面时，每从FSP_FREE_FRAG链表中分配一个空闲页，这个值都会加1并写入到文件中。
- FSP_SEG_ID：在表空间中，每一个段都有一个唯一分配的ID号，这个值表示的是下一个段的ID号，每次使用之后这个值都会自加，以保证所有的ID号都是不相同的。
- FSP_SEG_INODES_FULL：这里需要先介绍一下Inode，Inode是用来管理段的，简单来说，一个Inode就代表一个数据段。Inode可以说是一个结构体，它也是像上面一样，按顺序存储到Inode页面中，一个Inode页面可以存储多个Inode节点。如果页面中所有的空间都用来存放已经使用的Inode，则这个页面就称为满Inode页面，否则称为半满Inode页面。FSP_SEG_INODES_FULL就是用来存储所有的满Inode页面的链表头指针。
- FSP_SEG_INODES_FREE：用来存储所有半满Inode页面的链表头指针，或者是空闲的Inode页面。

Inode节点用来管理一个段，一个Inode中包括以下内容。
- FSEG_ID：表示这个段的ID号，在创建时唯一分配。
- FSEG_NOT_FULL：一个段管理很多簇，这些簇都是属于这个段的，这个地址用来存储所有半满簇的链表头指针。
- FSEG_NOT_FULL_N_USED：这个地址用来存储上面半满簇链表中所有已经使用的页面总数。
- FSEG_FREE：这个地址用来存储所有空闲簇的链表头指针。
- FSEG_FULL：这个地址用来存储所有满簇的链表头指针。

从上面的叙述中可以知道，表空间控制信息中有满簇链表、半满簇链表、空闲簇链表，而段的Inode信息中也有这些信息，但这两个其实是不同的。表空间中的链表管理的是整个表空间中所有的簇，包括满簇、半满簇及空闲簇，而段的Inode信息中管理的是属于自己段中的满簇、半满簇及空闲簇。当段新申请一个簇时，如果段上面没有空闲的簇，此时它就会从表空间的簇链表中找，找到后从相应链表中摘下来挂到段空闲簇链表中。

上面一直提到的簇，是一个段的组成元素，段通过三个链表将不同状态的簇管理起来，链表都是双向链表。在段控制信息中，链表头分别是FSEG_FREE、FSEG_FULL、FSEG_NOT_FULL，链表节点就是簇，每个簇上面都有向前指针和向后指针。每一个簇通过一个簇描述符来表示，簇是实际的物理存储空间，簇描述符是一个结构体，其内容如下。
- XDES_ID：这个值表示这个簇所属段的ID号，对应的值就是上面Inode结构中的FSEG_ID值。
- XDES_FLST_NODE：这个地址用来存储簇的链表指针，包括向前指针和向后指针，每一个指针（地址）都是一个页面地址，包括page、boffset。page表示这个簇描述符在文件中的哪一个页面，它是一个页面号；boffset表示簇描述符在page页面中的偏移地址，表示从这个位置开始就是这个簇的描述符地址。这里需要注意的是，当前所讲述的内容是一个簇描述符，簇描述符管理的是一个簇的状态及页面的使用情况等，簇链表就是多个这样的簇描述符通过XDES_FLST_NODE向前向后的指定而被链接起来的表，所以，这个指针指向的，其实还是这样的结构。一个簇描述符，是把这些信息存储在一个页面中，所以只要找到一个簇描述符的首地址，也就是存储XDES_ID的位置，就可以找到一个簇描述符了。这个链表指针的内容包括page、boffset两部分，page表示的是这个簇描述符所在的页面号，而boffset表示的是簇描述符所在的页面page中首地址的偏移量。这里，只需要把一个簇的描述符理解为一个簇即可，因为簇是被簇描述符管理的，所以这里可以等同理解。至于簇描述符是如何与簇页面对应上的，下面会有解释。
- XDES_STATE：表示当前这个簇的状态，状态包括XDES_FREE（空闲簇）、XDES_FREE_ FRAG（半满簇）、XDES_FULL_FRAG（满簇）、XDES_FSEG（属于一个段）。
- XDES_BITMAP：这个地址存储的是一个位图，InnoDB通过这个来管理一个簇中所有页面的使用情况。每一个页面用两个位来表示，簇大小FSP_EXTENT_SIZE表示的是一个簇的页面数，默认值为64，所以XDES_BITMAP占用的总长度为64*2/8=16个字节。用两个位来表示一个页面，第一个位表示这个页面是否使用，第二个位现在还没有使用，所以一个簇描述符的大小为XDES_ID(8)+XDES_FLST_NODE(12)+XDES_STATE(4)+16(XDES_ BITMAP的大小)=40个字节。

从上面得知，一个簇描述符，占用40B的空间，这些信息是被存储在页面中的，这个页面，就被称为簇描述页，它所存储的内容就叫作簇描述符。

在InnoDB中，一个簇描述页面默认要管理16384个页面，簇大小默认为（FSP_EXTENT_SIZE 64个，而一个簇描述符的大小为40B，所以一个簇描述页面中可以描述的簇的个数为（UNIV_ PAGE_SIZE-页面头长度）/40，其中UNIV_PAGE_SIZE=16384B表示页面大小。但一般情况下，都不会将簇描述页面存储满，因为在一个表空间中，簇描述页面的存储是每隔16384个页面就有一个是簇描述页面，所以簇描述页面中只需要描述16384个页面即可。每个簇大小为64个页面，所以需要存储的簇描述符个数为16384/64=256个。由此可知，页面大小为16384个，其实只用了256*40=10240B的空间，其他空间都是空闲的，那这样的话，256个簇描述符存储在一个簇描述页面中，可以管理16384个页面，也就是256个簇。

一个表空间文件以簇为单位被分隔开，同时每16384（默认值）个页面又用一个簇描述页面来描述，在每16384个页面的分隔中，第一个页面都用来做簇描述页面，用来描述后面16384-64=16320个页面。第一个簇（其实是第一个页面）只是用来做簇描述页面的，它没有被加入到表空间的簇链表中，也没有被加入到段的簇链表中，第一个簇后面的63个页面是被空出来的，并没有被使用，其实是被浪费掉的空间，真正的空间使用是从第二个簇开始直到最后一个簇，所以簇描述页面中实际上只有255个簇描述符。

上面在解释XDES_FLST_NODE的时候，提出了一个问题，就是簇描述页面中存储的簇描述符上的信息没有体现它管理的页面是哪些，只有一个位图用来表示管理的64个页面是否已经被使用，但是从图7.4中可以看到，每16384个页面就有一个簇描述页，所以第一个描述页的页号为0，第二个为16384，依此类推。同时，一个描述页面中，所有描述符描述的页面都是相隔64连续，所以只要知道一个描述符的位置，就可以计算出这个描述符所管理的页面号范围，因此在描述符中是不需要存储它的页面信息的，通过描述符的地址即可得到。计算方法概括如下，根据描述符的地址得到描述页的页面号describe_page_no，然后再根据簇描述符在簇描述页面中的偏移量得到它在这个簇描述页中的序号index，管理的范围scope可以通过下面的公式计算出来。

min_scope=describe_page_no+index*FSP_EXTENT_SIZE。

max_scope=describe_page_no+(index+1)*FSP_EXTENT_SIZE。

min_scope<=scope<max_scope

很明显，max_scope-m in_scope的值就是FSP_EXTENT_SIZE，即64。

下面简单叙述一下创建一个段的过程，用来说明文件管理的实现过程。
- 根据表空间ID号得到表空间头信息。
- 从得到的表空间头中分配一个Inode，首先判断FSP_SEG_INODES_FREE链表中是否还有空闲的Inode页面，如果有，则从页面的数据存储位置开始扫描，每一个Inode的大小是固定的，所以扫描的步长也是固定的。每找到一个Inode后判断Inode描述符中的FSEG_ID是否为0，如果是，则没有使用，否则便是已经使用过了，找到第一个为0的则返回，说明已经找到了合适的Inode，如果找到后发现这个Inode是这一页的最后一个Inode，则将这个页面从FSP_SEG_INODES_FREE链表中摘下来，同时将这个页面插入到FSP_SEG_INODES_FULL链表中。如果FSP_SEG_INODES_FREE链表中没有空闲的Inode页面，则需要重新分配一个Inode页面，分配后将所有的Inode描述符中的FSEG_ID置为0，表示未使用，然后将这个页面链接到FSP_SEG_INODES_FREE链表中，然后直接从这个页面中分配一个空闲的Inode，过程如上所述。
- 给新分配的Inode指定SEG_ID号，这个ID号要从表空间头的FSP_SEG_ID中取出来作为新段的ID号，然后将这个ID号写入到Inode的FSEG_ID中，同时更新FSP_SEG_ID中的值，更新为ID+1，表示下一个段的ID号。
- 初始化这个Inode信息，将偏移FSEG_NOT_FULL_N_USED处的值置为0。初始化链表FSEG_FREE、FSEG_NOT_FULL和FSEG_FULL。
- 从这个段中分配出一个页面，分配页面时首先找到表空间头上的半满簇链表FSP_FREE_ FRAG，然后从链表中找一个簇描述符，找到簇描述符之后，从它的XDES_BITMAP中找一个状态为XDES_FREE_BIT的页面，返回一个0～63的下标index，再根据簇描述符计算得到这个簇管理的64个页面的首页号page，之后申请到的真正页面号就是page+index。计算方法是首先得到这个描述页的页面号descr_page，然后再得到这个簇描述符在簇描述页面中的序号seq_no，那么簇描述的首页为page=descr_page+seq_no*64。
- 分配好页面之后，通过系统缓存得到页面号为page+index的页面，这个页面就是这个段的首页面。在一个段的首页上，需要记录这个段对应的Inode的位置，Inode的位置存储在页面头中，分别是FSEG_HDR_OFFSET（INODE在INODE页面中的偏移）、FSEG_HDR_PAGE_NO（INODE所在的INODE页面号）、FSEG_HDR_SPACE（INODE所在的表空间号）。
- 到此为止，一个段就分配完成了。以后如果需要在这个段中分配空间，只要找到其首页，然后找到对应的INODE即可分配空间。
```
Creates a new segment.
@return the block where the segment header is placed, x-latched, NULL
if could not create segment because of lack of space */
UNIV_INTERN
buf_block_t*
fseg_create_general(
/*================*/
    ulint    space,    /*!< in: space id */
    ulint    page,    /*!< in: page where the segment header is placed: if
            this is != 0, the page must belong to another segment,
            if this is 0, a new page will be allocated and it
            will belong to the created segment */
    ulint    byte_offset, /*!< in: byte offset of the created segment header
            on the page */
    ibool    has_done_reservation, /*!< in: TRUE if the caller has already
            done the reservation for the pages with
            fsp_reserve_free_extents (at least 2 extents: one for
            the inode and the other for the segment) then there is
            no need to do the check for this individual
            operation */
    mtr_t*    mtr)    /*!< in: mtr */
{
    ulint        flags;
    ulint        zip_size;
    fsp_header_t*    space_header;
    fseg_inode_t*    inode; //typedef byte fseg_inode_t;
    ib_id_t        seg_id;
    buf_block_t*    block    = 0; /* remove warning */
    fseg_header_t*    header    = 0; /* remove warning */
    rw_lock_t*    latch;
    ibool        success;
    ulint        n_reserved;
    ulint        i;
 
    ut_ad(mtr);
    ut_ad(byte_offset + FSEG_HEADER_SIZE
          <= UNIV_PAGE_SIZE - FIL_PAGE_DATA_END);
 
    latch = fil_space_get_latch(space, &flags);
    zip_size = dict_table_flags_to_zip_size(flags);
 
    if (page != 0) {
        block = buf_page_get(space, zip_size, page, RW_X_LATCH, mtr);
        header = byte_offset + buf_block_get_frame(block);
    }
 
    ut_ad(!mutex_own(&kernel_mutex)
          || mtr_memo_contains(mtr, latch, MTR_MEMO_X_LOCK));
 
    mtr_x_lock(latch, mtr);
 
    if (rw_lock_get_x_lock_count(latch) == 1) {
        /* This thread did not own the latch before this call: free
        excess pages from the insert buffer free list */
 
        if (space == IBUF_SPACE_ID) {
            ibuf_free_excess_pages();
        }
    }
 
    if (!has_done_reservation) {
        success = fsp_reserve_free_extents(&n_reserved, space, 2,
                           FSP_NORMAL, mtr);
        if (!success) {
            return(NULL);
        }
    }
 
    space_header = fsp_get_space_header(space, zip_size, mtr);//详见
 
    inode = fsp_alloc_seg_inode(space_header, mtr);//申请inode entry 详见     if (inode == NULL) {
 
        goto funct_exit;
    }
 
    /* Read the next segment id from space header and increment the
    value in space header */
 
    seg_id = mach_read_from_8(space_header + FSP_SEG_ID);//设置下一下seg id
 
    mlog_write_ull(space_header + FSP_SEG_ID, seg_id + 1, mtr);
   
    /**
 *#define FSEG_ID 0
 *#define FSEG_NOT_FULL_N_USED 8
 *#define FSEG_FREE 12
 
 *#define FSEG_NOT_FULL (12 + FLST_BASE_NODE_SIZE)
 *#define FLST_BASE_NODE_SIZE (4 + 2 * FIL_ADDR_SIZE)
 *#define FIL_ADDR_SIZE 6
 *
 *#define FSEG_FULL (12 + 2 * FLST_BASE_NODE_SIZE) 
 *
 */
    mlog_write_ull(inode + FSEG_ID, seg_id, mtr); 
    mlog_write_ulint(inode + FSEG_NOT_FULL_N_USED, 0, MLOG_4BYTES, mtr);
 
    flst_init(inode + FSEG_FREE, mtr); //初始化inode中的seg list 详见
    flst_init(inode + FSEG_NOT_FULL, mtr);
    flst_init(inode + FSEG_FULL, mtr);
 
    mlog_write_ulint(inode + FSEG_MAGIC_N, FSEG_MAGIC_N_VALUE,
             MLOG_4BYTES, mtr);
   
    //#define FSEG_FRAG_ARR_N_SLOTS (FSP_EXTENT_SIZE / 2) 64/2=32 for (i = 0; i < FSEG_FRAG_ARR_N_SLOTS; i++) {
        fseg_set_nth_frag_page_no(inode, i, FIL_NULL, mtr); //设置frag 碎片 详见
    }
 
    if (page == 0) {
        block = fseg_alloc_free_page_low(space, zip_size,
                         inode, 0, FSP_UP, mtr, mtr);
 
        if (block == NULL) {
 
            fsp_free_seg_inode(space, zip_size, inode, mtr);
 
            goto funct_exit;
        }
 
        ut_ad(rw_lock_get_x_lock_count(&block->lock) == 1);
 
        header = byte_offset + buf_block_get_frame(block);
        mlog_write_ulint(buf_block_get_frame(block) + FIL_PAGE_TYPE,
                 FIL_PAGE_TYPE_SYS, MLOG_2BYTES, mtr);
    }
    
    //设置fset_header信息
    mlog_write_ulint(header + FSEG_HDR_OFFSET,page_offset(inode), MLOG_2BYTES, mtr);
 
    mlog_write_ulint(header + FSEG_HDR_PAGE_NO,page_get_page_no(page_align(inode)),MLOG_4BYTES, mtr);
 
    mlog_write_ulint(header + FSEG_HDR_SPACE, space, MLOG_4BYTES, mtr);
 
funct_exit:
    if (!has_done_reservation) {
 
        fil_space_release_free_extents(space, n_reserved);
    }
 
    return(block);
}
```

那么，现在来看一下，在已经知道段簇页管理方式，以及如何创建一个段的情况下，InnoDB是如何创建一个B+树的，继续来看精简之后的代码，如下。
```

Creates the root node for a new index tree.
@return	page number of the created root, FIL_NULL if did not succeed */
UNIV_INTERN
ulint
btr_create(
/*=======*/
	ulint		type,	/*!< in: type of the index */
	ulint		space,	/*!< in: space where created */
	ulint		zip_size,/*!< in: compressed page size in bytes
				or 0 for uncompressed pages */
	index_id_t	index_id,/*!< in: index id */
	dict_index_t*	index,	/*!< in: index */
	mtr_t*		mtr)	/*!< in: mini-transaction handle */
{
	ulint		page_no;
	buf_block_t*	block;
	buf_frame_t*	frame;
	page_t*		page;
	page_zip_des_t*	page_zip;
 
	/* Create the two new segments (one, in the case of an ibuf tree) for
	the index tree; the segment headers are put on the allocated root page
	(for an ibuf tree, not in the root, but on a separate ibuf header
	page) */
 
	if (type & DICT_IBUF) {
		/* Allocate first the ibuf header page */
		buf_block_t*	ibuf_hdr_block = fseg_create(
			space, 0,
			IBUF_HEADER + IBUF_TREE_SEG_HEADER, mtr);
 
		buf_block_dbg_add_level(
			ibuf_hdr_block, SYNC_IBUF_TREE_NODE_NEW);
 
		ut_ad(buf_block_get_page_no(ibuf_hdr_block)
		      == IBUF_HEADER_PAGE_NO);
		/* Allocate then the next page to the segment: it will be the
		tree root page */
 
		block = fseg_alloc_free_page(
			buf_block_get_frame(ibuf_hdr_block)
			+ IBUF_HEADER + IBUF_TREE_SEG_HEADER,
			IBUF_TREE_ROOT_PAGE_NO,
			FSP_UP, mtr);
		ut_ad(buf_block_get_page_no(block) == IBUF_TREE_ROOT_PAGE_NO);
	} else {
#ifdef UNIV_BLOB_DEBUG
		if ((type & DICT_CLUSTERED) && !index->blobs) {
			mutex_create(PFS_NOT_INSTRUMENTED,
				     &index->blobs_mutex, SYNC_ANY_LATCH);
			index->blobs = rbt_create(sizeof(btr_blob_dbg_t),
						  btr_blob_dbg_cmp);
		}
#endif /* UNIV_BLOB_DEBUG */
		block = fseg_create(space, 0,
				    PAGE_HEADER + PAGE_BTR_SEG_TOP, mtr);
	}
 
	if (block == NULL) {
 
		return(FIL_NULL);
	}
 
	page_no = buf_block_get_page_no(block);
	frame = buf_block_get_frame(block);
 
	if (type & DICT_IBUF) {
		/* It is an insert buffer tree: initialize the free list */
		buf_block_dbg_add_level(block, SYNC_IBUF_TREE_NODE_NEW);
 
		ut_ad(page_no == IBUF_TREE_ROOT_PAGE_NO);
 
		flst_init(frame + PAGE_HEADER + PAGE_BTR_IBUF_FREE_LIST, mtr);
	} else {
		/* It is a non-ibuf tree: create a file segment for leaf
		pages */
		buf_block_dbg_add_level(block, SYNC_TREE_NODE_NEW);
 
		if (!fseg_create(space, page_no,
				 PAGE_HEADER + PAGE_BTR_SEG_LEAF, mtr)) {
			/* Not enough space for new segment, free root
			segment before return. */
			btr_free_root(space, zip_size, page_no, mtr);
 
			return(FIL_NULL);
		}
 
		/* The fseg create acquires a second latch on the page,
		therefore we must declare it: */
		buf_block_dbg_add_level(block, SYNC_TREE_NODE_NEW);
	}
 
	/* Create a new index page on the allocated segment page */
	page_zip = buf_block_get_page_zip(block);
 
	if (page_zip) {
		page = page_create_zip(block, index, 0, 0, mtr);
	} else {
		page = page_create(block, mtr,
				   dict_table_is_comp(index->table));
		/* Set the level of the new index page */
		btr_page_set_level(page, NULL, 0, mtr);
	}
 
	block->check_index_page_at_flush = TRUE;
 
	/* Set the index id of the page */
	btr_page_set_index_id(page, page_zip, index_id, mtr);
 
	/* Set the next node and previous node fields */
	btr_page_set_next(page, page_zip, FIL_NULL, mtr);
	btr_page_set_prev(page, page_zip, FIL_NULL, mtr);
 
	/* We reset the free bits for the page to allow creation of several
	trees in the same mtr, otherwise the latch on a bitmap page would
	prevent it because of the latching order */
 
	if (!(type & DICT_CLUSTERED)) {
		ibuf_reset_free_bits(block);
	}
 
	/* In the following assertion we test that two records of maximum
	allowed size fit on the root page: this fact is needed to ensure
	correctness of split algorithms */
 
	ut_ad(page_get_max_insert_size(page, 2) > 2 * BTR_PAGE_MAX_REC_SIZE);
 
	return(page_no);
}
```



























