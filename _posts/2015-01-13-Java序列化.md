---
layout: post
categories: [Java]
description: none
keywords: Java
---
# Java序列化
序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。

## 思考
- 序列化参数有枚举属性，序列化端增加一个枚举，能否正常反序列化？
- 序列化子类，它和父类有同名参数，反序列化时，同名参数能否能正常赋值？
- 序列化对象增加参数，反序列化类不增加参数，能否正常反序列化？
- 用于序列化传输的属性，用包装器比较好，还是基本类型比较好？

## 序列化简介
所以，简单理解序列化就是将“对象”存储的信息保存到某个“文件”中，之后再通过某种方式读取“文件”转换成对象。在Java中，序列化其实就是把一个Java对象变成二进制内容，本质上就是一个byte[]数组。

既然有序列化，那么就会有反序列化，在Java中，将一个byte[]数组重新变成Java对象就是一种反序列化。

## 为什么要序列化（Why）
这个时候肯定就有人会问了，直接把对象作为参数传递不就可以了吗？为什么还要多此一举把对象变成“文本”，然后再将“文本”变成对象？

我们知道，Java创建的对象都是存在于Java虚拟机中，也即JVM中，那么JVM又在哪里呢？

JVM是Java程序运行的环境，但是他同时是一个操作系统的一个应用程序，即一个进程。他的运行依赖于内存，因此Java中对象都是存储在内存中，准确地说是JVM的堆或栈内存中，可以各个线程之间进行对象传输，但是无法在进程之间进行传输。如果涉及到跨内存的数据传输（比如两台机器的传输），直接把对象作为参数传递就不可取了，这时就需要通过“网络”将数据传输。

程序在运行过程中，产生的数据，不能一直保存在内存中，需要暂时或永久存储到介质（如磁盘、数据库、文件）里进行保存，也可能通过网络发送给协作者。程序获取原数据，需要从介质，或网络传输获得。传输的过程中，只能使用二进制流进行传输。

简单的场景，基本类型数据传输。通过双方约定好参数类型，数据接收方按照既定规则对二进制流进行反序列化。

复杂的场景，传输数据的参数类型可能包括：基本类型、包装器类型、自定义类、枚举、时间类型、字符串、容器等。很难简单通过约定来反序列化二进制流。需要一个通用的协议，共双方使用，进行序列化和反序列化。
## 序列化
序列化是一种对象持久化的手段。通常我们在jvm平台创建对象。但是仅仅当jvm正在运行时，对象才会存在。也就是说，当java运行停止之后，这个对象所保存的信息也就消失了。

那么当我们需要保存一个java对象的信息，并需要的时候又可以把他取出来。java的序列化就可以帮我们实现。

我们对Java对象进行序列化的时候，会把其状态保存为一组字节，当我们需要的时候，又将其取出来。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量 那么也就是说，对象序列化不会关注类中的静态变量

## 如何进行序列化
在Java中想要实现序列化很简单 只需要实现一个Serializable接口即可。序列化接口没有方法或字段，仅用于标识可序列化的语义
```
public class Product implements Serializable {
    private String name;
    private double price;
    private String describe;

    public Product() {
    }

    public Product(String name, double price, String describe) {
        this.name = name;
        this.price = price;
        this.describe = describe;
    }
}
```
下面进行序列化和反序列化操作

所需要用到主要类有：
- ObjectOutputStream
- ObjectInputStream
```java
public class SerialazableDemoTest1 {
    
    public static void main(String[] args) {
        Product product = new Product("电视机",3900.00,"这是一台高清");
        System.out.println("序列化之前"+product);
        // 序列化
        ObjectOutputStream  out = null;
        try {
            out = new ObjectOutputStream(new FileOutputStream("D:\\a\\tempFile"));
            out.writeObject(product);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (out!=null){
                try {
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        //反序列化
        ObjectInputStream in = null;
        Product pro = null;
        try {
            in = new ObjectInputStream(new FileInputStream("D:\\a\\tempFile"));
            //反序列读取
            pro = (Product) in.readObject();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        System.out.println("反序列化之后"+pro);


    }
}
```
我们使用ObjectOutputStream和ObjectInputStreamwriteObject方法把一个对象进行持久化。再使用ObjectInputStream的readObject从持久化存储中把对象读取出来。当我们不想序列化某个字段时 使用transient关键字，标识该字段

## 序列化协议及对比
- jdk（jdk 自带）
序列化：除了 static、transient类型
特点：强类型，安全性高，序列化结果携带类型信息
反序列化：基于 Field 机制
应用场景：深拷贝

- fastjson（第三方实现）
可读性好，空间占用小
特点：弱类型，序列化结果不携带类型信息，可读性强。有一些安全性问题
反序列化：基于 Field 机制，兼容 Bean 机制
应用场景：消息、透传对象

- hessian（第三方实现）
序列化：除了 static、transient 类型
特点：强类型，体积小，可跨语言，序列化结果携带类型信息
反序列化：基于 Field 机制，兼容 Bean 机制
应用场景：RPC

## JDK 自带的序列化工具
JDK 提供了ObjectOutputStream用于支持序列化，ObjectInputStream用于反序列化。注意，使用 JDK 自带的序列化工具时，java bean 必须实现Serializable，否则会抛出NotSerializableException异常 。使用关键字 transient 修饰的成员属性不会被序列化。
```
    // 序列化
    @Benchmark
    public byte[] jdkSerialize(CommonState commonState) throws Exception {
        ByteArrayOutputStream byteArray = new ByteArrayOutputStream();
        ObjectOutputStream outputStream = new ObjectOutputStream(byteArray);
        outputStream.writeObject(commonState.user);
        outputStream.flush();
        outputStream.close();
        return byteArray.toByteArray();
    }
    // 反序列化
    @Benchmark
    public User jdkDeSerialize(JdkState jdkState) throws Exception {
        ByteArrayInputStream byteArray = new ByteArrayInputStream(jdkState.bytes);
        ObjectInputStream inputStream = new ObjectInputStream(byteArray);
        User user = (User)inputStream.readObject();
        inputStream.close();
        assert "zzs0".equals(user.getName());
        return user;
    }

```

## fastjson
fastjson 由阿里团队开发，是目前最快的Java 实现的 json 库。 fastjson 的 API 非常简洁，并且支持一定程度的定制（例如，注解@JSONField、枚举Feature等定制序列化）。被人诟病的，可能是 fastjson 的 bug 比较多。
```
    // 序列化
    @Benchmark
    public byte[] fastJsonSerialize(CommonState commonState) {
        return JSON.toJSONBytes(commonState.user);
    }
    // 反序列化
    @Benchmark
    public User fastJsonDeSerialize(FastJsonState fastJsonState) {
        User user = JSON.parseObject(fastJsonState.bytes, User.class);
        assert "zzs0".equals(user.getName());
        return user;
    }

```

## jackson
jackson 由 fasterxml 组织开发，相比 fastjson，有着更强大的功能、更高的稳定性、更好的扩展性、更丰富的定制支持。Spring 默认使用的 json 解析工具就是 jackson。

使用 jackson 需要注意，ObjectMapper对象是线程安全的，可以重复使用。
```
    // 序列化
    @Benchmark
    public byte[] jacksonSerialize(CommonState commonState, JacksonState jacksonState) throws Exception {
        return jacksonState.objectMapper.writeValueAsBytes(commonState.user);
    }
    // 反序列化
    @Benchmark
    public User jacksonDeSerialize(JacksonState jacksonState) throws Exception {
        User user = jacksonState.objectMapper.readValue(jacksonState.bytes, User.class);
        assert "zzs0".equals(user.getName());
        return user;
    }

```

## kryo
kryo 由 EsotericSoftware 组织开发，不兼容 jdk 自带序列化工具的数据，kryo 序列化后的数据要更小，至于 API 的简洁性方面，我觉得还是差了一些，一不小心就会采坑。使用 kryo 需要注意以下几点：

Kryo对象不是线程安全的，可以使用ThreadLocal或池来获取（本文使用池获取）；
kryo 通过类注册可以在序列化数据中写入类的 class id，而不是类的全限定类名，从而减小序列化数据的大小。但是，我们很难保证同样的类在不同的机器上注册的 class id，所以，建议设置kryo.setRegistrationRequired(false);，因为同样的 Class 在不同的机器上注册编号很难保证一致；
当 java bean 出现循环引用时，使用 kryo 可能会出现栈内存溢出，这个时候可以通过设置kryo.setReferences(true);来避免。如果项目中不可能出现循环引用，则可以设置为 false 以提高性能。
```
	// 序列化
    @Benchmark
    public byte[] kryoSerialize(CommonState commonState, KryoState kryoState) {
        ByteArrayOutputStream byteArray = new ByteArrayOutputStream();
        Output output = new Output(byteArray);
        Kryo kryo = kryoState.kryoPool.obtain();
        kryo.writeClassAndObject(output, commonState.user);
        kryoState.kryoPool.free(kryo);
        output.flush();
        output.close();
        return byteArray.toByteArray();
    }
	//反序列化
    @Benchmark
    public User kryoDeSerialize(KryoState kryoState) throws Exception {
        ByteArrayInputStream byteArray = new ByteArrayInputStream(kryoState.bytes);
        Input input = new Input(byteArray);
        Kryo kryo = kryoState.kryoPool.obtain();
        User user = (User)kryo.readClassAndObject(input);
        kryoState.kryoPool.free(kryo);
        input.close();
        assert "zzs0".equals(user.getName());
        return user;
    }

```































